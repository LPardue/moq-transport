<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.5.5 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc docmapping="yes"?>

<rfc ipr="trust200902" docName="draft-lcurley-warp-latest" category="info">

  <front>
    <title abbrev="WARP">Warp - Layered Live Media Transport</title>

    <author initials="L." surname="Curley" fullname="Luke Curley">
      <organization>Twitch</organization>
      <address>
        <email>kixelated@gmail.com</email>
      </address>
    </author>
    <author initials="K." surname="Pugin" fullname="Kirill Pugin">
      <organization>Meta</organization>
      <address>
        <email>ikir@meta.com</email>
      </address>
    </author>
    <author initials="S." surname="Nandakumar" fullname="Suhas Nandakumar">
      <organization>Cisco</organization>
      <address>
        <email>snandaku@cisco.com</email>
      </address>
    </author>

    <date />

    <area>General</area>
    <workgroup>Independent Submission</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This document defines the core behavior for Warp, a layered live media transport protocol.
Media is split into layers based on the underlying media encoding.
Each layer is transmitted independently over a QUIC stream.
QUIC streams are prioritized, allowing less important layers to be starved or dropped during congestion.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">
<t>Warp is a live media transport protocol that utilizes the QUIC network protocol <xref target="QUIC"/>.</t>

<t><xref target="motivation"/> covers the background and rationale behind Warp.
<xref target="layers"/> covers how media is encoded and split into layers.
<xref target="quic"/> covers how QUIC is used to transfer media.
<xref target="messages"/> covers how messages are encoded on the wire.</t>

<section anchor="terms-and-definitions" title="Terms and Definitions">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
"MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCPÂ 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they
appear in all capitals, as shown here.</t>

<t>Commonly used terms in this document are described below.</t>

<t>TODO definitions</t>

</section>
</section>
<section anchor="motivation" title="Motivation">

<section anchor="latency" title="Latency">
<t>In a perfect world, we could deliver live media at the same rate it is produced.
The end-to-end latency of a broadcast would be fixed and only subject to encoding and transmission delays.
Unfortunately, networks have variable throughput, primarily due to congestion.</t>

<t>Attempting to deliver media larger than this variable network bitrate causes queuing.
This queuing can occur anywhere in the path between the encoder and decoder.
For example: the application, the OS socket, a wifi router, within an ISP, or generally anywhere in transit.</t>

<t>If nothing is done, new frames will be appended to the end of a growing queue and will take longer to arrive than their predecessors, increasing latency.
Our job is to minimize the growth of this queue, and failing that, skip the queue when possible.</t>

<t>Thus speed at which a media protocol can detect and respond to queuing determines the latency.
We can generally classify existing media protocols into two categories based on the underlying network protocol:</t>

<t><list style="symbols">
  <t>TCP-based media protocols (ex. RTMP, HLS, DASH) are popular due to their simplicity.
Media is served/consumed in decode order while any networking is handled by the TCP layer.
However, these protocols primarily see use at higher latency targets due to their relatively slow detection and response to queuing.</t>
  <t>UDP-based media protocols (ex. RTP, WebRTC, SRT) can side-step the issues with TCP and provide lower latency with better queue management.
However the media protocol is now responsible for fragmentation, congestion control, retransmissions, receiver feedback, reassembly, and more.
This added complexity significantly raises the implementation difficulty and hurts interoperability.</t>
</list></t>

<t>A goal of this draft is to get the best of both worlds: a simple protocol that can still rapidly detect and respond to congestion.
This is possible emergence of QUIC, designed to fix the shortcomings of TCP.
This draft relies on QUIC streams to deliver media layers in priority order during congestion.</t>

</section>
<section anchor="universal" title="Universal">
<t>The media protocol ecosystem is fragmented; each protocol has it's own niche.
Specialization is often a good thing, but we believe there's enough overlap to warrant consolidation.</t>

<t>For example, a service might simultaneously ingest via WebRTC, SRT, RTMP, and/or a custom UDP protocol depending on the broadcaster.
The same service might then simultaneously distribute via WebRTC, LL-HLS, HLS, (or the DASH variants) and/or a custom UDP protocol depending on the viewer.</t>

<t>These media protocols are radically different and not interoperable; requiring transcoding or transmuxing.
This cost is further increased by the need to maintain separate stacks with different expertise requirements.</t>

<t>A goal of this draft is to cover a large spectrum of use-cases. Specifically:</t>

<t><list style="symbols">
  <t>Consolidated contribution and distribution.
The difference between the two has historically been push versus pull.
This is an over-simplification, as the real difference is the ability to fanout, which is much easier with HTTP GET.
A single protocol can cover both use-cases with adequate information on how an intermediary should forward media.</t>
  <t>A configurable latency versus quality trade-off.
The broadcaster (producer) chooses how to encode and transmit media based on the desired user experience.
Each viewer (consumer) chooses how long to wait for media based on their desired user experience and network.
We want an experience that can vary from real-time and lossy for one viewer, to delayed and loss-less for another viewer, without separate encodings or protocols.</t>
</list></t>

</section>
<section anchor="intermediaries" title="Intermediaries">
<t>The prevailing belief is that UDP-based protocols are more expensive and don't "scale".
While it's true that UDP is more difficult to optimize than TCP, QUIC itself is proof that it is is possible to reach performance parity.
In fact even some TCP-based protocols (ex. RTMP) don't "scale" either and are exclusively used for contribution as a result.</t>

<t>The truth is that the ability to scale a media protocol depends on intermediary support: proxies, caches, CDNs, SFUs, etc.
The success of HTTP-based media protocols is due to the ability to leverage traditional HTTP CDNs.</t>

<t>Meanwhile, it's difficult to build a CDN for media protocols that were not designed with intermediaries in mind.
For example, an intermediary has to parse the underlying codec to determine which RTP packets should be dropped first, and the decision is not deterministic or consistent for each hop.</t>

<t>A goal of this draft is to treat intermediaries as first class citizens.
Any identification, reliability, ordering, prioritization, caching, etc is written to the wire in header designed for intermediaries.
This ensures that intermediaries can easily route/fanout media to the final destination.
This also ensures that congestion response is consistent at every hop based on the preferences of the media producer.</t>

</section>
</section>
<section anchor="layers" title="Layers">
<t>Warp is based on a concept of layers.
A layer is a bitstream that is decoded in order and without gaps.</t>

<t>The goal is to deliver layers such that the least important media is dropped during congestion.
This is done by assigning dependencies and/or priority to each layer, as covered in the properties (<xref target="properties"/>) section.
Each layer is then transmitted over a QUIC stream, as covered in the streams (<xref target="streams"/>) section.
QUIC will ensure that the layer arrives in order until canceled by either endpoint.</t>

<t>Media is broken up into layers based on the underlying encoding.
The contents and properties of each layer is determined by the producer based on the desired user experience.</t>

<section anchor="properties" title="Properties">
<t>Each layer has properties to go along with its contents.
These are written on the wire and inform how they layer should be transmitted at each hop.
This is primarily for the purpose of supporting intermediaries, but this information may also be used by the decoder.</t>

<t>All currently defined properties are optional.</t>

<t><list style="symbols">
  <t><spanx style="verb">id</spanx>.
A numeric identifier for the layer.
If non-zero, this value MUST be unique.
The default value is 0.</t>
  <t><spanx style="verb">order</spanx>.
A numeric priority such that the smaller values take priority.
A sender SHOULD transmit layers with smallest value first, effectively starving layers with larger values during congestion.
If two layers use the same value, they SHOULD be round-robined.
Note that layers can still arrive out of the intended order due to packet loss.
The default value is 0.</t>
  <t><spanx style="verb">dependency</spanx>.
A numeric value that indicates this layer depends on the specified layer id.
TODO do we need multiple dependencies?
This informs the decoder that it MUST receive and process the dependency layer first.
The decoder SHOULD support stream processing, such that it does not need to receive the entire dependency layer first.
The layer MUST have a larger <spanx style="verb">order</spanx> than its dependency, if present.
The default value is 0, which means no dependency.</t>
  <t><spanx style="verb">cache</spanx>.
TODO Indicates the layer should be cached for some amount of time since last access. What about fragments with an unbounded age? Should we send an <spanx style="verb">expire</spanx> message instead?</t>
  <t><spanx style="verb">expires</spanx>.
TODO Indicates the layer should be dropped after some amount of time (ex. <spanx style="verb">RESET_STREAM</spanx>). Do we need clock sync for this? How does this interact with <spanx style="verb">cache</spanx>?</t>
  <t><spanx style="verb">timestamp</spanx>.
TODO The presentation timestamp of the earliest (not always first) frame in the layer. What does an intermediary need this for?</t>
</list></t>

<t>TODO example priorities</t>

</section>
<section anchor="tracks" title="Tracks">
<t>The simplest configuration is a single layer spanning the entire broadcast.
This is effectively a TCP stream and is a direct replacement for RTMP.
The downside of a single layer is that it can only respond to congestion by modifying the encoder bitrate, so it SHOULD NOT be used over networks with congestion.</t>

<t>Each track (audio and/or video) can be split into separate layers.
This improves user experience as individual tracks can be prioritized during congestion.
For example, audio could be prioritized before video, and/or a lower bitrate rendition could be prioritized before a higher bitrate rendition.</t>

<t>A layer MAY contain multiple tracks.
A layer SHOULD contain a single track.</t>

<t>A single layer per track means that all media within the track is ordered.
Multiple layers per track allow sections to be dropped or prioritized, which is necessary to skip media and reduce queuing.
The next section covers how to further split layers based on the type of media.</t>

</section>
<section anchor="video" title="Video">

<section anchor="encoding" title="Encoding">
<t>Video is a sequence of frames with a display timestamp.
To improve compression, frames are encoded as deltas and can reference number of frames in the past (P-frames) and/or in the future (B-frames).
A frame with no dependencies (I-frame) is effectively an image file and is a seek point.</t>

<t>A common encoding structure is to only reference the previous frame, as it is simple and minimizes latency:</t>

<figure><artwork><![CDATA[
 I <- P <- P <- P   I <- P <- P <- P   I <- P ...
]]></artwork></figure>

<t>Another common encoding structure is to use B-frames in a fixed pattern, which is easier for hardware encoding.
B-frames reference one or more future frames, which improves the compression ratio but increases latency.</t>

<t>This example is referenced in later sections:</t>

<figure><artwork><![CDATA[
    B     B         B     B         B
   / \   / \       / \   / \       / \
  /   \ /   \     /   \ /   \     /   \
 I <-- P <-- P   I <-- P <-- P   I <-- P ...
]]></artwork></figure>

<t>Note that the B-frames reference I and P frames in this example, despite the lack of an arrow.
TODO better ASCII art</t>

<t>There is no such thing as an optimal encoding structure.
Encoders tuned for the best quality will produce a tangled spaghetti of references.
Encoders tuned for the lowest latency still have a lot of options for references.</t>

</section>
<section anchor="decode-order" title="Decode Order">
<t>The encoder outputs the bitstream in decode order, which means that each frame is output after its dependencies.
This is only relevant for B-frames as they must be buffered until the frame they reference has been flushed.</t>

<t>A layer MUST be in decode order.</t>

<t>For the example above, this would look like:</t>

<figure><artwork><![CDATA[
encode order: I B P B P I B P B P I B P ..
decode order: I P B P B I P B P B I P B ..
]]></artwork></figure>

</section>
<section anchor="group-of-pictures" title="Group of Pictures">
<t>A group of pictures (GoP) is consists of an I-frame and the frames that directly or indirectly reference it.
Each GoP can be decoded independently and thus can be transmitted independently.
It is also safe to drop the tail of the GoP (in decode order) without causing decode errors.</t>

<t>A layer MAY consist of an entire GoP.
A layer MAY consist of multiple sequential GoPs.</t>

<t>Our example GoP structure would be split into three layers.</t>

<figure><artwork><![CDATA[
     layer 1         layer 2      layer 3
+---------------+---------------+---------
| I  P  B  P  B | I  P  B  P  B | I  P  B
+---------------+---------------+---------
]]></artwork></figure>

</section>
<section anchor="scalable-video-coding" title="Scalable Video Coding">
<t>The concept of layers is borrowed from scalable video coding (SVC).
When SVC is enabled, the encoder produces multiple bitstreams in a hierarchy.
Dropping the top layer degrades the user experience in a configured way, such as reducing the resolution, picture quality, and/or frame rate.</t>

<t>A layer MAY consist of an entire SVC layer.</t>

<t>Our example GoP structure would be split into six layers, assuming the B frames are part of a SVC layer:</t>

<figure><artwork><![CDATA[
    layer 2       layer 4     layer 6
+-------------+-------------+--------
|    B   B    |    B   B    |    B
+-------------+-------------+--------
|  I   P   P  |  I   P   P  |  I   P
+-------------+-------------+--------
    layer 1       layer 3     layer 5
]]></artwork></figure>

<t>Note that SVC encoding is more complicated than this; our example is a simple temporal encoding scheme.</t>

</section>
<section anchor="frames" title="Frames">
<t>With full knowledge of the encoding, the producer can split a GoP into multiple layers based on the frame.
However, this is highly dependent on the encoding, and the additional complexity might not improve the user experience.</t>

<t>A layer MAY consist of a single frame.</t>

<t>Our example GoP structure could be split into thirteen layers:</t>

<figure><artwork><![CDATA[
      2     4           7     9           12
+--------+--------+--------+--------+-----------+
|     B  |  B     |     B  |  B     |     B     |
|-----+--+--+-----+-----+--+--+-----+-----+-----+
|  I  |  P  |  P  |  I  |  P  |  P  |  I  |  P  |
+-----+-----+-----+-----+-----+-----+-----+-----+
   1     3     5     6     8     10    11    13
]]></artwork></figure>

<t>To reduce the number of layers, frames can be appended to a layer they depend on.
Layers are delivered in order so this is simpler and produces the same user experience.</t>

<t>A layer MAY consist of multiple frames within the same GoP.</t>

<t>The same GoP structure can be represented using eight layers:</t>

<figure><artwork><![CDATA[
      2     3           5     6           8
+--------+--------+-----------------+------------
|     B  |  B     |     B  |  B     |     B     |
+--------+--------+--------+--------+-----------+
|  I     P     P  |  I     P     P  |  I     P
+-----------------+-----------------+------------
         1                 4              7
]]></artwork></figure>

<t>We can further reduce the number of layers by combining some frames that don't depend on each other.
The only restriction is that frames can only reference frames earlier in the layer, or within a dependency layer.
For example, non-reference frames can have their own layer so they can be prioritized or dropped separate from reference frames.</t>

<t>The same GoP structure can also be represented using six layers, although we've removed our ability to drop individual B-frames:</t>

<figure><artwork><![CDATA[
    layer 2       layer 4     layer 6
+-------------+-------------+--------
|    B   B    |    B   B    |    B
+-------------+-------------+--------
|  I   P   P  |  I   P   P  |  I   P
+-------------+-------------+--------
    layer 1       layer 3     layer 5
]]></artwork></figure>

<t>Note that this is identical to our SVC example; we've effectively implemented our own temporal coding scheme.</t>

</section>
<section anchor="slices" title="Slices">
<t>Frames actually consist of multiple slices that reference other slices.
It's conceptually simpler to work with frames instead of slices, but splitting slices into layers may be useful.
For example, intra-refresh splits an I-frame into multiple I-slices (TODO terminology) and spread over multiple frames to smooth out the bitrate.
TODO are slices necessary?</t>

<t>A layer MAY consist of a single slice.
A layer MAY consist of multiple slices that are part of the same GoP.</t>

</section>
<section anchor="init" title="Init">
<t>For the most byte-conscious applications, initialization data can be sent over its own layer.
Multiple layers can depend on this initialization layer to avoid redundant transmissions.
For example: this is the init segment in CMAF (<spanx style="verb">moov</spanx> with no samples), which contains the SPS/PPS NALUs for h.264.</t>

<t>A layer MAY consist of no samples.</t>

<t>Our example layer per GoP would have an extra layer added:</t>

<figure><artwork><![CDATA[
     layer 2         layer 3      layer 4
+---------------+---------------+---------
| I  P  B  P  B | I  P  B  P  B | I  P  B
+---------------+---------------+---------
|                     init
+-----------------------------------------
                     layer 1
]]></artwork></figure>

<t>An initialization layer MUST be cached in memory until it expires.
TODO How do we do this?</t>

</section>
</section>
<section anchor="audio" title="Audio">

<section anchor="encoding-1" title="Encoding">
<t>Audio is dramatically simpler than video as it is not delta encoded.
Audio samples are grouped together (group of samples) at a configured rate, also called a "frame".
Frames do not depend on other frames and have a timestamp for synchronization.</t>

<t>In the below diagrams, each audio frame is denoted with an S.
The encoder spits out a continuous stream of samples:</t>

<figure><artwork><![CDATA[
S S S S S S S S S S S S S
]]></artwork></figure>

</section>
<section anchor="simple" title="Simple">
<t>The simplest configuration is to use a single layer for each audio track.
This may seem inefficient given the ease of dropping audio samples.
However, the audio bitrate is low and gaps cause quite a poor user experience, when compared to video.</t>

<t>A layer SHOULD consist of multiple audio frames.</t>

<figure><artwork><![CDATA[
          layer 1
+---------------------------
| S S S S S S S S S S S S S
+---------------------------
]]></artwork></figure>

</section>
<section anchor="refresh" title="Refresh">
<t>An improvement is to periodically split audio samples into separate layers.
This gives the consumer the ability to skip ahead during severe congestion or temporary connectivity loss.</t>

<figure><artwork><![CDATA[
     layer 1         layer 2      layer 3
+---------------+---------------+---------
| S  S  S  S  S | S  S  S  S  S | S  S  S
+---------------+---------------+---------
]]></artwork></figure>

<t>This frequency of audio layers is configurable, at the cost of additional overhead.
It's NOT RECOMMENDED to create a layer for each audio frame because of this overhead.</t>

<t>Video can only recover from severe congestion with an I-frame, so there's not much point recovering audio at a separate interval.
It is RECOMMENDED to create a new audio layer at each video I-frame.</t>

<figure><artwork><![CDATA[
     layer 1         layer 3      layer 5
+---------------+---------------+---------
| S  S  S  S  S | S  S  S  S  S | S  S  S
+---------------+---------------+---------
| I  P  B  P  B | I  P  B  P  B | I  P  B
+---------------+---------------+---------
     layer 2         layer 4      layer 6
]]></artwork></figure>

<t>This is effectively how HLS/DASH segments work, with the exception that the most recent layers are still pending.</t>

</section>
</section>
<section anchor="synchronization" title="Synchronization">
<t>The decoder MUST synchronize layers using presentation timestamps within the bitstream.</t>

<t>Layers are NOT REQUIRED to be aligned within or between tracks.
For example, a low quality rendition may have more frequent I-frames, and thus layers, than a higher quality rendition.
A decoder MUST be prepared to skip over any gaps between layers.</t>

</section>
</section>
<section anchor="quic" title="QUIC">

<section anchor="establishment" title="Establishment">
<t>A connection is established using WebTransport (<xref target="WebTransport"/>).</t>

<t>To summarize:
The client issues a HTTP CONNECT request with the intention of establishing a new WebTransport session.
The server returns an 200 OK response if the WebTransport session has been established, or an error status otherwise.
A WebTransport session mimics the QUIC API: either endpoint may create independent streams which are reliably delivered in order until canceled.</t>

<t>WebTransport can currently operate via HTTP/3 and HTTP/2, using QUIC or TCP under the hood respectively.
As mentioned in the motivation (<xref target="motivation"/>) section, TCP introduces head-of-line blocking and will result in a worse experience.
It is RECOMMENDED to use WebTransport over HTTP/3.</t>

<t>The application SHOULD use the CONNECT request for authentication and negotiation.
For example, including a authentication token and some identifier in the path.
The application MAY use QUIC streams for more complicated behavior.</t>

<t>TODO define auth inside the protocol?</t>

</section>
<section anchor="streams" title="Streams">
<t>Warp endpoints communicate over unidirectional QUIC streams.
The application MAY use bidirectional QUIC streams for other purposes.</t>

<t>A stream consists of sequential messages.
See messages (<xref target="messages"/>) for the list of messages and their encoding.
These are similar to QUIC and HTTP/3 frames, but called messages to avoid the media terminology.</t>

<t>Each stream MUST start with a <spanx style="verb">HEADERS</spanx> message. TODO better name.
This message includes information on how intermediaries should proxy or cache the stream.
If a stream is used to transmit a layer, the header MUST match the layer properties (<xref target="properties"/>).</t>

<t>Messages SHOULD be sent over the same stream if ordering is desired.
For example, <spanx style="verb">PAUSE</spanx> and <spanx style="verb">PLAY</spanx> messages SHOULD be sent on the same stream to avoid a race.</t>

</section>
<section anchor="prioritization" title="Prioritization">
<t>Warp utilizes stream prioritization to deliver the most important content during congestion.</t>

<t>The media producer SHOULD assign a numeric order to each stream, as contained in the HEADERS message (<xref target="headers"/>).
This is a strict prioritization scheme, such that any available bandwidth is allocated to streams in ascending order.
The order is determined at encode, written to the wire so it can be read by intermediaries, and will not be updated.
This effectively creates a priority queue that can be maintained over multiple hops.</t>

<t>QUIC supports stream prioritization but does not standardize any mechanisms; see Section 2.3 in <xref target="QUIC"/>.
QUIC libraries will need to expose a API to the application to set the priority of each stream.</t>

<t>Senders SHOULD support prioritized streams, although it is OPTIONAL on a path with no expected congestion.
Senders SHOULD use strict ordering, although relative weights MAY be acceptable if there are no other options.
Senders MUST obey the order as written to the wire.
Senders MAY choose to delay retransmitting lower priority streams when possible within QUIC flow control limits.</t>

</section>
<section anchor="cancellation" title="Cancellation">
<t>QUIC streams can be canceled by either endpoint with an error code.</t>

<t>When using <spanx style="verb">order</spanx>, lower priority streams will be starved during congestion, perhaps indefinitely.
These streams will consume resources and flow control until they are canceled.
When nearing resource limits, an endpoint SHOULD cancel the lowest priority stream with error code 0.</t>

<t>When using <spanx style="verb">expires</spanx>, a stream SHOULD be canceled after the duration has elapsed.
This is not a full replacement for prioritization, but can provide some congestion response by clearing parts of the queue.</t>

</section>
<section anchor="congestion-control" title="Congestion Control">
<t>As covered in the motivation section (<xref target="motivation"/>), the ability to prioritize or cancel streams is a form of congestion response.
It's equally important to detect congestion via congestion control, which is handled in the QUIC layer.</t>

<t>Bufferbloat is caused by routers queueing packets for an indefinite amount of time rather than drop them.
This latency significantly reduces the ability for the application to prioritize or drop media in response to congestion.
Senders SHOULD use a congestion control algorithm that reduces this bufferbloat.
It is NOT RECOMMENDED to use a loss-based algorithm (ex. Reno, CUBIC) unless the network fully supports ECN.</t>

<t>Live media is application-limited, which means that the encoder determines the max bitrate rather than the network.
Most TCP congestion control algorithms will only increase the congestion window if it is full, limiting the upwards mobility when application-limited.
Senders SHOULD use a congestion control algorithm that is designed for application-limited flows (ex. GCC).
Senders MAY periodically pad the connection with QUIC PING frames to fill the congestion window.</t>

</section>
<section anchor="termination" title="Termination">
<t>The QUIC connection can be terminated at any point with an error code.</t>

<t>The media producer MAY terminate the QUIC connection with an error code of 0 to indicate the clean termination of the broadcast.
The application SHOULD use a non-zero error code to indicate a fatal error.</t>

<texttable>
      <ttcol align='right'>Code</ttcol>
      <ttcol align='left'>Reason</ttcol>
      <c>0x0</c>
      <c>Broadcast Terminated</c>
      <c>0x1</c>
      <c>GOAWAY <xref target="goaway"/></c>
</texttable>

<t>TODO define more error codes</t>

</section>
</section>
<section anchor="messages" title="Messages">
<t>Messages consist of a type identifier followed by contents, depending on the message type.</t>

<t>TODO document varint identifier
TODO more message types</t>

<texttable>
      <ttcol align='right'>ID</ttcol>
      <ttcol align='left'>Messages</ttcol>
      <c>0x0</c>
      <c>HEADERS <xref target="headers"/></c>
      <c>0x1</c>
      <c>LAYER <xref target="layer"/></c>
      <c>0x2</c>
      <c>APP <xref target="app"/></c>
      <c>0x10</c>
      <c>GOAWAY <xref target="goaway"/></c>
</texttable>

<section anchor="headers" title="HEADERS">
<t>The <spanx style="verb">HEADERS</spanx> message contains the information listed in layer properties (<xref target="properties"/>).</t>

<t>TODO better name
TODO document wire format
TODO use QPACK?</t>

</section>
<section anchor="layer" title="LAYER">
<t>A <spanx style="verb">LAYER</spanx> message consists of the layer bitstream.
A <spanx style="verb">LAYER</spanx> message must be proceeded with a <spanx style="verb">HEADERS</spanx> message specifying the layer properties (<xref target="properties"/>).</t>

<t>TODO document CMAF
TODO document wire format
TODO support multiple container formats</t>

</section>
<section anchor="app" title="APP">
<t>The <spanx style="verb">APP</spanx> message contains arbitrary contents.
A stream containing <spanx style="verb">APP</spanx> message SHOULD be cached and forwarded by intermediaries like any other stream; based on the <spanx style="verb">HEADERS</spanx> message (<xref target="headers"/>).</t>

<t>TODO document wire format</t>

</section>
<section anchor="goaway" title="GOAWAY">
<t>The <spanx style="verb">GOAWAY</spanx> message is sent by the server to force the client to reconnect.
This is useful for server maintenance or reassignments without severing the QUIC connection.
A server MAY use QUIC load balancing instead of a GOAWAY message.</t>

<t>The server initiates the graceful shutdown by sending a GOAWAY message.
The server MUST close the QUIC connection after a timeout with the GOAWAY error code (<xref target="termination"/>).
The server MAY close the QUIC connection with a different error code if there is a fatal error before shutdown.
The server SHOULD wait until the <spanx style="verb">GOAWAY</spanx> message and any pending streams have been fully acknowledged, plus an extra delay to ensure they have been processed.</t>

<t>A client that receives a <spanx style="verb">GOAWAY</spanx> message should establish a new WebTransport session to the provided URL.
This session SHOULD be made in parallel and MUST use a different QUIC connection (not pooled).
The optimal client will be connected for two servers for a short period, potentially receiving layers from both in parallel.</t>

</section>
</section>
<section anchor="security-considerations" title="Security Considerations">
<t>TODO expand</t>

<section anchor="resource-exhaustion" title="Resource Exhaustion">
<t>Live media requires significant bandwidth and resources.
Failure to set limits will quickly cause resource exhaustion.</t>

<t>Warp uses QUIC flow control to impose resource limits at the network layer.
Endpoints SHOULD set flow control limits based on the anticipated media bitrate.</t>

<t>The media producer prioritizes and transmits streams out of order.
Streams might be starved indefinitely during congestion and SHOULD be canceled after hitting some timeout or resource limit.</t>

<t>The media consumer might receive streams out of order.
If stream data is buffered, for example to decode segments in order, then the media consumer SHOULD cancel a stream after hitting some timeout or resource limit.</t>

</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">
<t>TODO</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference anchor='QUIC' target='https://www.rfc-editor.org/info/rfc9000'>
<front>
<title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>
<author fullname='J. Iyengar' initials='J.' role='editor' surname='Iyengar'><organization/></author>
<author fullname='M. Thomson' initials='M.' role='editor' surname='Thomson'><organization/></author>
<date month='May' year='2021'/>
<abstract><t>This document defines the core of the QUIC transport protocol.  QUIC provides applications with flow-controlled streams for structured communication, low-latency connection establishment, and network path migration. QUIC includes security measures that ensure confidentiality, integrity, and availability in a range of deployment circumstances.  Accompanying documents describe the integration of TLS for key negotiation, loss detection, and an exemplary congestion control algorithm.</t></abstract>
</front>
<seriesInfo name='RFC' value='9000'/>
<seriesInfo name='DOI' value='10.17487/RFC9000'/>
</reference>



<reference anchor='QUIC-RECOVERY' target='https://www.rfc-editor.org/info/rfc9002'>
<front>
<title>QUIC Loss Detection and Congestion Control</title>
<author fullname='J. Iyengar' initials='J.' role='editor' surname='Iyengar'><organization/></author>
<author fullname='I. Swett' initials='I.' role='editor' surname='Swett'><organization/></author>
<date month='May' year='2021'/>
<abstract><t>This document describes loss detection and congestion control mechanisms for QUIC.</t></abstract>
</front>
<seriesInfo name='RFC' value='9002'/>
<seriesInfo name='DOI' value='10.17487/RFC9002'/>
</reference>


<reference anchor='WebTransport'>
   <front>
      <title>WebTransport over HTTP/3</title>
      <author fullname='Alan Frindell' initials='A.' surname='Frindell'>
         <organization>Facebook</organization>
      </author>
      <author fullname='Eric Kinnear' initials='E.' surname='Kinnear'>
         <organization>Apple Inc.</organization>
      </author>
      <author fullname='Victor Vasiliev' initials='V.' surname='Vasiliev'>
         <organization>Google</organization>
      </author>
      <date day='6' month='July' year='2022'/>
      <abstract>
	 <t>   WebTransport [OVERVIEW] is a protocol framework that enables clients
   constrained by the Web security model to communicate with a remote
   server using a secure multiplexed transport.  This document describes
   a WebTransport protocol that is based on HTTP/3 [HTTP3] and provides
   support for unidirectional streams, bidirectional streams and
   datagrams, all multiplexed within the same HTTP/3 connection.

	 </t>
      </abstract>
   </front>
   <seriesInfo name='Internet-Draft' value='draft-ietf-webtrans-http3-03'/>
   <format target='https://www.ietf.org/archive/id/draft-ietf-webtrans-http3-03.txt' type='TXT'/>
</reference>


<reference anchor="ISOBMFF" >
  <front>
    <title>Information technology â Coding of audio-visual objects â Part 12: ISO Base Media File Format</title>
    <author >
      <organization></organization>
    </author>
    <date year="2015" month="December"/>
  </front>
</reference>




<reference anchor='RFC2119' target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author fullname='S. Bradner' initials='S.' surname='Bradner'><organization/></author>
<date month='March' year='1997'/>
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference anchor='RFC8174' target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author fullname='B. Leiba' initials='B.' surname='Leiba'><organization/></author>
<date month='May' year='2017'/>
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>




    </references>

    <references title='Informative References'>

<reference anchor="CMAF" >
  <front>
    <title>Information technology -- Multimedia application format (MPEG-A) -- Part 19: Common media application format (CMAF) for segmented media</title>
    <author >
      <organization></organization>
    </author>
    <date year="2020" month="March"/>
  </front>
</reference>




<reference anchor='NewReno' target='https://www.rfc-editor.org/info/rfc6582'>
<front>
<title>The NewReno Modification to TCP's Fast Recovery Algorithm</title>
<author fullname='T. Henderson' initials='T.' surname='Henderson'><organization/></author>
<author fullname='S. Floyd' initials='S.' surname='Floyd'><organization/></author>
<author fullname='A. Gurtov' initials='A.' surname='Gurtov'><organization/></author>
<author fullname='Y. Nishida' initials='Y.' surname='Nishida'><organization/></author>
<date month='April' year='2012'/>
<abstract><t>RFC 5681 documents the following four intertwined TCP congestion control algorithms: slow start, congestion avoidance, fast retransmit, and fast recovery.  RFC 5681 explicitly allows certain modifications of these algorithms, including modifications that use the TCP Selective Acknowledgment (SACK) option (RFC 2883), and modifications that respond to &quot;partial acknowledgments&quot; (ACKs that cover new data, but not all the data outstanding when loss was detected) in the absence of SACK.  This document describes a specific algorithm for responding to partial acknowledgments, referred to as &quot;NewReno&quot;.  This response to partial acknowledgments was first proposed by Janey Hoe.  This document obsoletes RFC 3782.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6582'/>
<seriesInfo name='DOI' value='10.17487/RFC6582'/>
</reference>


<reference anchor='BBR'>
   <front>
      <title>BBR Congestion Control</title>
      <author fullname='Neal Cardwell' initials='N.' surname='Cardwell'>
         <organization>Google</organization>
      </author>
      <author fullname='Yuchung Cheng' initials='Y.' surname='Cheng'>
         <organization>Google</organization>
      </author>
      <author fullname='Soheil Hassas Yeganeh' initials='S. H.' surname='Yeganeh'>
         <organization>Google</organization>
      </author>
      <author fullname='Ian Swett' initials='I.' surname='Swett'>
         <organization>Google</organization>
      </author>
      <author fullname='Van Jacobson' initials='V.' surname='Jacobson'>
         <organization>Google</organization>
      </author>
      <date day='7' month='March' year='2022'/>
      <abstract>
	 <t>   This document specifies the BBR congestion control algorithm.  BBR
   (&quot;Bottleneck Bandwidth and Round-trip propagation time&quot;) uses recent
   measurements of a transport connection&#39;s delivery rate, round-trip
   time, and packet loss rate to build an explicit model of the network
   path.  BBR then uses this model to control both how fast it sends
   data and the maximum volume of data it allows in flight in the
   network at any time.  Relative to loss-based congestion control
   algorithms such as Reno [RFC5681] or CUBIC [RFC8312], BBR offers
   substantially higher throughput for bottlenecks with shallow buffers
   or random losses, and substantially lower queueing delays for
   bottlenecks with deep buffers (avoiding &quot;bufferbloat&quot;).  BBR can be
   implemented in any transport protocol that supports packet-delivery
   acknowledgment.  Thus far, open source implementations are available
   for TCP [RFC793] and QUIC [RFC9000].  This document specifies version
   2 of the BBR algorithm, also sometimes referred to as BBRv2 or bbr2.

	 </t>
      </abstract>
   </front>
   <seriesInfo name='Internet-Draft' value='draft-cardwell-iccrg-bbr-congestion-control-02'/>
   <format target='https://www.ietf.org/archive/id/draft-cardwell-iccrg-bbr-congestion-control-02.txt' type='TXT'/>
</reference>




    </references>


<section numbered="false" anchor="contributors" title="Contributors">

<t>TODO</t>

</section>


  </back>

<!-- ##markdown-source:
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
1VlQIpzNkJstRAd1roBUsem/7MBjOaDgSr4+jrv0JLjT3QAht+xpInSPdpPb
WHiuXiCYrDmCoC1oZrngJpbe2cCvIZ44StMjUpUT7oe4QvALW/artsGVAji6
V3G7O1EyDzvXWVH5/TpZnCcpXsERY35Hp0w0KKEv0ckap3Lpoe9eJvZnxytA
u3ljlEBclk4zh578cObeekqzfHtj14e4Qyl8eR9sGYVVcI842SfNiWwPk+MR
+kHI1t0Ure/qyCS60FTdVVNum0ygd6xof2OgO7Hu+U4VHGtnYxrxjVmse9Jm
IQKi3ujCvLl4obQcnug4eG0X3FuF9HxRkEMICDARiG3UoWCII762Y1NVBARF
beiw1TOFSISOCT2wt5XiRP02ufhY7VmCZdVIUkCqEgggyVVDXJ7AF5QmW5Yr
2WYuazlYgDtc6dji2vtwF8iGzsVy4iKEIk7frcizZDM3cWf0hlmfuoNJfFTv
fZZoyHT0zOZFK/8QBCJzEt2Qg+Mf07hGfJIrMGIAxMVVEbzgSDR6wncDSg1f
RFClY3V69aWCg6Zu82lM8YTIH21oT4iqL3Ut0lj5xsZ/qqYrkN1ntHeuru9d
tuojo+glTBoi1iSUtiIlUak09LQbouK57wzdrELVMaIsQRCxEE7h1DtALFSS
jYTLi/Zv+mwZNCDX1UZPG5y+7FIVEvlgkRQrJkIGl2MvwartbaAf7Ipxql94
ss/M2fGr432krv8gEG5ix2Mn4b7Rqvaj90fSieEW//xgaQvvHnwUrTr6X+gP
4puRbAAA

-->

</rfc>

