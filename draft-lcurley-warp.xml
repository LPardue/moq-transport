<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.5.5 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc docmapping="yes"?>

<rfc ipr="trust200902" docName="draft-lcurley-warp-latest" category="info">

  <front>
    <title abbrev="WARP">Warp - Segmented Live Media Transport</title>

    <author initials="L." surname="Curley" fullname="Luke Curley">
      <organization>Twitch</organization>
      <address>
        <email>kixelated@gmail.com</email>
      </address>
    </author>
    <author initials="K." surname="Pugin" fullname="Kirill Pugin">
      <organization>Meta</organization>
      <address>
        <email>ikir@meta.com</email>
      </address>
    </author>
    <author initials="S." surname="Nandakumar" fullname="Suhas Nandakumar">
      <organization>Cisco</organization>
      <address>
        <email>snandaku@cisco.com</email>
      </address>
    </author>

    <date />

    <area>General</area>
    <workgroup>Independent Submission</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This document defines the core behavior for Warp, a segmented live media transport protocol over QUIC.
Media is split into segments based on the underlying media encoding and transmitted independently over QUIC streams.
QUIC streams are prioritized based on the delivery order, allowing less important segments to be starved or dropped during congestion.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">
<t>Warp is a live media transport protocol that utilizes the QUIC network protocol <xref target="QUIC"/>.</t>

<t><list style="symbols">
  <t><xref target="motivation"/> covers the background and rationale behind Warp.</t>
  <t><xref target="segments"/> covers how media is encoded and split into segments.</t>
  <t><xref target="quic"/> covers how QUIC is used to transfer media.</t>
  <t><xref target="messages"/> covers how messages are encoded on the wire.</t>
</list></t>

<section anchor="terms-and-definitions" title="Terms and Definitions">

<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
"MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCPÂ 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they
appear in all capitals, as shown here.</t>

<t>Commonly used terms in this document are described below.</t>

<t><list style="hanging">
  <t hangText="Bitstream:">
  A continunous series of bytes.</t>
  <t hangText="Codec:">
  A compression algorithm for audio or video.</t>
  <t hangText="Congestion:">
  Packet loss and queuing caused by degraded or overloaded networks.</t>
  <t hangText="Consumer:">
  A QUIC endpoint receiving media over the network. This could be the media player or middleware.</t>
  <t hangText="Container:">
  A file format containing timestamps and the codec bitstream</t>
  <t hangText="Decoder:">
  A endpoint responsible for a deflating a compressed media stream into raw frames.</t>
  <t hangText="Decode Timestamp (DTS):">
  A timestamp indicating the order that frames/samples should be fed to the decoder.</t>
  <t hangText="Encoder:">
  A component responsible for creating a compressed media stream out of raw frames.</t>
  <t hangText="Frame:">
  An video image or group of audio samples to be rendered at a specific point in time.</t>
  <t hangText="I-frame:">
  A frame that does not depend on the contents of other frames; effectively an image.</t>
  <t hangText="Group of pictures (GoP):">
  A I-frame followed by a sequential series of dependent frames.</t>
  <t hangText="Group of samples:">
  A sequential series of audio samples starting at a given timestamp.</t>
  <t hangText="Player:">
  A component responsible for presenting frames to a viewer based on the presentation timestamp.</t>
  <t hangText="Presentation Timestamp (PTS):">
  A timestamp indicating when a frames/samples should be presented to the viewer.</t>
  <t hangText="Producer:">
  A QUIC endpoint sending media over the network. This could be the media encoder or middleware.</t>
  <t hangText="Rendition:">
  One or more tracks with the same content but different encodings.</t>
  <t hangText="Slice:">
  A section of a video frame. There may be multiple slices per frame.</t>
  <t hangText="Track:">
  An encoded bitstream, representing a single video/audio component that makes up the larger broadcast.</t>
</list></t>

</section>
</section>
<section anchor="motivation" title="Motivation">

<section anchor="latency" title="Latency">
<t>In a perfect world, we could deliver live media at the same rate it is produced.
The end-to-end latency of a broadcast would be fixed and only subject to encoding and transmission delays.
Unfortunately, networks have variable throughput, primarily due to congestion.</t>

<t>Attempting to deliver media encoded at a higher bitrate than the network can support causes queuing.
This queuing can occur anywhere in the path between the encoder and decoder.
For example: the application, the OS socket, a wifi router, within an ISP, or generally anywhere in transit.</t>

<t>If nothing is done, new frames will be appended to the end of a growing queue and will take longer to arrive than their predecessors, increasing latency.
Our job is to minimize the growth of this queue, and if necessary, bypass the queue entirely by dropping content.</t>

<t>The speed at which a media protocol can detect and respond to queuing determines the latency.
We can generally classify existing media protocols into two categories based on the underlying network protocol:</t>

<t><list style="symbols">
  <t>TCP-based media protocols (ex. RTMP, HLS, DASH) are popular due to their simplicity.
Media is served/consumed in decode order while any networking is handled by the TCP layer.
However, these protocols primarily see usage at higher latency targets due to their relatively slow detection and response to queuing.</t>
  <t>UDP-based media protocols (ex. RTP, WebRTC, SRT) can side-step the issues with TCP and provide lower latency with better queue management.
However the media protocol is now responsible for fragmentation, congestion control, retransmissions, receiver feedback, reassembly, and more.
This added complexity significantly raises the implementation difficulty and hurts interoperability.</t>
</list></t>

<t>A goal of this draft is to get the best of both worlds: a simple protocol that can still rapidly detect and respond to congestion.
This is possible emergence of QUIC, designed to fix the shortcomings of TCP.</t>

</section>
<section anchor="universal" title="Universal">
<t>The media protocol ecosystem is fragmented; each protocol has it's own niche.
Specialization is often a good thing, but we believe there's enough overlap to warrant consolidation.</t>

<t>For example, a service might simultaneously ingest via WebRTC, SRT, RTMP, and/or a custom UDP protocol depending on the broadcaster.
The same service might then simultaneously distribute via WebRTC, LL-HLS, HLS, (or the DASH variants) and/or a custom UDP protocol depending on the viewer.</t>

<t>These media protocols are often radically different and not interoperable; requiring transcoding or transmuxing.
This cost is further increased by the need to maintain separate stacks with different expertise requirements.</t>

<t>A goal of this draft is to cover a large spectrum of use-cases. Specifically:</t>

<t><list style="symbols">
  <t>Consolidated contribution and distribution.
The primary difference between the two is the ability to fanout.
How does a CDN know how to forward media to N consumers and how does it reduce the encoded bitrate during congestion?
A single protocol can cover both use-cases provided relays are informed on how to forward and drop media.</t>
  <t>A configurable latency versus quality trade-off.
The producer (broadcaster) chooses how to encode and transmit media based on the desired user experience.
Each consumer (viewer) chooses how long to wait for media based on their desired user experience and network.
We want an experience that can vary from real-time and lossy for one viewer, to delayed and loss-less for another viewer, without separate encodings or protocols.</t>
</list></t>

<t>A related goal is to not reinvent how media is encoded.
The same codec bitstream and container should be usable between different protocols.</t>

</section>
<section anchor="relays" title="Relays">
<t>The prevailing belief is that UDP-based protocols are more expensive and don't "scale".
While it's true that UDP is more difficult to optimize than TCP, QUIC itself is proof that it is possible to reach performance parity.
In fact even some TCP-based protocols (ex. RTMP) don't "scale" either and are exclusively used for contribution as a result.</t>

<t>The ability to scale a media protocol actually depends on relay support: proxies, caches, CDNs, SFUs, etc.
The success of HTTP-based media protocols is due to the ability to leverage traditional HTTP CDNs.</t>

<t>It's difficult to build a CDN for media protocols that were not designed with relays in mind.
For example, an relay has to parse the underlying codec to determine which RTP packets should be dropped first, and the decision is not deterministic or consistent for each hop.
This is the fatal flaw of many UDP-based protocols.</t>

<t>A goal of this draft is to treat relays as first class citizens.
Any identification, reliability, ordering, prioritization, caching, etc is written to the wire in a header that is easy to parse.
This ensures that relays can easily route/fanout media to the final destination.
This also ensures that congestion response is consistent at every hop based on the preferences of the media producer.</t>

</section>
</section>
<section anchor="segments" title="Segments">
<t>Warp works by splitting media into segments that can be transferred over QUIC streams.</t>

<t><list style="symbols">
  <t>The encoder determines how to fragment the encoded bitstream into segments (<xref target="media"/>).</t>
  <t>Segments are assigned an intended delivery order that should be obeyed during congestion (<xref target="delivery-order"/>)</t>
  <t>Segments can be dependent on other segments, in which case reordering is required (<xref target="dependencies"/>).</t>
  <t>The decoder receives each segment and skips any segments that do not arrive in time (<xref target="decoder"/>).</t>
</list></t>

<section anchor="media" title="Media">
<t>An encoder produces one or more codec bitstreams for each track.
The decoder processes the codec bitstreams in the same order they were produced, with some possible exceptions based on the encoding.
See the appendix for an overview of media encoding (<xref target="appendix.encoding"/>).</t>

<t>Warp works by fragmenting the bitstream into segments that can be transmitted somewhat independently.
Depending on how the segments are fragmented, the decoder has the ability to safely drop media during congestion.
See the appendix for fragmentation examples (<xref target="appendix.examples"/>)</t>

<t>A segment:</t>

<t><list style="symbols">
  <t>MUST contain a single track.</t>
  <t>MUST be in decode order. This means an increasing DTS.</t>
  <t>MAY contain any number of frames/samples.</t>
  <t>MAY have gaps between frames/samples.</t>
  <t>MAY overlap with other segments. This means timestamps may be interleaved between segments.</t>
  <t>MAY reference frames in other segments, but only if listed as a dependency.</t>
</list></t>

<t>Segments are encoded using fragmented MP4 <xref target="ISOBMFF"/>.
This is necessary to store timestamps and various metadata depending on the codec.
A future draft of Warp may specify other container formats.</t>

</section>
<section anchor="delivery-order" title="Delivery Order">
<t>Media is produced with an intended order, both in terms of when media should be presented (PTS) and when media should be decoded (DTS).
As stated in motivation (<xref target="latency"/>), the network is unable to maintain this ordering during congestion without increasing latency.</t>

<t>The encoder determines how to behave during congestion by assigning each segment a numeric delivery order.
The delivery order SHOULD be followed when possible to ensure that the most important media is delivered when throughput is limited.
Note that the contents within each segment are still delivered in order; this delivery order only applies to the ordering between segments.</t>

<t>A segment MUST NOT have a smaller delivery order than a segment it depends on.
Delivering segments out of dependency order will increase latency and can cause artifacting when memory limits are tight.
This is especially problematic and can cause a deadlock if the receiver does not release flow control until dependencies are received.</t>

<t>A sender MUST send each segment over a dedicated QUIC stream.
The QUIC library should support prioritization (<xref target="prioritization"/>) such that streams are transmitted in delivery order.</t>

<t>A receiver MUST NOT assume that segments will be received in delivery order for a number of reasons:</t>

<t><list style="symbols">
  <t>Newly encoded segments MAY have a smaller delivery order than outstanding segments.</t>
  <t>Packet loss or flow control MAY delay the delivery of individual streams.</t>
  <t>The sender might not support QUIC stream prioritization.</t>
</list></t>

</section>
<section anchor="dependencies" title="Dependencies">
<t>Media encoding uses references to improve the compression.
This creates hard and soft dependencies that need to be respected by the transport.
See the appendex for an overview of media encoding (<xref target="appendix.encoding"/>).</t>

<t>A segment MAY depend on any number of other segments.
The encoder MUST indicate these dependecies on the wire via the <spanx style="verb">HEADERS</spanx> message (<xref target="headers"/>).</t>

<t>The sender SHOULD NOT use this list of dependencies to determine which segment to transmit next.
The sender SHOULD use the delivery order instead, which MUST respect dependencies.</t>

<t>The decoder SHOULD process segments according to their dependencies.
This means buffering a segment until the relevent timestamps have been processed in all dependencies.
A decoder MAY drop dependencies at the risk of producing decoding errors and artifacts.</t>

</section>
<section anchor="decoder" title="Decoder">
<t>The decoder will receive multiple segments in parallel and out of order.</t>

<t>Segments arrive in delivery order, but media usually needs to be processed in decode order.
The decoder SHOULD use a buffer to reassmble segments into decode order and it SHOULD skip segments after a configurable duration.
The amount of time the decoder is willing to wait for a segment (buffer duration) is what ultimately determines the end-to-end latency.</t>

<t>Segments MUST synchronize frames within and between tracks using presentation timestamps within the container.
Segments are NOT REQUIRED to be aligned and the decoder MUST be prepared to skip over any gaps.</t>

</section>
</section>
<section anchor="quic" title="QUIC">

<section anchor="establishment" title="Establishment">
<t>A connection is established using WebTransport <xref target="WebTransport"/>.</t>

<t>To summarize:
The client issues a HTTP CONNECT request with the intention of establishing a new WebTransport session.
The server returns an 200 OK response if the WebTransport session has been established, or an error status otherwise.</t>

<t>A WebTransport session exposes the basic QUIC service abstractions.
Specifically, either endpoint may create independent streams which are reliably delivered in order until canceled.</t>

<t>WebTransport can currently operate via HTTP/3 and HTTP/2, using QUIC or TCP under the hood respectively.
As mentioned in the motivation (<xref target="motivation"/>) section, TCP introduces head-of-line blocking and will result in a worse experience.
It is RECOMMENDED to use WebTransport over HTTP/3.</t>

<t>The application SHOULD use the CONNECT request for authentication.
For example, including a authentication token and some identifier in the path.</t>

</section>
<section anchor="streams" title="Streams">
<t>Warp endpoints communicate over unidirectional QUIC streams.
The application MAY use bidirectional QUIC streams for other purposes.</t>

<t>A stream consists of sequential messages.
See messages (<xref target="messages"/>) for the list of messages and their encoding.
These are similar to QUIC and HTTP/3 frames, but called messages to avoid the media terminology.</t>

<t>Each stream MUST start with a <spanx style="verb">HEADERS</spanx> message (<xref target="headers"/>) to indicates how the stream should be transmitted.</t>

<t>Messages SHOULD be sent over the same stream if ordering is desired.
For example, <spanx style="verb">PAUSE</spanx> and <spanx style="verb">PLAY</spanx> messages SHOULD be sent on the same stream to avoid a race.</t>

</section>
<section anchor="prioritization" title="Prioritization">
<t>Warp utilizes stream prioritization to deliver the most important content during congestion.</t>

<t>The encoder may assign a numeric delivery order to each stream (<xref target="delivery-order"/>)
This is a strict prioritization scheme, such that any available bandwidth is allocated to streams in ascending priority order.
The sender SHOULD prioritize streams based on the delivery order.
If two streams have the same delivery order, they SHOULD receive equal bandwidth (round-robin).</t>

<t>QUIC supports stream prioritization but does not standardize any mechanisms; see Section 2.3 in <xref target="QUIC"/>.
In order to support prioritization, a QUIC library MUST expose a API to set the priority of each stream.
This is relatively easy to implement; the next QUIC packet should contain a STREAM frame for the next pending stream in priority order.</t>

<t>The sender MUST respect flow control even if means delivering streams out of delivery order.
It is OPTIONAL to prioritize retransmissions.</t>

</section>
<section anchor="cancellation" title="Cancellation">
<t>A QUIC stream MAY be canceled at any point with an error code.
The producer does this via a <spanx style="verb">RESET_STREAM</spanx> frame while the consumer requests cancellation with a <spanx style="verb">STOP_SENDING</spanx> frame.</t>

<t>When using <spanx style="verb">order</spanx>, lower priority streams will be starved during congestion, perhaps indefinitely.
These streams will consume resources and flow control until they are canceled.
When nearing resource limits, an endpoint SHOULD cancel the lowest priority stream with error code 0.</t>

<t>The sender MAY cancel streams in response to congestion.
This can be useful when the sender does not support stream prioritization.</t>

</section>
<section anchor="relays-1" title="Relays">
<t>Warp encodes the delivery information for each stream via a <spanx style="verb">HEADERS</spanx> frame (<xref target="headers"/>).
This MUST be at the start of each stream so it is easy for a relay to parse.</t>

<t>A relay SHOULD prioritize streams (<xref target="prioritization"/>) based on the delivery order.
A relay MAY change the delivery order, in which case it SHOULD update the value on the wire for future hops.</t>

<t>A relay that reads from a stream and writes to stream in order will introduce head-of-line blocking.
Packet loss will cause stream data to be buffered in the QUIC library, awaiting in order delivery, which will increase latency over additional hops.
To mitigate this, a relay SHOULD read and write QUIC stream data out of order subject to flow control limits.
See section 2.2 in <xref target="QUIC"/>.</t>

</section>
<section anchor="congestion-control" title="Congestion Control">
<t>As covered in the motivation section (<xref target="motivation"/>), the ability to prioritize or cancel streams is a form of congestion response.
It's equally important to detect congestion via congestion control, which is handled in the QUIC layer <xref target="QUIC-RECOVERY"/>.</t>

<t>Bufferbloat is caused by routers queueing packets for an indefinite amount of time rather than drop them.
This latency significantly reduces the ability for the application to prioritize or drop media in response to congestion.
Senders SHOULD use a congestion control algorithm that reduces this bufferbloat (ex. <xref target="BBR"/>).
It is NOT RECOMMENDED to use a loss-based algorithm (ex. <xref target="NewReno"/>) unless the network fully supports ECN.</t>

<t>Live media is application-limited, which means that the encoder determines the max bitrate rather than the network.
Most TCP congestion control algorithms will only increase the congestion window if it is full, limiting the upwards mobility when application-limited.
Senders SHOULD use a congestion control algorithm that is designed for application-limited flows (ex. GCC).
Senders MAY periodically pad the connection with QUIC PING frames to fill the congestion window.</t>

</section>
<section anchor="termination" title="Termination">
<t>The QUIC connection can be terminated at any point with an error code.</t>

<t>The media producer MAY terminate the QUIC connection with an error code of 0 to indicate the clean termination of the broadcast.
The application SHOULD use a non-zero error code to indicate a fatal error.</t>

<texttable>
      <ttcol align='right'>Code</ttcol>
      <ttcol align='left'>Reason</ttcol>
      <c>0x0</c>
      <c>Broadcast Terminated</c>
      <c>0x1</c>
      <c>GOAWAY (<xref target="goaway"/>)</c>
</texttable>

</section>
</section>
<section anchor="messages" title="Messages">
<t>Messages consist of a type identifier followed by contents, depending on the message type.</t>

<t>TODO document the encoding</t>

<texttable>
      <ttcol align='right'>ID</ttcol>
      <ttcol align='left'>Messages</ttcol>
      <c>0x0</c>
      <c>HEADERS (<xref target="headers"/>)</c>
      <c>0x1</c>
      <c>SEGMENT (<xref target="segment"/>)</c>
      <c>0x2</c>
      <c>APP (<xref target="app"/>)</c>
      <c>0x10</c>
      <c>GOAWAY (<xref target="goaway"/>)</c>
</texttable>

<section anchor="headers" title="HEADERS">
<t>The <spanx style="verb">HEADERS</spanx> message contains information required to deliver, cache, and forward a stream.
This message SHOULD be parsed and obeyed by any Warp relays.</t>

<t><list style="symbols">
  <t><spanx style="verb">id</spanx>.
An unique identifier for the stream.
This field is optional and MUST be unique if set.</t>
  <t><spanx style="verb">order</spanx>.
An integer indicating the delivery order (<xref target="delivery-order"/>).
This field is optional and the default value is 0.</t>
  <t><spanx style="verb">depends</spanx>.
An list of dependencies by stream identifier (<xref target="dependencies"/>).
This field is optional and the default value is an empty array.</t>
</list></t>

</section>
<section anchor="segment" title="SEGMENT">
<t>A <spanx style="verb">SEGMENT</spanx> message consists of a segment in a fragmented MP4 container.</t>

<t>Each segment MUST start with an initialization fragment, or MUST depend on a segment with an initialization fragment.
An initialization fragment consists of a File Type Box (ftyp) followed by a Movie Box (moov).
This Movie Box (moov) consists of Movie Header Boxes (mvhd), Track Header Boxes (tkhd), Track Boxes (trak), followed by a final Movie Extends Box (mvex).
These boxes MUST NOT contain any samples and MUST have a duration of zero.
Note that a Common Media Application Format Header <xref target="CMAF"></xref> meets all these requirements.</t>

<t>Each segment MAY have a Segment Type Box (styp) followed by any number of media fragments.
Each media fragment consists of a Movie Fragment Box (moof) followed by a Media Data Box (mdat).
The Media Fragment Box (moof) MUST contain a Movie Fragment Header Box (mfhd) and Track Box (trak) with a Track ID (<spanx style="verb">track_ID</spanx>) matching a Track Box in the initialization fragment.
Note that a Common Media Application Format Segment <xref target="CMAF"></xref> meets all these requirements.</t>

<t>Media fragments can be packaged at any frequency, causing a trade-off between overhead and latency.
It is RECOMMENDED that a media fragment consists of a single frame to minimize latency.</t>

</section>
<section anchor="app" title="APP">
<t>The <spanx style="verb">APP</spanx> message contains arbitrary contents.
This is useful for metadata that would otherwise have to be shoved into the media bitstream.</t>

<t>Relays MUST NOT differentiate between streams containing <spanx style="verb">SEGMENT</spanx> and <spanx style="verb">APP</spanx> frames.
The same forwarding and caching behavior applies to both as specified in the<spanx style="verb">HEADERS</spanx> frame.</t>

</section>
<section anchor="goaway" title="GOAWAY">
<t>The <spanx style="verb">GOAWAY</spanx> message is sent by the server to force the client to reconnect.
This is useful for server maintenance or reassignments without severing the QUIC connection.
The server MAY be a producer or consumer.</t>

<t>The server:</t>

<t><list style="symbols">
  <t>MAY initiate a graceful shutdown by sending a GOAWAY message.</t>
  <t>MUST close the QUIC connection after a timeout with the GOAWAY error code (<xref target="termination"/>).</t>
  <t>MAY close the QUIC connection with a different error code if there is a fatal error before shutdown.</t>
  <t>SHOULD wait until the <spanx style="verb">GOAWAY</spanx> message and any pending streams have been fully acknowledged, plus an extra delay to ensure they have been processed.</t>
</list></t>

<t>The client:</t>

<t><list style="symbols">
  <t>MUST establish a new WebTransport session to the provided URL upon receipt of a <spanx style="verb">GOAWAY</spanx> message.</t>
  <t>SHOULD establish the connection in parallel which MUST use different QUIC connection.</t>
  <t>SHOULD remain connected for two servers for a short period, processing segments from both in parallel.</t>
</list></t>

</section>
</section>
<section anchor="security-considerations" title="Security Considerations">

<section anchor="resource-exhaustion" title="Resource Exhaustion">
<t>Live media requires significant bandwidth and resources.
Failure to set limits will quickly cause resource exhaustion.</t>

<t>Warp uses QUIC flow control to impose resource limits at the network layer.
Endpoints SHOULD set flow control limits based on the anticipated media bitrate.</t>

<t>The media producer prioritizes and transmits streams out of order.
Streams might be starved indefinitely during congestion.
The producer and consumer MUST cancel a stream, preferably the lowest priority, after reaching a resource limit.</t>

</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">
<t>TODO</t>

</section>
<section anchor="appendix.encoding" title="Appendix A. Video Encoding">
<t>In order to transport media, we first need to know how media is encoded.
This section is an overview of media encoding.</t>

<section anchor="tracks" title="Tracks">
<t>A broadcast consists of one or more tracks.
Each track has a type (audio, video, caption, etc) and uses a corresponding codec.
There may be multiple tracks, including of the same type for a number of reasons.</t>

<t>For example:</t>

<t><list style="symbols">
  <t>A track for each codec.</t>
  <t>A track for each resolution and bitrate.</t>
  <t>A track for each language.</t>
  <t>A track for each camera feed.</t>
</list></t>

<t>Tracks can be muxed together into a single container or stream.
The goal of Warp is to independently deliver tracks, and even parts of a track, so this is not allowed.
Each Warp segment MUST contain a single track.</t>

</section>
<section anchor="appendix.init" title="Init">
<t>Media codecs have a wide array of configuration options.
For example, the resolution, the color space, the features enabled, etc.</t>

<t>Before playback can begin, the decoder needs to know the configuration.
This is done via a short payload at the very start of the media file.
The initialization payload MAY be cached and reused between segments with the same configuration.</t>

</section>
<section anchor="appendix.video" title="Video">
<t>Video is a sequence of pictures (frames) with a presentation timestamp (PTS).</t>

<t>An I-frame is a frame with no dependencies and is effectively an image file.
These frames are usually inserted at a frequent interval to support seeking or joining a live stream.
However they can also improve compression when used at scene boundaries.</t>

<t>A P-frame is a frame that references on one or more earlier frames.
These frames are delta-encoded, such that they only encode the changes (motion).
This result in a massive file size reduction for most content outside of few notorious cases (ex. confetti).</t>

<t>A common encoding structure is to only reference the previous frame, as it is simple and minimizes latency:</t>

<figure><artwork><![CDATA[
 I <- P <- P <- P   I <- P <- P <- P   I <- P ...
]]></artwork></figure>

<t>There is no such thing as an optimal encoding structure.
Encoders tuned for the best quality will produce a tangled spaghetti of references.
Encoders tuned for the lowest latency can avoid reference frames to allow more to be dropped.</t>

<section anchor="appendix.b-frame" title="B-Frames">
<t>The goal of video codecs is to maximize compression.
One of the improvements is to allow a frame to reference later frames.</t>

<t>A B-frame is a frame that can reference one or more frames in the future, and any number of frames in the past.
These frames are more difficult to encode/decode as they require buffering and reordering.</t>

<t>A common encoding structure is to use B-frames in a fixed pattern.
Such a fixed pattern is not optimal, but it's simpler for hardware encoding:</t>

<figure><artwork><![CDATA[
    B     B         B     B         B
   / \   / \       / \   / \       / \
  v   v v   v     v   v v   v     v   v
 I <-- P <-- P   I <-- P <-- P   I <-- P ...
]]></artwork></figure>

</section>
<section anchor="timestamps" title="Timestamps">
<t>Each frame is assigned a presentation timestamp (PTS), indicating when it should be shown relative to other frames.</t>

<t>The encoder outputs the bitstream in decode order, which means that each frame is output after its references.
This makes it easier for the decoder as all references are earlier in the bitstream and can be decoded immediately.</t>

<t>However, this causes problems with B-frames because they depend on a future frame, and some reordering has to occur.
In order to keep track of this, frames have a decode timestamp (DTS) in addition to a presentation timestamp (PTS).
A B-frame will have higher DTS value that its dependencies, while PTS and DTS will be the same for other frame types.</t>

<t>For the example above, this would look like:</t>

<figure><artwork><![CDATA[
     0 1 2 3 4 5 6 7 8 9 10
PTS: I B P B P I B P B P B
DTS: I   PB  PBI   PB  PB
]]></artwork></figure>

<t>B-frames add latency because of this reordering so they are usually not used for conversational latency.</t>

</section>
<section anchor="appendix.gop" title="Group of Pictures">
<t>A group of pictures (GoP) is an I-frame followed by any number of frames until the next I-frame.
All frames MUST reference, either directly or indirectly, only the most recent I-frame.</t>

<figure><artwork><![CDATA[
        GoP               GoP            GoP
+-----------------+-----------------+---------------
|     B     B     |     B     B     |     B
|    / \   / \    |    / \   / \    |    / \
|   v   v v   v   |   v   v v   v   |   v   v
|  I <-- P <-- P  |  I <-- P <-- P  |  I <-- P ...
+-----------------+-----------------+--------------
]]></artwork></figure>

<t>This is a useful abstraction because GoPs can always be decoded independently.</t>

</section>
<section anchor="appendix.svc" title="Scalable Video Coding">
<t>Some codecs support scalable video coding (SVC), in which the encoder produces multiple bitstreams in a hierarchy.
This layered coding means that dropping the top layer degrades the user experience in a configured way.
Examples include reducing the resolution, picture quality, and/or frame rate.</t>

<t>Here is an example SVC encoding with 3 resolutions:</t>

<figure><artwork><![CDATA[
      +-------------------------+------------------
   4k |  P <- P <- P <- P <- P  |  P <- P <- P ...
      |  |    |    |    |    |  |  |    |    |
      |  v    v    v    v    v  |  v    v    v
      +-------------------------+------------------
1080p |  P <- P <- P <- P <- P  |  P <- P <- P ...
      |  |    |    |    |    |  |  |    |    |
      |  v    v    v    v    v  |  v    v    v
      +-------------------------+------------------
 360p |  I <- P <- P <- P <- P  |  I <- P <- P ...
      +-------------------------+------------------
]]></artwork></figure>

</section>
</section>
<section anchor="appendix.audio" title="Audio">
<t>Audio is dramatically simpler than video as it is not typically delta encoded.
Audio samples are grouped together (group of samples) at a configured rate, also called a "frame".</t>

<t>The encoder spits out a continuous stream of samples (S):</t>

<figure><artwork><![CDATA[
S S S S S S S S S S S S S ...
]]></artwork></figure>

</section>
</section>
<section anchor="appendix.examples" title="Appendix B. Segment Examples">
<t>Warp offers a large degree of flexibility on how segments are fragmented and prioritized.
There is no best solution; it depends on the desired complexity and user experience.</t>

<t>This section provides a summary of some options available.</t>

<section anchor="video" title="Video">

<section anchor="group-of-pictures" title="Group of Pictures">
<t>A group of pictures (GoP) is consists of an I-frame and all frames that directly or indirectly reference it (<xref target="appendix.gop"/>).
The tail of a GoP can be dropped without causing decode errors, even if the encoding is otherwise unknown, making this the safest option.</t>

<t>It is RECOMMENDED that each segment consist of a single GoP.
For example:</t>

<figure><artwork><![CDATA[
    segment 1       segment 2    segment 3
+---------------+---------------+---------
| I  P  B  P  B | I  P  B  P  B | I  P  B
+---------------+---------------+---------
]]></artwork></figure>

<t>Depending on the video encoding, this approach may introduce unnecessary ordering and dependencies.
A better option may be available below.</t>

</section>
<section anchor="scalable-video-coding" title="Scalable Video Coding">
<t>Some codecs support scalable video coding (SVC), in which the encoder produces multiple bitstreams in a hierarchy (<xref target="appendix.svc"/>).</t>

<t>When SVC is used, it is RECOMMENDED that each segment consist of a single layer and GoP.
For example:</t>

<figure><artwork><![CDATA[
               segment 3             segment 6
      +-------------------------+---------------
   4k |  P <- P <- P <- P <- P  |  P <- P <- P
      |  |    |    |    |    |  |  |    |    |
      |  v    v    v    v    v  |  v    v    v
      +-------------------------+--------------

               segment 2             segment 5
      +-------------------------+---------------
1080p |  P <- P <- P <- P <- P  |  P <- P <- P
      |  |    |    |    |    |  |  |    |    |
      |  v    v    v    v    v  |  v    v    v
      +-------------------------+--------------

               segment 1             segment 4
      +-------------------------+---------------
 360p |  I <- P <- P <- P <- P  |  I <- P <- P
      +-------------------------+---------------
]]></artwork></figure>

</section>
<section anchor="frames" title="Frames">
<t>With full knowledge of the encoding, the encoder MAY can split a GoP into multiple segments based on the frame.
However, this is highly dependent on the encoding, and the additional complexity might not improve the user experience.</t>

<t>For example, we could split our example B-frame structure (<xref target="appendix.b-frame"/>) into 13 segments:</t>

<figure><artwork><![CDATA[
      2     4           7     9           12
+--------+--------+--------+--------+-----------+
|     B  |  B     |     B  |  B     |     B     |
|-----+--+--+-----+-----+--+--+-----+-----+-----+
|  I  |  P  |  P  |  I  |  P  |  P  |  I  |  P  |
+-----+-----+-----+-----+-----+-----+-----+-----+
   1     3     5     6     8     10    11    13
]]></artwork></figure>

<t>To reduce the number of segments, segments can be merged with their dependency.
QUIC streams will deliver each segment in order so this produces the same result as reordering within the application.</t>

<t>The same GoP structure can be represented using eight segments:</t>

<figure><artwork><![CDATA[
      2     3           5     6           8
+--------+--------+-----------------+------------
|     B  |  B     |     B  |  B     |     B     |
+--------+--------+--------+--------+-----------+
|  I     P     P  |  I     P     P  |  I     P
+-----------------+-----------------+------------
         1                 4              7
]]></artwork></figure>

<t>We can further reduce the number of segments by combining frames that don't depend on each other.
The only restriction is that frames can only reference frames earlier in the segment, or within a dependency segment.
For example, non-reference frames can have their own segment so they can be prioritized or dropped separate from reference frames.</t>

<t>The same GoP structure can also be represented using six segments, although we've removed the ability to drop individual B-frames:</t>

<figure><artwork><![CDATA[
   segment 2     segment 4   segment 6
+-------------+-------------+---------
|    B   B    |    B   B    |    B
+-------------+-------------+---------
|  I   P   P  |  I   P   P  |  I   P
+-------------+-------------+---------
   segment 1     segment 3   segment 5
]]></artwork></figure>

</section>
<section anchor="init" title="Init">
<t>Initialization data (<xref target="appendix.init"/>) is required to initialize the decoder.
Each segment MAY start with initialization data although this adds overhead.</t>

<t>Instead, it is RECOMMENDED to create a init segment.
Each media segment can then depend on the init segment to avoid the redundant overhead.
For example:</t>

<figure><artwork><![CDATA[
    segment 2       segment 3    segment 5
+---------------+---------------+---------
| I  P  B  P  B | I  P  B  P  B | I  P  B
+---------------+---------------+---------
|              init             |  init
+-------------------------------+---------
             segment 1           segment 4
]]></artwork></figure>

</section>
</section>
<section anchor="audio" title="Audio">
<t>Audio (<xref target="appendix.audio"/>) is much simpler than video so there's fewer options.</t>

<t>The simplest configuration is to use a single segment for each audio track.
This may seem inefficient given the ease of dropping audio samples.
However, the audio bitrate is low and gaps cause quite a poor user experience, when compared to video.</t>

<figure><artwork><![CDATA[
         segment 1
+---------------------------
| S S S S S S S S S S S S S
+---------------------------
]]></artwork></figure>

<t>An improvement is to periodically split audio samples into separate segments.
This gives the consumer the ability to skip ahead during severe congestion or temporary connectivity loss.</t>

<figure><artwork><![CDATA[
    segment 1       segment 2    segment 3
+---------------+---------------+---------
| S  S  S  S  S | S  S  S  S  S | S  S  S
+---------------+---------------+---------
]]></artwork></figure>

<t>This frequency of audio segments is configurable, at the cost of additional overhead.
It's NOT RECOMMENDED to create a segment for each audio frame because of this overhead.</t>

<t>Since video can only recover from severe congestion with an I-frame, so there's not much point recovering audio at a separate interval.
It is RECOMMENDED to create a new audio segment at each video I-frame.</t>

<figure><artwork><![CDATA[
    segment 1       segment 3    segment 5
+---------------+---------------+---------
| S  S  S  S  S | S  S  S  S  S | S  S  S
+---------------+---------------+---------
| I  P  B  P  B | I  P  B  P  B | I  P  B
+---------------+---------------+---------
    segment 2       segment 4    segment 6
]]></artwork></figure>

</section>
<section anchor="appendix.delivery-order" title="Delivery Order">
<t>The delivery order (<xref target="delivery-order"/> depends on the desired user experience during congestion:</t>

<t><list style="symbols">
  <t>if media should be skipped: delivery order = PTS</t>
  <t>if media should not be skipped: delivery order = -PTS</t>
  <t>if video should be skipped before audio: audio delivery order &lt; video delivery order</t>
</list></t>

<t>The delivery order may be changed if the content changes.
For example, switching from a live stream (skippable) to an advertisement (unskippable).</t>

</section>
</section>
<section numbered="false" anchor="contributors" title="Contributors">

<t><list style="symbols">
  <t>Alan Frindell</t>
  <t>Charles Krasic</t>
  <t>Cullen Jennings</t>
  <t>James Hurley</t>
  <t>Jordi Cenzano</t>
  <t>Mike English</t>
</list></t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference anchor='QUIC' target='https://www.rfc-editor.org/info/rfc9000'>
<front>
<title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>
<author fullname='J. Iyengar' initials='J.' role='editor' surname='Iyengar'><organization/></author>
<author fullname='M. Thomson' initials='M.' role='editor' surname='Thomson'><organization/></author>
<date month='May' year='2021'/>
<abstract><t>This document defines the core of the QUIC transport protocol.  QUIC provides applications with flow-controlled streams for structured communication, low-latency connection establishment, and network path migration. QUIC includes security measures that ensure confidentiality, integrity, and availability in a range of deployment circumstances.  Accompanying documents describe the integration of TLS for key negotiation, loss detection, and an exemplary congestion control algorithm.</t></abstract>
</front>
<seriesInfo name='RFC' value='9000'/>
<seriesInfo name='DOI' value='10.17487/RFC9000'/>
</reference>



<reference anchor='QUIC-RECOVERY' target='https://www.rfc-editor.org/info/rfc9002'>
<front>
<title>QUIC Loss Detection and Congestion Control</title>
<author fullname='J. Iyengar' initials='J.' role='editor' surname='Iyengar'><organization/></author>
<author fullname='I. Swett' initials='I.' role='editor' surname='Swett'><organization/></author>
<date month='May' year='2021'/>
<abstract><t>This document describes loss detection and congestion control mechanisms for QUIC.</t></abstract>
</front>
<seriesInfo name='RFC' value='9002'/>
<seriesInfo name='DOI' value='10.17487/RFC9002'/>
</reference>


<reference anchor='WebTransport'>
   <front>
      <title>WebTransport over HTTP/3</title>
      <author fullname='Alan Frindell' initials='A.' surname='Frindell'>
         <organization>Facebook</organization>
      </author>
      <author fullname='Eric Kinnear' initials='E.' surname='Kinnear'>
         <organization>Apple Inc.</organization>
      </author>
      <author fullname='Victor Vasiliev' initials='V.' surname='Vasiliev'>
         <organization>Google</organization>
      </author>
      <date day='6' month='July' year='2022'/>
      <abstract>
	 <t>   WebTransport [OVERVIEW] is a protocol framework that enables clients
   constrained by the Web security model to communicate with a remote
   server using a secure multiplexed transport.  This document describes
   a WebTransport protocol that is based on HTTP/3 [HTTP3] and provides
   support for unidirectional streams, bidirectional streams and
   datagrams, all multiplexed within the same HTTP/3 connection.

	 </t>
      </abstract>
   </front>
   <seriesInfo name='Internet-Draft' value='draft-ietf-webtrans-http3-03'/>
   <format target='https://www.ietf.org/archive/id/draft-ietf-webtrans-http3-03.txt' type='TXT'/>
</reference>


<reference anchor="ISOBMFF" >
  <front>
    <title>Information technology â Coding of audio-visual objects â Part 12: ISO Base Media File Format</title>
    <author >
      <organization></organization>
    </author>
    <date year="2015" month="December"/>
  </front>
</reference>




<reference anchor='RFC2119' target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author fullname='S. Bradner' initials='S.' surname='Bradner'><organization/></author>
<date month='March' year='1997'/>
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference anchor='RFC8174' target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author fullname='B. Leiba' initials='B.' surname='Leiba'><organization/></author>
<date month='May' year='2017'/>
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>




    </references>

    <references title='Informative References'>

<reference anchor="CMAF" >
  <front>
    <title>Information technology -- Multimedia application format (MPEG-A) -- Part 19: Common media application format (CMAF) for segmented media</title>
    <author >
      <organization></organization>
    </author>
    <date year="2020" month="March"/>
  </front>
</reference>




<reference anchor='NewReno' target='https://www.rfc-editor.org/info/rfc6582'>
<front>
<title>The NewReno Modification to TCP's Fast Recovery Algorithm</title>
<author fullname='T. Henderson' initials='T.' surname='Henderson'><organization/></author>
<author fullname='S. Floyd' initials='S.' surname='Floyd'><organization/></author>
<author fullname='A. Gurtov' initials='A.' surname='Gurtov'><organization/></author>
<author fullname='Y. Nishida' initials='Y.' surname='Nishida'><organization/></author>
<date month='April' year='2012'/>
<abstract><t>RFC 5681 documents the following four intertwined TCP congestion control algorithms: slow start, congestion avoidance, fast retransmit, and fast recovery.  RFC 5681 explicitly allows certain modifications of these algorithms, including modifications that use the TCP Selective Acknowledgment (SACK) option (RFC 2883), and modifications that respond to &quot;partial acknowledgments&quot; (ACKs that cover new data, but not all the data outstanding when loss was detected) in the absence of SACK.  This document describes a specific algorithm for responding to partial acknowledgments, referred to as &quot;NewReno&quot;.  This response to partial acknowledgments was first proposed by Janey Hoe.  This document obsoletes RFC 3782.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6582'/>
<seriesInfo name='DOI' value='10.17487/RFC6582'/>
</reference>


<reference anchor='BBR'>
   <front>
      <title>BBR Congestion Control</title>
      <author fullname='Neal Cardwell' initials='N.' surname='Cardwell'>
         <organization>Google</organization>
      </author>
      <author fullname='Yuchung Cheng' initials='Y.' surname='Cheng'>
         <organization>Google</organization>
      </author>
      <author fullname='Soheil Hassas Yeganeh' initials='S. H.' surname='Yeganeh'>
         <organization>Google</organization>
      </author>
      <author fullname='Ian Swett' initials='I.' surname='Swett'>
         <organization>Google</organization>
      </author>
      <author fullname='Van Jacobson' initials='V.' surname='Jacobson'>
         <organization>Google</organization>
      </author>
      <date day='7' month='March' year='2022'/>
      <abstract>
	 <t>   This document specifies the BBR congestion control algorithm.  BBR
   (&quot;Bottleneck Bandwidth and Round-trip propagation time&quot;) uses recent
   measurements of a transport connection&#39;s delivery rate, round-trip
   time, and packet loss rate to build an explicit model of the network
   path.  BBR then uses this model to control both how fast it sends
   data and the maximum volume of data it allows in flight in the
   network at any time.  Relative to loss-based congestion control
   algorithms such as Reno [RFC5681] or CUBIC [RFC8312], BBR offers
   substantially higher throughput for bottlenecks with shallow buffers
   or random losses, and substantially lower queueing delays for
   bottlenecks with deep buffers (avoiding &quot;bufferbloat&quot;).  BBR can be
   implemented in any transport protocol that supports packet-delivery
   acknowledgment.  Thus far, open source implementations are available
   for TCP [RFC793] and QUIC [RFC9000].  This document specifies version
   2 of the BBR algorithm, also sometimes referred to as BBRv2 or bbr2.

	 </t>
      </abstract>
   </front>
   <seriesInfo name='Internet-Draft' value='draft-cardwell-iccrg-bbr-congestion-control-02'/>
   <format target='https://www.ietf.org/archive/id/draft-cardwell-iccrg-bbr-congestion-control-02.txt' type='TXT'/>
</reference>




    </references>



  </back>

<!-- ##markdown-source:
H4sIANYQV2MAA9V96XYb15ngfzzFHflHxASAKcp2bDp9JtxksSNKbJKKT05P
H6tQdQFUWKhCaiEJW8rph5gHmGeZR5kn6W+9S6FASe6TmWkmpohC1V2+fbtf
TSaTUZu3hT00T35M6rWZmGu7WNmytZl5ld9Zc2GzPDE3dVI266pun4yS2ay2
d4fmx6Ory1FWpWWygqezOpm3kyLt6sJuJvcw1KRIWtu0owz+OTS/nB7dnH0Y
pfBhUdWbQ5OX82o0ytf1oWnrrmkP9ve/2z8YJbVNDs0PtrR1Uozuq/p2UVfd
+tCcl5ldW/hVtua6m63ypsmrcnRrN3BTht+3ti5tOznFlYxGTZuU2U9JUZUw
+8Y2o2aV1O1Pf+sqWNWhKavROj80/9pW6dg0sLHazhv4a7PiP2Bjq2S9zsvF
v41GSdcuq/pwZMwE/jOwdhjh1dSc0G7pEkPhVXdrw6tVvUjK/OekhaUempv7
vE2X9IVdJXlxaG7zB4tgyv64wAvTtFqN4ln+NDWX3SIvg0n+lNd5UQSX41ku
bJuEc+S3ef3HFVwcGP16al4DmJLbDoATTHHdLZOm/1U8zUnepFU4T1Py7X9M
8RuebFRW9QoeuLMIvH95e35yaK5enHy3v78vnydXZydv/nx29Rf94gC++NHO
HMEBZien09y288m9nbV4ebJs2/Vz3Mr59ZvjixcvDmkdSsfnQFk0a1Wa1qbL
siqqxcb8n3//n+akygCjppqbpMvyanKXN11SmGr2V5u2Dd1yCVRinh0c4tjm
OGmUA17khTUvaOAnNB3T9cH+s68nzw6AknVW3uvJxdGnLWsyMRdd0eYrmgVI
rshTvolvN08vLs9+mBzt4Z28uO8A+tVqBbfsfgjn38NPpnH8THfHiz/Yn+w/
hyuv7f2VLStCwjdff4tIOD6+YtinSZ3d26KY5GlaLybA/pO0KhfA2zAh/tnW
VTEBxI1GE1hjMmsASymw4M0yb5CROpzfZHael7Yx7dKatKqtmdllcpfDCnGV
KHzGJglWW6D04Q22SgxmXVfAsRWg7M7WREDTEeMHpmoADC0QdlvpMI2ZAQYz
gyCHaTsQH3WxQRLggW2ZMkUA6fIsq7zFyXMvbYqNn8zA1myyaqaj8JMBoQUr
g63kbf4zPB1NmlncSQ2j1DA77LEoqnucs7BNY/IV7isB+Lglw/JnFsZO6jsc
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
fkbiM8oY7x3RR7/ib/ztd2qrxL/ib37VJp7tf7u//q++CfP8G97Eli/1h1AE
bG/i86YRy88c0fsQAi6lsCEoDbrOHfKojwepJbV6qTaSudW5jKiyQBVr0110
nn0k9Ch6lQdqOtJJYcjt6aL3apA9DjIEbIacMeYogZydS8wTYponPRuyWefS
/4QGwLcD0cuB5K0tbg6QMnvCNtdm1/+cpRzGko+nLjftGD+MJmvPKs4TVOi5
NK5nLwoXy7499vSWEk/pw7WjB5f0NHfvGZtGrjS5wSoJvo+bw4hVy61cgz7i
EgWOe8fGQWvJQFGQig5OU5yQTE4JD/pjaEG4a4dp8rgpEiXMvVlCzqW3MFhm
D9oTgc8K+w8baKAd9EHKJVpYLgde0YBQi12aU2q2VssCxCDmxgljdwoqrBQk
Z8Nl17sSY5Yg48G7YNEvHSqxQ1rTCtSom+dgGUHUsSaqeJQwLyx62gumq9DX
x56xQHCfD8IPz7esht2fscQRZSYaQfR75+fPGZRY6XS7sTdKEwWqmO2AwLqi
GppkE5z96ErfYcyZ0fxmj7hhhvT5Z6BrPiM4NynvE9tpvvzfN1ciskWLiTsC
okeN2p/rD7KxyNzPJx82bhBWjxBS8OPIZvDqN5+tez7T0vj/S0GPdkHnYPDq
158Pnc8zYf6LQOfZ4NWvfgXtfJZt9Pnji5IHacAx29GPaGNjSYhx9SAaeg0l
VdBZiY80yvsqWcVQLnG7fU6UyhePNw4R4SmmfLF0ramDM/F+dq2nDQ6dBSre
t9EK+11tK/0oxedeYMW7qDr3nQvs+OhqKK80rv1hjzf97LnbbiRdmF2+Coji
9/T7u+DKswOvUz7lD/zbu/Lvt1z57SvG16b/Tv8/CX5vX9E5zoUR/e/HrowG
Rnn8N4KJmYbF7tf0+xv6/S1DZ59+003PnotTX4WvS/DRG9/709GeJr3xHSuZ
S2GGfa02vZfc3getEGMt405IagLbaTsXsZMkWBKFvYL2QsG5GC1ww8eQeTyh
yZrdy91c0x/LL0XZTWih7gpByT/fPkZnw7LiV9DZr6Llc3r4Un8/duXzY0Fe
WsfyGX++ij/+nglM3qql7z55lNj4HM5qxonfyHanFv8+pk3ERAY02+eSpuRO
GFI4E7zkk1/6Fqcy5ZteaF6WQpX72gMr7IUp3/fqG/Ao1tbIOKc2tQAuwWSG
kr9Gb7XUOHgRdPDyZveGCnkRRjz+40RP/u4g5Tfgh3ruTgr0XRZLkN+/ucPb
V1TdG54mxWMyeFY0aL+o0WrPN7FR49S1Cc2+3+2mq9h/EBY4dhzR+/QZI50L
5Xu673361LFM3zQJjVxvvLnkGJbTjM7jQhGqrw51H9XYfNiL+qtTOZA8FrWH
m24fOghOoeQDUznktvJKsMaVp6MzqQ0PB9yCSlt0JTSwJ/vgcILzGPjIa9l7
g2z4XNylCGVAmSXSEYhX87hzqqZy5Fh4oP+/dk7fx5KPdh7+vOdrA+J255DR
80M2sbeI1QDlsJxEzUIq4+gck9kKE9YDETmWSPTCsTm91NYVcrGUoSe40iSo
9vJZcucr6rpcAR2/PNU13s+5OXlj8UVqpcU8PtXNy7t50UxNOOXlYuzRK33j
dxDKd3oKG2P2WMgAVEh91TknAYxFlLyuYE09M3bMiWe0frXBoL7LO3JsHQoe
RSJQws6I4OMPEhLxwJcvzhDoRiemxUWIAqPS0V/fGBY0b4UBFvQihjZsTdOT
7dRPMaEjK1KWS6cOooPWmCS12FtBjpFQjfcdDoAn9Kf/2GjStQn/v/PzZ0eT
+KyhnuoJ3h3tWn82UR/PsRYI0vvc8HbvPXlBRv0oBhoaOHm6g0HYRepnfANx
fZ2j7pfwkTdn+EVlZCFs402PGEpYdByyOfp3JA3cm+QrOWzCC+L3iStZabHe
jt6Dbnd4OiECo9EAE698O0+7i2T+MzL+H0Ay/xDF8ZiO+yr88I3LvcTvJgiz
B70DvUPd8weO/e4K+fezl1sl+1SQnWtBelC2A/IErNfD/tz/hAUaA48gHT76
2MQ9J6qqP5We7SG6OxTy6w3zB3k4vjwaApJEfLk2M9PIvZZYSslmzwFogNP4
oIF0JwpqVs1TWieKEOqniNZ5dscvcOSuvl3p76CDCSf6frKqbka/HLKnZLN/
ejIHu94++TAaTcxRAQO9qDGrXhTw+WQJngzI+j/V2J8VL3RFAartn22J7lQD
V/6Z/JKXHdy3wY/YoNqc2PLnpKzg80V+a80ZaPG8WY7+A6mPnovniwAA

-->

</rfc>

