



Independent Submission                                         L. Curley
Internet-Draft                                                    Twitch
Intended status: Informational                                  K. Pugin
Expires: 23 April 2023                                              Meta
                                                           S. Nandakumar
                                                                   Cisco
                                                         20 October 2022


                  Warp - Layered Live Media Transport
                       draft-lcurley-warp-latest

Abstract

   This document defines the core behavior for Warp, a layered live
   media transport protocol.  Media is split into layers based on the
   underlying media encoding.  Each layer is transmitted independently
   over a QUIC stream.  QUIC streams are prioritized, allowing less
   important layers to be starved or dropped during congestion.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 23 April 2023.

Copyright Notice

   Copyright (c) 2022 IETF Trust and the persons identified as the
   document authors.  All rights reserved.










Curley, et al.            Expires 23 April 2023                 [Page 1]

Internet-Draft                    WARP                      October 2022


   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Simplified BSD License text
   as described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Simplified BSD License.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
     1.1.  Terms and Definitions . . . . . . . . . . . . . . . . . .   3
   2.  Motivation  . . . . . . . . . . . . . . . . . . . . . . . . .   3
     2.1.  Latency . . . . . . . . . . . . . . . . . . . . . . . . .   3
     2.2.  Universal . . . . . . . . . . . . . . . . . . . . . . . .   4
     2.3.  Intermediaries  . . . . . . . . . . . . . . . . . . . . .   5
   3.  Layers  . . . . . . . . . . . . . . . . . . . . . . . . . . .   6
     3.1.  Media . . . . . . . . . . . . . . . . . . . . . . . . . .   6
     3.2.  Properties  . . . . . . . . . . . . . . . . . . . . . . .   6
     3.3.  Decoder . . . . . . . . . . . . . . . . . . . . . . . . .   7
   4.  QUIC  . . . . . . . . . . . . . . . . . . . . . . . . . . . .   8
     4.1.  Establishment . . . . . . . . . . . . . . . . . . . . . .   8
     4.2.  Streams . . . . . . . . . . . . . . . . . . . . . . . . .   8
     4.3.  Prioritization  . . . . . . . . . . . . . . . . . . . . .   9
     4.4.  Cancellation  . . . . . . . . . . . . . . . . . . . . . .   9
     4.5.  Congestion Control  . . . . . . . . . . . . . . . . . . .   9
     4.6.  Termination . . . . . . . . . . . . . . . . . . . . . . .  10
   5.  Messages  . . . . . . . . . . . . . . . . . . . . . . . . . .  10
     5.1.  HEADERS . . . . . . . . . . . . . . . . . . . . . . . . .  11
     5.2.  LAYER . . . . . . . . . . . . . . . . . . . . . . . . . .  11
     5.3.  APP . . . . . . . . . . . . . . . . . . . . . . . . . . .  11
     5.4.  GOAWAY  . . . . . . . . . . . . . . . . . . . . . . . . .  11
   6.  Security Considerations . . . . . . . . . . . . . . . . . . .  12
     6.1.  Resource Exhaustion . . . . . . . . . . . . . . . . . . .  12
   7.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  12
   8.  Appendix A.  Layer Examples . . . . . . . . . . . . . . . . .  12
     8.1.  Recommended . . . . . . . . . . . . . . . . . . . . . . .  13
     8.2.  Tracks  . . . . . . . . . . . . . . . . . . . . . . . . .  13
     8.3.  Video . . . . . . . . . . . . . . . . . . . . . . . . . .  13
       8.3.1.  Encoding  . . . . . . . . . . . . . . . . . . . . . .  13
       8.3.2.  Decode Order  . . . . . . . . . . . . . . . . . . . .  14
       8.3.3.  Group of Pictures . . . . . . . . . . . . . . . . . .  14
       8.3.4.  Scalable Video Coding . . . . . . . . . . . . . . . .  15
       8.3.5.  Frames  . . . . . . . . . . . . . . . . . . . . . . .  15
       8.3.6.  Slices  . . . . . . . . . . . . . . . . . . . . . . .  17
       8.3.7.  Init  . . . . . . . . . . . . . . . . . . . . . . . .  17
     8.4.  Audio . . . . . . . . . . . . . . . . . . . . . . . . . .  17



Curley, et al.            Expires 23 April 2023                 [Page 2]

Internet-Draft                    WARP                      October 2022


       8.4.1.  Encoding  . . . . . . . . . . . . . . . . . . . . . .  17
       8.4.2.  Simple  . . . . . . . . . . . . . . . . . . . . . . .  18
       8.4.3.  Periodic Refresh  . . . . . . . . . . . . . . . . . .  18
       8.4.4.  Segments  . . . . . . . . . . . . . . . . . . . . . .  18
   9.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  18
     9.1.  Normative References  . . . . . . . . . . . . . . . . . .  19
     9.2.  Informative References  . . . . . . . . . . . . . . . . .  19
   Contributors  . . . . . . . . . . . . . . . . . . . . . . . . . .  20
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  20

1.  Introduction

   Warp is a live media transport protocol that utilizes the QUIC
   network protocol [QUIC].

   Section 2 covers the background and rationale behind Warp.  Section 3
   covers how media is encoded and split into layers.  Section 4 covers
   how QUIC is used to transfer media.  Section 5 covers how messages
   are encoded on the wire.

1.1.  Terms and Definitions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

   Commonly used terms in this document are described below.

   TODO definitions

2.  Motivation

2.1.  Latency

   In a perfect world, we could deliver live media at the same rate it
   is produced.  The end-to-end latency of a broadcast would be fixed
   and only subject to encoding and transmission delays.  Unfortunately,
   networks have variable throughput, primarily due to congestion.

   Attempting to deliver media larger than this variable network bitrate
   causes queuing.  This queuing can occur anywhere in the path between
   the encoder and decoder.  For example: the application, the OS
   socket, a wifi router, within an ISP, or generally anywhere in
   transit.





Curley, et al.            Expires 23 April 2023                 [Page 3]

Internet-Draft                    WARP                      October 2022


   If nothing is done, new frames will be appended to the end of a
   growing queue and will take longer to arrive than their predecessors,
   increasing latency.  Our job is to minimize the growth of this queue,
   and failing that, skip the queue when possible.

   Thus speed at which a media protocol can detect and respond to
   queuing determines the latency.  We can generally classify existing
   media protocols into two categories based on the underlying network
   protocol:

   *  TCP-based media protocols (ex.  RTMP, HLS, DASH) are popular due
      to their simplicity.  Media is served/consumed in decode order
      while any networking is handled by the TCP layer.  However, these
      protocols primarily see use at higher latency targets due to their
      relatively slow detection and response to queuing.

   *  UDP-based media protocols (ex.  RTP, WebRTC, SRT) can side-step
      the issues with TCP and provide lower latency with better queue
      management.  However the media protocol is now responsible for
      fragmentation, congestion control, retransmissions, receiver
      feedback, reassembly, and more.  This added complexity
      significantly raises the implementation difficulty and hurts
      interoperability.

   A goal of this draft is to get the best of both worlds: a simple
   protocol that can still rapidly detect and respond to congestion.
   This is possible emergence of QUIC, designed to fix the shortcomings
   of TCP.  This draft relies on QUIC streams to deliver media layers in
   priority order during congestion.

2.2.  Universal

   The media protocol ecosystem is fragmented; each protocol has it's
   own niche.  Specialization is often a good thing, but we believe
   there's enough overlap to warrant consolidation.

   For example, a service might simultaneously ingest via WebRTC, SRT,
   RTMP, and/or a custom UDP protocol depending on the broadcaster.  The
   same service might then simultaneously distribute via WebRTC, LL-HLS,
   HLS, (or the DASH variants) and/or a custom UDP protocol depending on
   the viewer.

   These media protocols are radically different and not interoperable;
   requiring transcoding or transmuxing.  This cost is further increased
   by the need to maintain separate stacks with different expertise
   requirements.





Curley, et al.            Expires 23 April 2023                 [Page 4]

Internet-Draft                    WARP                      October 2022


   A goal of this draft is to cover a large spectrum of use-cases.
   Specifically:

   *  Consolidated contribution and distribution.  The difference
      between the two has historically been push versus pull.  This is
      an over-simplification, as the real difference is the ability to
      fanout, which is much easier with HTTP GET.  A single protocol can
      cover both use-cases with adequate information on how an
      intermediary should forward media.

   *  A configurable latency versus quality trade-off.  The broadcaster
      (producer) chooses how to encode and transmit media based on the
      desired user experience.  Each viewer (consumer) chooses how long
      to wait for media based on their desired user experience and
      network.  We want an experience that can vary from real-time and
      lossy for one viewer, to delayed and loss-less for another viewer,
      without separate encodings or protocols.

2.3.  Intermediaries

   The prevailing belief is that UDP-based protocols are more expensive
   and don't "scale".  While it's true that UDP is more difficult to
   optimize than TCP, QUIC itself is proof that it is is possible to
   reach performance parity.  In fact even some TCP-based protocols (ex.
   RTMP) don't "scale" either and are exclusively used for contribution
   as a result.

   The truth is that the ability to scale a media protocol depends on
   intermediary support: proxies, caches, CDNs, SFUs, etc.  The success
   of HTTP-based media protocols is due to the ability to leverage
   traditional HTTP CDNs.

   Meanwhile, it's difficult to build a CDN for media protocols that
   were not designed with intermediaries in mind.  For example, an
   intermediary has to parse the underlying codec to determine which RTP
   packets should be dropped first, and the decision is not
   deterministic or consistent for each hop.

   A goal of this draft is to treat intermediaries as first class
   citizens.  Any identification, reliability, ordering, prioritization,
   caching, etc is written to the wire in header designed for
   intermediaries.  This ensures that intermediaries can easily route/
   fanout media to the final destination.  This also ensures that
   congestion response is consistent at every hop based on the
   preferences of the media producer.






Curley, et al.            Expires 23 April 2023                 [Page 5]

Internet-Draft                    WARP                      October 2022


3.  Layers

   Warp is based on the concept of layered coding.  A layer is a
   combination of a media bitstream and a set of properties.

   *  The encoder determines how to split the encoded bitstream into
      layers (Section 3.1).

   *  Each layer is transferred over a QUIC stream, which are delivered
      independently according to the layer properties (Section 3.2).

   *  The decoder receives each layer and skips any layers that do not
      arrive in time (Section 3.3).

3.1.  Media

   An encoder produces one or more codec bitstreams for each track.  The
   bitstream is then fed to the decoder on the other end, after being
   transported over the network, in the same order its produced.  The
   problem, as explained in motivation (Section 2.1), is that networks
   cannot sustain a continuous rate and thus queuing occurs.

   Warp works by splitting the codec bitstream into layers that can be
   transmitted independently.  The producer determines how to split the
   bistream into layers: based on the track, GoP, frame/sample, or even
   slice.  Depending on how the layers are produced, the consumer has
   the ability to decode layers out of order and skip over gaps.  See
   the appendix for examples based on media encoding (Section 8).

   TOOD specify CMAF

   A layer MUST contain a single track.  A layer MAY contain any number
   of samples which MUST be in decode order (increasing DTS).  There MAY
   be gaps between samples, as specified by the presentation timestamp
   and duration within the container.

   The goal of layers is to produce a hierarchy.  Layers MAY depend on
   any number of other layers and MAY overlap with other layers.

3.2.  Properties

   Each layer has properties to go along with its contents.  These are
   written on the wire and inform how they layer should be transmitted
   at each hop.  This is primarily for the purpose of supporting
   intermediaries, but some of this information may also be used by the
   decoder.

   All currently defined properties are optional.



Curley, et al.            Expires 23 April 2023                 [Page 6]

Internet-Draft                    WARP                      October 2022


   *  "id".  A numeric identifier for the layer.  If non-zero, this
      value MUST be unique.  The default value is 0.

   *  "order".  A numeric priority such that the smaller values take
      priority.  A sender SHOULD transmit layers with smallest value
      first, effectively starving layers with larger values during
      congestion.  If two layers use the same value, they SHOULD be
      round-robined.  Note that layers can still arrive out of the
      intended order due to packet loss.  The default value is 0.

   *  "depends".  A list of numeric layer IDs.  This informs the decoder
      that it MUST receive and process the dependency layers first.  The
      decoder MAY support stream processing, such that it does not need
      to fully receive the dependency layers first.  The layer SHOULD
      have a larger "order" than its dependencies, if present.  The
      default value is 0, which means no dependency.

   *  "cache".  TODO Indicates the layer should be cached for some
      amount of time since last access.  What about fragments with an
      unbounded age?  Should we send an "expire" message instead?

   *  "expires".  TODO Indicates the layer should be dropped after some
      amount of time (ex.  "RESET_STREAM").  Do we need clock sync for
      this?  How does this interact with "cache"?

   *  "timestamp".  TODO The presentation timestamp of the earliest (not
      always first) frame in the layer.  What does an intermediary need
      this for?

   *  "track" TODO The track identifier to be used in conjunction with
      the TRACK message.

   See the appendix for some example layers and properties.  Section 8

3.3.  Decoder

   The consumer will receive multiple layers over the network in
   parallel.  The decoder MUST synchronize layers using presentation
   timestamps within the bitstream.  The decoder might not support
   decoding each layer independently, so the consumer MAY need to
   reorder prior to passing a bitstream to the decoder.

   Layers are NOT REQUIRED to be aligned within or between tracks.  For
   example, a low quality rendition may have more frequent I-frames, and
   thus layers, than a higher quality rendition.  A decoder MUST be
   prepared to skip over any gaps between layers.





Curley, et al.            Expires 23 April 2023                 [Page 7]

Internet-Draft                    WARP                      October 2022


4.  QUIC

4.1.  Establishment

   A connection is established using WebTransport [WebTransport].

   To summarize: The client issues a HTTP CONNECT request with the
   intention of establishing a new WebTransport session.  The server
   returns an 200 OK response if the WebTransport session has been
   established, or an error status otherwise.  A WebTransport session
   mimics the QUIC API: either endpoint may create independent streams
   which are reliably delivered in order until canceled.

   WebTransport can currently operate via HTTP/3 and HTTP/2, using QUIC
   or TCP under the hood respectively.  As mentioned in the motivation
   (Section 2) section, TCP introduces head-of-line blocking and will
   result in a worse experience.  It is RECOMMENDED to use WebTransport
   over HTTP/3.

   The application SHOULD use the CONNECT request for authentication and
   negotiation.  For example, including a authentication token and some
   identifier in the path.  The application MAY use QUIC streams for
   more complicated behavior.

   TODO define auth inside the protocol?

4.2.  Streams

   Warp endpoints communicate over unidirectional QUIC streams.  The
   application MAY use bidirectional QUIC streams for other purposes.

   A stream consists of sequential messages.  See messages (Section 5)
   for the list of messages and their encoding.  These are similar to
   QUIC and HTTP/3 frames, but called messages to avoid the media
   terminology.

   Each stream MUST start with a "HEADERS" message.  TODO better name.
   This message includes information on how intermediaries should proxy
   or cache the stream.  If a stream is used to transmit a layer, the
   header MUST match the layer properties (Section 3.2).

   Messages SHOULD be sent over the same stream if ordering is desired.
   For example, "PAUSE" and "PLAY" messages SHOULD be sent on the same
   stream to avoid a race.







Curley, et al.            Expires 23 April 2023                 [Page 8]

Internet-Draft                    WARP                      October 2022


4.3.  Prioritization

   Warp utilizes stream prioritization to deliver the most important
   content during congestion.

   The media producer SHOULD assign a numeric order to each stream, as
   contained in the HEADERS message (Section 5.1).  This is a strict
   prioritization scheme, such that any available bandwidth is allocated
   to streams in ascending order.  The order is determined at encode,
   written to the wire so it can be read by intermediaries, and will not
   be updated.  This effectively creates a priority queue that can be
   maintained over multiple hops.

   QUIC supports stream prioritization but does not standardize any
   mechanisms; see Section 2.3 in [QUIC].  QUIC libraries will need to
   expose a API to the application to set the priority of each stream.

   Senders SHOULD support prioritized streams, although it is OPTIONAL
   on a path with no expected congestion.  Senders SHOULD use strict
   ordering, although relative weights MAY be acceptable if there are no
   other options.  Senders MUST obey the order as written to the wire.
   Senders MAY choose to delay retransmitting lower priority streams
   when possible within QUIC flow control limits.

4.4.  Cancellation

   QUIC streams can be canceled by either endpoint with an error code.

   When using "order", lower priority streams will be starved during
   congestion, perhaps indefinitely.  These streams will consume
   resources and flow control until they are canceled.  When nearing
   resource limits, an endpoint SHOULD cancel the lowest priority stream
   with error code 0.

   When using "expires", a stream SHOULD be canceled after the duration
   has elapsed.  This is not a full replacement for prioritization, but
   can provide some congestion response by clearing parts of the queue.

4.5.  Congestion Control

   As covered in the motivation section (Section 2), the ability to
   prioritize or cancel streams is a form of congestion response.  It's
   equally important to detect congestion via congestion control, which
   is handled in the QUIC layer.

   Bufferbloat is caused by routers queueing packets for an indefinite
   amount of time rather than drop them.  This latency significantly
   reduces the ability for the application to prioritize or drop media



Curley, et al.            Expires 23 April 2023                 [Page 9]

Internet-Draft                    WARP                      October 2022


   in response to congestion.  Senders SHOULD use a congestion control
   algorithm that reduces this bufferbloat.  It is NOT RECOMMENDED to
   use a loss-based algorithm (ex.  Reno, CUBIC) unless the network
   fully supports ECN.

   Live media is application-limited, which means that the encoder
   determines the max bitrate rather than the network.  Most TCP
   congestion control algorithms will only increase the congestion
   window if it is full, limiting the upwards mobility when application-
   limited.  Senders SHOULD use a congestion control algorithm that is
   designed for application-limited flows (ex.  GCC).  Senders MAY
   periodically pad the connection with QUIC PING frames to fill the
   congestion window.

4.6.  Termination

   The QUIC connection can be terminated at any point with an error
   code.

   The media producer MAY terminate the QUIC connection with an error
   code of 0 to indicate the clean termination of the broadcast.  The
   application SHOULD use a non-zero error code to indicate a fatal
   error.

                      +======+======================+
                      | Code | Reason               |
                      +======+======================+
                      |  0x0 | Broadcast Terminated |
                      +------+----------------------+
                      |  0x1 | GOAWAY Section 5.4   |
                      +------+----------------------+

                                  Table 1

   TODO define more error codes

5.  Messages

   Messages consist of a type identifier followed by contents, depending
   on the message type.

   TODO document varint identifier TODO more message types









Curley, et al.            Expires 23 April 2023                [Page 10]

Internet-Draft                    WARP                      October 2022


                      +======+=====================+
                      |   ID | Messages            |
                      +======+=====================+
                      |  0x0 | HEADERS Section 5.1 |
                      +------+---------------------+
                      |  0x1 | LAYER Section 5.2   |
                      +------+---------------------+
                      |  0x2 | APP Section 5.3     |
                      +------+---------------------+
                      | 0x10 | GOAWAY Section 5.4  |
                      +------+---------------------+

                                 Table 2

5.1.  HEADERS

   The "HEADERS" message contains the information listed in layer
   properties (Section 3.2).

   TODO better name TODO document wire format TODO use QPACK?

5.2.  LAYER

   A "LAYER" message consists of the layer bitstream.  A "LAYER" message
   must be proceeded with a "HEADERS" message specifying the layer
   properties (Section 3.2).

   TODO document CMAF TODO document wire format TODO support multiple
   container formats

5.3.  APP

   The "APP" message contains arbitrary contents.  A stream containing
   "APP" message SHOULD be cached and forwarded by intermediaries like
   any other stream; based on the "HEADERS" message (Section 5.1).

   TODO document wire format

5.4.  GOAWAY

   The "GOAWAY" message is sent by the server to force the client to
   reconnect.  This is useful for server maintenance or reassignments
   without severing the QUIC connection.  A server MAY use QUIC load
   balancing instead of a GOAWAY message.

   The server initiates the graceful shutdown by sending a GOAWAY
   message.  The server MUST close the QUIC connection after a timeout
   with the GOAWAY error code (Section 4.6).  The server MAY close the



Curley, et al.            Expires 23 April 2023                [Page 11]

Internet-Draft                    WARP                      October 2022


   QUIC connection with a different error code if there is a fatal error
   before shutdown.  The server SHOULD wait until the "GOAWAY" message
   and any pending streams have been fully acknowledged, plus an extra
   delay to ensure they have been processed.

   A client that receives a "GOAWAY" message should establish a new
   WebTransport session to the provided URL.  This session SHOULD be
   made in parallel and MUST use a different QUIC connection (not
   pooled).  The optimal client will be connected for two servers for a
   short period, potentially receiving layers from both in parallel.

6.  Security Considerations

   TODO expand

6.1.  Resource Exhaustion

   Live media requires significant bandwidth and resources.  Failure to
   set limits will quickly cause resource exhaustion.

   Warp uses QUIC flow control to impose resource limits at the network
   layer.  Endpoints SHOULD set flow control limits based on the
   anticipated media bitrate.

   The media producer prioritizes and transmits streams out of order.
   Streams might be starved indefinitely during congestion and SHOULD be
   canceled after hitting some timeout or resource limit.

   The media consumer might receive streams out of order.  If stream
   data is buffered, for example to decode segments in order, then the
   media consumer SHOULD cancel a stream after hitting some timeout or
   resource limit.

7.  IANA Considerations

   TODO

8.  Appendix A.  Layer Examples

   Warp offers a large degree of flexability on how layers are
   fragmented and prioritized.  There is no best solution; it depends on
   the desired complexity and user experience.

   This section provides a summary of media encoding and some options
   available.






Curley, et al.            Expires 23 April 2023                [Page 12]

Internet-Draft                    WARP                      October 2022


8.1.  Recommended

   Before explaining all of the options, there is a recommended
   approach:

   *  a video layer per GoP (Section 8.3.3)

   *  an audio layer at roughly the same timestamp (Section 8.4.4)

   TODO section on prioritization * audio should be delivered before
   video * for new media should be delivered before old media, or the
   opposite if reliability is desired

8.2.  Tracks

   A broadcast consists of one or more tracks.  Each track has a type
   (audio, video, caption, etc) and uses a cooresponding codec.  There
   may be multiple tracks, including of the same type for a number of
   reasons.

   For example:

   *  A track for each codec.

   *  A track for each resolution and bitrate.

   *  A track for each language.

   *  A track for each camera feed.

   Traditionally, these tracks could be muxed together into a single
   container or stream.  The goal of Warp is to independently deliver
   tracks, and even parts of a track, so they must be demuxed.

   The simplest configuration is a single, continuous layer per track.
   This allows tracks to be prioritized during congestion, although no
   media can be dropped.  The next section covers how to further split
   layers based on the type of media.

8.3.  Video

8.3.1.  Encoding

   Video is a sequence of frames with a display timestamp.  To improve
   compression, frames are encoded as deltas and can reference number of
   frames in the past (P-frames) and/or in the future (B-frames).  A
   frame with no dependencies (I-frame) is effectively an image file and
   is a seek point.



Curley, et al.            Expires 23 April 2023                [Page 13]

Internet-Draft                    WARP                      October 2022


   A common encoding structure is to only reference the previous frame,
   as it is simple and minimizes latency:

    I <- P <- P <- P   I <- P <- P <- P   I <- P ...

   Another common encoding structure is to use B-frames in a fixed
   pattern, which is easier for hardware encoding.  B-frames reference
   one or more future frames, which improves the compression ratio but
   increases latency.

   This example is referenced in later sections:

       B     B         B     B         B
      / \   / \       / \   / \       / \
     /   \ /   \     /   \ /   \     /   \
    I <-- P <-- P   I <-- P <-- P   I <-- P ...

   Note that the B-frames reference I and P frames in this example,
   despite the lack of an arrow.  TODO better ASCII art

   There is no such thing as an optimal encoding structure.  Encoders
   tuned for the best quality will produce a tangled spaghetti of
   references.  Encoders tuned for the lowest latency still have a lot
   of options for references.

8.3.2.  Decode Order

   The encoder outputs the bitstream in decode order, which means that
   each frame is output after its dependencies.  This is only relevant
   for B-frames as they must be buffered until the frame they reference
   has been flushed.

   A layer MUST be in decode order.

   For the example above, this would look like:

   encode order: I B P B P I B P B P I B P ..
   decode order: I P B P B I P B P B I P B ..

8.3.3.  Group of Pictures

   A group of pictures (GoP) is consists of an I-frame and the frames
   that directly or indirectly reference it.  Each GoP can be decoded
   independently and thus can be transmitted independently.  It is also
   safe to drop the tail of the GoP (in decode order) without causing
   decode errors.





Curley, et al.            Expires 23 April 2023                [Page 14]

Internet-Draft                    WARP                      October 2022


   A layer MAY consist of an entire GoP.  A layer MAY consist of
   multiple sequential GoPs.

   Our example GoP structure would be split into three layers.

        layer 1         layer 2      layer 3
   +---------------+---------------+---------
   | I  P  B  P  B | I  P  B  P  B | I  P  B
   +---------------+---------------+---------

8.3.4.  Scalable Video Coding

   The concept of layers is borrowed from scalable video coding (SVC).
   When SVC is enabled, the encoder produces multiple bitstreams in a
   hierarchy.  Dropping the top layer degrades the user experience in a
   configured way, such as reducing the resolution, picture quality,
   and/or frame rate.

   A layer MAY consist of an entire SVC layer.

   Our example GoP structure would be split into six layers, assuming
   the B frames are part of a SVC layer:

       layer 2       layer 4     layer 6
   +-------------+-------------+--------
   |    B   B    |    B   B    |    B
   +-------------+-------------+--------
   |  I   P   P  |  I   P   P  |  I   P
   +-------------+-------------+--------
       layer 1       layer 3     layer 5

   Note that SVC encoding is more complicated than this; our example is
   a simple temporal encoding scheme.

8.3.5.  Frames

   With full knowledge of the encoding, the producer can split a GoP
   into multiple layers based on the frame.  However, this is highly
   dependent on the encoding, and the additional complexity might not
   improve the user experience.

   A layer MAY consist of a single frame.

   Our example GoP structure could be split into thirteen layers:







Curley, et al.            Expires 23 April 2023                [Page 15]

Internet-Draft                    WARP                      October 2022


         2     4           7     9           12
   +--------+--------+--------+--------+-----------+
   |     B  |  B     |     B  |  B     |     B     |
   |-----+--+--+-----+-----+--+--+-----+-----+-----+
   |  I  |  P  |  P  |  I  |  P  |  P  |  I  |  P  |
   +-----+-----+-----+-----+-----+-----+-----+-----+
      1     3     5     6     8     10    11    13

   To reduce the number of layers, frames can be appended to a layer
   they depend on.  Layers are delivered in order so this is simpler and
   produces the same user experience.

   A layer MAY consist of multiple frames within the same GoP.

   The same GoP structure can be represented using eight layers:

         2     3           5     6           8
   +--------+--------+-----------------+------------
   |     B  |  B     |     B  |  B     |     B     |
   +--------+--------+--------+--------+-----------+
   |  I     P     P  |  I     P     P  |  I     P
   +-----------------+-----------------+------------
            1                 4              7

   We can further reduce the number of layers by combining some frames
   that don't depend on each other.  The only restriction is that frames
   can only reference frames earlier in the layer, or within a
   dependency layer.  For example, non-reference frames can have their
   own layer so they can be prioritized or dropped separate from
   reference frames.

   The same GoP structure can also be represented using six layers,
   although we've removed our ability to drop individual B-frames:

       layer 2       layer 4     layer 6
   +-------------+-------------+--------
   |    B   B    |    B   B    |    B
   +-------------+-------------+--------
   |  I   P   P  |  I   P   P  |  I   P
   +-------------+-------------+--------
       layer 1       layer 3     layer 5

   Note that this is identical to our SVC example; we've effectively
   implemented our own temporal coding scheme.







Curley, et al.            Expires 23 April 2023                [Page 16]

Internet-Draft                    WARP                      October 2022


8.3.6.  Slices

   Frames actually consist of multiple slices that reference other
   slices.  It's conceptually simpler to work with frames instead of
   slices, but splitting slices into layers may be useful.  For example,
   intra-refresh splits an I-frame into multiple I-slices (TODO
   terminology) and spread over multiple frames to smooth out the
   bitrate.  TODO are slices necessary?

   A layer MAY consist of a single slice.  A layer MAY consist of
   multiple slices that are part of the same GoP.

8.3.7.  Init

   For the most byte-conscious applications, initialization data can be
   sent over its own layer.  Multiple layers can depend on this
   initialization layer to avoid redundant transmissions.  For example:
   this is the init segment in CMAF ("moov" with no samples), which
   contains the SPS/PPS NALUs for h.264.

   A layer MAY consist of no samples.

   Our example layer per GoP would have an extra layer added:

        layer 2         layer 3      layer 4
   +---------------+---------------+---------
   | I  P  B  P  B | I  P  B  P  B | I  P  B
   +---------------+---------------+---------
   |                     init
   +-----------------------------------------
                        layer 1

   An initialization layer MUST be cached in memory until it expires.
   TODO How do we do this?

8.4.  Audio

8.4.1.  Encoding

   Audio is dramatically simpler than video as it is not delta encoded.
   Audio samples are grouped together (group of samples) at a configured
   rate, also called a "frame".  Frames do not depend on other frames
   and have a timestamp for synchronization.

   In the below diagrams, each audio frame is denoted with an S.  The
   encoder spits out a continuous stream of samples:

   S S S S S S S S S S S S S



Curley, et al.            Expires 23 April 2023                [Page 17]

Internet-Draft                    WARP                      October 2022


8.4.2.  Simple

   The simplest configuration is to use a single layer for each audio
   track.  This may seem inefficient given the ease of dropping audio
   samples.  However, the audio bitrate is low and gaps cause quite a
   poor user experience, when compared to video.

   A layer SHOULD consist of multiple audio frames.

             layer 1
   +---------------------------
   | S S S S S S S S S S S S S
   +---------------------------

8.4.3.  Periodic Refresh

   An improvement is to periodically split audio samples into separate
   layers.  This gives the consumer the ability to skip ahead during
   severe congestion or temporary connectivity loss.

        layer 1         layer 2      layer 3
   +---------------+---------------+---------
   | S  S  S  S  S | S  S  S  S  S | S  S  S
   +---------------+---------------+---------

   This frequency of audio layers is configurable, at the cost of
   additional overhead.  It's NOT RECOMMENDED to create a layer for each
   audio frame because of this overhead.

8.4.4.  Segments

   Video can only recover from severe congestion with an I-frame, so
   there's not much point recovering audio at a separate interval.  It
   is RECOMMENDED to create a new audio layer at each video I-frame.

        layer 1         layer 3      layer 5
   +---------------+---------------+---------
   | S  S  S  S  S | S  S  S  S  S | S  S  S
   +---------------+---------------+---------
   | I  P  B  P  B | I  P  B  P  B | I  P  B
   +---------------+---------------+---------
        layer 2         layer 4      layer 6

   This is effectively how HLS/DASH segments work, with the exception
   that the most recent layers are still pending.

9.  References




Curley, et al.            Expires 23 April 2023                [Page 18]

Internet-Draft                    WARP                      October 2022


9.1.  Normative References

   [ISOBMFF]  "Information technology — Coding of audio-visual objects —
              Part 12: ISO Base Media File Format", December 2015.

   [QUIC]     Iyengar, J., Ed. and M. Thomson, Ed., "QUIC: A UDP-Based
              Multiplexed and Secure Transport", RFC 9000,
              DOI 10.17487/RFC9000, May 2021,
              <https://www.rfc-editor.org/info/rfc9000>.

   [QUIC-RECOVERY]
              Iyengar, J., Ed. and I. Swett, Ed., "QUIC Loss Detection
              and Congestion Control", RFC 9002, DOI 10.17487/RFC9002,
              May 2021, <https://www.rfc-editor.org/info/rfc9002>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.

   [WebTransport]
              Frindell, A., Kinnear, E., and V. Vasiliev, "WebTransport
              over HTTP/3", Work in Progress, Internet-Draft, draft-
              ietf-webtrans-http3-03, 6 July 2022,
              <https://www.ietf.org/archive/id/draft-ietf-webtrans-
              http3-03.txt>.

9.2.  Informative References

   [BBR]      Cardwell, N., Cheng, Y., Yeganeh, S. H., Swett, I., and V.
              Jacobson, "BBR Congestion Control", Work in Progress,
              Internet-Draft, draft-cardwell-iccrg-bbr-congestion-
              control-02, 7 March 2022,
              <https://www.ietf.org/archive/id/draft-cardwell-iccrg-bbr-
              congestion-control-02.txt>.

   [CMAF]     "Information technology -- Multimedia application format
              (MPEG-A) -- Part 19: Common media application format
              (CMAF) for segmented media", March 2020.

   [NewReno]  Henderson, T., Floyd, S., Gurtov, A., and Y. Nishida, "The
              NewReno Modification to TCP's Fast Recovery Algorithm",
              RFC 6582, DOI 10.17487/RFC6582, April 2012,
              <https://www.rfc-editor.org/info/rfc6582>.



Curley, et al.            Expires 23 April 2023                [Page 19]

Internet-Draft                    WARP                      October 2022


Contributors

   TODO

Authors' Addresses

   Luke Curley
   Twitch

   Email: kixelated@gmail.com


   Kirill Pugin
   Meta

   Email: ikir@meta.com


   Suhas Nandakumar
   Cisco

   Email: snandaku@cisco.com





























Curley, et al.            Expires 23 April 2023                [Page 20]
