{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-04-02T01:10:19.720330+00:00",
  "repo": "moq-wg/moq-transport",
  "labels": [
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "Editorial",
      "description": "The draft is difficult to understand on a specific point, or it is open to multiple interpretations.",
      "color": "bfdadc"
    },
    {
      "name": "Requirement",
      "description": "The draft is missing text or a mechanism which addresses and agreed requirement (in the charter or r",
      "color": "B23702"
    },
    {
      "name": "streaming format draft",
      "description": "This issue applies to the streaming format draft rather than the transport",
      "color": "5319e7"
    },
    {
      "name": "Needs PR",
      "description": "",
      "color": "f9d0c4"
    },
    {
      "name": "NotTransport",
      "description": "",
      "color": "d93f0b"
    },
    {
      "name": "Implementation Blocker",
      "description": "Resolving the issue blocks implementing from the spec",
      "color": "006b75"
    },
    {
      "name": "Needs Discussion",
      "description": "Tags for issues which need discussion, ideally at an interim or IETF meeting.",
      "color": "006b75"
    },
    {
      "name": "Handshake",
      "description": "QUIC vs WebTransport, SETUP Message",
      "color": "f9d0c4"
    },
    {
      "name": "Announce",
      "description": "Issues with Announce message and handling",
      "color": "F59C96"
    },
    {
      "name": "Control Streams",
      "description": "Related to control streams and general control message handling",
      "color": "CC5EAA"
    },
    {
      "name": "Object Model",
      "description": "Relating to the properties of Tracks, Groups and Object",
      "color": "0CABD7"
    },
    {
      "name": "Subscribe",
      "description": "Related to SUBSCRIBE message and subscription handling",
      "color": "954469"
    },
    {
      "name": "Wire Format",
      "description": "Related to how messages are serialized and parsed",
      "color": "DD912B"
    },
    {
      "name": "Parameters",
      "description": "Parameter formatting, etc",
      "color": "d93f0b"
    },
    {
      "name": "Parked",
      "description": "Issue we may discuss later or close as OBE",
      "color": "d4c5f9"
    },
    {
      "name": "ABR",
      "description": "Issues about adaptive bitrate and may require moqt changes",
      "color": "c2e0c6"
    },
    {
      "name": "Transmission",
      "description": "Issues involving what to transmit when, what to drop, priorities, etc",
      "color": "0052cc"
    }
  ],
  "issues": [
    {
      "number": 2,
      "id": "I_kwDOG2Ho4M5D36o_",
      "title": "Consider dropping \"x-\" prefix for custom extensions ",
      "url": "https://github.com/moq-wg/moq-transport/issues/2",
      "state": "CLOSED",
      "author": "englishm-ietf",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This section:\r\n\r\nhttps://github.com/kixelated/warp-draft/blob/a8e121f901bf0f61a5b59fc56a913688d8b0ecdb/draft-lcurley-warp.md?plain=1#L265-L268\r\n\r\nmakes a recommendation that appears to be contrary to [RFC6648 - \"Deprecating the \"X-\" Prefix and Similar Constructs in Application Protocols\"](https://datatracker.ietf.org/doc/html/rfc6648)\r\n\r\nI'd suggest following the recommendations of that RFC and dropping the \"x-\" prefix for custom extensions.\r\n\r\nAdditionally, there will probably come a point where IANA registration of standardized extensions may be useful, but it's probably more than a little early to be talking about that.",
      "createdAt": "2022-02-15T13:58:03Z",
      "updatedAt": "2022-10-20T22:58:11Z",
      "closedAt": "2022-10-20T22:58:10Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "The new draft doesn't use JSON messages any longer. We'll still want to reserve a number space for custom messages.",
          "createdAt": "2022-10-20T22:58:10Z",
          "updatedAt": "2022-10-20T22:58:10Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDOG2Ho4M5D5Bo9",
      "title": "LUKE CURLEY",
      "url": "https://github.com/moq-wg/moq-transport/issues/3",
      "state": "CLOSED",
      "author": "coral",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-02-15T17:50:39Z",
      "updatedAt": "2022-07-10T18:20:29Z",
      "closedAt": "2022-07-10T18:20:29Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "no u",
          "createdAt": "2022-07-10T18:20:29Z",
          "updatedAt": "2022-07-10T18:20:29Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDOG2Ho4M5NfCNH",
      "title": "Simulcast",
      "url": "https://github.com/moq-wg/moq-transport/issues/4",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The current draft implies that there is a single track. We should definitely support the ability to send/receive multiple tracks.\r\n\r\nRight now, the media producer could send multiple segments with the same timestamp and the track ID in the MP4 segment could be used to identify the track. This does require that the media be encoded or rewritten with unique track IDs.\r\n\r\nHowever, I imagine that there are use-cases where tracks are encoded separately as track ID=1. To avoid needing to rewrite the segment data, we could just add a `track` identifier to the Warp message layer.\r\n\r\nThis seems simple but I haven't dealt much with multiple tracks. What happens when there are multiple tracks in the actual container? Should we advertise track metadata in the warp layer or leave that in the init segment?\r\n\r\nWe also need to specify that renditions can be prioritized. Seems like a very easy win to prioritize the 360p rendition during congestion while the 720p rendition starves.",
      "createdAt": "2022-07-10T18:02:09Z",
      "updatedAt": "2022-10-20T22:58:32Z",
      "closedAt": "2022-10-20T22:58:32Z",
      "comments": []
    },
    {
      "number": 5,
      "id": "I_kwDOG2Ho4M5NfCTR",
      "title": "Media Capabilities",
      "url": "https://github.com/moq-wg/moq-transport/issues/5",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "streaming format draft"
      ],
      "body": "Currently, media capabilities are left up to the application. It's implied that the producer and consumer have negotiated the codec, resolution, max bitrate, etc through an outside source.\r\n\r\nShould we add capabilities to the video protocol itself? Is there some existing standard we should leverage? Do capabilities change on the fly, and thus need to be part of the protocol? How do we get new codecs added to the protocol?",
      "createdAt": "2022-07-10T18:03:48Z",
      "updatedAt": "2023-08-07T21:39:03Z",
      "closedAt": "2023-08-07T21:39:03Z",
      "comments": [
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "This reminds me of [SDP](https://datatracker.ietf.org/doc/html/rfc4566) used in WebRTC. Capabilities negotiation seems like a one-time thing. The producer and consumer negotiate a capability set. Then the producer is free to change the codec, resolution, bitrate within the limit of the negotiated set. The set will not change on the fly, but the exact chosen value may vary from segment to segment.",
          "createdAt": "2022-07-12T10:01:14Z",
          "updatedAt": "2022-07-12T10:01:14Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "We need a way to setup manifest declaratively. But at the media transport layer, all we need is to have a mapping to the capability and media container will have further details ",
          "createdAt": "2022-11-09T18:16:07Z",
          "updatedAt": "2022-11-09T18:16:07Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We need something simple that can help make this work. I 100% don't want SDP offer/answer. Way too complicated. But I do want a player to be able understand how to move between varios renditions given the bitrate available and things like that.",
          "createdAt": "2022-11-12T12:23:42Z",
          "updatedAt": "2022-11-12T12:23:42Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Suhas and I chatted about this quite a bit in person.\n\nThere's quite a bit of overlap between announcing capabilities (ex. I support h.264 or VP9) and announcing available tracks (ex. you can choose the language/rendition).\n\nThe sender could just announce h.264 and VP9 as separate tracks and start encoding when first requested. I think that's how SDP works?\n\nWe would have to be careful about introducing too many permutations. For example, every combination of possible container, codec, resolution, bitrate, etc.",
          "createdAt": "2022-11-13T00:03:03Z",
          "updatedAt": "2022-11-13T00:03:03Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDOG2Ho4M5NfCkW",
      "title": "Producer Rendition Selection",
      "url": "https://github.com/moq-wg/moq-transport/issues/6",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The current draft has a brief section on ABR. The claim is that the producer should choose renditions because it has better insight into the state of the network.\r\n\r\nDoes the producer have enough information to choose the rendition, and should any additional information required be part of the protocol? For example, the current buffer size.\r\n\r\nAdditionally, should the consumer influence the decision? For example, the player is muted/backgrounded and we should save bandwidth by choosing from lower renditions.",
      "createdAt": "2022-07-10T18:08:39Z",
      "updatedAt": "2022-10-20T23:00:40Z",
      "closedAt": "2022-10-20T22:59:10Z",
      "comments": [
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "Those two questions are related.\r\nConsumer should influence the decision because:\r\n1. consumer has the final judgement of the QoE. Sending the QoE metric back to the producer can help the sender-side optimization. One exmaple is [xlink for multi-path transport](http://www.hongqiangliu.com/uploads/5/2/7/4/52747939/sigcomm2021-xlink.pdf). For single path, reporting the application layer buffer size would be helpful too. \r\n2. consumer application behavior may influence the QoE dramatically such as fast forwarding (which affects the application layer buffer size ) and backgrounding (which changes the QoE model).\r\n\r\nThose metric/behavior can not be inferred from simple ACKs of transport layer. It would be great that the protocol can provide an application-layer feedback channel from the consumer to the producer. ",
          "createdAt": "2022-07-12T03:48:48Z",
          "updatedAt": "2022-07-12T03:48:48Z"
        },
        {
          "author": "acbegen",
          "authorAssociation": "NONE",
          "body": "> The current draft has a brief section on ABR. The claim is that the producer should choose renditions because it has better insight into the state of the network.\r\n\r\nI don't agree with this claim as I mentioned before. There are a lot of things that do happen on the client side that the sender will never be aware of unless it is explicitly told by the client. Either the client provides all the other relevant details (some were listed by you and @VMatrix1900) to the sender so it can do a better decision or the sender tells the client what the current network conditions are and the client makes the decision and reports back to the sender. ",
          "createdAt": "2022-07-16T12:18:10Z",
          "updatedAt": "2022-07-16T12:18:10Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, I think I should remove this section. It's too much of an opinion rather than something to act upon. I just wanted a soapbox to complain about low-latency client-side ABR.",
          "createdAt": "2022-07-18T18:45:34Z",
          "updatedAt": "2022-07-18T18:45:34Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing because the new draft does not specify track management yet. The plan is to support contribution and distribution.",
          "createdAt": "2022-10-20T23:00:40Z",
          "updatedAt": "2022-10-20T23:00:40Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOG2Ho4M5NfDAt",
      "title": "Warp Box",
      "url": "https://github.com/moq-wg/moq-transport/issues/7",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently there's a `warp` box containing metadata about the upcoming init or segment data. However it's not clear what should be in this box, or if it needs to exist at all.\r\n\r\nYou can identify if it's an init or media segment based on the first atom. `ftyp` versus `styp`. Should we have a single message instead of `init` versus `segment`?\r\n\r\nYou can identify the timestamp of the first sample by parsing the first `moof`. Should we expose the timestamp of the first sample at the warp layer? I think so so we can offset timestamps (stitching) without modifying the entire container.\r\n\r\nYou can identify the track by using the TrackID littered throughout the MP4. Should we expose the track in the warp layer so middleware can parse/route it easier?\r\n\r\nThe only thing that you can't identify is which init segment to use. This could be avoided by using multiple tracks rather than reinitializing an existing track.\r\n\r\nBasically, how much do we expose at the Warp (network) layer versus how much should be parsed at the media (MP4) layer?",
      "createdAt": "2022-07-10T18:17:42Z",
      "updatedAt": "2022-10-20T22:59:20Z",
      "closedAt": "2022-10-20T22:59:20Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Removed.",
          "createdAt": "2022-10-20T22:59:20Z",
          "updatedAt": "2022-10-20T22:59:20Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOG2Ho4M5NfDHc",
      "title": "Transport Streams",
      "url": "https://github.com/moq-wg/moq-transport/issues/8",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The current draft is fragmented MP4 only.\r\n\r\nShould we support transport streams? How much information needs to be lifted into the Warp message layer because it's difficult to parse in TS?",
      "createdAt": "2022-07-10T18:19:39Z",
      "updatedAt": "2022-10-20T23:00:53Z",
      "closedAt": "2022-10-20T23:00:53Z",
      "comments": [
        {
          "author": "acbegen",
          "authorAssociation": "NONE",
          "body": "My vote is to ignore TS unless someone comes up with a good reason why it should be supported.",
          "createdAt": "2022-07-16T12:12:01Z",
          "updatedAt": "2022-07-16T12:12:01Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Warp is CMAF compatible so it's easy to transition from DASH/HLS to Warp, unless they're still using TS segments. I agree though I don't think it's worth supporting.",
          "createdAt": "2022-07-18T18:46:52Z",
          "updatedAt": "2022-07-18T18:46:52Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Ignoring TS.",
          "createdAt": "2022-10-20T23:00:53Z",
          "updatedAt": "2022-10-20T23:00:53Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "I_kwDOG2Ho4M5NfEbl",
      "title": "Scalable Video Coding",
      "url": "https://github.com/moq-wg/moq-transport/issues/9",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The current draft assumes that media segments are independent. However, scalable video coding (SVC) exists and is likely something we should support in the future. I don't have any experience with SVC but AFAIK, you could have a 720p rendition that depends on a 360p rendition, so they can share some compression.\r\n\r\nMy idea was to support it by indicating that segments can reference other segments. The decoder would know that SVC is being used and that it needs to interleave segments from multiple streams. Or is this something we should indicate at the track/rendition level instead of the segment level? Or is this something we don't need to support at the Warp level at all?",
      "createdAt": "2022-07-10T18:47:10Z",
      "updatedAt": "2022-10-20T23:02:05Z",
      "closedAt": "2022-10-20T23:02:05Z",
      "comments": [
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "Instead of one-dimensional frames dependency in which a frame only depends on its adjacent frame(s), SVC encoder produces frames of multiple layers in which higher-layer frames usually depend on lower-layer ones. This will produce multiple layers of segments in Warp's term. Knowing the dependency between segments can help Warp to make better scheduling decision.",
          "createdAt": "2022-07-12T07:39:52Z",
          "updatedAt": "2022-07-12T07:39:52Z"
        },
        {
          "author": "acbegen",
          "authorAssociation": "NONE",
          "body": "I would not really bother with scalable video codecs until more important issues are addressed (for example allowing for rate shifting across normal (non-scalable) encodings). Scalable codecs don't allow arbitrarily jumping from one resolution to another. There are significant limitations on what you can do. In addition to in-segment dependencies, you will create across-segment dependencies which will make things like prioritization even more complicated. Also to get the same quality with a codec like SVC, you always need to download more bits compared to AVC or alike. For your primary use case which is 1:1 media, I don't see any benefit here.",
          "createdAt": "2022-07-16T12:10:52Z",
          "updatedAt": "2022-07-16T12:10:52Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, Warp is simple because a stream == GoP. It gets more complicated when you try to break a GoP into smaller pieces that depend on each other. ",
          "createdAt": "2022-07-18T18:51:27Z",
          "updatedAt": "2022-07-18T18:51:27Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "The new draft breaks streams into layers, including SVC layers. I could use some SVC expert to chime in on what else is needed but this is supported (at least in spirit) now.\r\n\r\n",
          "createdAt": "2022-10-20T23:02:05Z",
          "updatedAt": "2022-10-20T23:02:05Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOG2Ho4M5NlbCR",
      "title": "JSON ?",
      "url": "https://github.com/moq-wg/moq-transport/issues/10",
      "state": "CLOSED",
      "author": "fcartegnie",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Moq isn't targeting web only usage\r\nWhat's the purpose of requiring a JSON parser with no benefits compared to regular ISOBMFF boxes ?\r\n",
      "createdAt": "2022-07-12T07:28:28Z",
      "updatedAt": "2022-10-20T23:02:35Z",
      "closedAt": "2022-10-20T23:02:35Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Solely because I don't have much experience with ISOBMFF. I agree that we should switch if the rest of the design seems sound (ie. 'warp' boxes).",
          "createdAt": "2022-07-21T13:50:33Z",
          "updatedAt": "2022-07-21T13:50:33Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "The encoding is currently undefined but I definitely don't want to go back to JSON.",
          "createdAt": "2022-10-20T23:02:35Z",
          "updatedAt": "2022-10-20T23:02:35Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "I_kwDOG2Ho4M5UfHRP",
      "title": "TRACK message",
      "url": "https://github.com/moq-wg/moq-transport/issues/12",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I think there should be a TRACK message containing optional metadata about a track. I don't think this should be required for decoding (ex. keep the SPS/PPS in a layer), although it's probably required for some capabilities exchange. Each track should have a unique identifier for sure.",
      "createdAt": "2022-10-20T23:06:55Z",
      "updatedAt": "2023-03-31T23:01:32Z",
      "closedAt": "2023-03-31T23:01:32Z",
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Having a track message that captures the details of the media being sent will be helpful. It does need to tie to media capabilities or manifest. +1 on having unique track identifier",
          "createdAt": "2022-11-09T17:55:38Z",
          "updatedAt": "2022-11-09T17:55:38Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we should require the sender to declare upfront what tracks are being sent, with ability to declare more later.  For instance, in case of ingestion, I would like to be able to immediately reject unsupported configuration with an error.\r\n\r\nAs for SPS/PPS, ideally, the layer system supports this by design?  E.g. you declare SPS/PPS on an `order=0` layer, and make all subsequent video frames depend on it.  We should make sure that having a permanent `order=0` layer does not prevent subsequent layers from being discarded.",
          "createdAt": "2022-11-09T18:25:18Z",
          "updatedAt": "2022-11-09T18:25:18Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@vasilvv agree. I think there are couple of issues that are related to\r\n- media capabilities \r\n- tracks\r\n- manifest \r\nall these need a similar thinking at a higher level  which is - \"way to setup and modify media capabilites between the publishers and consumers.\":",
          "createdAt": "2022-11-09T18:30:10Z",
          "updatedAt": "2022-11-09T18:30:10Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "A few features are missing but this is CATALOG.",
          "createdAt": "2023-03-31T23:01:32Z",
          "updatedAt": "2023-03-31T23:01:32Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "I_kwDOG2Ho4M5UfKI-",
      "title": "PLAY message",
      "url": "https://github.com/moq-wg/moq-transport/issues/13",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, there's no way to determine which layers/tracks get pushed. We probably need a new message to control which tracks the consumer wants. We need to support both simulcast (send all tracks), ABR (send one track of this group), and manual track selection (send just these tracks).",
      "createdAt": "2022-10-20T23:19:38Z",
      "updatedAt": "2023-03-31T23:01:15Z",
      "closedAt": "2023-03-31T23:01:14Z",
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I assume this should be the part of a higher-layer protocol / an optional extension, rather than the push layer.  I am not sure this makes sense for, e.g., the ingestion use case.",
          "createdAt": "2022-11-09T18:27:11Z",
          "updatedAt": "2022-11-09T18:27:11Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "A few features are still missing but this is SUBSCRIBE",
          "createdAt": "2023-03-31T23:01:14Z",
          "updatedAt": "2023-03-31T23:01:14Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "I_kwDOG2Ho4M5UfNM9",
      "title": "Container",
      "url": "https://github.com/moq-wg/moq-transport/issues/14",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "streaming format draft"
      ],
      "body": "We're missing a section on the container. A container is needed because the codec bitstream doesn't have timing information, nor is it specified how to support more fringe features like captions and DRM. I would advocate for using CMAF (fMP4) unless somebody wants to take on the work of standardizing a \"raw\" container.\r\n\r\nTo summarize the hierarchy:\r\n* the codec bitstream is packaged media container\r\n* the media container is split into layers\r\n* each layer is sent over a QUIC stream",
      "createdAt": "2022-10-20T23:34:09Z",
      "updatedAt": "2023-08-07T21:39:22Z",
      "closedAt": "2023-08-07T21:39:22Z",
      "comments": [
        {
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we need to:\r\n1) Have a way to signal what container is used\r\n2) Agree on \"default\" container and I agree it should be CMAF",
          "createdAt": "2022-10-21T15:43:40Z",
          "updatedAt": "2022-10-21T15:43:40Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 on need to signal the container being used. \r\nI think we need to atleast CMAF and raw container/something ( to keep the packet sizes small for audio). But yes these can happen in sequence starting with CMAF first.",
          "createdAt": "2022-11-09T17:59:30Z",
          "updatedAt": "2022-11-09T17:59:30Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that an ISO BMFF derivative is the most plausible answer here (if we use CMAF, we need to make sure we actually want everything in it as-is).\r\n\r\nThe other answers could be:\r\n* M2TS.  This has an advantage (at least from the ingestion perspective) of being already widely supported in the TV broadcast ecosystem.  On the other hand, the framing overhead involved is fairly high, and I don't think the advantage of being already used is that good -- since we're splitting video and audio into different QUIC streams, some form of remuxing is required regardless.\r\n* MoQ-specific bitstream framing.  I believe that we should not do that, as that would result in us having to define codec bindings for every codec forever.  Later versions might do things like defining lower-overhead format for audio codecs, but that's definitely a v2+ feature.",
          "createdAt": "2022-11-09T19:27:18Z",
          "updatedAt": "2022-11-09T19:27:18Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 on CMAF but also I think I would be happy to take on the work of *also* supporting an \"RTP Style\" container which would be pretty much what you find in the payload of an RTP packet and use the media type from IANA to describe the format inside it. I'm thinking this will be trivial to do but perhaps I am missing what is hard about this. ",
          "createdAt": "2022-11-12T12:21:29Z",
          "updatedAt": "2022-11-12T12:21:29Z"
        },
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "+1 on RTP style container. We already have those IANA registry and RTP payload format as RFC. Maybe we can reuse them. Sounds like RTP over QUIC?",
          "createdAt": "2022-11-12T21:43:29Z",
          "updatedAt": "2022-11-12T21:43:29Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "In #43, I define a mimetype for each track, which contains the type/container/codec. The receiver can choose which track to play based on those properties. For example: `video/mp4; codecs=avc1.64001e`.\r\n\r\nIs this all we need? And some text changes of course to remove the CMAF specifics. ",
          "createdAt": "2022-11-16T19:08:03Z",
          "updatedAt": "2022-11-16T19:09:32Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "I_kwDOG2Ho4M5UfUNa",
      "title": "Discontinuities",
      "url": "https://github.com/moq-wg/moq-transport/issues/15",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "streaming format draft"
      ],
      "body": "There's currently no way to reset the timescale. This is very useful when stitching in content, as the new media could start at PTS 0 but still appear continuous. Otherwise the server would need to rewrite the media timestamps. Discontinuities are also used to reset the decoder, although I'm not sure what else it impacts other than the timestamp.\r\n\r\nA discontinuity flag for each layer wouldn't work since layers arrive out of order. In order to support discontinuities, you need to know the last timestamp+duration, which may not have arrived yet.\r\n\r\nA possible solution is to include `baseTimestamp` in each layer, indicating the decoder should add this value to each timestamp. The only problem is that it would be a little annoying to repeat the base timestamp for each layer. Maybe the base timestamp could be inherited by dependency layer(s)? Not sure.",
      "createdAt": "2022-10-21T00:04:13Z",
      "updatedAt": "2023-08-07T21:38:34Z",
      "closedAt": "2023-08-07T21:38:34Z",
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I suggest that we have an \"epoch\" counter.  You start with epoch = 0, and then increment it by one every time you want to reset the timestamps.\r\n\r\nWe may also want to tie init segments (#21) to the epoch?  E.g. if you want to switch the resolution mid-stream, you would probably want to reset the decoder and add new video format metadata anyways.",
          "createdAt": "2022-11-09T19:36:47Z",
          "updatedAt": "2022-11-09T19:36:47Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah that's my thought as well.",
          "createdAt": "2022-11-11T11:11:31Z",
          "updatedAt": "2022-11-11T11:11:31Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hmm - I'd think it would be a good idea to sketch out a few design on this and get better idea of all the issue. I lean towards something that is mappable to real ntp time so that things can be debugged as well as synchronized. (note \"mapped to\" leave open a wide range of possible solutions including probably what you were talking about above ) \r\n\r\n",
          "createdAt": "2022-11-12T12:32:41Z",
          "updatedAt": "2022-11-12T12:32:41Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I definitely want some way to map PTS to wall clock timestamp as well.",
          "createdAt": "2022-11-13T00:07:29Z",
          "updatedAt": "2022-11-13T00:07:29Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Still needs discussion, but most definitely part of the streaming format draft.",
          "createdAt": "2023-08-07T21:38:34Z",
          "updatedAt": "2023-08-07T21:38:34Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "I_kwDOG2Ho4M5UfWJ6",
      "title": "Authentication",
      "url": "https://github.com/moq-wg/moq-transport/issues/16",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We're using WebTransport to establish the connection, which uses a HTTP CONNECT request. Is rejecting this CONNECT request enough for authentication or do people want an explicit message?",
      "createdAt": "2022-10-21T00:13:45Z",
      "updatedAt": "2023-08-07T21:37:28Z",
      "closedAt": "2023-08-07T21:37:27Z",
      "comments": [
        {
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's not do auth, client will get WebTransport url from somewhere - that part can take care of \"auth\"",
          "createdAt": "2022-10-24T17:50:35Z",
          "updatedAt": "2022-10-24T17:50:35Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Some form of auth mechanism (say token) is needed for relays/edge nodes to authorize publishes and subscribes.\r\nHow such a token is obtained is out of scope for MOQ , but the protocol needs a way to provide the auth info before sending or receiving the media",
          "createdAt": "2022-11-09T18:01:21Z",
          "updatedAt": "2022-11-09T18:01:21Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Reviewing this older thread per discussions at last week's editors call. Two issues regarding authentication need to be resolved:\r\n\r\n1. Do we have consensus that an auth mechanism (such as tokens) is out of scope for Moq-transport ?\r\n     2. Argument For: there are many possible means to authenticate and defining one (or a few) limits the flexibility of implementers in adopting the newest auth mechanism, thus inhibiting innovation.\r\n     3. Argument against: for the broadest interop, it would be useful to define a baseline authentication mechanism which all implementations must support. This does not stop implementers in adding additional authentication methods. \r\n5.  How should auth be communicated with a raw QUIC connection, in which no CONNECT equivalent is available? Should space be reserved in the PATH parameter per https://kixelated.github.io/warp-draft/draft-lcurley-warp.html#native-quic for a token? Is the format of this left to the implementers, or should moq-transport define a baseline implementation? ",
          "createdAt": "2023-04-26T07:08:14Z",
          "updatedAt": "2023-04-26T07:08:14Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> 2. How should auth be communicated with a raw QUIC connection, in which no CONNECT equivalent is available? Should space be reserved in the PATH parameter per https://kixelated.github.io/warp-draft/draft-lcurley-warp.html#native-quic for a token? Is the format of this left to the implementers, or should moq-transport define a baseline implementation?\r\n\r\nThe PATH parameter for native QUIC is intended as a replacement for the WebTransport CONNECT URL. We should treat both of them as semantically equivalent, so any solution works for both underlying transports.\r\n",
          "createdAt": "2023-04-26T17:08:23Z",
          "updatedAt": "2023-04-26T17:08:23Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "The current draft allows for auth to happen in a number of places:\r\n\r\n1. At the TLS layer when establishing the connection\r\n2. During the CONNECT step for WebTransport or PATH SETUP parameter for raw QUIC\r\n3. When sending ANNOUNCE or SUBSCRIBE\r\n\r\nDo we need more points to carry auth or can we close this for now?  There's also issue #152\r\n\r\n@kixelated ",
          "createdAt": "2023-05-26T23:51:34Z",
          "updatedAt": "2023-05-26T23:51:34Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we need more sophisticated authentication, which is why I filed #152. A byte blob in the SUBSCRIBE/ANNOUNCE sucks for interoperability and it doesn't support challenges (public key crypto). If we're going to add an authentication layer to MoQ (number 3 in Alan's message), it needs to be more fleshed out.\r\n\r\nBut I also don't really care and this issue is too broad, so CLOSED.",
          "createdAt": "2023-08-07T21:37:27Z",
          "updatedAt": "2023-08-07T21:37:27Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "I_kwDOG2Ho4M5UfXAX",
      "title": "HEADERS encoding",
      "url": "https://github.com/moq-wg/moq-transport/issues/17",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, there's a HEADERS message at the start of each stream, primarily indicating how the stream should be proxied through intermediaries. There's currently no encoding defined and many of the properties are optional.\r\n\r\nI see a lot of parallels with HTTP/3. Would it make sense to use HTTP/3? What about just QPACK?",
      "createdAt": "2022-10-21T00:18:24Z",
      "updatedAt": "2023-03-31T23:02:13Z",
      "closedAt": "2023-03-31T23:02:12Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Most people hate QPACK.  Maybe re-use the simple encoding from HTTP binary messages: https://www.ietf.org/archive/id/draft-thomson-http-binary-message-00.html\r\n\r\n\r\nFrom: kixelated ***@***.***>\r\nReply-To: kixelated/warp-draft ***@***.***>\r\nDate: Thursday, October 20, 2022 at 5:18 PM\r\nTo: kixelated/warp-draft ***@***.***>\r\nCc: Subscribed ***@***.***>\r\nSubject: [kixelated/warp-draft] HEADERS encoding (Issue #17)\r\n\r\nCurrently, there's a HEADERS message at the start of each stream, primarily indicating how the stream should be proxied through intermediaries. There's currently no encoding defined and many of the properties are optional. I see a lot of parallels\r\nZjQcmQRYFpfptBannerStart\r\nThis Message Is From an External Sender\r\nZjQcmQRYFpfptBannerEnd\r\n\r\nCurrently, there's a HEADERS message at the start of each stream, primarily indicating how the stream should be proxied through intermediaries. There's currently no encoding defined and many of the properties are optional.\r\n\r\nI see a lot of parallels with HTTP/3. Would it make sense to use HTTP/3? What about just QPACK?\r\n\r\n\u2014\r\nReply to this email directly, view it on GitHub<https://github.com/kixelated/warp-draft/issues/17>, or unsubscribe<https://github.com/notifications/unsubscribe-auth/AB7AQ2O7ZDRM5HZHNUC57F3WEHONXANCNFSM6AAAAAARKVBF4I>.\r\nYou are receiving this because you are subscribed to this thread.Message ID: ***@***.***>\r\n",
          "createdAt": "2022-10-24T16:24:46Z",
          "updatedAt": "2022-10-24T16:24:46Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah that's fair; I've implemented QPACK myself and it's probably too complicated for our use-case.\n\nI think a binary encoding would work best if we are confident about the fields. If there's any ambiguity, then we should use something more dynamic.",
          "createdAt": "2022-10-24T17:39:36Z",
          "updatedAt": "2022-10-24T17:39:36Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "The HTTP binary encoding for header fields is like\r\n\r\n[ Length of Headers ]\r\n([ Length ] [ Header Name String ] [ Length ] [ Header Value String ])+\r\n\r\nSo it\u2019s just as dynamic as regular HTTP headers.\r\n\r\nFrom: kixelated ***@***.***>\r\nReply-To: kixelated/warp-draft ***@***.***>\r\nDate: Monday, October 24, 2022 at 10:39 AM\r\nTo: kixelated/warp-draft ***@***.***>\r\nCc: Alan Frindell ***@***.***>, Comment ***@***.***>\r\nSubject: Re: [kixelated/warp-draft] HEADERS encoding (Issue #17)\r\n\r\nYeah that's fair; I've implemented QPACK myself and it's probably too complicated for our use-case. I think a binary encoding would work best if we are confident about the fields. If there's any ambiguity, then we should use something more\r\nZjQcmQRYFpfptBannerStart\r\nThis Message Is From an External Sender\r\nZjQcmQRYFpfptBannerEnd\r\n\r\nYeah that's fair; I've implemented QPACK myself and it's probably too complicated for our use-case.\r\n\r\nI think a binary encoding would work best if we are confident about the fields. If there's any ambiguity, then we should use something more dynamic.\r\n\r\n\u2014\r\nReply to this email directly, view it on GitHub<https://github.com/kixelated/warp-draft/issues/17#issuecomment-1289370348>, or unsubscribe<https://github.com/notifications/unsubscribe-auth/AB7AQ2NPW2ETVV7SKI7SLPLWE3CWHANCNFSM6AAAAAARKVBF4I>.\r\nYou are receiving this because you commented.Message ID: ***@***.***>\r\n",
          "createdAt": "2022-10-24T17:42:41Z",
          "updatedAt": "2022-10-24T17:42:41Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, I meant that we could also have concrete frame types (ex. PROXY, CACHE?) instead of HEADERS with arbitrary key/value pairs.",
          "createdAt": "2022-10-24T17:48:25Z",
          "updatedAt": "2022-10-24T17:48:25Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "Not much strong opinion on this. Reusing binary HTTP sounds like a good option, everywhere you can avoid inventing a new things, and worrying about extensibily, increases velocity.",
          "createdAt": "2022-10-27T20:34:41Z",
          "updatedAt": "2022-10-27T20:34:41Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think QPACK buys you much here given the overall usage. ",
          "createdAt": "2022-11-12T12:18:41Z",
          "updatedAt": "2022-11-12T12:18:41Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, my opinion has changed and I think we should just have a fixed encoding like QUIC/H3 frames.\n\nOriginally I was afraid the WG wouldn't buy into the delivery order idea, and everyone would want their own way to decide when to prioritize/drop media. The intent was to use generic key/value pairs so it was extensible.\n\nHowever the reaction has been far more positive than I expected. For the sake of interop with relays, let's go with a simple and fixed priority scheme. We can decide how extensible it should be with more deployment experience.",
          "createdAt": "2022-11-12T23:46:55Z",
          "updatedAt": "2022-11-12T23:47:09Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Some issues from discussion on PR #46:\r\n\r\n* Do we want to have fixed fields or do we want to have arbitrary key-value pairs?\r\n* If we do, should the keys be numbers or strings?\r\n* If strings, are those ASCII and case-sensitive or not?",
          "createdAt": "2022-11-19T00:09:55Z",
          "updatedAt": "2022-11-19T00:09:55Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "This has been rolled into OBJECT",
          "createdAt": "2023-03-31T23:02:12Z",
          "updatedAt": "2023-03-31T23:02:12Z"
        }
      ]
    },
    {
      "number": 18,
      "id": "I_kwDOG2Ho4M5UfY53",
      "title": "Negotiation",
      "url": "https://github.com/moq-wg/moq-transport/issues/18",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "streaming format draft"
      ],
      "body": "How do we negotiate which codecs, resolutions, bitrates, etc that an endpoint is willing to support?\r\n\r\nSDP sucks please don't suggest it.",
      "createdAt": "2022-10-21T00:27:32Z",
      "updatedAt": "2023-08-07T21:33:42Z",
      "closedAt": "2023-08-07T21:33:42Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Also we should have a way to negotiate the container format.",
          "createdAt": "2022-10-21T15:55:53Z",
          "updatedAt": "2022-10-21T15:55:53Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "QuicR has a simple manifest to declare/advertise  (not negotiate and hence no SDP ;) ) the capabilities . That would be one way to do and the same can be solved otherways too .\r\n\r\nSome starting notes here: https://www.ietf.org/id/draft-jennings-moq-quicr-proto-01.html#name-quicr-manifest",
          "createdAt": "2022-11-09T18:24:08Z",
          "updatedAt": "2022-11-09T18:24:08Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I feel like there are three related problems here:\r\n1. A sender needs to describe what it is going to send\r\n1. A receiver needs to describe what it is willing to accept\r\n1. Two of those parties might need to have an algorithm to come to an agreement regarding the best way to exchange media.\r\n\r\nI believe that the first one should be always required and we should have a uniform way of doing that.  The second one is optional though useful (e.g. as a live encoder I will send H.264 by default, but will upgrade to more recent codecs if offered support), but it is also harder (e.g. for problem one, you just say \"I am sending stereo\", for problem two, you need to say things like \"I accept both mono and stereo\").  The third one feels like it belongs on a higher level protocol/system.",
          "createdAt": "2022-11-09T20:02:27Z",
          "updatedAt": "2022-11-09T20:02:27Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "This is the catalog.",
          "createdAt": "2023-08-07T21:33:42Z",
          "updatedAt": "2023-08-07T21:33:42Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "I_kwDOG2Ho4M5UgC08",
      "title": "Raw QUIC as transport",
      "url": "https://github.com/moq-wg/moq-transport/issues/19",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We need to provide text on how to do the same over QUIC connection",
      "createdAt": "2022-10-21T04:01:46Z",
      "updatedAt": "2023-04-24T19:49:44Z",
      "closedAt": "2023-04-24T19:49:44Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure if raw QUIC is needed. Two separate modes that only differ from the handshake is just going to cut down on interoperability.\r\n\r\nWebTransport is pretty easy to implement. I'm not a huge fan of the HTTP/3 integration, and much preferred the older QuicTransport, but it's certainly not a blocker.\r\n\r\nIf we do support raw QUIC, we would need to define some method of authentication to replace the WebTransport CONNECT request. Plus the obvious ALPN.",
          "createdAt": "2022-10-24T17:13:29Z",
          "updatedAt": "2022-10-24T17:13:29Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "The MoQ charter says\r\n\r\n> Media will be mapped onto underlying QUIC mechanisms (QUIC streams and/or QUIC datagrams) and can be used over raw QUIC or WebTransport.\r\n\r\nIt's not clear if a MoQ protocol has to work on QUIC *and* WebTransport, that could certainly by one interpretation. Having to support both is feasible but, as Luke points out, it means that specs need to add a lot of extra words and considerations to make sure the design is sound. It also fragments the implementation base, increasing the chances that areas won't see implementation coverage and the protocol design can't be informed by experience.",
          "createdAt": "2022-10-27T20:29:58Z",
          "updatedAt": "2022-10-27T20:29:58Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe that any protocol that is defined for WebTransport will also work for raw QUIC, with the exception of having the URL path.  The converse, however, is not true (e.g. WebTransport does not provide consistent stream IDs as a part of the model).",
          "createdAt": "2022-11-09T20:05:28Z",
          "updatedAt": "2022-11-09T20:05:28Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "IIUC not having Raw QUIC is costing us a handshake RTT, since CONNECT can't be sent 0RTT. Not sure if that's important in these use cases or not.\r\n\r\nFor raw QUIC, it would be better if SETUP were sent on two unidirectional streams, rather than a client bidirectional stream, so that the server doesn't have to wait in the 1-RTT case. I don't think this breaks anything given SETUP has only one parameter, but the server sending first could break some negotiation models.",
          "createdAt": "2023-01-30T22:44:06Z",
          "updatedAt": "2023-01-30T22:44:06Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "Just applying some basic logic:\r\n\r\nIf its unsafe to send CONNECT powered 0-RTT requests over HTTP to start a MoQ thing, why would a raw mapping over QUIC make it safer? \r\n\r\nThis is a good example of where throwing out all of HTTP means we'd have to seriously consider all of the application layer issues we take for granted, because its a brand new application layer.",
          "createdAt": "2023-01-30T23:10:22Z",
          "updatedAt": "2023-01-30T23:10:22Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "Concretely, https://www.rfc-editor.org/rfc/rfc9308.html#section-3 describes the considerations for 0-RTT, which are covered in HTTP by https://httpwg.org/specs/rfc8470.html",
          "createdAt": "2023-01-30T23:16:19Z",
          "updatedAt": "2023-01-30T23:16:19Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Conceptually, the start of an MoQ session is a resource request, like a GET. That strikes me as idempotent, though I could be convinced otherwise.\r\n\r\nI agree that it's more work to do it directly over QUIC.",
          "createdAt": "2023-01-30T23:29:23Z",
          "updatedAt": "2023-01-30T23:29:23Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "Warp spec currently says:\r\n\r\n> The application SHOULD use the WebTransport CONNECT request for authentication. For example, including an authentication token in the path.\r\n\r\nSo skipping HTTP means you'll need to invent a way to carry authentication, which is a great target for 0-RTT capture and replay.",
          "createdAt": "2023-01-30T23:47:40Z",
          "updatedAt": "2023-01-30T23:47:56Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hmm, good point.",
          "createdAt": "2023-01-30T23:49:35Z",
          "updatedAt": "2023-01-30T23:49:35Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "But what would be the effect of this? The attacker would just get some packets it can't decode. When this is pulling a resource, it wouldn't affect the state of the server.",
          "createdAt": "2023-01-30T23:53:04Z",
          "updatedAt": "2023-01-30T23:53:04Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It might help to draw out some diagrams of packet/message exchanges, but I think there are more latency penalties. Even without 0RTT, with a dedicated ALPN the server could send SETUP and CATALOG in the 0.5RTT flight, allowing SETUP/SUBSCRIBE to go in the 1RTT flight.\r\n\r\nAs it stands, I believe we have:\r\n0.5RTT server SETTINGS\r\n1RTT client SETTINGS + CONNECT + SETUP\r\n1.5 RTT SETUP + CATALOG\r\n2 RTT SUBSCRIBE",
          "createdAt": "2023-01-31T00:35:26Z",
          "updatedAt": "2023-01-31T00:35:26Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "I guess I'm not really following the connection == media URI either. binding a MoQ broadcast to a single QUIC connection is a constraint that the WebTransport protocol doesn't have. \r\n\r\nEncoding a MoQ broadcast in a hostname is like sticking the content pointer in the DNS, that doesn't scale very well operationally IME. \r\n\r\nSo if MoQ over raw QUIC were to allow multiple broadcasts in a connection, it would need to sort out some way to advertise mutliple things. Which is again going to diverge from how HTTP does the same thing. ",
          "createdAt": "2023-01-31T01:18:45Z",
          "updatedAt": "2023-01-31T01:18:45Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "Actually, this URI thing extends to: how are endpoints supposed to discover each other? If I wanted to offer MoQ over WebTransport and MoQ over Raw QUIC simultaneously, then what are the expected interactions?\r\n\r\nThe protocol mapping part is the really easy bit. All the other stuff is hard and I think we need to hear from the people that really want to add and solve the complexity.",
          "createdAt": "2023-01-31T15:11:05Z",
          "updatedAt": "2023-01-31T15:11:05Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks like this can be closed now with #135 being merged?",
          "createdAt": "2023-04-21T19:39:42Z",
          "updatedAt": "2023-04-21T19:39:42Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I think so too. Closing this as fixed by #135.",
          "createdAt": "2023-04-24T19:49:42Z",
          "updatedAt": "2023-04-24T19:49:42Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "I_kwDOG2Ho4M5UorXe",
      "title": "Relays and extensions",
      "url": "https://github.com/moq-wg/moq-transport/issues/20",
      "state": "OPEN",
      "author": "xdfy",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "Handshake"
      ],
      "body": "It could help to add some text on relays support and extension. I'll try to provide some input there, from draft-defoy-moq-relay-network-handling. You may want to look at this draft for more context (this draft considers both stream-based and datagram-based MOQ, but it becomes simpler here because we are only using streams).\r\n\r\n- To support future relays, which may rely on metadata not present in the base protocol, an extension mechanism seems necessary. \r\n  - Negotiation within WebTransport-based protocol: negotiation of an extension could use HTTP headers when setting up the WebTransport session with connect (this is similar to how ECN support is negotiated in MASQUE in draft-schinazi-masque-connect-udp-ecn). This makes it possible for a relay to reject a connection establishment, if the extension it needs is missing.\r\n  - Negotiation within raw QUIC-based protocol could use QUIC transport parameters.\r\n  - The interest in using HTTP headers (or QUIC transport parameters) is that the session will only be opened if all extensions are accepted. Other methods can be used (e.g., using a message at the very beginning of the QUIC session), but in this case the session will be created and closed immediately if the negotiation fails.\r\n  - One open question is whether a MOQ relay could/should participate actively to the negotiation, beyond rejecting a request it does not like. For example, it could add a header in the CONNECT request forwarded to the server, to add an extension it needs.\r\n- Even with relays that can work with metadata currently defined in the base protocol, I wonder how it would work with optional metadata. Some relays may accept optional metadata (i.e., provide a certain level of service when a metadata field is present, and provide another level of service when it is not present). But what if a relay needs a timestamp to properly provide its service? One possibility is to define and use an extension, which specifies that certain optional metadata fields are mandatory when this extension is used.\r\n- What an extension can do could include:\r\n  - Defining new frames, defining where these new frames can be used (e.g., in independent streams or within existing streams, such as \"before media data frames\").\r\n  - Mandating the use of optional fields or frames\r\n  - Specifying whether new frames are encrypted end-to-end or only authenticated.\r\n- Also should we specify somewhere that unknown frames should be ignored?",
      "createdAt": "2022-10-23T21:52:03Z",
      "updatedAt": "2024-02-20T02:20:10Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Hey @xdfy, I read your draft and in particular agree with section 2.1. That's the motivation behind the `HEADERS` frame, although a better name would be `RELAY` since that's the intended usage. My general philosophy is that relays should default to being dumb (ex. a generic QUIC proxy) but have the potential to augment their behavior based on easy to parse content.\r\n\r\nI completely agree that we need a way of supporting new behavior. There's a few different options, like versioning the protocol, negotiating extensions in the handshake, or just adding new fields to existing frames (ex. HTTP headers). This section of the draft is completely missing at the moment and I don't have any insight on the best approach.",
          "createdAt": "2022-10-24T18:35:17Z",
          "updatedAt": "2022-10-24T18:35:17Z"
        },
        {
          "author": "xdfy",
          "authorAssociation": "NONE",
          "body": "Thanks @kixelated.\r\n\r\nFor \"default behavior\" (or endpoint-driven behavior), the endpoint can enable or improve relay behavior by placing certain metadata in HEADERS, and it appropriate for a class of relays (including CDN caches). All the endpoints need to know is that, probably, there are some relays on the path that can use certain metadata to provide a common type of service, similarly to what is done with HTTP caching metadata. Protocol versioning seems appropriate to add new metadata in this case.\r\n\r\nFor non-default (or more specialized) behavior, using (simple) extension negotiation enables driving endpoints decision to set, or not, metadata to obtain a service. For example, XR support in wireless networks is rather specialized. Without extension information, to make use of this feature, a server would have to set the necessary metadata on all streams, since in general any stream can be carried over a wireless access network. Exchanging extension information can tell the server whether or not this metadata is needed. \r\n\r\nA fully endpoint-driven behavior seems to align with the HTTP approach very well (which is the general philosophy you mentioned, I believe). We could always say, for example, that all XR clients/servers MOQ implementations will define their own default behavior, which is to send metadata that enables XR support through MOQ relays. On the other side, using extension negotiation clarifies interworking between network/relay and endpoints. For example, a client or server could detect early on that there is little chance that QoS will be acceptable, rather than try and get bad service. To conclude, I don't have a final argument here (between fully endpoint-driven or supporting both) and getting feedback from others in the community would be useful.",
          "createdAt": "2022-10-24T20:30:51Z",
          "updatedAt": "2022-10-24T21:46:02Z"
        },
        {
          "author": "xdfy",
          "authorAssociation": "NONE",
          "body": "Hi @kixelated, after thinking further about it, the distinction I proposed earlier is probably not needed. Even more specialized/niche relays like the one I mentioned for XR can use the HTTP-like model in your protocol design. I guess the idea is that the endpoint should, based on context (application type, server location, type of client device, etc.) determine the type of metadata that it should send to get the best service. It does not preclude the client or relay from giving a hint to the server, but that could be considered outside of the scope of the MOQ protocol (and, again, probably not needed in general).",
          "createdAt": "2022-10-26T14:22:05Z",
          "updatedAt": "2022-10-26T14:22:05Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "I_kwDOG2Ho4M5UtPpk",
      "title": "Init segments",
      "url": "https://github.com/moq-wg/moq-transport/issues/21",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "streaming format draft"
      ],
      "body": "HLS and DASH both have a concept of init segments when using fMP4. The init data could be prepended to each segment, but it's more efficient to transfer it once and have each segment reference it.\r\n\r\nThe current draft supports init segments via the `depends` property. At first glance this seems like an okay way to reuse the property, as it's probably needed for SVC and frame-based delivery. The use case is slightly different though, as init segments MUST be received in their entirety while SVC layers and frames need to be interleaved.\r\n\r\nThe two big issues that I see are:\r\n\r\n1. The ability to cache init segments for an undisclosed amount of time. It's not a lot of data so we could probably put a `cache: forever` field, but it needs to be a requirement.\r\n2. CMAF encoding is different. Init segments use ftyp/moov/mdat while other segments use styp/moof/mdat. It's not a huge deal but it does make it seem like init segments should be first class citizens in the draft, rather than something added on.",
      "createdAt": "2022-10-24T17:04:47Z",
      "updatedAt": "2023-08-07T21:33:11Z",
      "closedAt": "2023-08-07T21:33:11Z",
      "comments": [
        {
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "body": "init segments are going to create problems:\r\n\r\n- It introduces \"artificial\" dependency, so any decoder will have to receive them before they are able to decode any segment\r\n- if there is transcoder in the middle, they would need to be aware of \"init\" segment, which can be a problem when reconnect happens on ingestion side.\r\n- this doesn't support codec switch in the middle, at least not easily...",
          "createdAt": "2022-10-24T17:54:05Z",
          "updatedAt": "2022-10-24T17:54:05Z"
        },
        {
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "body": "What if we don't require init segments? And just require every \"Segment\" to have information needed for decoder, for h264, for example, have SPS/PPS, for audio segment, have AudioSpecificConfig for every audio segment",
          "createdAt": "2022-10-24T17:55:12Z",
          "updatedAt": "2022-10-24T17:55:12Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "HLS used to do that with TS segments, but moved to explicit init segments when MP4 support was added. The init segments are hundreds of bytes so they're not a huge deal but add up over the course of the entire stream.\r\n\r\nIn my opinion, there's not too much difference between init segments and I-frames. It's an explicit dependency between QUIC streams that introduces some head-of-line blocking. However the same head-of-line blocking is present if they are transferred over the same QUIC stream, or really any mode of transportation (ex. datagrams).",
          "createdAt": "2022-10-24T20:27:34Z",
          "updatedAt": "2022-10-24T20:27:58Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Thinking of it a bit more, typically in video calling the init information is sent as part of IDR frame and not separatly. Having then go together might be less error prone probably ?",
          "createdAt": "2022-11-09T18:22:13Z",
          "updatedAt": "2022-11-09T18:22:13Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm in favor of a separate track per init segment, matching HLS/DASH. Either way this is no longer part of the transport draft.",
          "createdAt": "2023-08-07T21:33:11Z",
          "updatedAt": "2023-08-07T21:33:11Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "I_kwDOG2Ho4M5UtbaQ",
      "title": "Should we specify in-order delivery within segment?",
      "url": "https://github.com/moq-wg/moq-transport/issues/22",
      "state": "CLOSED",
      "author": "kpugin",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "> Note that the contents within each segment are still delivered in order; this delivery order only applies to the ordering between segments.\r\n\r\nAre we creating head of line blocking in proxies here? For fmp4 segments without B-frames, we should allow dropping \"tail\" of the segment.",
      "createdAt": "2022-10-24T17:47:53Z",
      "updatedAt": "2022-10-24T21:35:05Z",
      "closedAt": "2022-10-24T21:35:05Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "From RFC 9000 regarding stream APIs:\r\n\r\n```\r\n   Endpoints MUST be able to deliver stream data to an application as an\r\n   ordered byte stream.  Delivering an ordered byte stream requires that\r\n   an endpoint buffer any data that is received out of order, up to the\r\n   advertised flow control limit.\r\n\r\n   QUIC makes no specific allowances for delivery of stream data out of\r\n   order.  However, implementations MAY choose to offer the ability to\r\n   deliver data out of order to a receiving application.\r\n```\r\n\r\nWe should not prevent relays from forwarding segment data out of order, if they are so capable.",
          "createdAt": "2022-10-24T18:03:25Z",
          "updatedAt": "2022-10-24T18:03:25Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, I like the QUIC wording, but we should point out that proxies can introduce latency unless they deliver data out of order.",
          "createdAt": "2022-10-24T19:42:41Z",
          "updatedAt": "2022-10-24T19:42:41Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "I_kwDOG2Ho4M5UtiTq",
      "title": "Protocol name :D",
      "url": "https://github.com/moq-wg/moq-transport/issues/23",
      "state": "CLOSED",
      "author": "kpugin",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Have we settled on Warp as a name for protocol? Or should we use RUSH as we discussed on one of the calls?",
      "createdAt": "2022-10-24T18:11:04Z",
      "updatedAt": "2023-04-21T21:46:27Z",
      "closedAt": "2023-04-21T21:46:27Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "SHWARP",
          "createdAt": "2022-10-24T18:17:30Z",
          "updatedAt": "2022-10-24T18:52:29Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Dunno, naming is hard.\r\n\r\nI was keeping it as Warp until the RUSH folks approved the base draft but maybe we see what the WG thinks. Both RUSH and WARP are four letter fake acronyms with a speedy context (like QUIC), so I like both of them. \r\n\r\nThe upside of Warp is that it describes the intended user behavior. Video will freeze/stutter until it \"warps\" forward to the next i-frame. The downside is that it's a common name. It should be capitalized like WARP at the very least.\r\n\r\nTechnically RUSH stands for  `Reliable (unreliable) streaming protocol`... although that would be \"RUSP\" so we'll have to fix that anyway.",
          "createdAt": "2022-10-24T18:48:14Z",
          "updatedAt": "2022-10-24T18:48:33Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "The H was originally for \"over HTTP\"",
          "createdAt": "2022-10-24T18:53:19Z",
          "updatedAt": "2022-10-24T18:53:19Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "not to say, quic, quicr, quicst ;) ..doesn;t matter , we can come with any name and it should do ",
          "createdAt": "2022-10-24T19:52:04Z",
          "updatedAt": "2022-10-24T19:53:08Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "The name we pick could very likely be replaced with \"moq\" anyways.  See what happened with QCRAM -> QPACK.",
          "createdAt": "2022-10-24T20:28:14Z",
          "updatedAt": "2022-10-24T20:28:14Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "How about WASH?",
          "createdAt": "2022-10-27T20:40:38Z",
          "updatedAt": "2022-10-27T20:40:38Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "how about CIUQ ( sounds very similar to QUIC) !!!",
          "createdAt": "2022-11-12T12:14:49Z",
          "updatedAt": "2022-11-12T12:14:49Z"
        },
        {
          "author": "maxstoller",
          "authorAssociation": "NONE",
          "body": "@kixelated \r\n> It should be capitalized like WARP at the very least.\r\n\r\nWhat is the thought behind all caps if it is not an acronym like RUSH?\r\n",
          "createdAt": "2022-11-16T20:58:06Z",
          "updatedAt": "2023-02-07T19:31:09Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> @kixelated\r\n> \r\n> > It should be capitalized like WARP at the very least.\r\n> \r\n> What is the though behind all caps if it is not an acronym like RUSH?\r\n\r\nIETF likes acronyms... even if they don't actually stand for anything. (ex. QUIC)",
          "createdAt": "2022-11-16T22:10:44Z",
          "updatedAt": "2022-11-16T22:10:53Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "FAST - **F**ast **AS**ynchronous media **T**ransport  :-) ",
          "createdAt": "2022-12-06T00:22:21Z",
          "updatedAt": "2022-12-06T00:22:21Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed on authors call: recommendation was moq-transport",
          "createdAt": "2023-04-21T19:40:38Z",
          "updatedAt": "2023-04-21T19:40:38Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Now tracked in #142 ",
          "createdAt": "2023-04-21T21:46:27Z",
          "updatedAt": "2023-04-21T21:46:27Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "I_kwDOG2Ho4M5UtlNv",
      "title": "Termination",
      "url": "https://github.com/moq-wg/moq-transport/issues/24",
      "state": "CLOSED",
      "author": "kpugin",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "> The QUIC connection can be terminated at any point with an error code.\r\n\r\nHm... this will prevent multiplexing, which I think would be pretty important on delivery side",
      "createdAt": "2022-10-24T18:21:20Z",
      "updatedAt": "2024-02-20T02:21:18Z",
      "closedAt": "2024-02-20T02:21:17Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah this is an excellent point.  I assume we want to support more than one different video on the same QUIC connection?  Do we do that with different WebTransport sessions per video, or is there a video grouping within the WT session.  If it's the latter, there needs to be a way to terminate only one of the videos but not all of them.",
          "createdAt": "2022-10-24T18:52:11Z",
          "updatedAt": "2022-10-24T18:52:11Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "WebTransport technically has the ability to pool multiple sessions over a single QUIC connection, although I'm not sure that will get much traction.\r\n\r\nWhat about an explicit TRACK_END frame like RUSH? We could still send CONNECTION_CLOSE for fatal errors.",
          "createdAt": "2022-10-24T19:05:08Z",
          "updatedAt": "2022-10-24T19:05:08Z"
        },
        {
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "body": "I know that for our use-cases, while ingestion may not need to be multiplex, for distribution - it pretty much must have.\r\nSo I think we should avoid touching QUIC connection - terminating it should be responsibility of QUIC endpoints, for MOQ we should have a way to terminate MOQ \"session\" whatever that is, in pull world - that would be \"moq request\", for PUSH - we going to need to identify that \"push\" session",
          "createdAt": "2022-10-28T15:49:03Z",
          "updatedAt": "2022-10-28T15:49:03Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 to having multiplexing. We can have per stream way to finish or terminate and need a way to identify that as part of MoQ WebTransport Session",
          "createdAt": "2022-11-09T18:27:31Z",
          "updatedAt": "2022-11-09T18:27:31Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe this is OBE.",
          "createdAt": "2024-02-20T02:21:17Z",
          "updatedAt": "2024-02-20T02:21:17Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "I_kwDOG2Ho4M5Utp2X",
      "title": "Discuss possible flow-control deadlocks",
      "url": "https://github.com/moq-wg/moq-transport/issues/25",
      "state": "CLOSED",
      "author": "afrind",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Any time you have inter-stream dependencies you create the possibility of deadlock if the encoder doesn't ensure that flow control is consumed in dependency order, and/or if the decoder withholds the release of flow control until all dependencies are resolved.  Add some advisory text to this effect.",
      "createdAt": "2022-10-24T18:36:18Z",
      "updatedAt": "2022-10-24T21:35:05Z",
      "closedAt": "2022-10-24T21:35:05Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Hmm, yeah that's unfortunate.\r\n\r\nI was thinking there should be an entire section on dependencies, just like there's a section on delivery order. The advisory would make sense in there.",
          "createdAt": "2022-10-24T19:59:52Z",
          "updatedAt": "2022-10-24T19:59:52Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "I_kwDOG2Ho4M5UttW9",
      "title": "Cancellation",
      "url": "https://github.com/moq-wg/moq-transport/issues/26",
      "state": "CLOSED",
      "author": "afrind",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "> QUIC streams can be canceled by either endpoint with an error code.\r\n\r\nThis isn't really true.  QUIC streams can be canceled only by the sender.  A receiver can request that a stream be reset.  To that end, I'm not sure how much value sending an `expires` value is, other than to inform the receiver that the sender plans to reset the stream if it's not completely sent and ack'd by then.  Should the receiver send a STOP_SENDING after expires to request a reset also or is that redundant?",
      "createdAt": "2022-10-24T18:48:00Z",
      "updatedAt": "2022-10-24T21:35:04Z",
      "closedAt": "2022-10-24T21:35:04Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I can change the language around STOP_SENDING. You're right that it technically doesn't cancel the stream... although it does in effect.\r\n\r\nThe previous version of the draft had an `expires` and `cache` field in the HEADERS. The intent was to inform the relay on how long a stream should be held in memory before it was dropped and reset.\r\n\r\nThe original idea is that the broadcaster and/or consumer would be responsible for knowing when a stream is no longer desired. This would involve sending a RESET_STREAM or STOP_SENDING respectively. However this breaks down when relays are involved, as they lack this information. For example, a broadcaster could transfer a stream in its entirety to a relay, which then keeps it buffered in memory, but doesn't know when to issue a RESET_STREAM to any consumers.\r\n\r\nBut I removed it from the draft because I'm not really sure how to deal with timestamps. Sending a duration on the wire is problematic because it only starts counting down when the first stream chunk has been received and processed. This is exacerbated by `order` since it can starve streams. This is not so much a problem for `cache` but it's a huge issue for `expires`, if the intention is to reset streams in response to congestion.",
          "createdAt": "2022-10-24T19:01:48Z",
          "updatedAt": "2022-10-24T19:01:48Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "I_kwDOG2Ho4M5Ut0A-",
      "title": "Issues with order",
      "url": "https://github.com/moq-wg/moq-transport/issues/27",
      "state": "CLOSED",
      "author": "afrind",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "> order. An numeric value indicating the delivery order ([Section 3.2](https://kixelated.github.io/warp-draft/draft-lcurley-warp.html#delivery-order)). A sender SHOULD transmit streams with smallest value first, as bandwidth permits. If two streams use the same value, they SHOULD be round-robined. Note that streams can still arrive out of the intended order due to packet loss. This field is optional and the default value is 0.\r\n\r\nCan we simply require that order be unique?  I'm thinking that having a sequential queue based on `order` that converts to a round-robin queue when it encounters multiple entries is a pain to implement.\r\n\r\nAlso, is 0 the right default?  Untagged segments get highest priority?",
      "createdAt": "2022-10-24T19:11:04Z",
      "updatedAt": "2023-05-26T23:49:18Z",
      "closedAt": "2023-05-26T23:49:18Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, so here's my use-case:\r\n\r\nIf audio has a smaller order than video, then we could spend all bandwidth downloading 10s of audio and 0s of video. If audio and video have the same order, then we would instead download something like 5s of audio and 2s of video, depending on the relative file size difference.\r\n\r\nThere's probably a better solution but I want to avoid making prioritization too complex (ex. HTTP/2). It's not too difficult to implement round-robin; basically after sending a stream you keep swapping it with the next stream if they have the same order value.\r\n\r\nAs for 0 being the default, the intention was to allow negative values. My code uses `-math.MaxInt` for control messages...",
          "createdAt": "2022-10-24T19:26:22Z",
          "updatedAt": "2022-10-24T19:26:22Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I think negative values might be bad.  Just reserve 0 for control messages?\r\n\r\nI am not a video experience expert, but what happens if the audio and video segments have roughly the same timestamps and the audio stream get higher priority than video?",
          "createdAt": "2022-10-24T20:26:54Z",
          "updatedAt": "2022-10-24T20:26:54Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "The production version of Warp uses the sequence number instead of the PTS so they would be equal. This draft doesn't have a concept of sequence numbers since there's no requirement that audio/video segments be aligned. It certainly makes it more difficult to use the same delivery order between audio/video when they're not aligned.",
          "createdAt": "2022-10-24T21:37:10Z",
          "updatedAt": "2022-10-24T21:37:39Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Going to close this out.  There's more work to do with priority and that's reflected in the draft.",
          "createdAt": "2023-05-26T23:49:18Z",
          "updatedAt": "2023-05-26T23:49:18Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "I_kwDOG2Ho4M5Ut3WY",
      "title": "APP message",
      "url": "https://github.com/moq-wg/moq-transport/issues/28",
      "state": "CLOSED",
      "author": "afrind",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This sounds a bit like an extension that just gets forwarded when not understood by a relay?  How does APP interact with caches, for example?  Can a single QUIC stream have SEGMENT and APP data interleaved?\r\n\r\nMight be too vague to leave in",
      "createdAt": "2022-10-24T19:21:16Z",
      "updatedAt": "2022-11-18T20:29:51Z",
      "closedAt": "2022-11-18T20:29:51Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "The intention was to cache/forward it the same way as media. It's just meant for arbitrary metadata and as a replacement for the current approach of shoving metadata into the media bitstream. For example, in h.264 land it's common to put arbitrary content (non-standardized) in SEI messages.\r\n\r\nEven if we don't cache/forward the stream, it would still be nice to let the application use unidirectional streams. This basically says prefix the stream with a 2 if it's used by the application instead of Warp. This wouldn't work with relays which is why I had the idea of reusing HEADERS to tell the relay which application streams should be forwarded/cached and how.",
          "createdAt": "2022-10-24T19:37:28Z",
          "updatedAt": "2022-10-24T19:37:28Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh and it's missing because there's no encoding yet, but I was envisioning that SEGMENT and APP frames do not specify a length. They would consume the remainder of the stream so there's no way to use them in conjunction.",
          "createdAt": "2022-10-24T19:39:03Z",
          "updatedAt": "2022-10-24T19:39:19Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Is there an MP4 box that we can just use as a part of the layer?  That would provide some form of uniformity.",
          "createdAt": "2022-11-09T20:03:16Z",
          "updatedAt": "2022-11-09T20:03:16Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> Is there an MP4 box that we can just use as a part of the layer? That would provide some form of uniformity.\r\n\r\nThat was my thought too, although it means every container will need some way of specifying application data. MP4 atoms require a length up-front so they would be limited to messages instead of unbounded streams.",
          "createdAt": "2022-11-11T10:59:36Z",
          "updatedAt": "2022-11-11T11:00:13Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "the RTCP APP message never turned out to be as useful in RTP as people thought it would be ...  that said, fan of being able to send whatever data in the payload. If it happens to be a protobuf app message instead of media, seem like MOQ shoudl not care, it should just deliver the bytes with not much care if they are audio, vidie, haptics, or an app custom media ",
          "createdAt": "2022-11-12T12:17:13Z",
          "updatedAt": "2022-11-12T12:17:13Z"
        },
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "We need to define the difference of APP message and Media data in terms of what is inside and how it is interacted with caching and dropping. Otherwise there is a risk that the APP message becomes the container for \u201cwhatever does not fit in the current RFC\u201c  which renders the standard useless.",
          "createdAt": "2022-11-12T21:50:50Z",
          "updatedAt": "2022-11-12T21:50:50Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "I_kwDOG2Ho4M5Ut338",
      "title": "GOAWAY stream",
      "url": "https://github.com/moq-wg/moq-transport/issues/29",
      "state": "CLOSED",
      "author": "afrind",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "What stream does the GOAWAY get sent on?\r\n\r\nCan producers send GOAWAY or only consumers?",
      "createdAt": "2022-10-24T19:22:25Z",
      "updatedAt": "2023-10-11T18:26:02Z",
      "closedAt": "2023-10-11T18:26:01Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Also what does this mean:\r\n\r\n> A server MAY use QUIC load balancing instead of a GOAWAY message.",
          "createdAt": "2022-10-24T19:22:59Z",
          "updatedAt": "2022-10-24T19:22:59Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Good questions.\r\n\r\nRight now there's no distinction between control streams and segment streams. In theory the GOAWAY could be sent on any stream. I'm not sure if this is the right behavior. See #31 \r\n\r\nOnly servers can send GOAWAY since the client must issue the WebTransport CONNECT. It doesn't matter if the server is a producer or consumer.\r\n\r\nI'll remove that blurb about QUIC load balancing. I was trying to be clever and say that the server can hijack a QUIC connection but that's really not needed in the draft.",
          "createdAt": "2022-10-24T19:30:34Z",
          "updatedAt": "2022-11-11T10:56:48Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Did not mean to close this.",
          "createdAt": "2022-10-24T22:19:27Z",
          "updatedAt": "2022-10-24T22:19:27Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the idea of control stream with GOAWAY message will be useful design here",
          "createdAt": "2022-11-09T18:12:32Z",
          "updatedAt": "2022-11-09T18:12:32Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "The direction is for a single control stream, so GOAWAY will be there.  There's a separate PR defining GOAWAY, which may or may not address the \"Can producers send GOAWAY or only consumers?\".  Closing this for now.\r\n\r\n",
          "createdAt": "2023-10-11T18:26:01Z",
          "updatedAt": "2023-10-11T18:26:01Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "I_kwDOG2Ho4M5Ut_8J",
      "title": "PADDING vs PING",
      "url": "https://github.com/moq-wg/moq-transport/issues/30",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "> Senders MAY periodically pad the connection with QUIC PING frames to fill the congestion window.\r\n\r\nI didn't want to go into more detail, but PADDING frames can cause deadlocks due to the fact they are congestion controlled but do not elicit an acknowledgement. They also don't test the if the network could support the higher acknowledgement frequency potentially caused by a higher bitrate.\r\n\r\nShould we remove this line, explain it in more detail, or leave as is?",
      "createdAt": "2022-10-24T19:45:48Z",
      "updatedAt": "2023-08-07T21:32:08Z",
      "closedAt": "2023-08-07T21:32:08Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "I found this line stuck out on my first reading.\r\n\r\nIf you need to fill a congestion window and need to elicit an ack, why not suggest many PADDING and one PING? Or if you don't want tocmake a concrete recommendation, explain the problems and provide non-exhaustive examples how somebody could avoid them.",
          "createdAt": "2022-10-27T20:48:36Z",
          "updatedAt": "2022-10-27T20:48:36Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe many PADDING packets followed one PING packet would still still have issues if the PING packet is lost. It wouldn't fully deadlock, but it would rely on the PTO timer to eventually retransmit the PING packet, finally elliciting an acknowledgement, and freeing up the congestion window held by the PADDING packets.\r\n\r\nYou could interleave more frequent PING packets to reduce the chance of random loss causing a stall, but you might as well send only PING packets then.",
          "createdAt": "2022-10-27T21:25:15Z",
          "updatedAt": "2022-10-27T21:25:33Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "To put things another way, sending a packet that is MTU sized and filled with 1000+ PING frames sounds weird. In H2 there are DoS vectors related to PING frame processing. I know QUIC is different but this normative recommendation sticks out.\r\n\r\nWhat is different if an endpoint sends several QUIC packets, each composed of many PADDING frames and a single PING frame?\r\n\r\nTo put things another way, sending a packet with ",
          "createdAt": "2022-10-27T21:39:17Z",
          "updatedAt": "2022-10-27T21:39:17Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh, my QUIC library just coalesces any consecutive PING frames as a single frame, likewise for PADDING. I suppose that's less obvious to implement.\r\n\r\nHow about changing the language to:\r\n> Senders MAY pad the connection with congestion controlled, ack-eliciting packets to periodically become network-limited.",
          "createdAt": "2022-10-27T23:11:44Z",
          "updatedAt": "2022-10-27T23:11:44Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "It's more inclusive as well because another approach would be to speculatively retransmit STREAM frames, potentially adding PADDING if needed.\r\n\r\nValid packets:\r\nSTREAM + PADDING\r\nPING + PADDING\r\nPING\r\n\r\nInvalid packets:\r\nPADDING",
          "createdAt": "2022-10-27T23:13:41Z",
          "updatedAt": "2022-10-27T23:14:39Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "This might be down to my reading of what \"fill the congestion window\" means. If it's read like \"fill the pipe with bytes in flight\" sending only one PING in a packet doesn't sound right?\r\n\r\nI still might be off track here but it seems like we can avoid saying \"MAY pad the connection  \" - QUIC already let's endpoints do that and no point restating things defined elsewhere. So perhaps more like\r\n\r\n> senders might find it beneficial to avoid becoming application limited. One strategy for doing this is by padding the connection with congestion-controlled, ack-eliciting packets.",
          "createdAt": "2022-10-28T00:02:34Z",
          "updatedAt": "2022-10-28T00:02:34Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "That sounds good to me. Plus \"filling the congestion window\" doesn't even make sense for paced CC algorithms.",
          "createdAt": "2022-10-28T00:08:00Z",
          "updatedAt": "2022-10-28T00:08:00Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "I wonder if we need to go in detail on how the QUIC library does react is needed at all ? This is an implementation detail and can be just an informal note if needed",
          "createdAt": "2022-11-09T18:14:14Z",
          "updatedAt": "2022-11-09T18:14:14Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "My intention is an informal note on congestion control in general, since it's very important but implementation specific. I'm not sure the best way to do that.",
          "createdAt": "2022-11-11T10:56:07Z",
          "updatedAt": "2022-11-11T10:56:07Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think it's worth it to mention the need for some sort of padding in the draft.\r\n\r\nI would be comfortable with a recommendation of sending PING + PADDING packets.",
          "createdAt": "2023-01-30T20:30:04Z",
          "updatedAt": "2023-01-30T20:30:04Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "This section got deleted in the most recent version.  @kixelated : should we close it out?  Open a new issue to track adding these kind of performance considerations back in?",
          "createdAt": "2023-05-26T23:48:35Z",
          "updatedAt": "2023-05-26T23:48:35Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think we need this text. It's more of a best practice and tied very closely to congestion control.\r\n\r\nI think live media is difficult enough that we could have have an entire document surrounding congestion control mechanisms to minimize latency. Or we can leave it undefined and let implementors figure it out.",
          "createdAt": "2023-08-07T21:31:51Z",
          "updatedAt": "2023-08-07T21:32:05Z"
        }
      ]
    },
    {
      "number": 31,
      "id": "I_kwDOG2Ho4M5UuA_a",
      "title": "Control streams",
      "url": "https://github.com/moq-wg/moq-transport/issues/31",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "ianswett"
      ],
      "labels": [
        "Control Streams"
      ],
      "body": "As mentioned in #29, there's currently no distinction between control streams and media streams.\r\n\r\nShould we have dedicated control streams? When should these be cached or forwarded by relays?\r\n\r\nFor example, GOAWAY must NOT be forwarded by a relay, but something like TRACK (does not exist yet) should be forwarded.",
      "createdAt": "2022-10-24T19:49:42Z",
      "updatedAt": "2023-10-16T17:19:06Z",
      "closedAt": "2023-10-16T17:19:06Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "This sounds like something worth thinking on and capturing more about in the spec.",
          "createdAt": "2022-10-27T20:50:33Z",
          "updatedAt": "2022-10-27T20:50:33Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "QuicR supports control streams and media streams.\r\nControl Stream is for setup and other control features\r\nMedia Streams for delivery media - today it supports QUIC Streams or QUIC Datagrams. \r\n\r\nMore details can be seen here : https://www.ietf.org/id/draft-jennings-moq-quicr-proto-01.html#name-quicr-protocol-design. This keeps protocol design cleanly separated and also extensible\r\n",
          "createdAt": "2022-11-09T18:09:25Z",
          "updatedAt": "2022-11-09T18:11:27Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed today, there was interest in separating today's control messages from media/object streams, but not yet interest in constraining a MoQ session to a single control stream.  Per track and per namespace were both mentioned as reasonable scopes, as well as 1 per session.\r\n\r\nThere were follow-up questions about Setup messages and version negotiation and how you know which version is in use.",
          "createdAt": "2023-08-07T17:39:01Z",
          "updatedAt": "2023-08-07T17:39:01Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "One conclusion from the chat is that QUIC streams MUST NOT contain messages with different priorities. Otherwise, a QUIC library would need the ability to reprioritize a stream at a given byte offset. If control messages are always higher priority than data messages (debated), then separate streams are required.\r\n\r\nI also mentioned that in my implementation, separate threads process control and data messages separately. Data streams are immediately sent to a media decoder thread (WebWorker) while control streams stay in the main thread. This architecture is nice but breaks if control messages and data messages can be interleaved.\r\n\r\n---\r\n\r\nI think we were in pretty good alignment that there should be control streams. The primary discussion surrounds the scope and number of control streams.\r\n\r\n1. control stream per track.\r\n2. control stream per track namespace.\r\n3. control stream per session.\r\n\r\nI don't think option 1 is viable for ABR, as you want to coalesce the UNSUBSCRIBE / SUBSCRIBE for separate tracks. For example, (near) simultaneously unsubscribe to 480p and subscribe to 720p. If the tracks are truly independent and can not tolerate head-of-line blocking, perhaps they should use a separate namespace instead?\r\n\r\nI think option 2 is acceptable. The goal is to avoid introducing head-of-line blocking for thousands of unrelated track namespaces, but I think this bleeds into the infamous pooling discussion. If pooling is accomplished via multiple sessions like WebTransport, then option 3 also accomplishes that goal.\r\n\r\nI'm currently using option 3 since it makes the SETUP marginally handshake easier. Control messages are written immediately after the SETUP message, avoiding the need to buffer messages pending the handshake. It also means you can coordinate subscriptions when tracks are NOT within the same track namespace (ex. ABR across different producers).",
          "createdAt": "2023-08-07T20:48:58Z",
          "updatedAt": "2023-08-07T20:49:39Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Okay so I can't help but start a tiny bit of the POOLING discussion.\r\n\r\nMy application uses Warp for media and Alan's protocol for chat. Let's assume that I want to use the same QUIC connection for both for efficiency reasons. I would like to design my application into two halves, so one part of the code deals with chat and one part deals with media. I don't want a situation where I have to pass control and data messages between threads. \r\n\r\nIt would be really nice if there were two control streams: one to control the chat protocol and one to control the media protocol. This would also be nice for the CDN, as each control streams could be routed to a separate backend/origin. A fatal error (RESET_STREAM) on the chat control stream would not impact the media control stream and vice-versa.\r\n\r\nHowever, this doesn't quite work right now because the can be `track_id` collisions. The chat and media system would need to coordinate to avoid collisions, otherwise IDs need to be rewritten. Any incoming data streams need to be forwarded to the correct component based on this rewrite lookup table.\r\n\r\nOne way to fix this is to extend all messages to include a `session_id`, where 0=media and 1=chat in this example. Each control stream gets its own ID and OBJECTs would include the ID, avoiding collisions and making it very easy to route within the application and CDN.\r\n\r\n(this is basically WebTransport session pooling)\r\n\r\nIn fact, now each session could even use a different version of MoQ. This would be super useful when the chat and media backends are running different versions of the protocol. It's why I suggested at the end of the call (@vasilvv) that each control stream contains it's own SETUP handshake.",
          "createdAt": "2023-08-07T21:05:07Z",
          "updatedAt": "2023-08-07T21:05:58Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual comment:\r\n\r\n> One conclusion from the chat is that QUIC streams MUST NOT contain messages with different priorities\r\n\r\nDo you mean the \"sendOrder\" field in OBJECT (section 6.2), or something else?  \r\n\r\nI'm not sure normative language is required here, especially if it's based on what current QUIC implementations supports as a prioritization API.  Someday a QUIC implementation could support changing priorities at different offsets for a stream.\r\n\r\nAs for pooling - WebTransport has taught us that pooling is a huge headache.  I suggest we defer to WebTransport or open multiple QUIC connections rather than trying to define yet another pooling layer in moqt.",
          "createdAt": "2023-08-07T22:50:55Z",
          "updatedAt": "2023-08-07T22:50:55Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": ">  Someday a QUIC implementation could support changing priorities at different offsets for a stream.\r\n\r\nI have a draft in the works to  support doing this for HTTP/3, so it's not far off in my world",
          "createdAt": "2023-08-07T22:57:06Z",
          "updatedAt": "2023-08-07T22:57:06Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> Individual comment:\r\n> \r\n> > One conclusion from the chat is that QUIC streams MUST NOT contain messages with different priorities\r\n> \r\n> Do you mean the \"sendOrder\" field in OBJECT (section 6.2), or something else?\r\n> \r\n> I'm not sure normative language is required here, especially if it's based on what current QUIC implementations supports as a prioritization API. Someday a QUIC implementation could support changing priorities at different offsets for a stream.\r\n\r\nWell, I kinda think the normative language is justified when priority schemes are written on the wire. You're totally right that an implementation could prioritize at byte offsets... but that doesn't mean a relay can support it.\r\n\r\nUgh, I guess we need to discuss if prioritization schemes are negotiated or not. My goal was to require a base scheme (send order) in the transport draft so we could just assume that every MoQ relay will support it, and thus normative language like this is fine. But you're right, new prioritization schemes will absolutely come along and maybe send order should be a guinea pig.\r\n\r\nSo maybe: if the `extension_send_order` is negotiated, then messages on the same stream MUST use the same `send_order` value. I believe the same is true for @huitema's prioritization scheme.\r\n\r\nEither way, point taken and it was a bad argument on my part, and barely even related to the topic of control streams.\r\n\r\n> > Someday a QUIC implementation could support changing priorities at different offsets for a stream.\r\n> \r\n> I have a draft in the works to support doing this for HTTP/3, so it's not far off in my world\r\n\r\nGross but point taken. I assume the priority can only decrease?",
          "createdAt": "2023-08-08T00:09:42Z",
          "updatedAt": "2023-08-08T00:09:42Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "> Gross but point taken. I assume the priority can only decrease?\r\n\r\nThe design doesn't currently implement that constraint, the reason being that an application using HTTP might have a need to increase the priority of some bytes relative to other streams. ",
          "createdAt": "2023-08-08T00:19:34Z",
          "updatedAt": "2023-08-08T00:20:03Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Going back to the topic of control streams, we need to support both  the following\r\n1. Control stream per track namespace\r\n2. One Control stream for the session - (for setup, termination)\r\n\r\nAlso i feel the transport draft should have the text for it as well to explain what happens when a control stream for a track namespace is created or reset and how are they related to the data streams carrying the objects.",
          "createdAt": "2023-08-08T05:16:48Z",
          "updatedAt": "2023-08-08T05:16:48Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@kixelated mentioned my priority scheme. On the prioritization scheme, my personal thinking evolved as I was studying implementations and consequences. For a while, I did believe that layered encodings would be better implemented by having a single track for the whole media, and having for each object priority fields of some kind indicating the relative urgency of the object. I think now that I was wrong, because it leads to a complex mapping that makes relaying harder, and also because the exact semantic of the \"priority field\" is too complex to specify in a base protocol.\r\n\r\nThe transport mappings get much simpler if all objects in a track are treated with the same precedence -- at least within a group. We may debate whether the next group should ever take precedence over the previous one, or never, or only some times. This simplification does force layered encodings to use separate tracks for each layer, and to explain the relation between the tracks as part of the application data. Which amounts to pushing complexity out of the transport and back into the application, which I think is a better tradeoff.\r\n\r\nThe tradeoff also simplifies the tasks of the control stream, because it only has to manage precedence between streams, not precedence between objects.\r\n",
          "createdAt": "2023-08-10T15:00:21Z",
          "updatedAt": "2023-08-10T15:00:21Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Should be fixed with the PR that fixes #138 ",
          "createdAt": "2023-10-09T16:25:51Z",
          "updatedAt": "2023-10-09T16:25:51Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "I_kwDOG2Ho4M5VjFH2",
      "title": "GOAWAY seems overly restrictive",
      "url": "https://github.com/moq-wg/moq-transport/issues/32",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The general motivation here isn't bad but mandating client behaviours in response to these types of messages seems a bit like overreach. The requirements also more restrictive than H2 or H3 GOAWAY, which are on theory also available as a capability in the same connection. \r\n\r\nRephrasing the text can probably hit the notes you want with respect to preserving service continuity, without painting people into corners.\r\n\r\n",
      "createdAt": "2022-11-03T21:07:51Z",
      "updatedAt": "2023-10-19T02:49:05Z",
      "closedAt": "2023-10-19T02:49:05Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Sure, I agree.",
          "createdAt": "2022-11-11T10:53:40Z",
          "updatedAt": "2022-11-11T10:53:40Z"
        },
        {
          "author": "jordicenzano",
          "authorAssociation": "NONE",
          "body": "> The endpoint successfully drained the session after a GOAWAY was initiated (Section 6.9).\r\n\r\nThis seems confusing. Do you mean:  The server endpoint is asking the client to terminate the session and reconnect as soon as possible because it wants to drain / shutdown",
          "createdAt": "2023-06-03T22:01:24Z",
          "updatedAt": "2023-06-03T22:01:24Z"
        },
        {
          "author": "jordicenzano",
          "authorAssociation": "NONE",
          "body": "> SHOULD remain connected on both connections for a short period\r\n\r\nI think this has bad implications from the end user:\r\n        - The client (receiver of GOAWAY) needs to keep 2 connections (more complexity)\r\n        - It will double the BW required for that connection during some period of time (that could be a big problem causing quality issues)\r\n\r\nWhat about something like: \r\n**Ingest usecase:**\r\n   - The client (publisher) will ensure to not create gaps (data loss) between connections for all the tracks, making sure the switch will be done at group boundaries for all tracks.\r\n      - So if last object sent for track 1, group 1 is N (last in the group 1) for connection 1,\r\n      - Then,  the 1st object sent in connection 2 for track 1, will be: group 2 object 0\r\n  - Optionally, the client can keep 2 connections open and the server side should implement dedupe\r\n  \r\n  **delivery usecase:**\r\n   - The client (player) could:\r\n      - Make sure it can survive to a GAP (data loss), then do nothing that is the easiest thing to do\r\n      - On the new subscription message send a parameter that indicates the last objects received (but that breaks the assumption of always sending live edge, adds a lot of complexity)\r\n",
          "createdAt": "2023-06-03T22:04:29Z",
          "updatedAt": "2023-06-03T22:11:55Z"
        }
      ]
    },
    {
      "number": 33,
      "id": "I_kwDOG2Ho4M5V-oM6",
      "title": "Role of CMAF",
      "url": "https://github.com/moq-wg/moq-transport/issues/33",
      "state": "CLOSED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "There is no actual description of how to use CMAF in the document, but the current text suggests that it will use CMAF.\r\n\r\nThe charter says \"The proposed solution will provide extensibility for supporting different media formats and will support multiple media types and media encodings.\", which to me suggests that we basically have to support alternatives to CMAF even if CMAF is the MTI thing we define at first.  I suspect that if we define the boundary between what the protocol does and what CMAF does correctly, this will solve the problem by itself.",
      "createdAt": "2022-11-09T17:29:36Z",
      "updatedAt": "2023-04-28T18:01:16Z",
      "closedAt": "2023-04-28T18:01:16Z",
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 to @vasilvv \r\n\r\nI think it would be good to say what are the things we need to describe and then have subsections on how they map to different container formats.\r\n\r\nMay be start with CMAF and Raw QUIC  to cover most of the use-cases. ",
          "createdAt": "2022-11-09T17:51:28Z",
          "updatedAt": "2022-11-09T18:10:57Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah I added CMAF right before the draft deadline. In hind-sight it wasn't necessary and needs more specification.",
          "createdAt": "2022-11-11T10:53:12Z",
          "updatedAt": "2022-11-11T10:53:12Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I need to actually read the full CMAF spec, but terminology for reference:\r\n\r\n- CMAF Header: Headers contain information that includes information for initializing a track.\r\n- CMAF Segment: A sequence of one or more consecutive fragments from the same track.\r\n- CMAF Chunk: A chunk contains a sequential subset of samples from a fragment.\r\n- CMAF Track File: A complete track in one ISO_BMFF file.\r\n\r\nThere's discussion (#21) on if the CMAF Header should be sent as a separate stream. I think \"Warp Segments\" are a superset of CMAF Chunks, since they don't need to be sequential (but do need to be ordered). We either need to change that, or mention that Warp is backwards compatible with CMAF, but not equivalent.",
          "createdAt": "2022-11-11T11:10:08Z",
          "updatedAt": "2022-11-11T11:10:31Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Seems clear to me that we will need to allow CMAF to be used but I think we will also end up with things like audio only applications (thing clouhouse) where the overhead of CMAF would be very high and they will want to be able to use RTP style media types instead. I'd put a strong bet that when the dust settles we will need support for both CMAF and RTP style container and possibly extensibility for others. Probably not much to this other than some enum that indicates what container type is in the payloads.  ",
          "createdAt": "2022-11-12T12:13:13Z",
          "updatedAt": "2022-11-12T12:13:13Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, a raw container does seem necessary at some point. At a minimum we need DTS and PTS for each frame.\r\n\r\nAnecdotally, here's the statistics for 2 channels of AAC audio encoded at 128 Kb/s @ 44.1KHz and fragmented at \"frame\" boundaries (23ms):\r\n\r\n```\r\ninit segment:   765 bytes\r\nsegment header: 24 bytes\r\nframe header:   100 bytes\r\nframe payload:  350-400 bytes\r\n```\r\n\r\nIt's not as bad as I thought but it could definitely be improved. The fragmentation can be done at a configurable frequency to reduce the overhead but increase the latency.",
          "createdAt": "2022-11-14T18:35:43Z",
          "updatedAt": "2022-11-14T18:38:55Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Has this moved out of the base protocol and into the media-format spec or do we need to leave this open.",
          "createdAt": "2023-04-21T19:41:57Z",
          "updatedAt": "2023-04-21T19:41:57Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "We can close this.",
          "createdAt": "2023-04-28T18:01:16Z",
          "updatedAt": "2023-04-28T18:01:16Z"
        }
      ]
    },
    {
      "number": 34,
      "id": "I_kwDOG2Ho4M5V-rmP",
      "title": "Timestamps and metadata redundancy",
      "url": "https://github.com/moq-wg/moq-transport/issues/34",
      "state": "OPEN",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "NotTransport"
      ],
      "body": "The draft currently defines a timestamp layer property that's the min-PTS of the bitstream in the layer.  I find those kind of parameters somewhat concerning, because the timing information at the layer level may contradict what's in CMAF (this is already a problem for certain codec/container situations that usually results in odd implementation-defined behavior).\r\n\r\nI believe that `order` should be enough, and we should remove the timestamp (the current text in the draft suggests its actual utility is currently unclear)",
      "createdAt": "2022-11-09T17:40:31Z",
      "updatedAt": "2023-10-17T01:24:44Z",
      "closedAt": null,
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes , the timestamp is media payload specific and should be scoped inside media container. \r\nRelays can use priority and delivery order to make forward/drop decisions. Our goals should be making relays as media agnostic as possible",
          "createdAt": "2022-11-09T18:07:49Z",
          "updatedAt": "2022-11-09T18:07:49Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, I believe that using the delivery order is more powerful than a TTL based on the timestamp. I want to make sure there's consensus first.\r\n\r\nOne thing to note is that we might want to specify a timestamp to support discontinuities (#15) without rewriting the media.  The playlist contains a timestamp, effectively used as a base offset, so the CDN does not need to constantly rewrite the media bitstream with the correct timestamp.\r\n\r\nIn the case of Twitch, advertisements always start with a PTS of 0. When we want to display an advertisement, we can insert the advertisement segments into the playlist with a discontinuity, allowing us to use the same segments across any broadcast and improving the cachability.",
          "createdAt": "2022-11-11T10:50:57Z",
          "updatedAt": "2022-11-11T10:52:12Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think there is two different things here. One is we need some sort of timestamp that lets you know how to deliver it to the decoder. The relays don't need to know about how to present it so any information about presentation times can be in encrypted payload part, but the envelop needs something about delivery order. \r\n\r\nAnd then we have a separate things, which is how long to keep this before it useless. This allows the relays to get rid of stuff that is of no use and allows the application to indicate how long it wants to be billed for storage on the relay. This could be a delta time or expired time but we probably need something that indicates a time the relays can start ignoring this information. If there is no caching, perhaps this can be avoided but still good to be able to toss out stuff that is too old to be useful even before starting the priority stuff. This does not remove the need for priority, just is a pre filter on it that allows application to tell relays useful information. \r\n\r\n",
          "createdAt": "2022-11-12T12:08:45Z",
          "updatedAt": "2022-11-12T12:08:45Z"
        },
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "\n> And then we have a separate things, which is how long to keep this before it useless. This allows the relays to get rid of stuff that is of no use and allows the application to indicate how long it wants to be billed for storage on the relay.\n> \nWill the business model of such relay charge based on the storage? From what I know, most current Live streaming CDN system are charging for the total media delivery throughput(viewers * bitrate) which is meaningful to the customer. After all, the customer pays for its live content to be delivered instead of being stored in some kind of cold storage.\n\nThat being said, I agree the delivery order and the expiration/lifetime is two different kinds of timestamp. We should not expose both them in one form of raw media timestamp and hope that the relay/endpoint derives the correct dropping and cache purging behavior by its own logic. Better way is to define a clear command in the control message(metadata) so that relay does not need to understand the media/codec specific logic.",
          "createdAt": "2022-11-12T22:42:05Z",
          "updatedAt": "2022-11-12T22:42:05Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "I_kwDOG2Ho4M5WC_zy",
      "title": "QUIC Streams and Datagrams support",
      "url": "https://github.com/moq-wg/moq-transport/issues/35",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Needs Discussion",
        "Object Model"
      ],
      "body": "Creating this issue to reflect WG discussions. Not sure what's the right next steps, but would be good as a placeholder to further discussions",
      "createdAt": "2022-11-10T10:19:27Z",
      "updatedAt": "2024-01-31T00:30:39Z",
      "closedAt": "2024-01-31T00:30:39Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I filed #38 for a common issue brought up with streams.",
          "createdAt": "2022-11-11T10:44:15Z",
          "updatedAt": "2022-11-11T10:44:15Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I definitely want to play with both stream and datagrams and see what the performance looks like. The more we dig into this, the less clear it all is to me. When I was playing with it before I was not doing the WARP new is higher priority stuff and that changes things in a good way. I think there are a few thought experiments I am interested in and perhaps trying to collect data on. \r\n\r\nOne: On high latency, high packet loss connections, does the time to end a stream result in significantly less \"good put\". \r\n\r\nTwo: On a relay that was fanning out to to 10k clients that were each getting a 4 mbps stream with normal packet loss and say 50 ms RTT,  is memory use of duplicate copies of the data before it is ack'd in each of the 10k connections a problem? Back of the envelope would suggest it is no big deal but like to play with a few of theses things more. \r\n\r\nTotally in favour of collecting more data and talking about this before making a decision. ",
          "createdAt": "2022-11-12T12:00:53Z",
          "updatedAt": "2022-11-12T12:00:53Z"
        },
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "\n> Two: On a relay that was fanning out to to 10k clients that were each getting a 4 mbps stream with normal packet loss and say 50 ms RTT, is memory use of duplicate copies of the data before it is ack'd in each of the 10k connections a problem? Back of the envelope would suggest it is no big deal but like to play with a few of theses things more.\nThis reminds of the Reliable Multicast Transport(rmt) working group which tries to solve the fan-in ack scalability problem during 2000-2013. It uses NACK and FEC to reduce the feedback frequency and designs a feedback suppression mechanism to deal with the extreme case. Maybe it is time to re-examine the problem.\n",
          "createdAt": "2022-11-12T22:06:48Z",
          "updatedAt": "2022-11-12T22:06:48Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "> is memory use of duplicate copies of the data before it is ack'd in each of the 10k connections a problem\r\n\r\nThis is kind of dependent on how your QUIC API works.  mvfst for example doesn't have to exclusively own data written to the transport, but rather owns relatively small descriptors that reference count underlying memory.",
          "createdAt": "2022-12-20T23:18:40Z",
          "updatedAt": "2022-12-20T23:18:40Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": " My proposed resolution to this would be that the decision to transmit object(s) over a Stream or Datagram is a decision made by the publisher based on whether the connection supports datagrams, the MTU, and the size of the object(s).\r\n\r\nThis also relates to the object model, since I suspect datagrams make the most sense when a single Object is mapped to a single stream.",
          "createdAt": "2023-10-16T23:56:08Z",
          "updatedAt": "2023-10-16T23:56:08Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Agree that this goes back to Object Model mapping discussion. Having publisher being able to make that choice will be important for different classes of applications over moqt.",
          "createdAt": "2023-10-17T04:46:33Z",
          "updatedAt": "2023-10-17T04:46:33Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, the publisher can decide if it wants to use a datagram and relays would maintain that decision.\r\n\r\nA few caveats though:\r\n* **Max MTU of 1200**. Please don't make me refragment datagrams on relays like RTP.\r\n* **Fire-and-forget**. Don't reinvent QUIC streams with retransmissions, reassembly, acknowledgments, flow control, etc. A relay could drop a datagram for any reason without any signal.",
          "createdAt": "2023-10-17T05:10:02Z",
          "updatedAt": "2023-10-17T05:11:47Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd like to separate the decision of how to bundle things from whether data is sent over streams or datagrams.  They can be made to have identical properties in terms of reliability, it's just a matter of implementation.\r\n\r\nIs there a reason to believe transforming from one to the other causes undue cost?  And if it does, could we just say not to negotiate datagram support if you don't want to do the transformation?  This would allow us to experiment and see when they work well without requiring anyone to support them.",
          "createdAt": "2023-10-24T00:54:03Z",
          "updatedAt": "2023-10-24T00:54:03Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "draft-02 has a mechanism for datagram support. ",
          "createdAt": "2024-01-31T00:30:39Z",
          "updatedAt": "2024-01-31T00:30:39Z"
        }
      ]
    },
    {
      "number": 36,
      "id": "I_kwDOG2Ho4M5WHEWQ",
      "title": "IETF115-Handle priority and delivery order ",
      "url": "https://github.com/moq-wg/moq-transport/issues/36",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From WG discussions, there were few points on separating these concepts and also having a need for relays to just read a single integer (limited in values it can consider) and also pushing complexity to application to control its semantics\r\n\r\nWe need to discuss further on the next steps here",
      "createdAt": "2022-11-10T23:17:03Z",
      "updatedAt": "2023-05-26T23:46:46Z",
      "closedAt": "2023-05-26T23:46:45Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Personally, I like global integer space (per connection) to specify the transmit order. It adds some complexity for the application to decide how to map media to this single number space, but it makes it easy for relays to transmit in a desired order. Publishing a full dependency graph on the wire is more complicated and requires more state tracking.\r\n\r\nThe draft should do a better job indicating that a sender should atempt to transmit in this order, but it can use any prioritization mechanism. The better it can adhere to this order, the better the user experience, but it's not a requirement. This opens the door to using extensisible priorities (ex. limited to 8 urgencies) and/or marking the packets at a lower layer (ex. IP prioritization or lower).",
          "createdAt": "2022-11-11T10:22:43Z",
          "updatedAt": "2022-11-11T10:23:28Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "After hearing the discussion in the room, I am pretty sure we should *not* publish the full graph. I had that option in my slides but I don't think we should do that. \r\n",
          "createdAt": "2022-11-12T11:46:16Z",
          "updatedAt": "2022-11-12T11:46:16Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Agree on keeping things simple here by not needing to have the entire graph. Also we need to keep in mind what's the relay/app behavior vs how QUIC stack itself deals with the order. \r\n\r\nShould we have an app level decision to insert/not to insert a given moq object into the quic library\r\nand\r\nMechanism for QUIC stack to deliver in a given order.\r\n\r\nBoth of these might be needed for some use-cases. We just need to evaluate a bit more on the scope and impact\r\n",
          "createdAt": "2022-11-12T12:12:57Z",
          "updatedAt": "2022-11-12T12:12:57Z"
        },
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "This discussion sounds similar to all sorts of priority discussion (see w3c/webtransport#62 and HTTP/2 or HTTP/3 priority. Basically you have a scheduler running on lower layer and an app which only have limited interface to the scheduler. For the scheduler to be useful in real world, app needs to be able to influence its behavior precisely enough by altering the parameter. A general and consist scheduler is hard to design. [RFC 8260](https://www.rfc-editor.org/rfc/rfc8260.html) defines many different scheduler for SCTP which might be useful. However RFC9000 does not describe the scheduler for QUIC. Neither does HTTP/3. We need to evaluate the problem carefully. ",
          "createdAt": "2022-11-12T22:29:02Z",
          "updatedAt": "2022-11-12T22:29:02Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Can this be collapsed into #139 or is this separate?",
          "createdAt": "2023-04-21T19:43:11Z",
          "updatedAt": "2023-04-21T19:43:11Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just as a point of note that a good schedule is hard to defines ... I would say a perfect schedule is impossible to define but the whole internet runs fine a good schedulers that are well defined in every router that forms the internet. This problem of fair scheduling is very well understood and it is easy to get a good solution, just impossible to get a perfect solution. ",
          "createdAt": "2023-04-22T14:28:46Z",
          "updatedAt": "2023-04-22T14:28:46Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "The draft has the author's current thinking, with send order and object priority approaches described in the draft.  Can this be closed for now?",
          "createdAt": "2023-05-05T20:31:09Z",
          "updatedAt": "2023-05-05T20:31:09Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "@suhasHere I'm closing this one out for now, please refer to the two proposals in the draft and open new issues as needed.",
          "createdAt": "2023-05-26T23:46:45Z",
          "updatedAt": "2023-05-26T23:46:45Z"
        }
      ]
    },
    {
      "number": 37,
      "id": "I_kwDOG2Ho4M5WHKu5",
      "title": "Dealing with Congestion Control",
      "url": "https://github.com/moq-wg/moq-transport/issues/37",
      "state": "OPEN",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "ABR"
      ],
      "body": "There were few discussions that discussed on dealing with congestion and needing more thinking around decisions around how and when to drop things. ",
      "createdAt": "2022-11-10T23:52:32Z",
      "updatedAt": "2024-02-20T02:26:34Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I've been verballizing this quite often but here's my thoughts written down. There's a few problems with traditional TCP congestion control that is common in QUIC (Reno, CUBIC, BBR).\r\n\r\n**Bufferbloat**\r\nTraditional loss-based congestion control (ex. CUBIC and Reno) is especially bad for live media. Bufferbloat is the tendency for routers, especially in emerging countries, to queue packets rather than drop them during congestion. These queued packets effectively cause head-of-line blocking (and thus latency), even if there's no packet loss. The sender loses the ability to decide which packets should be dropped or prioritized without some way to signal that decision on the wire at the IP layer.\r\n\r\n**Application-Limited**\r\nThe live media bitrate is gated by the encoder which most of the time will be lower than the maximum network bitrate (otherwise media is queued/dropped). This is especially a problem when delivering media frame-by-frame, as the sender is not able to fully saturate the congestion window outside of I-frames. Many congestion control algorithms (ex. CUBIC, Reno, BBR) can only increase the congestion window iff it's fully utilized, which is rare for live media and causes slow growth.\r\n\r\n**Consistent Throughput**\r\nTCP congestion control algorithms are typically optimized for average throughput, not consistency. This is especially a problem with BBR, as it periodically switches to the PROBE_RTT state that effectively stops sending packets for an extended period. This gap causes starvation and in the live media case, depleting the jitter buffer which causes frame dropping or rebuffering.",
          "createdAt": "2022-11-11T10:03:51Z",
          "updatedAt": "2022-11-11T10:05:18Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "To address these issues, [GCC](https://datatracker.ietf.org/doc/html/draft-ietf-rmcat-gcc-02) is the standard congestion control in WebRTC-land. It requires [transport wide CC](https://datatracker.ietf.org/doc/html/draft-holmer-rmcat-transport-wide-cc-extensions-01). I don't have too much experience with the algorithm itself.\r\n\r\nThe idea is that the receiver reports the arrival timestamp for every packet. The sender can inspect the jitter between these packets to guess the pacing rate on intermediate routers. It's a similar concept to BBR, except it works at the packet level instead of the ACK level. This means it works when application-limited, unlike BBR.\r\n\r\nQUIC ACKs includes the delay relative to the largest received sequence number. This means the sender can deduce the RTT for a single packet with each acknowledgement. This is more information than TCP, but I'm not sure if it's good enough.\r\n\r\nIn my opinion, there's a few improvements we should recommend to the QUIC WG. Specifying that the receiver ACK each packet immediately would be verbose but would be sufficient. Some way of batching the delay for each packet, much like how ACKs themselves are batched, would be an improvement.",
          "createdAt": "2022-11-11T10:15:50Z",
          "updatedAt": "2022-11-11T10:16:22Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the closest thing that will work well for us is BBRV2 but with modifications. Of course the modifications would need to be done over in QUIC. Basically the problem with it right now is when it probes for RTT, it causes a temporary stop of media flow which kills the jitter buffers and makes for huge latency in the jitter buffers. I think the BBRv2 algorithm could be tweeked to still get this RTT without the pause. \r\n",
          "createdAt": "2022-11-12T11:43:27Z",
          "updatedAt": "2022-11-12T11:43:27Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, I agree.\r\n\r\nIn fact, I think we can skip the BBR PROBE_RTT phase entirely because live video is sufficiently application-limited. It's meant to detect a local maxima caused by over-saturating the network, but that shouldn't be necessary since media will under-saturate the network.",
          "createdAt": "2022-11-14T18:23:20Z",
          "updatedAt": "2022-11-14T18:23:37Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "You definitely don't want to ACK every packet individually.  If you want per-packet timestamps, I wrote a draft that was used by some internal projects.\r\nhttps://www.ietf.org/archive/id/draft-smith-quic-receive-ts-00.html\r\n\r\nIt can probably be improved, but it works with GCC and similar congestion controllers.\r\n\r\nI agree that if you're app-limited often enough, you should be able to skip PROBE_RTT in BBRv2/3.  I keep wanting to write a version of the BBR bandwidth estimator that uses timestamps, but it's hard for me to know how much better it'd be without just doing it.\r\n\r\nThis is an interesting topic, but is there a clear ack for the QUIC WG or text we should add to the existing draft?  I'm inclined to park this for now and wait for more deployment experience.",
          "createdAt": "2023-10-28T18:31:08Z",
          "updatedAt": "2023-10-28T18:31:08Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "This is one area where WebRTC has advantage over MoQ. While I don't think the draft should have any text, it would be good to have a plan we can point to. Getting your timestamp draft adopted eventually sounds like a good plan to me.",
          "createdAt": "2023-10-28T23:30:49Z",
          "updatedAt": "2023-10-28T23:31:46Z"
        }
      ]
    },
    {
      "number": 38,
      "id": "I_kwDOG2Ho4M5WJTk4",
      "title": "Relay latency caused by streams",
      "url": "https://github.com/moq-wg/moq-transport/issues/38",
      "state": "OPEN",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Parked"
      ],
      "body": "This was brought up by @suhasHere, and also at IETF 115 by @huitema.\r\n\r\nLet's assume a sender wants to transmit a stream with 3k bytes passed through a relay. The relay will read from the source stream and write any data to the destination stream. The sender fragments the stream into 3 packets of 1k bytes each.\r\n\r\n1. The 1st packet arrives. The QUIC library will flush the contents to the application, which then writes to the destination stream.\r\n2. The 2nd packet is dropped. If will be retransmitted later when a gap is detected.\r\n3. The 3rd packet arrives. The QUIC library will NOT flush the contents to the application due to the gap.\r\n4. The 2nd packet is retransmitted and arrives. The QUIC library will flush the stream contents of the 2nd and 3rd packet to the application, which then writes to the destination stream.\r\n\r\nThis relay setup means we do not immediately transmit stream contents as they arrive. Each additional relay exacerbates the issue.\r\n\r\nI will note that is not an issue specific to MoQ or even QUIC, as TCP relays suffer the same problem. However it's a larger issue for live media as latency is critical.",
      "createdAt": "2022-11-11T10:36:50Z",
      "updatedAt": "2024-02-20T02:27:33Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "This is not an issue with datagrams, as are typically relayed independently (much like IP packets). Using datagrams instead of streams is an option, although this incurs more complexity as it requires application ownership of fragmentation, retransmissions, flow control, etc.\r\n\r\nAn alternative is to recommend that relays use QUIC libraries that support reading from and writing to streams based on offsets. This adds some complexity, primarily on the sender, but it is limited to relays only. This same approach should be used for HTTP/3.",
          "createdAt": "2022-11-11T10:42:47Z",
          "updatedAt": "2022-11-11T10:43:17Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What's the status on QUIC implementations support this offset type API for reading and writing ? I need to learn more about quic. ",
          "createdAt": "2022-11-12T11:44:30Z",
          "updatedAt": "2022-11-12T11:44:30Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In theory, everything is possible. In practice, passing fragments of streams at the API is hard in two ways: it requires non-standard API, and it requires application ownership of fragmentation, etc., which is much of the complexity of supporting datagrams.\r\n\r\nThe API point can be debated for a long time but RFC 9000 is clear: section 2 stats that \"Streams in QUIC provide a lightweight, ordered byte-stream abstraction to an application.\" Most implementations that I know provide a simple byte stream API. There is no standard API for QUIC except for Web Transport, which does not provide a \"fragmented stream\" API. There have been proposals for the related concept of unreliable streams, such as this [abandoned draft](https://datatracker.ietf.org/doc/draft-tiesel-quic-unreliable-streams/) from P. Tiesel & al. at TU Berlin, or this [more recent draft](https://datatracker.ietf.org/doc/draft-chen-quic-quicu/)  from a J. Chen & al. at Bytedance. These proposals come and go, and mostly fail to get traction. In contrast, there is lots of support for the datagram extension, see for example how it is used in Masque.\r\n\r\nFrom an implementation perspective, I feel that a fragmented and unordered stream API will require much of the same application complexity as datagrams. The stack will manage retransmission and flow control, but application will clearly have to manage fragmentation: receiving a set of bytes at a random offset is pretty much the same as receiving datagrams. From looking at my code for datagram support, managing fragmentation is much more complex than managing retransmissions, which relies on ack and timers from the QUIC stack. Flow control is definitely more complex, because datagrams are not subject to it. I think the application complexity for unordered streams will be very similar to that of supporting datagrams.\r\n\r\nSo in theory everything is possible, but in practice supporting datagrams is simpler than trying to add an unordered or unreliable extension to streams.",
          "createdAt": "2022-11-12T16:06:18Z",
          "updatedAt": "2022-11-12T16:06:18Z"
        },
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "I agree with Christian. QUIC stream should be treated like a block of data (message) which is either delivered in order or not. Splitting QUIC stream into multiple part and manage them is like reinventing the QUIC multiplexing feature on top of TCP which is too complex. That is why in my draft (https://datatracker.ietf.org/doc/draft-shi-quic-dtp/), I map block into stream 1:1. On the other hand, implementing block on top of QUIC datagram does not have to any constrain of QUIC stream.",
          "createdAt": "2022-11-12T21:26:23Z",
          "updatedAt": "2022-11-12T21:27:50Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "These would not be unreliable streams. Let me try to explain end-to-end:\n\nThe encoder would write the media bitstream to a QUIC stream in order. Let's just suppose we're using a QUIC stream per GoP, but it's the same with other fragmentation approaches.\n\nOnly relays would benefit from read/write using offsets, and only when latency is critical. I think that's important because it's not something a client or browser will ever need to support, for example.\n\nOn the receiving end, the relay would call a `ReadChunk` function that returns a byte array and an offset, effectively each STREAM frame. The QUIC library will ensure that there are no gaps unless the stream is reset early. This seems trivial to implement.\n\nOn the sending end, the relay would call a `WriteChunk` function providing the same byte array and offset. The QUIC library will block if the application tries to write beyond what flow control allows; gaps have to be filled eventually. This is the trickier side to implement, although it seems similar to how you implement retransmits. It's also more dangerous since the application can screw up.\n\nAnyway, at the final hop, the decoder reads from each steam in order and blocks if there's a gap. This is required since the media decoder cannot handle gaps anyway. If you actually want a gap, ex. to drop a single frame, then you need to make a separate stream for just that frame.\n\n@huitema does this make sense?\n\nI'm grappling with the cost of asking QUIC libraries to implement new APIs. I would like to try implementing it and see if it's a reasonable ask. If it's not, we always have the option to hit the eject button and use datagrams instead.\n",
          "createdAt": "2022-11-13T00:36:57Z",
          "updatedAt": "2022-11-13T00:49:00Z"
        },
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "\n> On the receiving end, the relay would call a `ReadChunk` function that returns a byte array and an offset, effectively each STREAM frame. The QUIC library will ensure that there are no gaps unless the stream is reset early. This seems trivial to implement.\n> \n> On the sending end, the relay would call a `WriteChunk` function providing the same byte array and offset. The QUIC library will block if the application tries to write beyond what flow control allows; gaps have to be filled eventually. This is the trickier side to implement, although it seems similar to how you implement retransmits. It's also more dangerous since the application can screw up.\n> \n> Anyway, at the final hop, the decoder reads from each steam in order and blocks if there's a gap. This is required since the media decoder cannot handle gaps anyway. If you actually want a gap, ex. to drop a single frame, then you need to make a separate stream for just that frame.\n\nThe readchunk and writechunk looks like send and receive datagram. And the datagram contains the offset so that final hop can reassemble the stream. \n\nThe difference is the layer in which the offset is handled. If using datagram, the offset is handled by MoQ layer at the final hop. The relay just does blind forwarding and does not care about the offset because it is in the datagram payload. \n\nIn your sendchunk solution, each hop needs to get the offset information from receiving side QUIC and put it into the sending side QUIC. Naturally the relay is aware of the offset. Do you see other use-case for the offset information in the relay? \n\n\n> I'm grappling with the cost of asking QUIC libraries to implement new APIs. I would like to try implementing it and see if it's a reasonable ask. If it's not, we always have the option to hit the eject button and use datagrams instead.\n> \n\nIt seems the cost is fine at least when compared with implementing it using datagram. Set aside the cost, we should consider the use case and benefit that a new change brings and what it changes/breaks.\n\nDoes this new api introduce a new semantic into QUIC stream? Currently QUIC stream is a fifo bytes stream like a pipe. With this chunk, data inside QUIC stream can arrive out of order. Feels like a big change to the quic stream semantic. Do we have strong motivation to introduce this new semantic? Maybe more broad/general use cases?",
          "createdAt": "2022-11-13T01:20:31Z",
          "updatedAt": "2022-11-13T01:20:31Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "For me streams vs datagrams is a complexity tradeoff between the endpoints and the relays.  There's no question that with datagrams relays become simpler, but the application endpoints pay the price in terms of having to implement message reassembly and retransmission.  The relays however may also need to do some reassembly, if it needs to find the header for a particular segment in order to know it's transmission priority or other metadata to determine what do to with a particular datagram.\r\n\r\nI expect there to be more endpoint implementers with a greater need for simplicity, while the relays are likely to be implemented by a smaller number of relative experts.  Therefore I'd prefer to concentrate the complexity there.  And there's no *requirement* that a relay implement out of order stream forwarding, it's just an optimization they are free to implement or not.\r\n\r\nI don't view this as changing the semantics of a stream vs what is described in the RFC.  It only requires that an application allow the stream to be read in-order, but doesn't preclude other mechanisms for accessing stream data.  mvfst already has a peek API that allows the application to view received stream data that has been received out of order.\r\n\r\nUltimately though, data wins arguments.  We're hoping to implement an out-of-order stream relay as a proof of concept for the next interim or hackathon to assess the actual complexity and challenges with that design.",
          "createdAt": "2022-11-14T17:09:14Z",
          "updatedAt": "2022-11-14T17:09:14Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "We are building a moq protocol for set of use-cases and I think it becomes an hard argument to justify to say if a stack supports a special api we get certain use-cases covered otherwise ymmv. \r\n\r\n@afrind  Glad that you are helping test out some of these ideas. Look forward to learn more and proposal submitted for everyone's benefit once its ready .. Thanks",
          "createdAt": "2022-11-23T05:18:39Z",
          "updatedAt": "2022-11-23T05:19:03Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "> We are building a moq protocol for set of use-cases and I think it becomes an hard argument to justify to say if a stack supports a special api we get certain use-cases covered otherwise ymmv.\r\n\r\nI don't see a relay that is unable to forward stream data out of order as causing a use-case to be uncovered.  It might just be a suboptimal relay.  One of the advantages of QUIC is that it's not baked into the kernel and there's a marketplace of stacks to choose from, and many of them are open source.",
          "createdAt": "2022-11-30T00:41:35Z",
          "updatedAt": "2022-11-30T00:41:35Z"
        },
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "I am afraid that the ultra low latency is in conflict with the reliable/in-order delivery. What if the end-to-end latency requirement is so tight that the reordering latency is unacceptable? If reordering is done at the relay, it may accumulate at each relay. If only some relays support out-of-order forwarding, then it creates fragmentation on the relay provider implementations. How do you chain those relays together?",
          "createdAt": "2022-12-12T06:17:12Z",
          "updatedAt": "2022-12-12T06:17:12Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> I am afraid that the ultra low latency is in conflict with the reliable/in-order delivery. What if the end-to-end latency requirement is so tight that the reordering latency is unacceptable? If reordering is done at the relay, it may accumulate at each relay. If only some relays support out-of-order forwarding, then it creates fragmentation on the relay provider implementations. How do you chain those relays together?\r\n\r\nI want to +1 what @afrind said earlier.\r\n\r\nThere's a trade-off here. We can have a simpler protocol but require more work for an optimal relay. Or we can have a more complex protocol but require less work for an optimal relay. We should quantify that work with a proof-of-concept.\r\n\r\nAt the very least, using datagrams would dramatically increase the surface area of the protocol. It might actually be more work to build an optimal relay using datagrams since the protocol would be more complex. The relay would be responsible for optimally implementing retransmissions, prioritization, fragmentation, etc instead of delegating to an existing QUIC library.\r\n\r\n\r\nAs for a fragmented ecosystem, well don't use sub-optimal relays when latency is critical. That goes for any protocol really.",
          "createdAt": "2022-12-13T03:02:02Z",
          "updatedAt": "2022-12-13T03:02:36Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\n\nOn 12/12/2022 7:02 PM, kixelated wrote:\n>> I am afraid that the ultra low latency is in conflict with the reliable/in-order delivery. What if the end-to-end latency requirement is so tight that the reordering latency is unacceptable? If reordering is done at the relay, it may accumulate at each relay. If only some relays support out-of-order forwarding, then it creates fragmentation on the relay provider implementations. How do you chain those relays together?\n> I want to +1 what @afrind said earlier.\n> \n> There's a trade-off here. We can have a simpler protocol but require more work for an optimal relay. Or we can have a more complex protocol but require less work for an optimal relay. We should quantify that work with a proof-of-concept.\n> \n> At the very least, using datagrams would dramatically increase the surface area of the protocol. It might actually be more work to build an optimal relay using datagrams since the protocol would be more complex. The relay would be responsible for optimally implementing retransmissions, prioritization, fragmentation, etc instead of delegating to an existing QUIC library.\n\nHaving actually implemented such datagram relays, I don't believe it is \nthat much harder than \"delegating to the QUIC library\". Each datagram \ncarries a fragment of an object. The relays by default relay the \nfragments in the order they are received, unless congestion control \ntells them that the object shall be dropped. In that case, they just \ndrop all the fragment of that object.\n\n> As for a fragmented ecosystem, well don't use a sub-optimal relay when latency is critical. That goes for any protocol really.\n\nWell, yes. So, if we want the best performance, we end up sending \nfragments of objects as datagrams, doing reassembly end to end. That \nwill avoid any head-of-line blocking in relays. It will also simplify \nimplementations, by completely bypassing the flow control mechanisms of \nQUIC.\n\n-- Christian Huitema\n",
          "createdAt": "2022-12-13T04:36:39Z",
          "updatedAt": "2022-12-13T04:36:39Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> On 12/12/2022 7:02 PM, kixelated wrote: > I am afraid that the ultra low latency is in conflict with the reliable/in-order delivery. What if the end-to-end latency requirement is so tight that the reordering latency is unacceptable? If reordering is done at the relay, it may accumulate at each relay. If only some relays support out-of-order forwarding, then it creates fragmentation on the relay provider implementations. How do you chain those relays together? I want to +1 what @afrind said earlier. There's a trade-off here. We can have a simpler protocol but require more work for an optimal relay. Or we can have a more complex protocol but require less work for an optimal relay. We should quantify that work with a proof-of-concept. At the very least, using datagrams would dramatically increase the surface area of the protocol. It might actually be more work to build an optimal relay using datagrams since the protocol would be more complex. The relay would be responsible for optimally implementing retransmissions, prioritization, fragmentation, etc instead of delegating to an existing QUIC library.\r\n> Having actually implemented such datagram relays, I don't believe it is that much harder than \"delegating to the QUIC library\". Each datagram carries a fragment of an object. The relays by default relay the fragments in the order they are received, unless congestion control tells them that the object shall be dropped. In that case, they just drop all the fragment of that object.\r\n> As for a fragmented ecosystem, well don't use a sub-optimal relay when latency is critical. That goes for any protocol really.\r\n> Well, yes. So, if we want the best performance, we end up sending fragments of objects as datagrams, doing reassembly end to end. That will avoid any head-of-line blocking in relays. It will also simplify implementations, by completely bypassing the flow control mechanisms of QUIC.\r\n> [\u2026](#)\r\n> -- Christian Huitema\r\n\r\nI would like to +1 to Christian's comment. Reassembly only needs to happen at the end , unless Relays want to store the things as full objects instead of fragments, which is not the case typically. Relays gets fragments in and sends fragments out and store/drop fragments as needed by caching policy.",
          "createdAt": "2022-12-13T18:32:42Z",
          "updatedAt": "2022-12-13T18:32:42Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> I am afraid that the ultra low latency is in conflict with the reliable/in-order delivery. What if the end-to-end latency requirement is so tight that the reordering latency is unacceptable? If reordering is done at the relay, it may accumulate at each relay. If only some relays support out-of-order forwarding, then it creates fragmentation on the relay provider implementations. How do you chain those relays together?\r\n\r\nI don't see a need to reorder DATAGRAM fragments at the relays ( which could be the case with streams though) .. If there is a need for full objects, the publisher can say it needs reliable transport and it uses Streams in such cases.",
          "createdAt": "2022-12-13T18:36:57Z",
          "updatedAt": "2022-12-13T18:36:57Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "> Reassembly only needs to happen at the end , unless Relays want to store the things as full objects instead of fragments\r\n\r\nAren't some relays actually caches, and wouldn't they want to store things as full objects?",
          "createdAt": "2022-12-16T16:11:32Z",
          "updatedAt": "2022-12-16T16:11:32Z"
        },
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "> Aren't some relays actually caches, and wouldn't they want to store things as full objects?\r\n\r\nThe store and relay of the datagram can be done in two threads parrallely. The relay thread just forwards datagram as it comes without reordering. The store thread needs to do reorder.\r\n",
          "createdAt": "2023-01-17T08:13:41Z",
          "updatedAt": "2023-01-17T08:16:43Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "This seems like an optimization one can do at the relay if the necessary library API is present.  Is this something that needs text and something like a RECOMMENDED normative statement, or just leave it up to relays to do their best?\r\n\r\nI'll also note that packet loss is likely going to be lower upstream of the relay than downstream, at least based on my experience.",
          "createdAt": "2023-10-16T23:49:53Z",
          "updatedAt": "2023-10-16T23:49:53Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> This seems like an optimization one can do at the relay if the necessary library API is present. Is this something that needs text and something like a RECOMMENDED normative statement, or just leave it up to relays to do their best?\r\n\r\nYeah, I don't even think we mention it. It only matters for real-time latency over bandwidth constrained relays; situational at best.",
          "createdAt": "2023-10-17T04:23:16Z",
          "updatedAt": "2023-10-17T04:23:16Z"
        }
      ]
    },
    {
      "number": 39,
      "id": "I_kwDOG2Ho4M5WNuEX",
      "title": "Need approaches to Reduce time to join the live media stream",
      "url": "https://github.com/moq-wg/moq-transport/issues/39",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We need a way for the player to indicate where in the current ongoing stream to receive the media.\r\n\r\nFollowing 3 options come to mind\r\n1. Start from a previous i-frame ( beginning of the gop)\r\n2. Start from the next i-frame ( wait until the next gop)\r\n3. Start from the current frame ( default )\r\nLast one will not be useful for video probably, but it allows audio frames to rendered from the latest point in time.\r\n\r\nThis might relate to adding further info to the ``` PLAY ``` message ?",
      "createdAt": "2022-11-12T12:42:49Z",
      "updatedAt": "2023-08-08T05:35:09Z",
      "closedAt": "2023-08-08T05:35:09Z",
      "comments": [
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "Option 2 will bring more complicity than option 1 because the time of next I-frame is unknown to client. A client almost always want to minimalize the join time. Do we need a mechanism to race between option 1 and option 2? Or we can let sender side decide how to deliver the appropriate frame so that the client can join the stream ASAP.",
          "createdAt": "2022-11-12T21:37:23Z",
          "updatedAt": "2022-11-12T21:37:41Z"
        },
        {
          "author": "acbegen",
          "authorAssociation": "NONE",
          "body": "> * Start from a previous i-frame ( beginning of the gop)\r\n> * Start from the next i-frame ( wait until the next GOP)\r\n\r\nRFC 6285 discusses the two options above in detail (the sender determines which option is better). There is also mathematical proof in this [paper](https://ali.begen.net/files/articles/PV12.pdf) showing which idea works better when. The problem space is a bit different but you get the idea.\r\n\r\n> * Start from the current frame ( default )\r\n\r\nFor audio this works. For video, you need an auxiliary stream like we have in HESP.\r\n",
          "createdAt": "2022-11-14T08:56:20Z",
          "updatedAt": "2022-11-14T08:56:20Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Ultimately, it depends on the desired user experience. Thus the best option will be to let the viewer/player choose. We could add a \"latency hint\" but it might not actually be necessary.\r\n\r\nThanks to delivery order and prioritization, the newest GoP will get sent when it's available, taking priority over delivering the rest of the previous GoP. This means the player has the ability to choose between option 1 and 2 by choosing how long to wait (ex. start playback when the jitter buffer has 1s of media). Or the player can start playback immediately with option 1 and skip forward once the next keyframe arrives for option 2 (ex. shrink the jitter buffer when all pending media has been received).\r\n\r\nAlso, I don't think audio and video should be aligned. This means you could have a video segment every 2s at keyframe boundaries while you have an audio segment every 200ms or whatever. It introduces some extra overhead, but it enables option 3 either with blank video or desynchronized audio/video.\r\n\r\nOr like @acbegen mentioned, we could do something like HESP, where different segments are delivered to different viewers. We must not impose that every viewer gets identical content anyway for stuff like server-side ad insertion.",
          "createdAt": "2022-11-14T18:03:16Z",
          "updatedAt": "2022-11-14T18:18:56Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I think a latency hint makes sense though. Let's assume the CDN has ten 2s segments in the cache, each of which is an entire GoP, and the player wants to use a jitter buffer of roughly 6s.\r\n\r\nWe probably need the latency hint when head-of-line blocking is desired (ascending delivery order). The player will need to specify 6s desired latency to start back three segments in the past. Otherwise the earlier seven segments will get transmitted until the player issues STOP_SENDING for each, both wasting bandwidth and increasing time to video.\r\n\r\nThe latency hint is optional when live delivery is desired (descending delivery order per GoP). The newest GoP will always get transmitted first until eventually the segments are backfilled to reach the target latency. \r\n\r\nHowever, if the CDN doesn't know the target latency, then it won't know when to stop transmitting segments, and will have to rely on the player to send STOP_SENDING to avoid wasting bandwidth, although it won't impact the user experience. Knowing the target latency also gives the CDN the potential to temporarily ignore the delivery order and first transmit the segment -6s in the past, then go back to obeying delivery order, which seems like a custom but decent time-to-video optimization for high target latencies.",
          "createdAt": "2022-11-14T18:17:19Z",
          "updatedAt": "2022-11-14T18:20:44Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "At a high level what is needed here is for the player to choose it experience and indicate its preference when joining by specify from where/when it would like to get its media delivered. Latency hint is another useful thing that can be added too.\r\n",
          "createdAt": "2022-11-15T13:07:53Z",
          "updatedAt": "2022-11-15T13:07:53Z"
        },
        {
          "author": "acbegen",
          "authorAssociation": "NONE",
          "body": "> Knowing the target latency also gives the CDN the potential to temporarily ignore the delivery order and first transmit the segment -6s in the past, then go back to obeying delivery order, which seems like a custom but decent time-to-video optimization for high target latencies.\r\n\r\nWe have certain keys in CMCD (and CMSD) to help with this. For example, 'dl' (deadline) CMCD key lets the client tell the CDN when it needs the response. Since client-desired latency is a client-side value, it has to be told to the CDN by each client - if that is an expected feature. ",
          "createdAt": "2022-11-17T07:12:48Z",
          "updatedAt": "2022-11-17T07:12:48Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "SUBSCRIBE now supports starting from the latest GROUP and/or OBJECT.  Is that sufficient?",
          "createdAt": "2023-05-05T20:28:35Z",
          "updatedAt": "2023-05-05T20:28:35Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Done with group support",
          "createdAt": "2023-08-08T05:35:09Z",
          "updatedAt": "2023-08-08T05:35:09Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "I_kwDOG2Ho4M5WcLCh",
      "title": "Controlling encoding parameters on the receive side",
      "url": "https://github.com/moq-wg/moq-transport/issues/42",
      "state": "OPEN",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "NotTransport"
      ],
      "body": "Currently, all of the parameters like expiration time for layers are always configured by the sender.  This makes sense in most cases (when doing delivery to the CDN or to an end user), however, in case of ingestion, the receiver might have a better understanding of, say, when the layers should expire.  We should provide a way for the receiver to give hints to the encoder.",
      "createdAt": "2022-11-15T18:52:46Z",
      "updatedAt": "2024-02-20T02:28:07Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Twitch would love the ability to influence the encoder on the server side. Stuff like choosing the renditions, bitrate, codec, CBR/VBR, etc.",
          "createdAt": "2022-11-15T19:49:10Z",
          "updatedAt": "2022-11-15T19:49:10Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Meta has asked for something similar too. Although this doesn't need to be part of MoQ; it could be as simple as a JSON file at a known endpoint.",
          "createdAt": "2022-11-15T19:50:26Z",
          "updatedAt": "2022-11-15T19:50:26Z"
        },
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "+1. The receiver has the final say on the QoE. Feeding the QoE back to sender can help the sender side optimization. Like [QoE feedback in this draft](https://datatracker.ietf.org/doc/draft-ma-quic-mpqoe/).",
          "createdAt": "2023-01-28T06:40:54Z",
          "updatedAt": "2023-01-28T06:40:54Z"
        }
      ]
    },
    {
      "number": 44,
      "id": "I_kwDOG2Ho4M5Wi6ue",
      "title": "Auto Bitrate Selection",
      "url": "https://github.com/moq-wg/moq-transport/issues/44",
      "state": "OPEN",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "ABR"
      ],
      "body": "We're unable to modify the encoder bitrate for 1:N distribution. The common approach to deal with this is to encode multiple renditions, each at a different bitrate/resolution, and choose one to serve to each viewer.\r\n\r\nMy plan is to treat each rendition as a separate track and use `group_id` to group renditions (#43). However, there's some particulars about who chooses the next track, and when that choice takes impact. Traditionally in HLS/DASH, the receiver chooses both.\r\n\r\n### WHO\r\nOne of the things that I've learned at Twitch is that client-side ABR just does not work for per frame delivery, which is necessary to minimize latency. The receiver lacks access to the sender's congestion controller and cannot measure the network bitrate when application-limited. We could have the sender frequently push the estimated bitrate to the receiver, but to be the most responsive the sender should choose the rendition to use.\r\n\r\nWe still need the ability for the receiver to choose any number of tracks manually. The user might manually select a rendition, or it might not support a rendition (based on resolution or profile), or the sender just don't know what language the user wants.\r\n\r\n### WHEN\r\nThe other thing I've learned from LL-HLS is that a constantly updating a playlist is a pain and can introduce latency. I would like something push based, where the sender just knows the next segment to push, instead of needing to constantly inform the receiver so it can select one.\r\n\r\nAnother one of my requirements is that renditions do not need to be aligned. This means renditions could have different GoP sizes, including an extremely frequent one like HESP. Just because the current track has an independently decodable segment does not mean that the requested track will also have one at the same timestamp. \r\n\r\nIt's not clear when to switch between tracks. Should it happen immediately, at the next I-frame, a previous I-frame, a specific timestamp, etc? How does the sender or receiver even know where these boundaries exist?",
      "createdAt": "2022-11-16T17:26:44Z",
      "updatedAt": "2024-02-19T23:35:05Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Additionally, we probably need a way of specifying when the track switch should take place. This seems required for client-side ABR otherwise you could waste bandwidth or introduce gaps. It also seems required when higher latencies are desired, as the receiver needs a way of telling the sender to start playback x seconds in the last.",
          "createdAt": "2022-11-16T20:51:00Z",
          "updatedAt": "2022-11-16T20:51:00Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Also worth mentioning that we sponsored an [academic challenge](https://blog.twitch.tv/en/2020/01/15/twitch-invites-you-to-take-on-our-acm-mmsys-2020-grand-challenge/). Throwing machine learning at the problem can help, but it's nowhere near as good as sender-side ABR.",
          "createdAt": "2022-11-30T17:36:45Z",
          "updatedAt": "2022-11-30T17:36:45Z"
        },
        {
          "author": "acbegen",
          "authorAssociation": "NONE",
          "body": "> One of the things that I've learned at Twitch is that client-side ABR just does not work for per frame delivery, which is necessary to minimize latency. The receiver lacks access to the sender's congestion controller and cannot measure the network bitrate when application-limited. We could have the sender frequently push the estimated bitrate to the receiver, but to be the most responsive the sender should choose the rendition to use.\r\n\r\nClients can switch tracks only at the switching points, which are fragment boundaries in CMAF language. You cannot expect the client to get 4 frames from one track and the subsequent 3 frames from another track to smoothly decode those seven frames. So, per-frame delivery is not the right term here IMO. Even if you do sender-side ABR, it is not actually doing per-frame delivery.\r\n\r\nSecond, close to the switching points, the sender can convey its own estimation to the client and the client can still make a proper choice. There are tons of advantages why the client should pick what it wants to receive.\r\n\r\nThird, obviously the sender has better knowledge of the currently available bandwidth but I don't agree with the statement that a client cannot make a measurement when the data is application-limited. Yes, it won't be perfect but we do have good methods to deal with this (not only as part of the challenge you mentioned but also thru other methods that are enabled to use because we are able to use QUIC rather than TCP now).",
          "createdAt": "2022-12-01T16:12:52Z",
          "updatedAt": "2022-12-01T16:12:52Z"
        },
        {
          "author": "acbegen",
          "authorAssociation": "NONE",
          "body": "> Another one of my requirements is that renditions do not need to be aligned. This means renditions could have different GoP sizes, including an extremely frequent one like HESP. Just because the current track has an independently decodable segment does not mean that the requested track will also have one at the same timestamp.\r\n\r\nGoP durations don't need to be the same but the segments (in CMAF) need to be aligned for seamless switching. Putting I frames at different frames for the same content would be illogical.",
          "createdAt": "2022-12-01T16:14:51Z",
          "updatedAt": "2022-12-01T16:14:51Z"
        },
        {
          "author": "jordicenzano",
          "authorAssociation": "NONE",
          "body": "Should we mention ABR in the draft, I missed some comments about it / implications.I think this could have big implications in the overall MOQT, for instance:\r\n- For live streaming is a paradigm change (from player driven to server driven)\r\n- It needs much smarter servers (perhaps we need to specify / mention what servers needs to do, inputs, etc)",
          "createdAt": "2023-06-03T21:57:45Z",
          "updatedAt": "2023-06-03T21:57:45Z"
        },
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "Does MOQT draft prevent the server side ABR? Publisher are free to adjust the bitrate of any track, right?",
          "createdAt": "2023-06-05T06:49:23Z",
          "updatedAt": "2023-06-05T06:49:23Z"
        },
        {
          "author": "acbegen",
          "authorAssociation": "NONE",
          "body": "> Does MOQT draft prevent the server side ABR? Publisher are free to adjust the bitrate of any track, right?\r\n\r\nThe sender can do whatever it wants to do with its tracks as long as the receivers are notified of the changes (one way or another) or the changes are within acceptable limits per the catalog/manifest. None of this removes the need for client-side rate adaptation which we still need for a variety of reasons.",
          "createdAt": "2023-06-05T10:06:30Z",
          "updatedAt": "2023-06-05T10:06:30Z"
        }
      ]
    },
    {
      "number": 45,
      "id": "I_kwDOG2Ho4M5WjFG5",
      "title": "Requirements document?",
      "url": "https://github.com/moq-wg/moq-transport/issues/45",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Do you guys think we should have an explicit document, or use Github issues to track requirements? ",
      "createdAt": "2022-11-16T17:56:13Z",
      "updatedAt": "2023-04-26T19:01:23Z",
      "closedAt": "2023-04-26T19:01:23Z",
      "comments": [
        {
          "author": "acbegen",
          "authorAssociation": "NONE",
          "body": "I think a separate requirements draft is needed. The current requirements document is more like use-cases document. I also think there is a need for a \"definitions\" document to get everyone on the same page and keep the terminology consistent. I am volunteering for this work if anybody else is willing to help.",
          "createdAt": "2022-11-21T19:19:10Z",
          "updatedAt": "2022-11-21T19:19:10Z"
        },
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "@acbegen I agree a definition and a requirement draft are needed and I am willing to help.",
          "createdAt": "2022-11-22T09:25:26Z",
          "updatedAt": "2022-11-22T09:25:26Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm going to work on a definitions document next, since naming has been the most problematic. I'll need a lot of help with non HLS/H.264 terminology.",
          "createdAt": "2022-11-27T19:32:21Z",
          "updatedAt": "2022-11-27T19:32:21Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@kixelated I am happy to help on this",
          "createdAt": "2022-11-28T06:27:19Z",
          "updatedAt": "2022-11-28T06:27:19Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "NONE",
          "body": "I have two thoughts here - \r\n- the use cases and requirements document that @fiestajetsam and I have been working on is intended to contain \"requirements\", but I suspect that document should be talking about requirements that enable MOQ to be used in overall systems (so, things like the ability to have \"relays\" that don't have access to the media payload, as well as the ability to have relays that are also, for example, transcoders that need access to the media payload). \r\n\r\nI suspect that protocol drafts, such as this one, also need to talk about more detailed requirements that apply to a single protocol. Does that make sense?\r\n- I could not agree more with @acbegen, @VMatrix1900, @kixelated, and @suhasHere about the need for a definitions draft, and I'm **also** willing to help. Has anyone started that draft yet? By \"started\", I mean, is there an active GitHub repo for it?",
          "createdAt": "2023-01-10T13:31:57Z",
          "updatedAt": "2023-01-10T13:31:57Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the ship has sailed on requirements documents.  We have the requirements draft, and we have architectural issues in this repo -- ready to close?",
          "createdAt": "2023-04-21T19:34:26Z",
          "updatedAt": "2023-04-21T19:34:26Z"
        }
      ]
    },
    {
      "number": 49,
      "id": "I_kwDOG2Ho4M5Wxud5",
      "title": "Segments vs fragments",
      "url": "https://github.com/moq-wg/moq-transport/issues/49",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I've mentioned this to Suhas a few times but I figured I'd write it down. Here's a breakdown of how CMAF works:\r\n\r\n* An **Init Segment** consist of a File Type Box (`ftyp`) and Movie Box (`moov`). The latter contains a description of each track.\r\n* A **Media Segment** consist of a Segment Type Box (`styp`) and any number of **Media Fragments** concatenated.\r\n* A **Media Fragment** consists of a Movie Fragment Box (`moof`) and Movie Data Box (`mdat`). This contains any number of **Samples** for any number of tracks. The `moof` contains the metadata while the `mdat` contains the codec bitstream.\r\n* A **Sample** is a video **Frame** or a group of audio samples (also called a **Frame**), depending on the codec.\r\n\r\nSo how do we map this to QUIC streams? Currently:\r\n\r\n* Warp: each QUIC stream contains a SEGMENT message, with a **Media Segment** , with any number of **Media Fragments**, with any number of **Frames**, until the end of the GoP.\r\n* RUSH: each QUIC stream contains a SEGMENT message with a **Media Segment**, with a single **Media Fragment**, with a single **Frame**.\r\n\r\nDoes this work or do we shed a layer?\r\n\r\n* Warp: each QUIC stream contains any number of FRAGMENT messages, with a single **Media Fragment**, with any number of **Frames**, until the end of the GoP.\r\n* RUSH: each QUIC stream contains a FRAGMENT message, with a single **Media Fragment**.",
      "createdAt": "2022-11-18T21:59:08Z",
      "updatedAt": "2023-04-26T19:01:12Z",
      "closedAt": "2023-04-26T19:01:12Z",
      "comments": [
        {
          "author": "acbegen",
          "authorAssociation": "NONE",
          "body": "In CMAF, fragment means independently decodable. Segments may consist of one or more fragments. And you can switch to a different track at a fragment boundary (which also happens to be a segment boundary). Based you wrote above, your definition for a fragment is \"looser\". I suggest we keep the definitions consistent with CMAF if we will keep it central to MOQ.",
          "createdAt": "2022-11-20T09:12:02Z",
          "updatedAt": "2022-11-20T09:12:02Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "This issue is pretty old - and the terminology has already changed (possibly more than once) since the last update.  Can we close?",
          "createdAt": "2023-04-21T19:35:07Z",
          "updatedAt": "2023-04-21T19:35:07Z"
        }
      ]
    },
    {
      "number": 50,
      "id": "I_kwDOG2Ho4M5WySxR",
      "title": "Naming for tracks and terminology",
      "url": "https://github.com/moq-wg/moq-transport/issues/50",
      "state": "CLOSED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It has been pointed out to me by multiple people that \"track\" usually can refer to multiple versions of the same video/audio (e.g. 360p and 720p would be same track, but different renditions).  We might want to change terminology in the draft.",
      "createdAt": "2022-11-19T00:13:17Z",
      "updatedAt": "2023-05-28T20:08:53Z",
      "closedAt": "2023-05-28T20:08:53Z",
      "comments": [
        {
          "author": "acbegen",
          "authorAssociation": "NONE",
          "body": "\"Track\" has a specific meaning in the ISO BMFF/mp4/CMAF world, so do segment, fragment and chunk. If you are talking about the variation of the same content, DASH calls them representations and HLS calls them renditions or variant streams. These could be in separate \"track\" files but in that case you are referring to the physical - addressable media - objects rather than the concept itself. The bottomline is that whatever we decide to use, we should be dead clear about their definitions.",
          "createdAt": "2022-11-20T09:06:57Z",
          "updatedAt": "2022-11-20T09:06:57Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I discussed this with Suhas. We concur that 'track' is overloaded especially with the CMAF context, and prefer the term \"representation\" as describing a sequence of media objects which have a consistent  codec, framerate, resolution and content-focus.  \"Rendition\" is also an option, but that is something the CIA does when no-one's watching and I've heard objections to its media use on those grounds.",
          "createdAt": "2022-11-21T18:26:58Z",
          "updatedAt": "2022-11-21T18:26:58Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "  It might help define terms  and say how is that maps to CMAF when using CMAF containers and say RTP when using RTP based containers .. thoughts ?",
          "createdAt": "2022-11-21T21:14:50Z",
          "updatedAt": "2022-11-21T21:14:50Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm certainly not the most well-versed with video terminology, so definitely correct me if I'm wrong. Also +1 to @acbegen; there will always be inconsistent naming in the industry so we need to clearly define what we're talking about.\r\n\r\nMy understanding is that \"tracks\" in ISOBMFF refer to a single encoding. For example, you could have an MP4 file:\r\n\r\ntrack 1: english audio AAC\r\ntrack 2: spanish audio AAC\r\ntrack 3: english audio OPUS\r\ntrack 4: spanish audio OPUS\r\ntrack 5: H.264 video\r\ntrack 6: AV1 video\r\ntrack 7: english subtitles\r\ntrack 8: spanish subtitles\r\n\r\nEach of these would have a separate `track_id` and `trak` box. In VLC, you would switch between these by selecing them in the \"audio track\" and \"video track\" drop down.",
          "createdAt": "2022-11-22T19:03:12Z",
          "updatedAt": "2022-11-22T23:29:03Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "I feel we need to define our terminology and work back to think how it maps to existing names in different contexts. this will keep our terminology clean of ambiguity and also helps someone coming from different contexts to get an idea of how it maps to the terms they are familair\r\n\r\nTo that extent, i am willing to propose the following \r\n\r\nMedia Representations:\r\n\r\nThese are the media representations examples\r\n-  H.264 video 1080p 60 fps ...\r\n-  H.264 Video 1080p 30 fps ...\r\n- AAC audio  48khz english-lang\r\n- AAC audio 48khz french-lang\r\n- Spanish Subtitles \r\n\r\n\r\nMedia Representation Groups \r\n- Camera 1 is a Group that has following representations under it \r\n  -  H.264 video 1080p 60 fps ... , H.264 Video 1080p 30 fps ...\r\n\r\nMedia Object\r\n   This is any media payload that is being sent and can have one or more container encapsulations. Each container defines how to call the thing inside a given MediaObject ( CMAF Segment, RTP Payload Enc ... )\r\n   \r\n   \r\nThis can then be explains how it maps to CMAF track for example in the text\r\n",
          "createdAt": "2022-11-23T04:41:01Z",
          "updatedAt": "2022-11-23T05:10:11Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "For RTP  we did a similar effort and it was pretty useful\r\n\r\nhttps://datatracker.ietf.org/doc/rfc7656/",
          "createdAt": "2022-11-28T17:45:43Z",
          "updatedAt": "2022-11-28T17:45:43Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "My current proposal would be something:\r\n\r\n- A *broadcast* is the largest individually addressable unit.  It's what you specify when you first connect to a server.\r\n- A *media feed* is the smallest thing that you can subscribe to.  It's equivalent to representation/etc.  There might be a hierarchy of multiple media feeds.  A media feed is an init object plus an ordered sequence of media objects.\r\n- A *media object* is an atomic cachable entry.\r\n\r\nWe also need some terminology for feeds that are interchangeable.",
          "createdAt": "2022-11-28T19:18:41Z",
          "updatedAt": "2022-11-28T19:18:41Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I started exploring terminology in some existing specifications: #56",
          "createdAt": "2022-11-28T23:43:49Z",
          "updatedAt": "2022-11-28T23:43:49Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "#55 is also relevant",
          "createdAt": "2022-12-20T23:26:18Z",
          "updatedAt": "2022-12-20T23:26:18Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd like to propose the term \"catalog\" to refer to a text file describing the media feeds available in a broadcast (to use Victor's taxonomy). This is as an alternative to \"manifest\" or \"playlist\", both of which have overloaded meaning in HLS and DASH.",
          "createdAt": "2022-12-21T23:16:56Z",
          "updatedAt": "2022-12-21T23:16:56Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I think catalog/track/group/object are reasonably well explained now, do we need more?",
          "createdAt": "2023-05-05T20:27:10Z",
          "updatedAt": "2023-05-05T20:27:10Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "@vasilvv are you ok to close this?  We seem to have baked track into the draft at this point, including naming concepts like \"Full Track Name\".",
          "createdAt": "2023-05-26T23:45:10Z",
          "updatedAt": "2023-05-26T23:45:10Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed, let's close this.",
          "createdAt": "2023-05-28T20:08:53Z",
          "updatedAt": "2023-05-28T20:08:53Z"
        }
      ]
    },
    {
      "number": 51,
      "id": "I_kwDOG2Ho4M5XFR4U",
      "title": "Allow subscribes to request for individual things or group of things",
      "url": "https://github.com/moq-wg/moq-transport/issues/51",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Based on our brainstorming today, adding a note here.\r\n\r\n1. We need a way for a given subscriber to be able to request a group of things that match a certain parts of the Media resource being published to support pushing of those objects as and when they are available\r\n2.  There is also use-cases where an subscriber can ask for a specific object\r\n\r\nI think we need to support both ?",
      "createdAt": "2022-11-23T04:43:50Z",
      "updatedAt": "2023-05-05T19:55:01Z",
      "closedAt": "2023-05-05T19:55:01Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "The receiver also needs to specify which tracks are supported. For example, there may be 5 renditions ranging from 240p to 1080p, but a device might not support all of them due to the profile, resolution, etc.",
          "createdAt": "2022-11-23T22:53:08Z",
          "updatedAt": "2022-11-23T22:53:08Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "@suhasHere regarding this\r\n\r\n> request a group of things that match a certain parts of the Media resource\r\n\r\nCan you give an example of what you are trying to achieve here?",
          "createdAt": "2022-12-20T23:28:25Z",
          "updatedAt": "2022-12-20T23:28:25Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Does the current format of SUBSCRIBE_REQUEST with optional Group and Object sequence meet the requirements here?",
          "createdAt": "2023-04-21T19:36:24Z",
          "updatedAt": "2023-04-21T19:36:24Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "SUBSCRIBE REQUEST now supports requesting entire track, track from starting group, track from starting group/object, and has parameters which can be further use to specify what can be requested.",
          "createdAt": "2023-05-05T19:55:01Z",
          "updatedAt": "2023-05-05T19:55:01Z"
        }
      ]
    },
    {
      "number": 52,
      "id": "I_kwDOG2Ho4M5XFSVO",
      "title": "Subscribe with time offset",
      "url": "https://github.com/moq-wg/moq-transport/issues/52",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It would be good if a subscriber can specify he is interested to in the media being sent starting from a given time offset\r\n\r\nFor the first phase, we can keep it focussed on time offsets that is closer to live edge and may be expand eventually to support DVR like long running time offsets.",
      "createdAt": "2022-11-23T04:45:51Z",
      "updatedAt": "2023-08-08T05:35:54Z",
      "closedAt": "2023-08-08T05:35:54Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "side note; I'd like to see this use the presentation timestamp instead of the GoP sequence number. It should be possible to use an absolute timestamp (ex. 3:12) and a relative timestamp (ex. 5s before live).",
          "createdAt": "2023-01-28T18:40:34Z",
          "updatedAt": "2023-01-28T18:40:34Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "@suhasHere : this is kind of an old issue, has it beed overtaken by events?  The current draft allows for subscribing against track, track+group, or track+object+group.  There is also a generic Track Parameters struct in the SUBSCRIBE REQUEST that would allow for extensions, such as querying by Timestamp *if* the publisher supported that.",
          "createdAt": "2023-05-26T23:43:45Z",
          "updatedAt": "2023-05-26T23:43:45Z"
        }
      ]
    },
    {
      "number": 53,
      "id": "I_kwDOG2Ho4M5XFSva",
      "title": "Something like Manifest",
      "url": "https://github.com/moq-wg/moq-transport/issues/53",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "There are few ideas floating around merging manifest and decoder init info that is cached and can be provided to clients. Also being able to send updated Manifests as needed.\r\n\r\nBut the goal here is being the realm of manifes-less ( not to require millions of mnifest updates as is done in HLS today)",
      "createdAt": "2022-11-23T04:47:39Z",
      "updatedAt": "2023-01-29T05:22:16Z",
      "closedAt": "2023-01-29T05:22:16Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Does PUBLISH_TRACK from #43 meet the need you are describing here?",
          "createdAt": "2022-12-20T23:32:02Z",
          "updatedAt": "2022-12-20T23:32:02Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "@kixelated can this be closed now that CATALOG PR has been merged?",
          "createdAt": "2023-01-21T03:09:48Z",
          "updatedAt": "2023-01-21T03:09:48Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah I think CATALOG meets this requirement, even if there's some noise around the format.",
          "createdAt": "2023-01-29T05:22:08Z",
          "updatedAt": "2023-01-29T05:22:08Z"
        }
      ]
    },
    {
      "number": 54,
      "id": "I_kwDOG2Ho4M5XFTmt",
      "title": "Add text to talk about Relays and Pub/Sub",
      "url": "https://github.com/moq-wg/moq-transport/issues/54",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "suhasHere"
      ],
      "labels": [],
      "body": "The draft should specify more information on aspects of Relays such as their role in forwarding/caching, interactions with pub/sub flow and the data model to meet the charter goals (https://datatracker.ietf.org/wg/moq/about/)\r\n",
      "createdAt": "2022-11-23T04:51:22Z",
      "updatedAt": "2023-05-05T19:49:52Z",
      "closedAt": "2023-05-05T19:49:52Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Is this a duplicate of #112 now - can merge them?",
          "createdAt": "2023-04-21T19:37:27Z",
          "updatedAt": "2023-04-21T19:37:27Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Duplicate of #112",
          "createdAt": "2023-05-05T19:49:52Z",
          "updatedAt": "2023-05-05T19:49:52Z"
        }
      ]
    },
    {
      "number": 57,
      "id": "I_kwDOG2Ho4M5aICYi",
      "title": "Slice as segment",
      "url": "https://github.com/moq-wg/moq-transport/issues/57",
      "state": "OPEN",
      "author": "ZmGorynych",
      "authorAssociation": "NONE",
      "assignees": [
        "suhasHere"
      ],
      "labels": [
        "NotTransport"
      ],
      "body": "In some ultra low latency use cases a video frame is encoded in multiple slices (which are independently decodable complete NAL units) and the upper slices are ready earlier than the ones on the bottom. In case of gradual decoder refresh, some slices may be intra-coded and some can be inter-coded.\r\nA frequent optimization is to send slices as they are ready as opposed to waiting till the end of the frame. It looks like this use case is not supported in the draft  ",
      "createdAt": "2022-12-27T18:25:35Z",
      "updatedAt": "2023-10-18T02:55:20Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, I think breaking the media into slices will eventually be necessary. I don't have much experience with gradual decoder refresh but it makes a ton of sense for smoothing out IDR bitrate spike.",
          "createdAt": "2023-01-07T19:05:15Z",
          "updatedAt": "2023-01-07T19:05:15Z"
        },
        {
          "author": "acbegen",
          "authorAssociation": "NONE",
          "body": "I suppose the subject should be \"slice as a stream\" and this will certainly make sense in certain low-latency apps, especially in interactive ones.",
          "createdAt": "2023-01-16T09:49:39Z",
          "updatedAt": "2023-01-16T09:49:39Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@ZmGorynych, does the proposed update help  #69  . I have seem many low latency use-cases needing sort of grouping this issue raises",
          "createdAt": "2023-01-26T13:15:47Z",
          "updatedAt": "2023-01-26T13:15:47Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think it would be just fine to encode each slice as a separate object, and use metadata to manage transmission order, priorities, etc. For example, upper slices would be marked at higher priority than slices with fine details, and would be sent first. In case of congestion, relays might drop the details.",
          "createdAt": "2023-03-07T01:50:32Z",
          "updatedAt": "2023-03-07T01:50:32Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree an applications should be able to choose to do an object per slice.  If a slice is lost, some video devices want to display the rest of the frame that was received. Some application choose not to show the whole frame if any part of it was not received. I think that should be an application choice and it would probably change how the application decided to to put slices or full frames into single objects. \r\n",
          "createdAt": "2023-03-12T16:19:12Z",
          "updatedAt": "2023-03-12T16:19:12Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "This seems like a valid use case, but I'm unsure anything needs to be added to the transport draft to address it.",
          "createdAt": "2023-07-24T12:57:49Z",
          "updatedAt": "2023-07-24T12:57:49Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "moq-usages draft address some of the discussions around such an encoding. Agree with @ianswett , this is application defined and not specific to MOQT.",
          "createdAt": "2023-07-24T21:31:49Z",
          "updatedAt": "2023-07-24T21:31:49Z"
        }
      ]
    },
    {
      "number": 58,
      "id": "I_kwDOG2Ho4M5aIDIT",
      "title": "Marking references",
      "url": "https://github.com/moq-wg/moq-transport/issues/58",
      "state": "CLOSED",
      "author": "ZmGorynych",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Marking reference list (i.e., which frame(s) depend on which) is non-trivial and complex (it requires parsing of bitstream headers). It may be simpler to use temporal layers for the purpose. In some codecs, these are explicitly signaled. In some codecs they may be inferred (e.g. IDR frames are 0, P frames are 1, reference B's are 2, non-reference B are 3). In this case a loss of a frame at level X leads to dropping frames of a higher layer until end of the GOP is reached. This may be much easier to handle.",
      "createdAt": "2022-12-27T18:30:16Z",
      "updatedAt": "2023-07-24T21:55:02Z",
      "closedAt": "2023-07-24T21:55:02Z",
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 ... IIRC similar concerns were raised during IETF 115.  May be we need to think on it a bit and if it is an end to end information, then it is better left in the payload header rather than object metadata (as it is today)\r\n\r\nWithin QUICR, we did support a 8 bit flags defined as\r\n1 bit - is discardable or not to identify if a given object is independent or not\r\n3 bits for relative priority . This is used by application to say my i-frame is more important than b-frame than p-frame  .. 3 bits would cover most of the cases.\r\n\r\ntop-order 4 bits are RESERVED\r\n\r\n@ZmGorynych would something like that work ?",
          "createdAt": "2023-01-07T18:31:27Z",
          "updatedAt": "2023-01-07T18:31:27Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd like to remove the dependency list entirely for all of the reasons you mentioned.\r\n\r\nIMO relays should _only_ use the delivery order to determine what to deliver during congestion. Knowing what frames are droppable isn't actually useful, and might conflict with the delivery order.\r\n\r\nThe only reason why I kept the dependency list is for stuff like init segments. However I think that's solved with the CATALOG PR that I'm about to post.",
          "createdAt": "2023-01-07T19:22:48Z",
          "updatedAt": "2023-01-07T19:22:48Z"
        },
        {
          "author": "ZmGorynych",
          "authorAssociation": "NONE",
          "body": "This should work.\n\nWe need some additional logic saying that e.g. if a single non-discardable\nframe with priority X was discarded, all video frames with same or higher\npriority may be discarded.\n\nOn Sat, Jan 7, 2023, 11:31 AM Suhas Nandakumar ***@***.***>\nwrote:\n\n> +1 ... IIRC similar concerns were raised during IETF 115. May be we need\n> to think on it a bit and if it is an end to end information, then it is\n> better left in the payload header rather than object metadata (as it is\n> today)\n>\n> Within QUICR, we did support a 8 bit flags defined as\n> 1 bit - is discardable or not to identify if a given object is independent\n> or not\n> 3 bits for relative priority . This is used by application to say my\n> i-frame is more important than b-frame than p-frame .. 3 bits would cover\n> most of the cases.\n>\n> top-order 4 bits are RESERVED\n>\n> @ZmGorynych <https://github.com/ZmGorynych> would something like that\n> work ?\n>\n> \u2014\n> Reply to this email directly, view it on GitHub\n> <https://github.com/kixelated/warp-draft/issues/58#issuecomment-1374566899>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAGEYZJG6PJEM2U3OATGZMLWRGZAVANCNFSM6AAAAAATKUFYX4>\n> .\n> You are receiving this because you were mentioned.Message ID:\n> ***@***.***>\n>\n",
          "createdAt": "2023-01-07T22:12:42Z",
          "updatedAt": "2023-01-07T22:12:42Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@ZmGorynych  agreed and yes that's the idea. ",
          "createdAt": "2023-01-07T23:20:06Z",
          "updatedAt": "2023-01-07T23:20:06Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd like to have a deterministic mechanism, so some rule or additional logic would be required on top of priority bits.\r\n\r\nFor the real-time case, there's only a buffer of like ~5 frames. There's not much difference between a good and a poor dropping decision given the limited options. And you probably need to generate a new IDR anyway because only dropping non-reference frames likely won't be good enough to recover from congestion.\r\n\r\nFor higher latency scenarios, we've now got a buffer of 100+ frames. There's a HUGE difference between a good and a poor dropping decision, especially with multiple GoPs involved. There's also no strict latency budget so it makes dropping frame less compelling.\r\n\r\nI would focus the discussion on these high latency scenarios since it's significantly more difficult. Having a list of dependencies isn't really enough information for a relay to make the best decision and priority bits are even less information.",
          "createdAt": "2023-01-09T18:37:59Z",
          "updatedAt": "2023-01-09T18:41:38Z"
        },
        {
          "author": "ZmGorynych",
          "authorAssociation": "NONE",
          "body": "For higher latency scenarios you're better off switching to a lower bitrate\n/ resolution. The savings from dropping the cheapest non-reference frames\nwon't be huge (I had an encoding where IDRs were about 200Kbits while\nnon-reference B's were 10Kbits).\n\n\nOn Mon, Jan 9, 2023 at 11:38 AM kixelated ***@***.***> wrote:\n\n> I'd like to have a deterministic mechanism, so some rule or additional\n> logic would be required on top of priority bits.\n>\n> For the real-time case, there's only a buffer of like ~5 frames. There's\n> not much difference between a good and a poor dropping decision given the\n> limited options. And you probably need to generate a new IDR anyway because\n> only dropping non-reference frames won't be good enough.\n>\n> For higher latency scenarios, we've now got a buffer of 100+ frames.\n> There's a HUGE difference between a good and a poor dropping decision,\n> especially with multiple GoPs involved. We also want to avoid dropping\n> frames without a strict latency budget.\n>\n> The fundamental latency problem with HLS/DASH (that I'm trying to address)\n> is that they do not have a strategy to drop frames during congestion. I\n> would focus the discussion on these high latency scenarios and if priority\n> bits are sufficient.\n>\n> \u2014\n> Reply to this email directly, view it on GitHub\n> <https://github.com/kixelated/warp-draft/issues/58#issuecomment-1376104045>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAGEYZKORYLUCROXHW64ML3WRRLJDANCNFSM6AAAAAATKUFYX4>\n> .\n> You are receiving this because you were mentioned.Message ID:\n> ***@***.***>\n>\n",
          "createdAt": "2023-01-09T21:14:37Z",
          "updatedAt": "2023-01-09T21:14:37Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> For higher latency scenarios you're better off switching to a lower bitrate\n> / resolution. The savings from dropping the cheapest non-reference frames\n> won't be huge (I had an encoding where IDRs were about 200Kbits while\n> non-reference B's were 10Kbits).\n> \n> \n> On Mon, Jan 9, 2023 at 11:38 AM kixelated ***@***.***> wrote:\n> \n> > I'd like to have a deterministic mechanism, so some rule or additional\n> > logic would be required on top of priority bits.\n> >\n> > For the real-time case, there's only a buffer of like ~5 frames. There's\n> > not much difference between a good and a poor dropping decision given the\n> > limited options. And you probably need to generate a new IDR anyway because\n> > only dropping non-reference frames won't be good enough.\n> >\n> > For higher latency scenarios, we've now got a buffer of 100+ frames.\n> > There's a HUGE difference between a good and a poor dropping decision,\n> > especially with multiple GoPs involved. We also want to avoid dropping\n> > frames without a strict latency budget.\n> >\n> > The fundamental latency problem with HLS/DASH (that I'm trying to address)\n> > is that they do not have a strategy to drop frames during congestion. I\n> > would focus the discussion on these high latency scenarios and if priority\n> > bits are sufficient.\n> >\n> > \u2014\n> > Reply to this email directly, view it on GitHub\n> > <https://github.com/kixelated/warp-draft/issues/58#issuecomment-1376104045>,\n> > or unsubscribe\n> > <https://github.com/notifications/unsubscribe-auth/AAGEYZKORYLUCROXHW64ML3WRRLJDANCNFSM6AAAAAATKUFYX4>\n> > .\n> > You are receiving this because you were mentioned.Message ID:\n> > ***@***.***>\n> >\n> \n\nAbsolutely, and I think that's mostly true for real-time media too. Non-reference frames either hurt the image compression (fewer references) or add latency (b-frames). I don't think WebRTC uses non-reference frames.\n\nThe core idea behind Warp is to effectively send a priority queue over the network. The \"delivery order\" for each media object is decided by the application and lets the broadcaster set up rules, like audio>video and new>old. It's just a number and relays always just deliver the highest priority objects first.\n\nMy argument is that this scheme works for any sort of latency budget and it's a superset of priority bits. In fact, a good RTP sender should be using a priority queue. You can only send X packets during congestion, so consult the priority queue to determine which ones. A relay could try to recreate the priority queue based on priority bits but it's far easier and less ambiguous to use the delivery order as written on the wire.\n ",
          "createdAt": "2023-01-10T02:06:44Z",
          "updatedAt": "2023-01-10T02:09:09Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "My current plan is to not identify reference frames or dependencies as part of the transport. That information is inside of the container/codec so the decoder can still function.\n\nThe transport should only use the delivery order. We might extend that but I don't want a full dependency tree.",
          "createdAt": "2023-01-29T05:20:45Z",
          "updatedAt": "2023-01-29T05:20:45Z"
        },
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "Full dependency tree is too complicated and unneccessary. In the end you may need to group multiple depended objects into one schedule unit to save the processing overhead. ",
          "createdAt": "2023-01-29T07:46:26Z",
          "updatedAt": "2023-01-29T07:46:26Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Assigned to Christian",
          "createdAt": "2023-02-01T22:35:02Z",
          "updatedAt": "2023-02-01T22:35:02Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Picking this up. I will propose a PR.",
          "createdAt": "2023-02-01T22:39:18Z",
          "updatedAt": "2023-02-01T22:39:18Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we need to find a middle ground between no dependency graph and a full dependency graph.\r\n\r\nThe broadcaster may have to parse the encoded bitstream if the encoder doesn't expose an API to get frame references. This could be easy (identifying GoPs) to difficult (parsing the full reference list). I certainly think an advanced broadcaster should be able to parse the full reference list, but I don't want it to be a requirement.\r\n\r\nA relay will have to support whatever schemes we support. A full reference list is going to involve a lot of book-keeping so ideally we can minimize the amount of work required.\r\n",
          "createdAt": "2023-02-02T14:31:44Z",
          "updatedAt": "2023-02-02T14:31:44Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Jumping back to London, I had a few relevant slides although they were about a slightly different context:\r\n\r\n### Example GoP structure\r\n![image](https://user-images.githubusercontent.com/432854/216355309-b5875bb5-c74f-4f67-9dd1-954f8cb4fb75.png)\r\n\r\nIt's  a relatively simple but interesting encoding. You can replace the B frames with non-reference P frames; it's the same thing.\r\n\r\n\r\n### Group dependencies by GoP\r\n![image](https://user-images.githubusercontent.com/432854/216352739-99d22900-c3f0-48a5-90da-59bac77a62df.png)\r\n\r\nThis is group ID in QUICR and the entire stream when Warp was GoP delivery only. It's good enough to start playback although you end up potentially downloading useless non-reference frames. In this example, if you wanted to start playback at frame 4, you would end up unnecessarily downloading frame 1\r\n\r\n\r\n### Group dependencies by layer\r\n![image](https://user-images.githubusercontent.com/432854/216353192-ddde432a-2600-4f65-ad2f-71d410ce96f3.png)\r\n\r\nInspired by SVC, but not quite the same. Layers can depend on each other, creating a crude dependency graph. A layer may introduce non-existent dependencies, like how frame 3 shouldn't actually depend on frame 1 in this example. It also creates some unnecessary downloads if you tried to start playback at frame 1 (would download 2&4 first).\r\n\r\n\r\n### Group dependencies by layer, but layers can be as small as a frame\r\n![image](https://user-images.githubusercontent.com/432854/216354047-d2a21521-6d20-4d46-bd1f-7b84eb9cee3e.png)\r\n\r\nThis is a more accurate dependency graph although it's still not completely correct unless you can specify and offset with the dependency. If not, you run into the same problem with above if you tried to start playback at frame 1.\r\n\r\n\r\n### List dependencies by frame\r\n![image](https://user-images.githubusercontent.com/432854/216354472-775cfed1-7781-4dc9-a87d-fe3054307a34.png)\r\n\r\nThis is a full dependency graph. Perfect is the enemy of simplicity though.",
          "createdAt": "2023-02-02T14:49:51Z",
          "updatedAt": "2023-02-02T14:56:12Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh and Victor has a PR already #86 if it's similar to what you were thinking @huitema. I think it's a fine starting point, but it's not optimal for non-reference frames, intra-frame refresh, and SVC. But maybe it doesn't need to be.",
          "createdAt": "2023-02-02T15:36:42Z",
          "updatedAt": "2023-02-02T15:37:23Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Based on @kixelated suggestion, closing this as obsolete.\r\n\r\nIf there's an issue we want to extract from this, please create a new issue.",
          "createdAt": "2023-07-24T21:55:02Z",
          "updatedAt": "2023-07-24T21:55:02Z"
        }
      ]
    },
    {
      "number": 64,
      "id": "I_kwDOG2Ho4M5cSlj2",
      "title": "Catalog track definition insufficient to communicate client selection criteria",
      "url": "https://github.com/moq-wg/moq-transport/issues/64",
      "state": "OPEN",
      "author": "wilaw",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "wilaw"
      ],
      "labels": [
        "streaming format draft",
        "NotTransport"
      ],
      "body": "The current CATALOG allows for an overly simplistic track definition\r\n\r\n> Track Descriptor {\r\n>   Track ID (i),\r\n>   Container Format (i),\r\n>   Container Init Payload (b)\r\n> }\r\n\r\nThese fields do not include sufficient semantics to communicate selection criteria present in modern streaming productions. Some examples would include:\r\n\r\n- language  - audio tracks in english, french german\r\n- accessibility options - video description, signing\r\n- captions\r\n- subtitles \r\n- codec - HEVC, AVC, VVC\r\n- resolution - 1080p, 2160p, \r\n- framerate - 30,60,24\r\n- spatial audio - 5.1, Dolby Atmos\r\n",
      "createdAt": "2023-01-19T01:21:12Z",
      "updatedAt": "2023-11-10T12:17:08Z",
      "closedAt": null,
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "That is by design.  All of those are available in the Container Init Payload, which in case of fMP4 would contain a MOOV atom.",
          "createdAt": "2023-01-21T03:03:44Z",
          "updatedAt": "2023-01-21T03:03:44Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "This assumes fMP4 as the only container format and supports a specific set of use-cases with specific set of constraints\r\n",
          "createdAt": "2023-01-22T01:42:55Z",
          "updatedAt": "2023-01-22T01:42:55Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Indeed, if you are defining a format that is not fMP4, you would need to figure out how to specify all of those details for the newly defined format.",
          "createdAt": "2023-01-22T17:13:48Z",
          "updatedAt": "2023-01-22T17:13:48Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "That's true ... but I am not seeing a reason why CATALOG message define any structure .. All it needs is \r\n\r\n```\r\nCATALOG Message {\r\n  WarpStreamid/TrackId\r\n [Container Type(8)],\r\n  Length(i),\r\n  Payload(...)...\r\n}\r\n``` \r\nplease note the catalog payload might be encrypted too and its contents is not useful for intermediaries .",
          "createdAt": "2023-01-23T23:16:04Z",
          "updatedAt": "2023-01-23T23:16:54Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> That's true ... but I am not seeing a reason why CATALOG message define any structure .. All it needs is\r\n> \r\n> ```\r\n> CATALOG Message {\r\n>   WarpStreamid/TrackId\r\n>  [Container Type(8)],\r\n>   Length(i),\r\n>   Payload(...)...\r\n> }\r\n> ```\r\n> \r\n> please note the catalog payload might be encrypted too and its contents is not useful for intermediaries .\r\n\r\nYep that's the idea, and is almost verbatim in the draft. The only difference is that a CATALOG message can have multiple tracks, but each `Track Descriptor` is exactly as you described.\r\n\r\nI like the idea of splitting each track descriptor into a separate message (#43 had the TRACK message) so tracks can be added/updated/removed independently. The CATALOG message with all tracks was a compromise.",
          "createdAt": "2023-01-27T14:53:22Z",
          "updatedAt": "2023-01-27T14:53:22Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> The current CATALOG allows for an overly simplistic track definition\r\n> \r\n> > Track Descriptor {\r\n> > Track ID (i),\r\n> > Container Format (i),\r\n> > Container Init Payload (b)\r\n> > }\r\n> \r\n> These fields do not include sufficient semantics to communicate selection criteria present in modern streaming productions. Some examples would include:\r\n> \r\n> * language  - audio tracks in english, french german\r\n> * accessibility options - video description, signing\r\n> * captions\r\n> * subtitles\r\n> * codec - HEVC, AVC, VVC\r\n> * resolution - 1080p, 2160p,\r\n> * framerate - 30,60,24\r\n> * spatial audio - 5.1, Dolby Atmos\r\n\r\nLike Victor mentioned, [he realized](https://github.com/kixelated/warp-draft/pull/43#issuecomment-1319023237) that most of this stuff was already in the fMP4 init segment (`trak` box) and it was redundant to include in the CATALOG. The relay shouldn't parse any of this information so it's nice to delegate it to an opaque \"container format\" blob that only the broadcaster/viewer will support.\r\n\r\nI think all of your examples are present in `trak` but there's a few things missing in fMP4 that might be useful, like peak bitrate, and we should discuss how to add those fields. Modify fMP4? Add a new track format? Add additional fields to the CATALOG message?\r\n\r\nI'd love to see us specify more track formats. A possible example would be \"HLS\", where the `Container Init Payload` would be a `EXT-X-STREAM-INF` string and the `Object Payload` would be a TS segment (including SPS/PPS). And possibly rename \"container\" to something else (\"track format\"?) so it's less confusing.",
          "createdAt": "2023-01-27T16:02:20Z",
          "updatedAt": "2023-01-27T16:03:47Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Label for Ted: Architectural",
          "createdAt": "2023-01-28T00:17:59Z",
          "updatedAt": "2023-01-28T00:17:59Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The resolution of this issue depends on two other issues - specifically [Relax the CATALOG definition to decouple the base protocol from the streaming format #66](https://github.com/kixelated/warp-draft/issues/66) and [Move Catalog details to its own spec #85](https://github.com/kixelated/warp-draft/issues/85). If either of these issues is adopted, then the track definition will be a function of the CATALOG description that may or may not reside in a separate spec. \r\n\r\nIf neither issue is adopted, then we need to address how to extend the the current WARP draft track definition. \r\n\r\n> here's a few things missing in fMP4 that might be useful, like peak bitrate, and we should discuss how to add those fields. Modify fMP4? Add a new track format? Add additional fields to the CATALOG message?\r\n\r\n@kixelated  - modifying fmp4 via ISO/MPEG will take a long time and is not a process we would want to follow for ad-hoc changes to selection criteria. The more flexible path for MoQ would be to extend the track format and/or CATALOG message fields to hold the new selection criteria. While we could hang new fields off of CATALOG, they would increase with application requirements. Consider for example a live VR game in which the client subscribes to streaming mp4 texture maps based on spatial location, velocity and degree-of-invisibility (i'm making that up to illustrate my point). We could add TRACK.location, TRACK.velocity and TRACK.invisibility.  This could take a year or so to push through IETF. Then we'd need to wait for relay providers  to pick up those changes and deploy support for them. That could take another year. That's a long delay before the game developer could use MoQ to stream their game in production. And that's just one application. What if there were ten different ones that all needed different fields in the CATALOG. After years of updates, we'd have 50 or more custom fields in TRACK catering to different applications. So a more flexible approach would be define a standardized key/value selection field for TRACK for carrying application-specific selection criteria not contained within the INIT object. For example TRACK.SELECTION = [{key:value}]. This could be used by all applications for custom selection and it would not require any spec updates. ",
          "createdAt": "2023-02-27T20:21:00Z",
          "updatedAt": "2023-02-27T20:21:00Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Catalog track definitions are being moved out to https://github.com/wilaw/MoQ, so maybe we can close this?",
          "createdAt": "2023-05-05T20:25:03Z",
          "updatedAt": "2023-05-05T20:25:03Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "@wilaw do you have this issue captured in your repo and can you close this out?",
          "createdAt": "2023-05-26T23:41:58Z",
          "updatedAt": "2023-05-26T23:41:58Z"
        }
      ]
    },
    {
      "number": 65,
      "id": "I_kwDOG2Ho4M5ceVOy",
      "title": "Optimize OBJECT message metadata by requiring Object ID to define delivery order",
      "url": "https://github.com/moq-wg/moq-transport/issues/65",
      "state": "CLOSED",
      "author": "wilaw",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The Object message contains header info including separate fields for Object ID and Delivery Order. \r\n\r\n```\r\nOBJECT Message {\r\n  Broadcast URI (b)\r\n  Track ID (i),\r\n  Object ID (i),\r\n  Object Delivery Order (i),\r\n  Object Payload (b),\r\n}\r\n```\r\n\r\nGiven that is in distribution interest to keep this metadata overhead as small as possible, one optimization would be to constrain the Object ID to be a monotonically increasing integer and then remove the Object Delivery Order Field, as the ObjectID could then serve a dual purpose of identifying both the object and its order. new message structure would be:\r\n\r\n```\r\nOBJECT Message {\r\n  Broadcast URI (b)\r\n  Track ID (i),\r\n  Object ID (i),\r\n  Object Payload (b),\r\n}\r\n```\r\n\r\nAre there any use-cases under which an integer Object ID cannot reasonably be made to work?\r\n\r\n",
      "createdAt": "2023-01-20T21:10:34Z",
      "updatedAt": "2023-01-21T02:28:40Z",
      "closedAt": "2023-01-21T02:28:40Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Object ID needs to be unique but I don't think delivery order does?  \r\n\r\nFrom 5.4 prioritization: \r\n\r\n> If two streams have the same delivery order, they SHOULD receive equal bandwidth (round-robin).",
          "createdAt": "2023-01-20T22:17:47Z",
          "updatedAt": "2023-01-20T22:17:47Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In my reading of 6.2, ObjectID has to be unique within the scope of Broadcast URI + trackID. So you could name the first object in every track \"1\". \r\n\r\nI was interpreting the order value as the objects order within the track. Since the objects are sent one-per-stream, this allows the receiver to re-order the objects in decode order, since receipt order is not guaranteed between streams. \r\n\r\nCloser reading of 5.4 however indicates that this \"order\" functions as a priority for transport-level prioritization, not for intra-object re-ordering. In that case it cannot be coupled with the object ID . Closing this tissue. ",
          "createdAt": "2023-01-21T02:28:40Z",
          "updatedAt": "2023-01-21T02:28:40Z"
        }
      ]
    },
    {
      "number": 66,
      "id": "I_kwDOG2Ho4M5cemPl",
      "title": "Relax the CATALOG definition to decouple the base protocol from the streaming format ",
      "url": "https://github.com/moq-wg/moq-transport/issues/66",
      "state": "CLOSED",
      "author": "wilaw",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "vasilvv",
        "wilaw"
      ],
      "labels": [],
      "body": "The success of HTTP streaming is partly due to the fact that it is built upon ubiquitous low level API, namely HTTP/S GET, POST of binary files.  The distribution architecture (ingest, caching nodes, edge nodes, routers etc) only has to be built to support this API. On top of that can be layered many streaming protocols - such as HLS, Smooth, HDS and DASH. These streaming protocols can innovate and co-exist and also evolve their features without having to make any changes to the distribution network. The distribution network is unaware of the internal workings for the streaming formats. This decoupling allows good economics (any distribution network can deliver any streaming format), scale (because distribution networks are not specific to a streaming format) and innovation ( networks and formats can be improved independently of one another, as long as the both preserve the API interface). \r\n\r\nThe current WARP architecture is a relatively tight binding of streaming format to pub/sub architecture, with the CATALOG message having explicit descriptors for a f4mp4 solution with init segments. This is not broad enough to address all the [use-cases](https://datatracker.ietf.org/doc/draft-gruessing-moq-requirements/) that have been defined for MoQ to address.  \r\n\r\nOne option is to keep adding explicit fields to the CATALOG message as we encounter new use-cases. An alternative approach is that MoQ define a Common Base Protocol of core APIs. These can be very simple constructs such as AUTH,PUBLISH, SUBSCRIBE, ERROR commands and message structure, essentially much of what WARP draft defines. On top of this Base Protocol we can define and operate various streaming formats. Some might use fmp4 only with a 2s delay target, others might focus on real-time communications. But they can coexists and have quite different CATALOG contents. The benefits of economics, scale and flexibility will apply to this MoQ distribution infra as they have applied to HTTP. The WARP draft 03 actually meets many of the requirements for a base protocol definition. \r\n\r\nThe primary change that needs to be made is to make the CATALOG message more generic. **The CATALOG message should have a single payload** , rather than a set of fixed fields such as track count, track descriptors, init payload etc. The catalog is a contract between the publisher and the subscriber and defines all the information necessary for the subscriber to subscribe to the broadcast.  At no point should relays have to understand or parse the catalog. It needs to contain a broadcastID and subscribeID(s), but how it does this can be defined differently by formats that extend Common Base Protocol. A simple instantiation of the payload could be a binary encoding of a JSON file. Why text ?- because it's easy for humans to read, manipulate and debug. Don't equate text with the verboseness of HLS playlists. This CATALOG can be intentionally concise and unless the content of the broadcast changes, need only be sent once. \r\n",
      "createdAt": "2023-01-20T22:21:04Z",
      "updatedAt": "2023-05-26T05:36:01Z",
      "closedAt": "2023-05-26T05:36:01Z",
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "+1  to Will's comments here. Catalog should be opaque within the media delivery network and can be cached at edges like media objects. In some cases, it is also preferred to encrypt the contents so to avoid metadata leakage while traversing the network\r\n\r\nTo the extent, Catalogs should be a kind of Media Object and publishers/subscribers can use the same mechanisms for distribting catalogs",
          "createdAt": "2023-01-22T01:41:50Z",
          "updatedAt": "2023-01-22T01:41:50Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "> The current WARP architecture is a relatively tight binding of streaming format to pub/sub architecture, with the CATALOG message having explicit descriptors for a f4mp4 solution with init segments.\r\n\r\nfMP4 is one of the formats described, but as far as I am aware, nothing in the spec requires relays to be aware of the format details.\r\n\r\n> This is not broad enough to address all the [use-cases](https://datatracker.ietf.org/doc/draft-gruessing-moq-requirements/) that have been defined for MoQ to address.\r\n\r\nCould you say more about the specific use cases and the specific problems encountered by those?\r\n\r\n> The CATALOG message should have a single payload , rather than a set of fixed fields such as track count, track descriptors, init payload etc. \r\n\r\nI do not believe this is feasible.  The tracks are a protocol-level concept, and any WARP/MoQ implementation has to be aware of different tracks since they are layered onto different QUIC streams.",
          "createdAt": "2023-01-22T17:35:52Z",
          "updatedAt": "2023-01-22T17:35:52Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> > The current WARP architecture is a relatively tight binding of streaming format to pub/sub architecture, with the CATALOG message having explicit descriptors for a f4mp4 solution with init segments.\r\n> \r\n> fMP4 is one of the formats described, but as far as I am aware, nothing in the spec requires relays to be aware of the format details.\r\n> \r\n> > This is not broad enough to address all the [use-cases](https://datatracker.ietf.org/doc/draft-gruessing-moq-requirements/) that have been defined for MoQ to address.\r\n> \r\n> Could you say more about the specific use cases and the specific problems encountered by those?\r\n> \r\n> > The CATALOG message should have a single payload , rather than a set of fixed fields such as track count, track descriptors, init payload etc.\r\n> \r\n> I do not believe this is feasible. The tracks are a protocol-level concept, and any WARP/MoQ implementation has to be aware of different tracks since they are layered onto different QUIC streams.\r\n\r\nYes tracks/streams are protocol level concepts but its for application to define its structure. This specification should mention that a catalog message lists the various resources (Tracks/warpStreams/Representations) but shouldn't define its encoding. ",
          "createdAt": "2023-01-23T20:18:48Z",
          "updatedAt": "2023-01-23T20:18:48Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I do not believe this is feasible. The tracks are a protocol-level concept, and any WARP/MoQ implementation has to be aware of different tracks since they are layered onto different QUIC streams.\r\n\r\nIn my reading of the current warp-draft, tracks are an application level concept. Warp-draft specifies a protocol for handling the routing of message objects, not of tracks. A sender MUST send each object over a dedicated QUIC stream. Relays see a flow of streams where each stream contains an object. They forward these objects according to the priority defined for each one and to subscribers based upon a match of the BroadcastID and the TrackID. The only components aware that a particular flow of these objects constitute a media track are the publisher and subscriber. The trackID in the message object is a bit of a misnomer - it could be called subscriptionID to better reflect its purpose. ",
          "createdAt": "2023-01-23T23:07:17Z",
          "updatedAt": "2023-01-23T23:07:17Z"
        },
        {
          "author": "gwendalsimon",
          "authorAssociation": "NONE",
          "body": "Reading the draft with fresh eyes (sorry if I miss past intense conversations), the idea behind CATALOG (and more generally Warp broadcast) is pretty obscure. Is it an attempt to reproduce (with new terms and concepts) a DASH manifest? \r\nI can understand why the QUIC underlying protocol and the considered use-cases can require some changes in the definition of media segments, but I am not sure to understand why we would need to change the overall signalling between the client and the server. \r\nIn last year's [DASH-IF exploration group on WebRTC](https://dashif.org/webRTC/report.html), one of the proposals was the integration of session descriptors (related to SDP) into DASH adaptation sets so that we eventually have one common support for discovering the multiple \"variants\" of a content (being regular DASH segments or WebRTC gateway endpoints). Wouldn't it be possible to do the same with WARP and to describe the Track(s) into an adaptation set?",
          "createdAt": "2023-01-24T17:58:57Z",
          "updatedAt": "2023-01-24T17:58:57Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Wouldn't it be possible to do the same with WARP and to describe the Track(s) into an adaptation set?\r\n\r\nWhile it is appealing to conceptualize a single document describing the availability of content delivered via HTTP, WebRTC and MoQ, the semantics of  Manifest/AdaptationSet/Representation and the mpd structure was developed by MPEG and is encumbered by their IP rules. I'm not clear enough on IETF IPR policies to know if that is something that could be leveraged directly? ",
          "createdAt": "2023-01-25T16:38:40Z",
          "updatedAt": "2023-01-25T16:38:40Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Label for Ted: Architectural",
          "createdAt": "2023-01-28T00:16:36Z",
          "updatedAt": "2023-01-28T00:16:36Z"
        },
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "+1 to Will about decoupling the base protocol with the payload codec/format. Relay does not have to be aware of the media payload(it may be encrypted end-to-end anyway). \r\n\r\nWhether the CATALOG contains the track ID and track count depends on what kind of service we want the relay network to provide. If the relay network only provide the object forwarding service, then we do not need to expose the track concept.  If the relay network need to provide track(WarpStream from #69) forwarding service, then the track ID and track count is necessary at least for relay at the edge.",
          "createdAt": "2023-01-28T08:44:12Z",
          "updatedAt": "2023-01-28T08:44:12Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "The QUICR architecture is appealing because it's generic. It's a standard pub/sub framework with some different terminology. In RabbitMQ terms it's a topic exchange; messages are routed to queues based on wildcard routing keys.\r\n\r\nBut first and foremost we're building a live media protocol. I too share the desire to only route objects based on their URI like RabbitMQ, but it gets increasingly difficult to meet all of the live media requirements. I'm afraid that if our primary goal is to develop a generic protocol, then we'll end up with a protocol that does a poor job delivering media while simultaneously being too specialized for other use-cases.\r\n\r\nMy suggestion is to work backwards. Let's make sure we check all of the boxes first and later figure out if the protocol can be more applicable to other use-cases. I would love to design the next push-based HTTP but it is not the primary goal.",
          "createdAt": "2023-01-28T12:52:36Z",
          "updatedAt": "2023-01-28T12:52:36Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Anyway, about CATALOG in particular:\r\n\r\nA broadcast is split into associated tracks. These tracks are presentation timestamp aligned and share delivery order space. Broadcast A will not share the same number space as broadcast B.\r\n\r\nI'm looking ahead, but I think for features like DVR, prioritization, server-side ABR, simulcast need a concept of a broadcast, so SUBSCRIBE is scoped to a broadcast for that reason. I'd love to loosen that requirement but I think the relay still needs some indication that specific tracks are grouped together. I don't think it's a controversial place to start.\r\n\r\nBut 100% we don't want the relay having access to anything it doesn't need. The idea behind the container formats is that it's an opaque blob to the relay; it SHOULD NOT parse the contents. We only specify fMP4 at the moment but I totally expect to add more text formats like HLS/DASH.",
          "createdAt": "2023-01-28T12:56:30Z",
          "updatedAt": "2023-01-28T13:04:47Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this issue could be best summarized as \"does the relay need to know about broadcast/track/object relationships?\" \r\n\r\n- If no, then I like the QUICR design. The endpoints exchange some blob and instruct the relay to push objects according to some rules.\r\n- If yes, then we need separate broadcast/track/object IDs. The CATALOG message would provide any additional information needed by the relay, such as the timestamp/order space.\r\n - If maybe, then start by assuming \"yes\" and reevaluate if we can say \"no\" in the future.",
          "createdAt": "2023-01-28T13:13:11Z",
          "updatedAt": "2023-01-28T13:14:13Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Here's what I propose based on the interim discussion\r\n\r\n```\r\nCATALOG Message {\r\n  Broadcast URI (b),\r\n  Format (i),\r\n  Payload (b)\r\n}\r\n```\r\n\r\nwhere\r\n\r\n- Broadcast URI: The broadcast URI defining the session\r\n- Format (i): a registered identifier for the format of the payload\r\n- Payload: a binary object that can be parsed by any client understanding the format. This payload MUST describe the subscription IDs that the client will use to request content. It may define tracks,  selection criteria for those tracks, along with initialization and other useful information for the client. The payload is not intended to be read by relays and may be encrypted for privacy. ",
          "createdAt": "2023-02-01T23:54:44Z",
          "updatedAt": "2023-02-01T23:57:18Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Martin brought up a good point in chat. If a relay doesn't know the valid track IDs, then it will have to forward every SUBSCRIBE to the origin. This could be an abuse vector although I suppose it's no different than HTTP.",
          "createdAt": "2023-02-02T00:29:37Z",
          "updatedAt": "2023-02-02T00:29:37Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The relay does not need to know the trackIDs, as it receives them in the SUBSCRIBE request from the client. The relay has to forward just one subscribe request to the origin, as that is the only way for it to receive the content. Once it has made that one subscribe request for that trackID, any new requests for subscription it can be satisfied from its cache. This is similar to how hierarchical HTTP caching works. \r\n\r\nThe only case is which the relay would have to forward each SUBSCRIBE request to the origin is if the system implemented origin-based AUTH and wanted to authorize each subscribe request in the centralized origin.  That has clear scalability problems and I'd not recommend that we do it. The solution is to delegate auth to the edge relays by way of tokens/certs , which again is what we do with HTTP delivery.\r\n\r\nRegarding abuse, yes, in an open network you do not know if each incoming request is valid or malicious. Today you can ask any CDN server for anything, and it will do a bunch of work trying to find that content for you. This is an attack vector and CDNs as a consequence get DOS'd every day. But they are designed for that and so would our hypothetical MoQ CDN. You can reduce most malicious or fake requests at the edge by requiring some form of authentication to accompany the request. By requiring AUTH on the original webtransport connection, we could better trust subscribe requests that occur within it. ",
          "createdAt": "2023-02-02T18:27:17Z",
          "updatedAt": "2023-02-02T18:27:17Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "It sounds like doing this would also make CATALOG messages entirely optional in the base protocol spec, as that same information could be exchanged out of band.  I do like having an in-band mechanism even if it's somewhat generic (at the base level)",
          "createdAt": "2023-02-03T01:18:33Z",
          "updatedAt": "2023-02-03T01:18:33Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "IMO the CATALOG message and its response should exist in the base protocol and be mandatory to implement on the part of the publisher and relays. For the client, its optional. The majority of clients would use it. Those that can receive the catalog out-of-band would not need to use it. I envisage CATALOGS not being static in the life of a stream. They should update when the mix of content being produced by the publisher changes (i.e a webex user suddenly starts sharing their desktop). To that end, even a client that starts with an out-of-band catalog would still want to SUBSCRIBE to CATALOG updates, so that it can be apprised of any future changes to the subscription IDs on offer. I can also imagine dynamic ad insertion opportunities being signaled by CATALOG changes. Additionally, a CATALOG update to say there is no more content being published would be a clean way to terminate a broadcast. ",
          "createdAt": "2023-02-03T06:15:45Z",
          "updatedAt": "2023-02-03T06:15:45Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Speaking as an individual.\r\n\r\nSo to clarify you mean publishers MUST publish a CATALOG?  Is it ok to define a catalog that is just a URL (pointer to the real catalog)?\r\n\r\nIf the catalog is more dynamic, we may want more than just a single \"CATALOG - here it is\" kind of message, to help endpoints from having to compare two catalogs and try to figure out what changed.  Or maybe an operation type in the message like \"append (add these catalog contents to the previous one), remove (subtract these catalog elements), update (update these catalog elements, leaving the rest unchanged), replace (this is a totally new catalog)\".  My understanding of manifest files is that their lack of append-ability is a major pain point.  I guess if a relay never looks at catalog contents, only append and replace are easily implementable.",
          "createdAt": "2023-02-03T17:54:45Z",
          "updatedAt": "2023-02-03T17:54:45Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> So to clarify you mean publishers MUST publish a CATALOG? \r\n\r\nYes. A publisher MUST create a CATALOG to describe the media tracks that they are producing.\r\n\r\n>  Is it ok to define a catalog that is just a URL (pointer to the real catalog)?\r\n\r\nI guess we could allow that. However it seems a bit strange that we would use an out-of-band mechanism to describe something so central to MoQ as the CATALOG, which is the contract between publisher and subscriber. To enable fast start for clients, the publisher could supply the CATALOG in-band but then also supply it to a 3rd party CMS service which gave it to the client. This would allow the client to know the subscription IDs before joining via MoQ, which would allow it to append them to the CONNECT or SETUP and thereby have the relay immediately start to forward the media, reducing the start time by 1xRTT.\r\n\r\n> If the catalog is more dynamic, we may want more than just a single \"CATALOG - here it is\" kind of message, to help endpoints from having to compare two catalogs and try to figure out what changed.\r\n\r\nYes, this is efficient if the CATALOG is a verbose object and if we can guarantee that subscribers see the full sequence of updates and hence can build up the final model by compositing the delta updates (or patches if its easier to think of them that way). Two problems with this that would need addressing: 1) New subscribers joining late. We would have to teach the relay to cache all old CATALOG messages, including the original and every patch, and then send them to the new subscriber in the correct order when asked to supply the CATALOG. 2) Accrued updates - over a long running web conference among a hundred interactive users, there could be hundreds of CATALOG updates. For late joining clients, these would all need to be sent in the correct order. \r\n\r\n If the CATALOG can me made concise, then having it hold the absolute independent state (versus a relative dependent one) and having the client figure out the difference makes relay forwarding and client joining simpler. I could see allowing both modes and letting implementers choose based upon the anticipated size of their CATALOGS, the rate of change and the duration of the broadcast. My preference would be that we keep the CATALOG as small as possible, that it provide only the current state, and that the clients figure out the difference. ",
          "createdAt": "2023-02-03T23:15:50Z",
          "updatedAt": "2023-02-03T23:15:50Z"
        },
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "Can we treat the CATALOG like the video stream? Priodically sync the full CATALOG(snapshot), delta update in between. Just like the I frame and P frame. In this way, the data model of the CATALOG and the media can be unified.",
          "createdAt": "2023-02-06T06:44:01Z",
          "updatedAt": "2023-02-06T06:44:01Z"
        },
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "Using the term defined in #69, The MoQ media session would be composed by one CATALOG stream + multiple Media streams. Both CATALOG stream and media stream includes group of objects. For video media stream, the object can be frame/slice/GoP. For CATALOG stream, the object can be SETUP message, Paticipant JOIN/LEAVE message, Media JOIN/LEAVE message. SETUP message is a full snapshot of the CATALOG while other message can change the CATALOG.",
          "createdAt": "2023-02-06T07:03:30Z",
          "updatedAt": "2023-02-06T07:03:30Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Consider catalog as another form of track is cleaner in the design. Like objects from a media track are indistinguishable from blob of catalog for the relays.\r\n\r\nClients get list of media tracks from Catalog and they can get catalog trackId as well. Clients would know how to parse these differently\r\n\r\nAgree that we should allow for delivering updated catalog as well. ",
          "createdAt": "2023-02-23T19:37:17Z",
          "updatedAt": "2023-02-23T19:50:48Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@VMatrix1900  - I like the conceptual idea that the Catalog as a type of media stream, with independently decodable points and then deltas in between. There is a nice symmetry there with media. We can debate whether participants joining/leaving should be a separate message type, or just a delta update to the catalog object reflecting the change in available participants. Notions like \"participants\" and \"join/leave\" are very specific to web conferences and have little correlation if the broadcast represents a sports game. If we are to satisfy multiple use-cases with MoQ (as per our charter), then I feel that for MoQ Base protocol we should generalize the CATALOG as some object that has either an  independent state or a dependent state. Per #85, the contents of the catalog can be specified by a separate spec, which for a web conference would define semantics around join/leave and for a sports game might instead describe different camera views, drone footage etc. If we give each CATALOG object a sequence identifier, then we can signal dependency by simply referring to a prior object sequence identifier. \r\n\r\n\r\n```\r\nCATALOG Message {\r\n  Broadcast URI (b),\r\n  Format (i),\r\n  Sequence (i),\r\n  Dependency (i),\r\n  Payload (b)\r\n}\r\n```\r\n\r\nwhere\r\n\r\n- Broadcast URI: The broadcast URI defining the session\r\n- Format (i): a registered identifier for the format of the payload i.e WARP = 1, QUICR = 2\r\n- Sequence (i): an integer that starts at 1 and increases sequentially at the original media publisher. Sequences are scoped to the BroadcastURI.\r\n- Dependency (i): an integer that specifies a prior sequence number on which this message depends. A dependency of 0 signals an independent message. \r\n- Payload: a binary object that can be parsed by any client understanding the format. This payload MUST describe the subscription IDs that the client will use to request content. It may define tracks, selection criteria for those tracks, along with initialization and other useful information for the client. The payload is not intended to be read by relays and may be encrypted for privacy.\r\n\r\n",
          "createdAt": "2023-02-23T21:55:30Z",
          "updatedAt": "2023-02-23T21:55:30Z"
        },
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "> Dependency (i): an integer that specifies a prior sequence number on which this message depends. A dependency of 0 signals an independent message.\r\n\r\nWill a CATALOG object depends on multiple previous objects? Just like a B frame can improve the compression efficiency,  allowing multiple dependency may improve the CATALOG update speed.  \r\n",
          "createdAt": "2023-02-24T03:39:13Z",
          "updatedAt": "2023-02-24T03:39:13Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Will a CATALOG object depends on multiple previous objects?\r\n\r\nI think that's unnecessary complexity. We're not encoding macro-blocks here, we're just communicating the availability of subscribable tracks for a broadcast.  Can you describe a use-case which warrants a multi-parent dependency tree for the CATALOG description? ",
          "createdAt": "2023-02-24T18:45:33Z",
          "updatedAt": "2023-02-24T18:45:33Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@vasilvv  - can you look over this issue, particularly the proposal of https://github.com/kixelated/warp-draft/issues/66#issuecomment-1442481197. We are both assigned to resolve. I'd like to prepare a PR for the  interim meeting next week and will do so, but would prefer your consensus or opinion before doing that. ",
          "createdAt": "2023-02-27T19:24:57Z",
          "updatedAt": "2023-02-27T19:24:57Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think I fully understand the idea proposed in that comment.\r\n\r\n(1) If catalog is a type of the track, how would a player identify which track is the catalog without prior knowledge?\r\n(2) If catalog is a type of the track, why do we need a separate catalog message in the protocol?",
          "createdAt": "2023-02-28T22:27:33Z",
          "updatedAt": "2023-02-28T22:27:33Z"
        },
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "@vasilvv I think your second question answers the first one. We need a separate catalog message to distinguish from the object message.",
          "createdAt": "2023-03-01T02:26:30Z",
          "updatedAt": "2023-03-01T02:26:30Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">  If catalog is a type of the track, how would a player identify which track is the catalog without prior knowledge?\r\n\r\nOne way is for the spec to define a reserved trackID that would always represent the catalog. For example , a trackID of 0. \r\n\r\n> If catalog is a type of the track, why do we need a separate catalog message in the protocol?\r\n\r\nIf we want to use the existing OBJECT message to carry catalog information, and we allow that catalog payload to vary with application, then we would need to take one of these actions:\r\n\r\n- add a field to the OBJECT message indicate the type of catalog that might be carried. This field would be wasted overhead for all audio/video (non-catalog) messages.\r\n- we could define that the catalog payload MUST start with a standard header which defines the type. This limits the binary packing options which different formats may want to explore for their catalogs.\r\n- we could define a new OBJECT ID for each catalog type. For example, current draft specifies just one catalog type of 0x2. However we could define 0x2 = WARP catalog, 0x3 = QUICR, OxN = something else. \r\n- or we keep the separate CATALOG message and adjust its fields as suggested \r\n\r\n",
          "createdAt": "2023-03-01T06:05:23Z",
          "updatedAt": "2023-03-01T06:05:23Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "The more I think about it, the more I like the idea of catalog as its own track.  We had an issue figuring out how to update the catalog before; if we make it its own track, it will become a subject to the timing model of the broadcast, which should help with updating it.\r\n\r\n> One way is for the spec to define a reserved trackID that would always represent the catalog. For example , a trackID of 0.\r\n\r\nI like that idea.\r\n\r\n> add a field to the OBJECT message indicate the type of catalog that might be carried. This field would be wasted overhead for all audio/video (non-catalog) messages.\r\n\r\nI agree that adding a field for this sole purpose seems wasteful.  I suspect that down the line we might find ourselves having to add more optional fields to the OBJECT message, and this would fit in nicely, but right now that is not the case.\r\n\r\n> we could define that the catalog payload MUST start with a standard header which defines the type. This limits the binary packing options which different formats may want to explore for their catalogs.\r\n\r\nI think this is the best answer.  Could you explain how this limits the packing options?  I assume you would just parse the header and then whatever comes after the header is entirely up to the application.\r\n\r\n> we could define a new OBJECT ID for each catalog type. For example, current draft specifies just one catalog type of 0x2. However we could define 0x2 = WARP catalog, 0x3 = QUICR, OxN = something else.\r\n\r\n> or we keep the separate CATALOG message and adjust its fields as suggested\r\n\r\nI feel like not using the OBJECT message kind of defeats the purpose of making catalog be a form of track data.",
          "createdAt": "2023-03-01T07:04:30Z",
          "updatedAt": "2023-03-01T07:04:30Z"
        },
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "> We had an issue figuring out how to update the catalog before; if we make it its own track, it will become a subject to the timing model of the broadcast, which should help with updating it.\r\n\r\nExactly. The catalog shares the timing model with the object message. \r\n\r\nHowever, the CATALOG as a track does not mean that the OBJECT message shares the same header fields with the OBJECT message. For example, the object delivery order field may only apply to the Object message and the CATALOG message is always the highest priority. \r\n\r\n> - add a field to the OBJECT message indicate the type of catalog that might be carried. This field would be wasted overhead for all audio/video (non-catalog) messages.\r\n> - we could define that the catalog payload MUST start with a standard header which defines the type. This limits the binary packing options which different formats may want to explore for their catalogs.\r\n> - we could define a new OBJECT ID for each catalog type. For example, current draft specifies just one catalog type of 0x2. However we could define 0x2 = WARP catalog, 0x3 = QUICR, OxN = something else.\r\n> - or we keep the separate CATALOG message and adjust its fields as suggested\r\n\r\nBasically, above options are about which field to put the type number for CATALOG. I would add another option: use the delivery order 0(highest) to indicate that OBJECT is the CATALOG message.\r\n\r\nI suggest we figure out the format of CATALOG message and OBJECT message separately, then consider if/how to merge them.\r\n\r\n\r\n",
          "createdAt": "2023-03-01T07:51:06Z",
          "updatedAt": "2023-03-01T07:51:06Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Could you explain how this limits the packing options? I assume you would just parse the header and then whatever comes after the header is entirely up to the application.\r\n\r\nAssume there are two parallel catalog formats A and B. A chooses to define its catalog using Protobuf, while B uses MessagePack. Each would have a different way to serialize \"type=1\". So my initial thought is that if we prescribe one way of doing it, then we force format architects to use that serialization in their catalogs. However upon further thought, we can just define that the first N bytes of the catalog payload define the catalog type and then after that the catalog-specific serialization kicks-in. So I'm fine with this solution to the problem of identifying the catalog type. \r\n\r\n> For example, the object delivery order field may only apply to the Object message and the CATALOG message is always the highest priority.\r\n\r\nI think catalog-as-object and media-as-object could share the same priority scheme. If someone always want the catalog updates sent ahead of the media, then they can give them a higher priority. We should not force catalog objects to be the highest priority, there may be some future application which does not want that behavior. \r\n\r\n> I would add another option: use the delivery order 0(highest) to indicate that OBJECT is the CATALOG message.\r\n\r\nI think that overloading the priority field for catalog ID type would work us in to a corner pretty quickly. \r\n\r\n> I suggest we figure out the format of CATALOG message and OBJECT message separately, then consider if/how to merge them.\r\n\r\nCatalog can fit quite neatly into the Object scheme. Here's what a catalog object would look like, assuming the Group and Object sequence counters can be used to describe any dependency:\r\n\r\n\r\n```\r\nOBJECT Message {\r\n  Broadcast URI (b)\r\n  0,\r\n  Group Sequence (i),\r\n  Object Sequence (i),\r\n  Object Delivery Order (i),\r\n  Object Payload (b),\r\n}\r\n```\r\n\r\nwhere \r\n\r\n```\r\nPayload {\r\n    type (i)\r\n    catalog (b)\r\n}\r\n```",
          "createdAt": "2023-03-02T15:54:11Z",
          "updatedAt": "2023-03-02T15:54:11Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "So it sounds like instead of using the CATALOG message, we can define that\r\n1. Track 0 is always the catalog.\r\n2. Every object in the catalog starts with a header (varint62?) that tells you what is the format of the catalog used.\r\n3. The rest of the object contents is interpreted according to the format corresponding to the varint.\r\n\r\nDoes this sound reasonable?",
          "createdAt": "2023-03-02T17:27:16Z",
          "updatedAt": "2023-03-02T17:27:16Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes. I would adjust items [2] and [3] to use the language of the OBJECT message:\r\n\r\n- Track 0 is always the catalog.\r\n- The payload of every OBJECT message with a trackID of 0 starts with a header (varint62?) that tells you what is the format of the catalog used.\r\n- The remainder of the OBJECT payload is interpreted according to the format corresponding to the varint.\r\n\r\nWe should also figure out how to signal the dependency issue raised earlier in the thread. The use case is a larger initial catalog of many subscribable items with later updates where just a few of those items change. For efficiency we'd like to distribute just the updates to subscribed clients. New clients joining however will need to start at an independent point.  For this I propose that we leverage the Group sequence (of the OBJECT message) to indicate an _independent_ catalog and the object sequence to indicate a _dependent_ one.\r\n\r\n```\r\nGroup 0\r\n     Object 0\r\n     Object 1\r\n     Object 2\r\nGroup 1\r\n     Object 0\r\n     Object 1\r\n```\r\n\r\nA client already subscribed to track 0 would receive [1,1] and be able to update its model of the catalog.\r\nA new client joining would have to be sent [1,0] and [1,1] in order to have an up-to-date view of the catalog. The relay would know what to send because it could look in its cache for the highest Group sequence for track 0 and send from that point on. \r\nA broadcast in which nothing changes would send [0,0] for track 0 and be done. \r\n[N,0] are independent catalog payloads sent by the publisher at some interval, much like I-frames in a encoded video sequence. \r\n\r\n",
          "createdAt": "2023-03-02T18:15:06Z",
          "updatedAt": "2023-03-02T18:15:06Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Shoving CATALOG inside of an OBJECT payload makes sense. You could even use the same encoding if you wanted. Using track 0 as the CATALOG track seems cool.\r\n\r\nI'm not sure I follow the independent versus dependent catalog stuff. It sounds like the goal is to reduce the scope of catalog updates. When broadcaster Z publishes a new track, you don't want to send the CATALOG for track A-Y since they didn't change. As a relay I would rather not keep a chain of every TRACK update, replaying them when a new viewer joins. Merging sounds impossible because a relay is agnostic to the format.\r\n\r\nWhat if we had a separate TRACK_CATALOGs? Most of the information in the CATALOG is specific to a single track anyway, with only a handful of fields to unite them. There's no reason to retransmit everything when on a single track is added/removed/updated.\r\n\r\nWhat if OBJECT 0 for each track is the TRACK_CATALOG?  On a new connection, a publisher would send OBJECT 0 for every track. The subscriber would issue a SUBSCRIBE if it wants more of the track.\r\n\r\nWhat if TRACK_CATALOG... was just an init segment! Each track would start with an init segment, which is super clean. It's also great for debugging because you can dump the OBJECT payloads to disk and it'll play.\r\n\r\nI think we still need CATALOG, but it can be extremely minimal. Just a list of active track IDs and some relationship between them. Then there's no need for deltas any longer; each CATALOG OBJECT would be independently decodable.",
          "createdAt": "2023-03-02T19:01:49Z",
          "updatedAt": "2023-03-02T19:05:34Z"
        },
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "> We should also figure out how to signal the dependency issue raised earlier in the thread. The use case is a larger initial catalog of many subscribable items with later updates where just a few of those items change. For efficiency we'd like to distribute just the updates to subscribed clients. New clients joining however will need to start at an independent point. For this I propose that we leverage the Group sequence (of the OBJECT message) to indicate an independent catalog and the object sequence to indicate a dependent one.\r\n\r\nCan we reuse the dependency for OBJECTS? For example, an OBJECT depends on prior OBJECTS within the same group. The first OBJECT of the group is a full set of the track IDs, each following OBJECT is the delta update of the set. Kind of like the I frame and P frame.\r\n",
          "createdAt": "2023-03-03T10:44:25Z",
          "updatedAt": "2023-03-03T10:44:25Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "@wilaw : given that the CATALOG message and media references has been removed from the draft, are we good to close this one?  See #156.",
          "createdAt": "2023-05-26T00:19:53Z",
          "updatedAt": "2023-05-26T00:19:53Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes. Closing. I'll open a new issue about catalog requirements for moqt.",
          "createdAt": "2023-05-26T05:36:01Z",
          "updatedAt": "2023-05-26T05:36:01Z"
        }
      ]
    },
    {
      "number": 68,
      "id": "I_kwDOG2Ho4M5cgT5P",
      "title": "Data Model needs to expand to support different use-cases",
      "url": "https://github.com/moq-wg/moq-transport/issues/68",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "vasilvv",
        "kixelated",
        "suhasHere"
      ],
      "labels": [],
      "body": "The currently proposed data model in -03 is a good start, but it does seem to lack things needed to various use-cases as defined in (https://datatracker.ietf.org/wg/moq/about/)\r\n\r\n  -  querying/subscribing to data from Relay at various granularities in a application agnostic way \r\n  -  represent different forms of  media objects grouping - gops, slices,  audio groups, something new\r\n  -   describe dependencies between objects within a group enabling relays appropriate caching strategies.\r\n",
      "createdAt": "2023-01-22T01:37:04Z",
      "updatedAt": "2023-05-05T19:55:40Z",
      "closedAt": "2023-05-05T19:55:40Z",
      "comments": [
        {
          "author": "vr000m",
          "authorAssociation": "NONE",
          "body": "Does this issue also cover one publisher per broadcast or is that another issue?",
          "createdAt": "2023-02-01T23:04:26Z",
          "updatedAt": "2023-02-01T23:04:26Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Does the now-merged model of track/group/object resolve this issue?",
          "createdAt": "2023-04-21T19:38:22Z",
          "updatedAt": "2023-04-21T19:38:22Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Data model has been updated",
          "createdAt": "2023-05-05T19:55:40Z",
          "updatedAt": "2023-05-05T19:55:40Z"
        }
      ]
    },
    {
      "number": 70,
      "id": "I_kwDOG2Ho4M5c-TFb",
      "title": "Globally unique broadcast URI",
      "url": "https://github.com/moq-wg/moq-transport/issues/70",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "suhasHere",
        "hardie"
      ],
      "labels": [],
      "body": "The current broadcast URI has no restrictions except for being unique within a WebTransport session. There's a desire for a globally unique broadcast URI. See #69 \r\n\r\nFrom my understanding, the issue is that a relay might have to rewrite the broadcast URI in the OBJECT message if two incoming WebTransport sessions use the same URI. This could be a performance concern at scale, so it would be nice to pre-authenticate every broadcast URI.\r\n\r\n@suhasHere @wilaw @fluffy is there additional rationale that I'm missing?",
      "createdAt": "2023-01-27T14:11:42Z",
      "updatedAt": "2023-05-26T00:04:45Z",
      "closedAt": "2023-05-26T00:04:45Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "My concern is that enforcing a globally unique URL is basically impossible without a central authority. @wilaw suggested public key crypto in our [previous discussion](https://github.com/kixelated/warp-draft/pull/63#discussion_r1065223997) but I don't think it prevents abuse.\r\n\r\nAdditionally, I think the performance benefit is overblown. The cost of serializing a new OBJECT header is negligible and would only need to be done if there's a collision. A relay already has to rewrite connection IDs, WebTransport sessions, STREAM IDs, QPACK indexes, and of course, re-encrypt. \r\n\r\nFor a service like Twitch, where relays are exposed to the internet, we would rewrite the broadcast URI once when it enters our video system. This also gives us the ability to add internal routing information to the URI in a way that is transparent to the end-user. The broadcast URI we serve to viewers would almost certainly be different than the one we ingested.",
          "createdAt": "2023-01-27T14:30:20Z",
          "updatedAt": "2023-01-27T14:30:20Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Reays must correctly route incoming traffic from multiple vendors.  It is not practical to enforce the constraint that each Broadcast must be contained within its own WebTransport connection. A relay network may be aggregating hundreds of thousands of individual broadcasts across many providers. This would require every pair of relays to establish a matching number of WebTransport connections, which is impractical and also costly from a TLS session establishment POV. We therefore need an architecture which decouples the identity of an object from the Webtransport connection which delivers it. \r\n\r\n> Additionally, I think the performance benefit is overblown. The cost of serializing a new OBJECT header is negligible and would only need to be done if there's a collision. \r\n\r\nThe performance cost is not in re-writing headers, which I agree is no more expensive than the other operations you cite.  It is in doing lookups in to a dynamically changing and distributed table to determine if there is a collision. \r\n\r\n>  is there additional rationale that I'm missing?\r\n\r\nWe should note that this broadcast ID does not have to be a character-sequence URI. It could also be a number. Its global uniqueness can be satisfied with either type. Considerations such as binary-encoding size may determine which form of identify we choose. \r\n\r\nAdditionally, if a network considers an incoming ID header verbose, it can always on its own volition create a dictionary that ties that ID to a more concise alias that is unique within its network and then rewrite the header to use that alias. For example if we used a character URI such as \"twitch.com/live/games/2342342342/bob\", we could replace it with \"1234\". This would result in fewer bits across the wire. Any time a relay delivers content to a subscriber outside its network (either the end-user or the entry point of a different network) it would need to restore the original ID header. This has the disadvantage that we don't get the compactness benefit over the last mile to the end-user. If we can design a means for a relay can distinguish an end-user from another relay, then we could avoid this problem.",
          "createdAt": "2023-01-28T00:15:13Z",
          "updatedAt": "2023-01-28T00:15:13Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> Additionally, if a network considers an incoming ID header verbose, it can always on its own volition create a dictionary that ties that ID to a more concise alias that is unique within its network and then rewrite the header to use that alias. For example if we used a character URI such as \"twitch.com/live/games/2342342342/bob\", we could replace it with \"1234\". This would result in fewer bits across the wire. Any time a relay delivers content to a subscriber outside its network (either the end-user or the entry point of a different network) it would need to restore the original ID header. This has the disadvantage that we don't get the compactness benefit over the last mile to the end-user. If we can design a means for a relay can distinguish an end-user from another relay, then we could avoid this problem.\r\n\r\nOh absolutely, I think rewriting the broadcast URI at the edge of the network is both a good idea and necessary. I think this boils down to a MUST versus SHOULD.\r\n\r\n\"The broadcast ID MUST be globally unique\" means your suggestion of using broadcast ID \"1234\" does not adhere to the specification. An internal relay could ignore this requirement, but I don't think that is acceptable.\r\n\r\n\"The broadcast ID SHOULD be globally unique\" adds some wiggle room but opens the possibility for collisions. A client will try to make IDs unique but can't guarantee it, so a relay will either need to reject duplicates or rewrite the URI. \r\n\r\n\"The broadcast ID SHOULD be random\" could be a nice way to reduce the possibility of collisions without any central authority. The client initial QUIC connection ID works like this (at least 8 random bytes).\r\n\r\n\"The broadcast ID MUST be unique within the session\" is the weakest requirement for the protocol to function. A client might just hardcode ID \"0\" and the relay always will need to rewrite URIs. This is basically how QUIC connection IDs work; an endpoint can use whatever they want provided it's not a duplicate.",
          "createdAt": "2023-01-28T06:48:40Z",
          "updatedAt": "2023-01-28T06:48:40Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "From #69  , there is Warp Media Session and per representation Warp Streams . Its the uniqueness requirements from Media Session identifier that encompasses rest of the sub components under it. IIUC Warp Media Sessions , when represented as character URI, typically have components that form the origin component (like twitch.com or webex.com that are globally unique) and what happens inside that is controlled by the owning domain. \r\n\r\nWith that in mind  a Warp Stream Id is output of some function that takes in (Warp Media Session Id and Representation Id) , which makes each such representation globally unique. \r\n",
          "createdAt": "2023-01-28T08:06:06Z",
          "updatedAt": "2023-01-28T08:06:06Z"
        },
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "\r\n> Reays must correctly route incoming traffic from multiple vendors. It is not practical to enforce the constraint that each Broadcast must be contained within its own WebTransport connection. A relay network may be aggregating hundreds of thousands of individual broadcasts across many providers. This would require every pair of relays to establish a matching number of WebTransport connections, which is impractical and also costly from a TLS session establishment POV. We therefore need an architecture which decouples the identity of an object from the Webtransport connection which delivers it.\r\n\r\nAgree. IIUC, the WARP Media Session from #69 is the end-to-end concept. The job of the relay is to forward object or stream/track hop by hop. The endpoint is responsible to group the object or stream/track into the Media Session. We should not enforce the mapping between the WARP Media Session and the Webtransport connection between each relay hop.",
          "createdAt": "2023-01-28T08:31:23Z",
          "updatedAt": "2023-01-28T08:31:23Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> From #69 , there is Warp Media Session and per representation Warp Streams . Its the uniqueness requirements from Media Session identifier that encompasses rest of the sub components under it. IIUC Warp Media Sessions , when represented as character URI, typically have components that form the origin component (like twitch.com or webex.com that are globally unique) and what happens inside that is controlled by the owning domain.\r\n\r\nWe need to support broadcasters who do not own a globally unique domain name. Twitch/Meta broadcasters must be able to publish media from clients like OBS via a URL, and most certainly cannot be trusted.\r\n\r\nMaybe we could have them go through a one-time setup to certificate (ex. `kixelated.users.quic.video`) but they can still be malicious, perhaps by sharing the certificate or reusing  broadcast IDs. Really the only way to make something globally unique is to have a trusted authority (ex. `quic.video`) issue and sign broadcast IDs, scoped to a specific time and host. That just seems excessive for what amounts to a near-zero performance improvement.\r\n\r\nA relay SHOULD NOT assume that a broadcast URI is globally unique. However a relay MAY negotiate a broadcast URI scheme with publishers to avoid collisions within a session.",
          "createdAt": "2023-01-28T19:02:26Z",
          "updatedAt": "2023-01-28T19:02:26Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> We need to support broadcasters who do not own a globally unique domain name. Twitch/Meta broadcasters must be able to publish media from clients like OBS via a URL, and most certainly cannot be trusted.\r\n\r\nBroadcasters don't need to own the domain name. They just need permission to broadcast under its identity. Think what happens if I want to publish rtmp in to Twitch today. I validate myself to your portal by logging in with username/password/2FA, get a secret key from your portal and then I set up OBS to publish to\r\n\r\n`rtmp://live.twitch.tv/app/`\r\n\r\nand provide the key for authentication. Cannot we use something similar for WARP? I could get my the same key and use OBS to set up a WebTransport connection to\r\n\r\n`https://live.twitch.tv/moq`\r\n\r\n",
          "createdAt": "2023-01-30T00:25:19Z",
          "updatedAt": "2023-01-30T00:25:19Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "That means every MoQ ingest endpoint will need to run an intermediate CA.\nAnd clients will need to perform an extra round trip or two in order to\nfetch a certificate.\n\nIt could be a one-time setup, ex. OBS fetches a MoQ scoped certificate for `\nkixelated.twitch.tv`. But that still doesn't stop them from producing\nidentical broadcast URIs, possibly even on accident from different\ncomputers. Revoking certificates when old ones are lost would be a massive\npain and still won't prevent abuse.\n\nAll this mess for maaaaybe a tiny performance increase. Honestly I need to\nsee the benchmark results. Lookups and serializing frames are some of the\nfastest operations in my experience and don't even show up on profiles.\n\n\nIMO I think the middle-ground solution is to give the subscriber the\nability to choose the broadcast URI/ID. This is how QUIC connection IDs\nwork, and it allows the receiver to transparently dictate the schema.\n\nex. OBS could connect to `live.twitch.tv` and receive instructions (in the\nSETUP message?) to use broadcast URI `moq://dfw02.twitch.tv/kixelated/6734`.\n\nThe tricky part is avoiding an extra round trip, which is why QUIC lets the\nclient choose the initial connection ID. The client will switch to the\nserver's chosen connection ID for the rest of the handshake and going\nforward.\n\n\n\nOn Sun, Jan 29, 2023, 6:25 PM Will Law ***@***.***> wrote:\n\n> We need to support broadcasters who do not own a globally unique domain\n> name. Twitch/Meta broadcasters must be able to publish media from clients\n> like OBS via a URL, and most certainly cannot be trusted.\n>\n> Broadcasters don't need to own the domain name. They just need permission\n> to broadcast under its identity. Think what happens if I want to publish\n> rtmp in to Twitch today. I validate myself to your portal by logging in\n> with username/password/2FA, get a secret key from your portal and then I\n> set up OBS to publish to\n>\n> rtmp://live.twitch.tv/app/\n>\n> and provide the key for authentication. Cannot we use something similar\n> for WARP? I could get my the same key and use OBS to set up a WebTransport\n> connection to\n>\n> https://live.twitch.tv/moq\n>\n> \u2014\n> Reply to this email directly, view it on GitHub\n> <https://github.com/kixelated/warp-draft/issues/70#issuecomment-1407819611>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AADJVVUYVYPWZWMER4I7ANTWU4C7VANCNFSM6AAAAAAUIXXSZQ>\n> .\n> You are receiving this because you authored the thread.Message ID:\n> ***@***.***>\n>\n",
          "createdAt": "2023-01-30T18:55:54Z",
          "updatedAt": "2023-01-30T18:55:54Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "As a general principle, I believe we should not define any semantic concepts that exceed the scope of current MoQ connection.  HTTP generally follows this principle (a browser talking to an HTTP server generally does not care whether it's talking to a random Python web server or an nginx reverse proxy or a CDN).  There are many reasons why this is a good design (better protocol agility, easier to reason about, etc), but ultimately, I believe that even if we design some \"public global identifier\", a lot of deployments will disregard it in favor of \"backend rewrites everything to make things appear the same to the end user\".\r\n\r\n> From my understanding, the issue is that a relay might have to rewrite the broadcast URI in the OBJECT message if two incoming WebTransport sessions use the same URI. This could be a performance concern at scale, so it would be nice to pre-authenticate every broadcast URI.\r\n\r\nI think we should use a connection-scoped numeric ID for broadcasts, and do any URL matching, authentication checks, etc, at subscription time.\r\n\r\n> The performance cost is not in re-writing headers, which I agree is no more expensive than the other operations you cite. It is in doing lookups in to a dynamically changing and distributed table to determine if there is a collision.\r\n\r\nI don't understand this problem.  Almost every HTTP proxy that caches things identifies the objects by the URL that it used to fetch it from the backend.  Why can't a MoQ relay identify objects in a similar fashion?",
          "createdAt": "2023-01-30T23:08:26Z",
          "updatedAt": "2023-01-30T23:08:26Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "NONE",
          "body": "I'm thinking that this is related to [Issue 77 in the Requirements draft](https://github.com/fiestajetsam/draft-gruessing-moq-requirements/issues/77l), and at least a high-level description of what's possible might belong in the Requirements section of that draft. No need to figure that out now, but I did want to call attention to it. ",
          "createdAt": "2023-02-01T23:10:21Z",
          "updatedAt": "2023-02-01T23:10:56Z"
        },
        {
          "author": "grmocg",
          "authorAssociation": "NONE",
          "body": "Hoping that the minimum requirement here is to preclude or make highly improbable any corruption/poisoning.",
          "createdAt": "2023-02-01T23:12:29Z",
          "updatedAt": "2023-02-01T23:12:29Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "#69  will be updated once  this issue is resolved ",
          "createdAt": "2023-02-13T14:35:15Z",
          "updatedAt": "2023-02-13T14:35:15Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I don't understand this problem. Almost every HTTP proxy that caches things identifies the objects by the URL that it used to fetch it from the backend. \r\n\r\nHTTP caching works because the proxy can construct a cache key based (at a minimum) upon the concatenation of the objects' HOST and PATH . The HOST is managed by a global registry (DNS) and each HOST domain is responsible for assuring that the PATH maps consistently to the appropriate binary object. These two features avoid conflicts at the proxy. This cache key is independent of the HTTP connection used to request the content, allowing flexibility in how distribution systems use connections to move content. \r\n\r\n> Why can't a MoQ relay identify objects in a similar fashion?\r\n\r\nExactly. I think that is what this issue is asking for. Can we introduce the notion of globally registered identifier to the objects we are publishing and subscribing with MoQ just as we have with the objects we are getting and putting with HTTP?",
          "createdAt": "2023-02-13T17:20:49Z",
          "updatedAt": "2023-02-13T17:20:49Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> > I don't understand this problem. Almost every HTTP proxy that caches things identifies the objects by the URL that it used to fetch it from the backend.\r\n> \r\n> HTTP caching works because the proxy can construct a cache key based (at a minimum) upon the concatenation of the objects' HOST and PATH . The HOST is managed by a global registry (DNS) and each HOST domain is responsible for assuring that the PATH maps consistently to the appropriate binary object. These two features avoid conflicts at the proxy. This cache key is independent of the HTTP connection used to request the content, allowing flexibility in how distribution systems use connections to move content.\r\n\r\nWhen you say HOST, do you mean the hostname in the URL? If so, that's how HTTP proxies work, but it's certainly not how HTTP caches work.\r\n\r\nWhen using a HTTP proxy, the client sends a request for `http://HOST/PATH` to a configured address (ex. `HTTP_PROXY` env). The IP address is not the result of a DNS lookup, but rather an external configuration. The proxy uses the `Origin` header to determine the upstream HOST (which may not be the origin) and proxies the request.\r\n\r\nWhen using a HTTP cache, the client sends a request for `http://HOST/PATH` to HOST based on a DNS lookup. The server has no information about the origin and needs some business logic. It's usually as simple as forward any paths starting with abc to upstream xyz. The HTTP cache constructs a new URL to perform the fetch, something like `http://UPSTREAM/PATH`. This is repeated until the origin is the upstream.\r\n\r\nThe hostname part of the URL must be rewritten when using a HTTP cache. After all, the HOST is the address of the next hop, not the origin.\r\n\r\nIt sounds like you want the ORIGIN and the PATH, which is not quite the same thing as a URL. Each hop would use some business logic to determine the UPSTREAM. It would connect to UPSTREAM but SUBSCRIBE with ORIGIN/PATH. ",
          "createdAt": "2023-02-13T18:18:34Z",
          "updatedAt": "2023-02-13T18:20:31Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we're getting too deep in semantics and need some examples. @wilaw you mentioned earlier that a broadcaster streaming to Twitch would be assigned an ORIGIN and would use public key crypto to verify authenticity, so let's try that out.\r\n\r\nAs a one-time setup, I would generate a private key for `kixelated.users.twitch.tv` and ask `auth.twitch.tv` to sign my public key.  Going forward I would PUBLISH broadcasts starting with `kixelated.users.twitch.tv`. We would need to standardize this exchange in order to support generic clients.\r\n\r\nWhen I publish a broadcast, I start by connecting to the closest ingest edge using geo DNS or anycast, which could change even during a broadcast via the GOAWAY message. I send a CATALOG `kixelated.users.twitch.tv/123` and sign it using my private key, preventing relays from modifying the CATALOG. I also need to sign each OBJECT to prevent modification.\r\n\r\nIf the relay wants to modify the broadcast (ex. transcoder), it needs to make a brand new broadcast URL with itself as the origin (ex. `transcode123.sfo01.twitch.tv`). Otherwise, any requests for a new track ID or new object ID could somehow make their way to the origin (me) and I would have no idea what to do. This means a new private/public key.\r\n\r\nWhen a viewer wants to watch my broadcast, they connect to the closest distribution edge using geo DNS or anycast, which again could change. They issue a SUBSCRIBE `kixelated.users.twitch.tv/123` and simultaneously fetch my public key(s) from `auth.twitch.tv` via the same standardized auth service. If there's a relay that modifies the broadcast, the viewer will need to be told to use that URL/key instead. \r\n\r\nThe relay receives the request for my broadcast. It would need to use a database to figure out where `kixelated.users.twitch.tv/123` is currently ingested. DNS is not an option because `kixelated.users.twitch.tv` does not actually exist, could switch suddenly (DNS caching), and could have multiple broadcasts ingested at different locations. The relay figures out the upstream based on the origin and this repeats for each hop.\r\n\r\n---\r\n\r\nMy problem with this scheme is that I would ALWAYS rewrite the broadcast URL on ingest. My relay knows how to route to `transcode123.sfo01.twitch.tv`, but has no way of routing to `kixelated.users.twitch.tv`. I must avoid each relay performing a lookup for each broadcast because of the performance and reliability implications.\r\n\r\nBy terminating and rewriting the broadcast, I lose any benefit gained by using public key crypto. The viewer can't authenticate that `kixelated` produced the transcoded broadcast any longer, although I suppose we could create a signature chain...\r\n\r\nFinally, I actually don't want to expose the inner-workings of my video system. I don't want viewers to subscribe to `transcode123.sfo01.twitch.tv` because it leaks information. I want them to subscribe to `live.twitch.tv/<token>` and I can decipher the encrypted token payload to get the actual origin/broadcast ID. I have to rewrite each OBJECT ID at our edge but that's literally what we do today with HTTP URLs.\r\n\r\nSo yeah, I don't think there's any reason to fake an origin for each user. It introduces complexity and doesn't give us much in return. Just let the broadcast push whatever broadcast ID they want to my ingest server and I'll rewrite if needed. Akamai could go through the trouble of generating and enforcing unique broadcast IDs in their system as a layer on top of Warp.",
          "createdAt": "2023-02-13T19:15:39Z",
          "updatedAt": "2023-02-13T19:19:00Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Like Luke, I would hate to be required to have a domain for every user.  But there are also many cases where for firewall management rules reasons you want to have a domain per customer. For example, twitches domain for webex is twitch.webex.com and akamai has akamai.webex.com - what edge they both route to depends on a ton of things including geolocation, private peering, and how much you pay webex, security policy, and other junk.  I think we do want to be able to support things where there is a domain per customer. ",
          "createdAt": "2023-03-12T16:15:41Z",
          "updatedAt": "2023-03-12T16:15:41Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Am I right in thinking this is also related to Announce (#150)?  Can we merge or close this issue now?",
          "createdAt": "2023-05-05T20:21:59Z",
          "updatedAt": "2023-05-05T20:21:59Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "The current draft contains text requiring global unique track names. \r\n\r\n> Applications building on top of MoQ MUST ensure that the mechanism used guarantees global uniqueness\r\n\r\nI absolutely disagree and want to remove this text. An application should be allowed to use any track name. I don't want `track=video` or `track=localhost/video` to be against the spec, especially when there's no mechanism to actually ensure global uniqueness (ex. DNS, certificates, etc).",
          "createdAt": "2023-05-17T18:13:55Z",
          "updatedAt": "2023-05-17T18:13:55Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "We discussed this topic in length and at IETF116 and the current proposal works for all the use-cases. I would be against removing it though",
          "createdAt": "2023-05-17T20:17:04Z",
          "updatedAt": "2023-05-17T20:22:43Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "> `track=video` or `track=localhost/video`\r\n\r\nThese look like names without namespaces, eg: not full track names, so they don't need to be globally unique.  You can't have two clients show up at the same relay though and both announce these as *full* track names, because the relay cannot know where to route subscriptions.  Each would need a unique namespace in order to use the same track names.\r\n\r\nClarifying question: \r\n\r\nIs the \"global uniqueness\" required of the application minting track names and namespaces limited to within that application, or across all moq applications everywhere?  Some additional text around the scope and also the rationale may be useful.",
          "createdAt": "2023-05-17T20:35:22Z",
          "updatedAt": "2023-05-17T20:35:22Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> We discussed this topic in length and at IETF116 and the current proposal works for all the use-cases. I would be against removing it though\r\n\r\nI'm sorry, I must have missed it during the PR because you know I've objected loudly every time this language has shown up in a PR.\r\n\r\nDespite so many discussions, I still don't understand:\r\n- what it means to be \"globally unique\"\r\n- how an application would implement this\r\n- how a relay must enforce this\r\n- and most importantly, what is this trying to accomplish\r\n\r\nI certainly think we should leave the door open for track naming schemes that can guarantee uniqueness. I would love to see an extension that uses TLS certs to both name tracks and sign objects (required!). Another silly but actually \"globally unique\" example would be to use the wallet ID (ex. fingerprint of a self-signed cert) as the track name to announce blockchain updates over MoQ.\r\n\r\nBut this should be optional unless there's a compelling reason to require it. I want arbitrary track names.",
          "createdAt": "2023-05-17T21:47:30Z",
          "updatedAt": "2023-05-17T21:47:30Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "@suhasHere can you elaborate on why this is a requirement? I think the goal is that `track name == cache key`, but I can think so many use-cases where this does not work or is a giant security hole. I can list examples if this is the intent.",
          "createdAt": "2023-05-17T22:07:35Z",
          "updatedAt": "2023-05-17T22:12:26Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I think the goal is that track name == cache key, but I can think so many use-cases where this does not work or is a giant security hole\r\n\r\n@kixelated   - can you elaborate on the cases where globally unique trackname cannot serve as a cache key? And also the security holes that this approach brings? Clearly a client-initiated unauthenticated trackname  leaves a network open to cache poisoning (because I can push content that claims to be someone else's content) , however this issue is a) no different than if local track names are used and b) Addressed via authentication and access control, which I think most agree is a baseline requirement for moq-transport to operate in a multi-tenant and multi-network model? \r\n\r\n",
          "createdAt": "2023-05-17T22:57:11Z",
          "updatedAt": "2023-05-17T22:57:11Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "> cases where globally unique trackname cannot serve as a cache key\r\n\r\nThis isn't exactly the same thing, but will moq need concepts like no-cache or vary?  In HTTP there's dynamically generated content where the same URL gives different bits for different users.",
          "createdAt": "2023-05-18T00:35:23Z",
          "updatedAt": "2023-05-18T00:35:23Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> This isn't exactly the same thing\r\n\r\nIf we use global track names as cache key or a hash of it or some transformation of it , it should be possible .. I also don't understand why it can't be cache key and security issues with it\r\n\r\nFull Track Names are what subscribers ask and it should work within and across distribution systems and also when a CDN support multiple applications.  We had a long discussion on this during IETF116 (https://datatracker.ietf.org/meeting/116/materials/slides-116-moq-base-scenarios-for-moq-01) and also in 2 or 3 authors calls and agreed to have the design that is documented today.  ",
          "createdAt": "2023-05-18T01:38:02Z",
          "updatedAt": "2023-05-18T04:27:10Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> If we use global track names as cache key or a hash of it or some transformation of it , it should be possible .. I also don't understand why it can't be cache key and security issues with it\r\n\r\nOkay, so.\r\n\r\nFirst off, this is far too restrictive. It's equivalent to saying the path in a HTTP request MUST be globally unique. There has to be a clearly defined reason why this restriction is in the draft. It's a lot of work to both produce and enforce uniqueness within any distributed system, let alone a \"global\" one.\r\n\r\nFrom what I can gather, the underlying reason is the ability to gossip multiple origins for a track. Here are some examples I've heard:\r\n\r\n--- \r\n### 1. Akamai and Cloudflare both announce they can serve the `whitehouse.gov/union` broadcast.\r\nThis needs to be fleshed out before you can really even argue for or against it. But I'm going to try anyway by listing a few options.\r\n\r\nLet's suppose we do want something like BGP, where CDNs gossip origins between themselves. Allowing any CDN to announce any track is extremely dangerous, as a compromised CDN could hijack any broadcast by announcing itself as a new origin. At the very least you'll need to pre-configure CDNs with a very narrow allowlist of\u00a0possible origins for each track prefix.\r\n\r\nBut really, why do you want dynamic origins? A Webex participant doesn't know if it should publish to Akamai or Cloudflare. I don't think the client should choose since it doesn't know any better. It should be told where to publish by some Webex API that factors in the cost, peering, location of other participants, etc. That Webex API is then responsible for providing the corresponding subscribe URL to other participants, rather than relying on them to figure it out based on some gossip protocol. This is objectively safer and simpler than gossip with an allowlist.\r\n\r\nThe most secure would be something like torrent magnet links, where any entity can announce themselves as an origin if they can prove it. ANNOUNCE and OBJECT messages would be signed using a certificate, as proof that this content originated from `whitehouse.gov` and has not been tampered with. I really like this design as it decentralizes CDNs, however you gotta ask yourself: How is this media over QUIC? Why are we designing a torrent-like CDN architecture? Why would a CDN support this dramatic departure from their traditional architecture?\r\n\r\n---\r\n\r\n### 2. CNN and Newsmax publish the same `whitehouse.gov/union` broadcast, sharing a cache.\r\nTed brought up this example but with a sporting event. The benefits of situationally sharing a CDN cache are minor at best, and practically I don't even see why these two publishers would ever produce the same content since both are going to want their own editing and overlays.\r\n\r\nThe security problem is that there's no authority on the contents of the `whitehouse.gov` broadcast, so either publisher could insert their own content and poison the cache. This approach would only be acceptable if both publishers mutually trust each other, but in that case then why do they both need to publish? The CDN would just need to be configured with a rewrite, so Newsmax could reuse the CNN broadcast or vice-versa while still billing the right entities.\r\n\r\nAgain the proper solution again relies on crypto. Everything needs to be signed by `whitehouse.gov` to prevent tampering. \r\n\r\n---\r\n\r\n### 3. WebEx participants screen share the same `youtube.com/shorts/AWOyEIuVzzQ clip, sharing a cache.\r\nSimilar to the above, although all Webex users are authorized to publish Youtube clips. The same deal, a user could poison the cache and publish the wrong media, like a rick-roll or something more sinister. The same solution, youtube needs to sign everything. Although I'm not even sure if this is legal, and there's some billing ramifications.\r\n\r\nA better solution is to stitch in tracks. Conceptually, this is server-side ad insertion. I don't actually think users should re-encode or re-publish Youtube clips, but rather insert a pointer into the catalog that says \"use this external track instead\". That (VOD) track could even be served over an entirely separate CDN, for example over Youtube's CDN, while the user's feed is served over Akamai.",
          "createdAt": "2023-05-18T18:03:48Z",
          "updatedAt": "2023-05-18T18:09:46Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Please refer to https://datatracker.ietf.org/meeting/116/materials/slides-116-moq-base-scenarios-for-moq-01 for scenarios/requirements that will help support unified use-cases.\r\n\r\n\r\n> Allowing any CDN to announce any track is extremely dangerous, as a compromised CDN could hijack any broadcast by announcing itself as a new origin\r\n\r\nThe authorization will fail and the hijacked CDN cannot vouch itself as the origin. Also, if CDN-A want to announce to CDN-b, there is business relationships setup, appropriate authz schemes would be worked out. Its not gossip.\r\n\r\n> A Webex participant doesn't know if it should publish to Akamai or Cloudflare. I don't think the client should choose since it doesn't know any better. It should be told where to publish by some Webex API that factors in the cost, peering, location of other participants, etc. That Webex API is then responsible for providing the corresponding subscribe URL to other participants, rather than relying on them to figure it out based on some gossip protocol. This is objectively safer and simpler than gossip with an allowlist.\r\n\r\nNone in the current text suggest that participants need to know the CDN. Only thing the current text says is Announce/Subscribes happens on tracks and their names are not tied to a CDN/Connection but instead to the application. However, Tracks have connection url which identifies the next hop network node.\r\n\r\n> The security problem is that there's no authority on the contents of the `whitehouse.gov` broadcast, so either publisher could insert their own content and poison the cache.\r\n\r\nThis is incorrect reading. If the orginal broadcast is expected to be modified  at the raw media level by CNN and Newsmax, then they own the content ownership each and this is done by having business relationship between CNN, Newsmax and Whitehouse. This is similar to Media Transformer Entities (https://datatracker.ietf.org/doc/html/draft-nandakumar-moq-arch-00#section-2.2) .. Then the content will need to be identified with new track names ( whitehose-cnn track, whitehouse-newsmax track) in the cache.\r\n\r\n \r\nIf the original broadcaster doesn't want its content to be modified, then they have to end to end encrypt OR an agreement between the parties where it can happen. \r\n\r\nRealtime conferences have Media Switches ( not Media Transformers), where the media is just switched at these servers. Then the track names need to carry over\r\n\r\n\r\n\r\n> Again the proper solution again relies on crypto. Everything needs to be signed by `whitehouse.gov` to prevent tampering.\r\n\r\nYes at some level. You don't need to public key sign the every object, there are other ways too.\r\n\r\n\r\n> Similar to the above, although all Webex users are authorized to publish Youtube clips. The same deal, a user could poison the cache and publish the wrong media, like a rick-roll or something more sinister. The same solution, youtube needs to sign everything. Although I'm not even sure if this is legal, and there's some billing ramifications.\r\n\r\nThis use-case seems to be misplaced or I am not understanding. Youtube publish needs per user auth token to publish media. Each user in the above use-case will be publishing his/her own track and there is no cache poisoning.\r\n\r\n\r\n\r\n\r\n> But really, why do you want dynamic origins?\r\nCan you please elaborate \"dynamic origins\" ?",
          "createdAt": "2023-05-18T22:02:56Z",
          "updatedAt": "2023-05-18T22:04:23Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we have lots of confusion about what we mean by all of this. I think people are turning this into something way too complex and not needed. \r\n\r\nI view any HTTP URI with a domain name as globally unique by what we mean here for globally unique. \r\n\r\n I view that in in today's CDNs, multiple CDN can serve up whitehouse.gov. Basically it might be the for DNS requests in the roughly the US, the CNAME points at cloudflare but for the rest of the world the CNAME that points at Akamai. I think this is fairly common. \r\n \r\n Just ignore multiple CDN for a second and only think about distributions side. When A and B both want to watch a video, something needs to indicate what video it is.  I think of that a HTTP like path name that defines the application and which video. For example, www.youtube.com/watch?v=3456 and yes perhaps some more stuff after that for different resolution languages or whatever. But I think we agree on the later part, the question is where is the information the part that need to uniquely identify the application and identity which video inside that application. Something needs to tell the CDN if A and B should get the same video or different ones. I suspect some people think that is part of the track name or something and some people think it is a setup or connect message or something. I'm not worried about where the bits are so much but we seem to keep coming back to this. We need some way the relay knows if A and B get the same or different videos. \r\n \r\nThe next thing is authorization. Clearly, in any CDN, not everyone that can read some data can be allowed to write the data or you will have cache poisoning. There has to be separate token to authorize read and write into the cache. \r\n\r\nIn any CDN situation, if a service like youtube uses more than one CDN, they need to synchronize how the data gets into both CDNs. I don't think this is any different and I don't think it requires a routing protocol between the CDNs. The origin will take things from each CDN and synchronize the deliver of them onto all the other CDNs that applications uses. That does not rule out certain CDNs having more optimized ways to move data between CDN. For example, bulk subscriptions to other CDNs, but I don't think it changes any of the design for client to relay. \r\n\r\nIf it is as complicated as what Luke is thinking, then I agree with Luke that this looks too complicated, but I don't think it is that complicated at all, I feel like we just mean different things by words like \"globally unique\". \r\n\r\n( And as a side note, the SIP spec talks about \"globally unique across space and time\" and I have never had any idea what that means - so lets avoid stuff that makes no sense to anyone )",
          "createdAt": "2023-05-18T23:46:16Z",
          "updatedAt": "2023-05-18T23:46:16Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would like to make a proposal on the call today that I hope can sort this out.  I'm trying to model this after todays HTTP CDNs. \r\n\r\nMy proposal is we defined \"globally unique\" to mean the full track name for a given application, is unique across all the CDNs that that application uses. \r\n\r\nThe goal here is simply that we when A and B both subscribe, the relay knows to send them the same or different things.  One way to do this is track names that are like HTTP URLs. And if webex has a client publishing to webex.com/meeting123/track22, that does not mean the the DNS for webex.com resolves to the IP of the client, it just means that webex delegated that part of the name space for the client to use. \r\n\r\nIf you had a CDN that only supported one application and that application had a database of integers for track names, that would work too. So for example, on the twitch CDN, a twitch broadcast ID might be globally unique. (I don't understand the twitch CDN so I might have this wrong).  If you had just a single relay running on localhost, a track name of \"1\" could be a globally unique full track name. \r\n\r\nThere is never any way to enforce this. The CDNs can have business agreements with application using the CDN about what portion of names the CDN is willing to authorize and route. ",
          "createdAt": "2023-05-19T16:04:24Z",
          "updatedAt": "2023-05-19T16:04:24Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> I view any HTTP URI with a domain name as globally unique by what we mean here for globally unique.\r\n\r\nFirst off, this draft is the equivalent of saying that part of the HTTP path must be globally unique.\r\n\r\nSecond off, HTTP resources do not have a globally unique URI. The URI is a routing mechanism, not a unique identifier. The same URI may serve different resources, and the same resource may be served out of different URIs.\r\n\r\nCDNs are configured on how to cache, deduplicate, and fetch HTTP resources. This is done based on the full path by default, but the cache can be split based on headers like Accept-Language, Accept-Encoding, Auth, Cookie, Host, Origin, Referrer, etc. The connection properties can be used, like IP address, ASN, and Geo. A fragment of the full path can be used, like the extension, the base directory, or just some arbitrary regex.\r\n\r\nFrom what I can gather, you would like to encode all of these cacheable properties into a globally unique track name, that is exclusively used as the cache key. That does not work for HTTP and I do not think it will work for MoQ, and it cannot be required.\r\n\r\nYou are certainly allowed to use unique track names, just like you're allowed to use unique HTTP paths. Although I still question how you could make \"globally unique\" names without an authority\r\n\r\n> ( And as a side note, the SIP spec talks about \"globally unique across space and time\" and I have never had any idea what that means - so lets avoid stuff that makes no sense to anyone )\r\n\r\nIt's a good point, because it's not clear if \"globally unique\" in the draft means at this instant or for all time. Are you allowed to reuse track names in the future?\r\n\r\nI want to remove this text. it's a vague, unenforceable, and restrictive MUST.",
          "createdAt": "2023-05-19T16:42:04Z",
          "updatedAt": "2023-05-19T16:43:54Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual comment:\r\n\r\n> First off, this draft is the equivalent of saying that part of the HTTP path must be globally unique.\r\n\r\nI don't read this as the intent - Full Track Name is what is intended to be unique.  FTN is comprised of Track Namespace and Track Name.  I view Full Track Name and URL as similar, but the division between Namespace and Name is not necessarily the same as the division between authority and path.  I like the way Cullen phrased it which is that part of the namespace (little n) can be delegated to a client.\r\n\r\n> The same URI may serve different resources, and the same resource may be served out of different URIs.\r\n\r\nI think this needs to be discussed - can two subscribers subscribe to the same FTN and receive different content?",
          "createdAt": "2023-05-19T16:51:07Z",
          "updatedAt": "2023-05-19T16:51:07Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\r\n\r\n>  Although I still question how you could make \"globally unique\" names without an authority\r\n\r\nBy leveraging an existing authority for global uniqueness, which is the domain name system. By using streams.whitehouse.gov/live/stream/3 as your track name, you avoid conflicts with all other moq-transport tracks on all distribution networks. Yes, someone else can claim that they also have authority to publish under the namespace streams. whitehouse.gov. In that case we can leverage certificates in which case only one entity has the correct certificate to prove that they have the rights to that namespace. If we don;t leverage existing domain name registration and certification , then we need to build an almost identical system for assuring uniqueness. That seems unnecessary. \r\n\r\nBTW -  I  like the term \"network unique\" as a replacement for \"globally unique\".",
          "createdAt": "2023-05-19T16:55:02Z",
          "updatedAt": "2023-05-19T16:55:02Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I filed #159 to explain how I see things working. The disagreement is over the `track_namespace` and I think I can simplify into a few questions:\r\n\r\n1. Is `track_namespace` independent of the `connect_url`?\r\n2. Does the producer's `track_namespace` need to be the same as the consumer's `track_namespace`?\r\n3. Do all consumer's `track_namespace` need to be the same?\r\n3a. What about between different CDNs?\r\n\r\nFrom what I understand, the phrase \"globally unique\" implies yes to all of the above. The `track_namespace` is the only piece of information allowed to identify a piece of content. ",
          "createdAt": "2023-05-19T20:36:08Z",
          "updatedAt": "2023-05-19T21:08:18Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Here are some concrete examples of what I would like to support. I'm keeping it Twitch specific since I'm most familiar with that system, but there's a multitude of different options.\r\n\r\n### OBS could be provided:\r\n`connect_url`: `https://ingest.twitch.tv`\r\n`track_namespace`: `kixelated`\r\n`auth`: `<token>`\r\n\r\nAnycast or geo DNS is used to route to the closest Twitch origin (in this example: cmh01). Each unique broadcast would be stored in a database and given a unique ID to distinguish between later broadcasts (in this example: 1234532).\r\n\r\nThe catalog contains relative track names, so the `track_namespace` could be rewritten without rewriting the catalog.\r\n\r\n\r\n### VLC could be provided:\r\n`connect_url`: `https://video-edge-abc123.sfo01.twitch.tv`\r\n`track_namespace`: `video-ingest-def456.cmh01/kixelated/1234532`\r\n`auth`: `<token>`\r\n\r\nThe connect URL is provided on a per-user basis based on capacity. The namespace encodes routing information, so my CDN can perform stateless routing to the origin (no database lookup at every hop).\r\n\r\nNote that the auth token is scoped to ONLY the provided `connect_url` and `track_namespace`. We explicitly prohibit users from being able to choose their own edge since we perform application-level load-balancing.\r\n\r\nor \r\n\r\n`connect_url`: `https://moq.akamai.com`\r\n`track_namespace`: `twitch.tv/cdn-origin.jfk06/kixelated/1234532`\r\n`auth`: `<token>`\r\n\r\nNote that the routing information in the namespace is different for Akamai, as we have pre-negotiated peering agreements in New York (jfk06). How to route to the Twitch origin, including how that information is encoded in the track namespace, could be different for each CDN.\r\n\r\nThe auth token is also different based on the connect URL. Again, we don't want users to be able to choose their own CDN or edge for cost reasons. But also we need to use a scheme that Akamai supports, which may be different than our own edge or other CDNs.\r\n\r\nor \r\n\r\n`connect_url`: `https://video-edge-abc123.sfo01.twitch.tv`\r\n`track_namespace`: `a124hdfhkjae234rwtjnwovmasdokv232asdg`\r\n\r\nThis is actually how Twitch works today. The request path contains an encrypted payload so we can both hide and prevent tampering with any routing information. It also contains some user information so we can track metrics on a per user-basis. No authentication token is required since the namespace is unguessable.\r\n\r\nor\r\n\r\n`connect_url`: `https://moq.cloudflare.com/twitch.tv/kixelated`\r\n`track_namespace`: `jfk06/1234532`\r\n\r\nThis is an example of something more _controversial_... a vanity URL. The CDN is configured with a mechanism to route requests to the origin based on both the `connect_url` and `track_namespace`.",
          "createdAt": "2023-05-19T20:58:31Z",
          "updatedAt": "2023-05-19T21:13:24Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you for the simplification.\r\n\r\nIndividual comment:\r\n\r\n> Is track_namespace independent of the connect_url?\r\n\r\nIn the meeting I heard \"generally yes.  You could couple them, but that might come with limitations\".\r\n\r\n> Does the producer's track_namespace need to be the same as the consumer's track_namespace?\r\n\r\nI think this depends a bit on the architecture of the application using moq.  In a system like Meta live today, we have effectively two systems, one for contribution and one for distribution, and a lot of Meta-only business logic in between -- it sounds like twitch is similar. In this case, the producer and consumer _can_ have separate namespaces.  In a system where someone writes an application (producer and consumer) and wants to traverse a generic relay (CDN), then *yes*, the namespaces need to be the same.  My read is that both flows are ok. \r\n\r\n> Do all consumer's track_namespace need to be the same?\r\n\r\nWithin a relay network connected to the publisher via ANNOUNCE, I think the answer is *yes*.  This applies more to the generic case than the closed case (eg: Meta).  The protocol only allows for the publisher to announce one namespace for a given track.  I'm imagining it's possible for a publisher to connect to two different CDNs, and could announce different track_namespaces to each, but publish the same content.  I don't know that's advantageous - as far as the CDNs are concerned these are two totally different track_namespaces, and it might complicate a bunch of other things.",
          "createdAt": "2023-05-19T21:03:41Z",
          "updatedAt": "2023-05-19T21:03:41Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> 1. Is `track_namespace` independent of the `connect_url`?\r\n\r\nyes , they are different as defined in https://kixelated.github.io/warp-draft/draft-lcurley-warp.html#name-connection-url\r\n+1 to Alan's point on the exception where they can be same but comes with limitations\r\n\r\n> 2\\. Does the producer's `track_namespace` need to be the same as the consumer's `track_namespace`?\r\n\r\nThis questions needs further qualification on architecture to answer i think and below is take of typical setup \r\n\r\n- Ingest client to ingest server  - they are same , where the ingest server will subscribe to producer tracks in the catalog\r\n\r\n- distribution server to viewer  - they are same, where the viewer will subscribe to tracks names listed by the distribution server in the catalog\r\n \r\n- ingest client to ingest sever to \"some-app-servers\" to distribution sever to viewer - they may or may not be same. There are 2 sub-cases here \r\n    - realtime conference use-case where they are more unified and alice's video wants to be consumed by  bob - they are same, where the bob is told on alice's track in the catalog distributed by a media switch, for example.\r\n    - This applies to media  transformer entity role, as defined in the arch spec. In this case the middle box can perform some transforms and introduce new track names and provide it in the catalog.\r\n\r\n\r\nPlease do refer to https://datatracker.ietf.org/doc/html/draft-nandakumar-moq-scenarios-00#section-2 for some explanation on this topic.\r\n\r\n> 3\\. Do all consumer's `track_namespace` need to be the same?\r\n\r\nI don't think I understand this question. can you please elaborate\r\n\r\n",
          "createdAt": "2023-05-20T17:12:33Z",
          "updatedAt": "2023-05-20T17:43:28Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\r\n> 1. Is `track_namespace` independent of the `connect_url`?\r\n\r\nYes. (You could twist my arm into the default track_namespace was the connect_url if not track_namespace was provide if that made things easier in some way)\r\n\r\n> 2. Does the producer's `track_namespace` need to be the same as the consumer's `track_namespace`?\r\n\r\nDepends on what you mean but I think mostly No.  Lets say the producer is using a namespace of fluffy-ingest and that goes to a transcode that republishes the media on a distribution network on akamai with the namespace fluffy786 and also publishes the media on cloudflare with the namespace webex.com:fluffy. Consumer on akamai would be using fluffy786 and consumers on cloudflare would be using  webex.com:fluffy. That would all seem fine to me. \r\n\r\nIf there was just one CDN, and that CDN had some API for applications to say \"hey fluffy-canada is an alias for the namespace fluffy-ingest\", that would also seem fine to me but the MoQ protocol does not define a way to provide that alias. (I would not object to adding a way to define aliases in an annouce or similar message). \r\n\r\nWe just need some fixed set of well defined bits that allow the Relays to map any given subscription to the corespoding annouce. \r\n\r\n> 3. Do all consumer's `track_namespace` need to be the same?\r\n>    3a. What about between different CDNs?\r\n\r\n(covered above)\r\n",
          "createdAt": "2023-05-20T22:24:44Z",
          "updatedAt": "2023-05-20T22:24:44Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Few comments on example given connect/track/auth message Luke had above. Very useful to have theses concreted examples. Thanks you.\r\n\r\n\r\nIn the example:\r\nconnect_url: https://ingest.twitch.tv\r\ntrack_namespace: kixelated\r\n\r\nI assume that this example is on the twitch CDN and that kixelated provided the uniqueness so that two different users don't publish to the same namespace. Do I have that correct ?\r\n\r\nIf it is the connect_url + track_namesace that is unique for that user, then I think you should just make your track namspace be https://ingest.twitch.tv/kixelated. If that causes problems in rewriting the catalog, then we should fix that by making the catalog so it does not have the rewrite problem. \r\n\r\nWhen you talk about \r\n\r\nvideo-ingest-def456.cmh01/kixelated/1234532\r\n\r\nI think what you are saying is your particular CDN has a prorietary meachism, which clients don't even need to know about, to say that video-ingest-def456.cmh01/kixelated/1234532 is alias for kixelated but that also caries the state tokens to allow used by the CDN. \r\n\r\nI'g got no issue with that, application and CDN will embed all kinds of state into the namespace bits. Go for it, but that is all outside the moq protocol. We will want to keep that out of protocol as it is probably covered by many patents. \r\n\r\nOn the encrypted namespace example of \r\n\r\ntrack_namespace: a124hdfhkjae234rwtjnwovmasdokv232asdg\r\n\r\nYes, that sense for the twitch CDN. IF that was on Akamai I might expect it to look more like \r\n\r\ntrack_namespace: twitch.tv/a124hdfhkjae234rwtjnwovmasdokv232asdg\r\n\r\non the assumption that Akamai was providing relay for other services as well.\r\n\r\n\r\nOn the vanity URL, I don't thing a track namespace is going to show up a user readable thing so seems sort of unlikely place to have a vanity URL, but as long as the CDN had a way to make sure they did allocate the same name to two different users, I don't see a problem. \r\n\r\nOn the auth of \r\ntrack_namespace: a124hdfhkjae234rwtjnwovmasdokv232asdg\r\n\r\nI view this as just an example of a124hdfhkjae234rwtjnwovmasdokv232asdg being the bearer token. You just stuff that same bits in the auth token and have that be the way that CDN does the auth for that namespace. \r\n\r\n\r\n\r\nOn the auth tokens. I would argue strongly for separate auth tokens for the connect URL and the namespace. In some situations you do want to authenticate the connect but it may not always be known at the time you want to generate the auth tokens for the namespace. In the case of enterprise relay, it may not even be operated by the same organization. This has some parallels to HTTP Proxy.  Nothing would stop an application from using same auth token for both but from a protocol point of view, I think it is better to separate them.\r\n\r\nI also think that the auth tokens for a namespace need to allow for separate tokens for consumer vs producer and allow multiple tokens for things such as key rotation, upgrade, multidomain etc. \r\n",
          "createdAt": "2023-05-20T22:54:06Z",
          "updatedAt": "2023-05-20T22:54:06Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> On the auth tokens. I would argue strongly for separate auth tokens for the connect URL and the namespace\r\n\r\n+1 \r\n\r\n> Lets say the producer is using a namespace of fluffy-ingest and that goes to a transcode that republishes the media on a distribution network on akamai with the namespace fluffy786 and also publishes the media on cloudflare with the namespace webex.com:fluffy.\r\n\r\nThis would be the Media Transformer entity within moq architecture, where a transcoder sources its own tracks by republishing the media after carrying out necessary transformation. ",
          "createdAt": "2023-05-21T04:39:23Z",
          "updatedAt": "2023-05-21T04:39:23Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "@kixelated Did #162 resolve this issue?",
          "createdAt": "2023-05-25T23:59:28Z",
          "updatedAt": "2023-05-25T23:59:28Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "\ud83d\udc4d ",
          "createdAt": "2023-05-26T00:04:45Z",
          "updatedAt": "2023-05-26T00:04:45Z"
        }
      ]
    },
    {
      "number": 71,
      "id": "I_kwDOG2Ho4M5dDLQ-",
      "title": "Generic clients connect via single URL ",
      "url": "https://github.com/moq-wg/moq-transport/issues/71",
      "state": "OPEN",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Requirement",
        "NotTransport"
      ],
      "body": "This is more of a requirement. \n\nWe need the ability for generic clients to publish and/or view a broadcast via a single URL. Examples of generic clients include OBS, ffmpeg, ExoPlayer, moq.js (TBD), and any other implementations.\n\nCurrently, Twitch broadcasters publish broadcasts via a `rtmp://` URL and viewers can consume via a HTTP HLS URL. We would want something similar for MoQ.\n\nIf there's a good reason we can require more than just a URL, but it has to be simple enough and explicitly part of the specification. No punting responsibility to the application because it hurts interoperability. An example is WebRTC, which did not specify how to exchange the SDP offer, and was only recently fixed by introducing WHIP and WHEP.",
      "createdAt": "2023-01-29T04:01:30Z",
      "updatedAt": "2024-02-19T23:37:15Z",
      "closedAt": null,
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Based on how the current draft reads, I think you could construct a URL like:\r\n\r\nhttps://example.org/webtransport-endpoint?full-track-name=X&auth=token\r\n\r\n[or similar for raw QUIC, but using the moq:// scheme]\r\n\r\nThis would establish a QUIC/H3 connection to example.org, a session to /webtransport-endpoint (WT CONNECT or SETUP PATH) and a SUBSCRIBE to full-track-name, with the associated auth (see #159 for example flow).\r\n\r\nThere are of course other ways to spell this.  Should this draft explain how to go from a full URL through connection/session establishment + sequence of messages?\r\n\r\n@kixelated ",
          "createdAt": "2023-05-26T23:41:09Z",
          "updatedAt": "2023-05-26T23:41:09Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this should be in it's own draft, not part of the transport draft. It need to point at the appropriate catalog, transport etc.  I think it should also specify what media codecs are MTI and what are optional.  To have interoperable, it needs to be that if I give the player the URL, I know that if can be played.  Similarly, if the URL is publish, a client that is implements whatever the spec that de",
          "createdAt": "2023-10-05T11:35:10Z",
          "updatedAt": "2023-10-05T11:35:10Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, this would be part of the Warp draft, not the transport draft.",
          "createdAt": "2023-10-05T11:36:42Z",
          "updatedAt": "2023-10-05T11:36:42Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "What is the relationship of this issue to #268?  Can one be closed?",
          "createdAt": "2023-11-10T12:18:33Z",
          "updatedAt": "2023-11-10T12:18:33Z"
        }
      ]
    },
    {
      "number": 73,
      "id": "I_kwDOG2Ho4M5dLiMt",
      "title": "QUIC is over UDP",
      "url": "https://github.com/moq-wg/moq-transport/issues/73",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Editorial"
      ],
      "body": "In Sec 3.1 it says \"This is possible with the emergence of QUIC, designed to fix the shortcomings of TCP\" in the context of TCP and UDP-based protocols.\r\n\r\nPedants will note that QUIC is over UDP. It is probably worth to add something to the effect of:\r\n\r\n\"While QUIC is also over UDP, it frees the media protocol from handling functions that might otherwise be handled by TCP.\"",
      "createdAt": "2023-01-30T22:22:02Z",
      "updatedAt": "2023-10-19T03:09:28Z",
      "closedAt": "2023-10-19T03:09:27Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "This section now reads:\r\n\r\n> TCP-based protocols are simple but are slow to detect congestion and suffer from head-of-line blocking. UDP-based protocols can avoid queuing, but the application is now responsible for the complexity of fragmentation, congestion control, retransmissions, receiver feedback, reassembly, and more. One goal of MOQT is to achieve the best of both these worlds: leverage the features of QUIC to create a simple yet flexible low latency protocol that can rapidly detect and respond to congestion\r\n\r\nNot sure if that fully addressed your concern @martinduke ",
          "createdAt": "2023-05-26T23:35:34Z",
          "updatedAt": "2023-05-26T23:35:34Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Not really. It's a minor point, but how about\r\ns/UDP-based protocols/protocols directly over UDP",
          "createdAt": "2023-05-30T17:50:35Z",
          "updatedAt": "2023-05-30T17:50:35Z"
        }
      ]
    },
    {
      "number": 74,
      "id": "I_kwDOG2Ho4M5dLjJL",
      "title": "Initial Delivery Order?",
      "url": "https://github.com/moq-wg/moq-transport/issues/74",
      "state": "OPEN",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Editorial"
      ],
      "body": "S4.2 remarks that later objects might have a lower delivery order than older objects. Maybe this is obvious, but is it therefore smart to have the first object with an arbitrary large delivery order so that subsequent objects can have a lower one?\r\n\r\nA naive implementation might start with zero, but there are no negative varints.",
      "createdAt": "2023-01-30T22:25:26Z",
      "updatedAt": "2023-01-31T20:08:47Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 75,
      "id": "I_kwDOG2Ho4M5dLns5",
      "title": "RESET_STREAM and STOP_SENDING are half-duplex",
      "url": "https://github.com/moq-wg/moq-transport/issues/75",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Editorial"
      ],
      "body": "S 5.5 To be precise, if a bidirectional stream, the endpoint may have to send both to fully cancel the stream.\r\n\r\nOn the other hand, the need for bidirectional streams is a little under-defined.",
      "createdAt": "2023-01-30T22:46:50Z",
      "updatedAt": "2023-10-16T21:26:16Z",
      "closedAt": "2023-10-16T21:26:16Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is OBE, so closing, but please reopen if I'm incorrect.",
          "createdAt": "2023-10-16T21:26:16Z",
          "updatedAt": "2023-10-16T21:26:16Z"
        }
      ]
    },
    {
      "number": 76,
      "id": "I_kwDOG2Ho4M5dLoFD",
      "title": "Fate of SETUP stream?",
      "url": "https://github.com/moq-wg/moq-transport/issues/76",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Editorial",
        "Control Streams"
      ],
      "body": "What is the expected behavior once the endpoint sends the whole SETUP message? FIN it, or leave it open forever?",
      "createdAt": "2023-01-30T22:48:45Z",
      "updatedAt": "2023-10-16T21:23:34Z",
      "closedAt": "2023-10-16T21:23:34Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #280 ",
          "createdAt": "2023-10-16T21:23:00Z",
          "updatedAt": "2023-10-16T21:23:00Z"
        }
      ]
    },
    {
      "number": 77,
      "id": "I_kwDOG2Ho4M5dLpEb",
      "title": "\"fully supports ECN\"",
      "url": "https://github.com/moq-wg/moq-transport/issues/77",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Editorial"
      ],
      "body": "Sec 5.7. \"It is NOT RECOMMENDED to use a loss-based algorithm (ex. [[NewReno](https://kixelated.github.io/warp-draft/draft-lcurley-warp.html#NewReno)]) unless the network fully supports ECN.\"\r\n\r\n1) Thanks for mentioning ECN!\r\n\r\n2) Add a reference! Do you mean RFC 3168, RFC 9330 (L4S), or both? I'm not sure 3168 helps all that much with bufferbloat, but regardless the draft should say what you mean.\r\n\r\n3) What is \"full support\" for ECN and how would an endpoint know this? Perhaps you mean \"all routers in the path apply congestion markings in accordance with the scheme we operating\" and an endpoint knows this a priori (perhaps because it's a transfer to a relay over a single AS). But the draft should be more specific!",
      "createdAt": "2023-01-30T22:54:00Z",
      "updatedAt": "2023-05-30T16:51:02Z",
      "closedAt": "2023-05-30T16:51:02Z",
      "comments": [
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think things about congestion control algorithms are probably best left to the QUIC layer than trying to deal with them at MoQ layer. ",
          "createdAt": "2023-03-30T23:14:31Z",
          "updatedAt": "2023-03-30T23:14:31Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "This section (and the ECN reference) got removed in the latest draft.  @martinduke Is it OK to close this issue?",
          "createdAt": "2023-05-26T23:32:12Z",
          "updatedAt": "2023-05-26T23:32:12Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "SGTM",
          "createdAt": "2023-05-30T16:51:02Z",
          "updatedAt": "2023-05-30T16:51:02Z"
        }
      ]
    },
    {
      "number": 78,
      "id": "I_kwDOG2Ho4M5dL6BC",
      "title": "Definition of Messages in Section  makes too many assumptions",
      "url": "https://github.com/moq-wg/moq-transport/issues/78",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "suhasHere",
        "huitema"
      ],
      "labels": [],
      "body": "I am concern that the definition of messages in section 6 relies too much on a specific way to organize the application, i.e., the \"catalog\". My experience building the QUICR prototype tells me that a much simpler design is possible:\r\n\r\n1) Applications are designed to handle a number of media streams, organizing these media streams as a set of media streams possibly coming from multiple sources, e.g., multiple participants in a video conference. But then, some applications will have different designs, e.g., just one single broadcast source. The \"catalog\" is an attempt to advertise and organize these multiple streams, but it is pretty hard to do that in a fully generic way. It might be much simpler to punt, and decide that QUICR will only specify the transport of exactly one media stream, identified by a unique URI. That means, removing the \"catalog\".\r\n\r\n2) The current protocol (WARP) specifies organizing the media stream as a set of \"group of objects\". This should be reflected in the protocol messages.\r\n\r\n3) Implementations would be simpler if the transport definitions were split for each media stream between a \"bidirectional QUIC control stream\" carrying setup messages and a set of \"unidirectional QUIC data streams\" (or possibly, datagrams). This can negotiate a media ID (e.g., the stream ID of the control stream), making the object headers significantly shorter.\r\n\r\n4) WARP stream would be better defined as composed of a WARP header (media ID, group ID, some group parameters) followed by series of object in the group -- no need then to repeat media ID and group ID for each object.\r\n\r\n5) We should pay more attention to termination conditions, e.g. specify how many objects were expected in a given block, or what is the last object of a media stream. This is useful to detect error conditions, monitor losses, etc. Also, allows termination of streams \"as soon as everything is received\", instead of waiting for time outs.\r\n\r\n",
      "createdAt": "2023-01-31T00:08:29Z",
      "updatedAt": "2024-02-20T02:30:46Z",
      "closedAt": "2024-02-20T02:30:46Z",
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this issue is still valid and address with some of the recent alignments and changes that went in or proposed\n",
          "createdAt": "2023-05-21T19:42:34Z",
          "updatedAt": "2023-05-21T19:42:34Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe this is OBE, but reopen or open new more focused issues if I'm wrong.",
          "createdAt": "2024-02-20T02:30:46Z",
          "updatedAt": "2024-02-20T02:30:46Z"
        }
      ]
    },
    {
      "number": 79,
      "id": "I_kwDOG2Ho4M5dQtHF",
      "title": "Broadcast publisher reconnect support",
      "url": "https://github.com/moq-wg/moq-transport/issues/79",
      "state": "OPEN",
      "author": "kpugin",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Subscribe"
      ],
      "body": "In [Model](https://github.com/kixelated/warp-draft/blame/main/draft-lcurley-warp.md#L186) section it says that each Media object is uniquely identified within broadcast, track, etc. I am wondering how reconnect would work - wouldn't it require publisher to maintain state? What happens if one encoder box fails and broadcast needs to be resumed from another box?",
      "createdAt": "2023-01-31T16:39:49Z",
      "updatedAt": "2024-02-19T23:36:10Z",
      "closedAt": null,
      "comments": [
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What happens in a HTTP CDN today if a cache asks for an file from origin, origin says it is cachable for a long time, then the origin servers crashes when it comes up generates a different file, with the same name. What will happen is pretty broken on different clients get different version of the file.\r\n\r\nWe have the same issue here, if two clients publish an object with different data but same full track name, group ID, and object ID, then it is undefined which version will get served to any given subscription. This is going to be the nature of any design that provides both aggregation and caching and has unique names. \r\n",
          "createdAt": "2023-11-27T19:14:35Z",
          "updatedAt": "2023-11-27T19:14:35Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment: \r\n\r\nHTTP has eTags to help deal with this problem.  This is not an endorsement that we should add eTags to moq.",
          "createdAt": "2023-11-27T19:25:45Z",
          "updatedAt": "2023-11-27T19:25:45Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The OP raises two questions - how to handle reconnects and how to handle failovers. These are separate behaviors and should be addressed separately. Here's how it might work: \r\n\r\n**Reconnect**\r\nA publishers connects the first time and ANNOUNCES a namespace+name. It receives a subscribe request, starts publishing and then has a loss of connection. Its connection fails midway through publishing a group and object. A minute later, its connection returns. Prior to resuming publishing the track, it can publish a catalog update in which it describes a discontinuity in the track. It can list the the last known good group and number and also the group and number on which it will resume publishing. It then resumes publishing at the new group and number. Since end-clients should always be subscribed to catalog updates, they would be informed of the discontinuity and could purge their buffers and reset their decoders accordingly. This behavior would give publishers the choice or resuming where they left off (and thus falling behind in latency) or resuming at the live point. \r\n\r\n**Failover**\r\nI don't think 3rd party networks should be responsible for seamlessly repairing tracks. This means that the notion of \"primary\" and \"backup\" versions of a track exists only between publishers and end-subscribers. We can use the catalog, published by each redundant publisher, to describe the failover track and whether it is timeline-identical, or not. If an end-subscriber times-out against the primary source (or receives some sort of error message), then it can switch itself to the backup source. These primary and backup sources must have different namespace+name tuples so that the network caches them independently. ",
          "createdAt": "2023-11-27T19:55:00Z",
          "updatedAt": "2023-11-27T19:55:00Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> I am wondering how reconnect would work - wouldn't it require publisher to maintain state? What happens if one encoder box fails and broadcast needs to be resumed from another box?\r\n\r\nThe publisher MUST retain state for any reconnect to work. Even something as trivial as group sequence numbers needs to be maintained, otherwise you run into split brain and potential cache poisoning. Consider a player that receives group 69 and then suddenly group 0 (because of a stateless reconnect): it will just throw it out. And of course tracks need to be consistent; the new encoder can't just use different encodings or identification on a whim.\r\n\r\nWe should absolutely support publishers that can seamlessly continue a broadcast if they can persist the required state. Like @afrind mentioned, I think this would look more like an ETag. The new ANNOUNCE would specify that it's a continuation of the original ANNOUNCE if they have matching IDs.",
          "createdAt": "2023-11-27T20:46:26Z",
          "updatedAt": "2023-11-27T20:47:38Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "IOT media publishers will for sure not maintain any state on restarts.   I think a system where we are using static names and maintain caches based on that and expect it to work over restarts is a brittle system and doesn't scale really well where the system is dynamic and networks/connections come and go.\r\n\r\n",
          "createdAt": "2023-11-29T03:48:56Z",
          "updatedAt": "2023-11-29T03:48:56Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Possibly this can be fixed as part of @fluffy PRs for make before break?",
          "createdAt": "2024-02-07T22:17:19Z",
          "updatedAt": "2024-02-07T22:17:19Z"
        }
      ]
    },
    {
      "number": 80,
      "id": "I_kwDOG2Ho4M5dRElX",
      "title": "Relay failover support for subscribers and publishers",
      "url": "https://github.com/moq-wg/moq-transport/issues/80",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "duplicate",
        "Requirement"
      ],
      "body": "There is a need for subscribers and publishers to reconnect across relays with minimal state loss.",
      "createdAt": "2023-01-31T17:47:51Z",
      "updatedAt": "2024-02-20T02:33:44Z",
      "closedAt": "2024-02-20T02:33:44Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, that means limiting the amount of per-connection state. As was mentioned at lunch, we could still use something like QPACK to compress on a per-connection state, but stuff like the broadcast URN should be consistent across connections.",
          "createdAt": "2023-02-01T22:14:25Z",
          "updatedAt": "2023-02-01T22:14:25Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is a duplicate of #79, which is more generic (the reconnect problem applies to all publishers/subscribers and not just relays)",
          "createdAt": "2023-05-05T20:19:10Z",
          "updatedAt": "2023-05-05T20:19:10Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed it too quickly, that issue is only about publishers.",
          "createdAt": "2023-05-05T20:20:02Z",
          "updatedAt": "2023-05-05T20:20:02Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "yes, this needs some handling in the transport",
          "createdAt": "2023-08-08T05:36:50Z",
          "updatedAt": "2023-08-08T05:36:50Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "There are newer issues that discuss this in more detail, so closing this as a duplicate.",
          "createdAt": "2024-02-20T02:33:44Z",
          "updatedAt": "2024-02-20T02:33:44Z"
        }
      ]
    },
    {
      "number": 81,
      "id": "I_kwDOG2Ho4M5dRF4Y",
      "title": "MoQ Control Stream Support for managing the data streams",
      "url": "https://github.com/moq-wg/moq-transport/issues/81",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Requirement"
      ],
      "body": "",
      "createdAt": "2023-01-31T17:51:49Z",
      "updatedAt": "2023-05-05T19:50:21Z",
      "closedAt": "2023-05-05T19:50:21Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I can imagine a relay would want to push multiple broadcasts over a single QUIC connection. A single control stream would introduce head-of-line blocking.\r\n\r\nA few options:\r\n\r\n1. Don't care about HoL blocking\r\n2. Create a WebTransport session per broadcast\r\n3. Create a control stream per broadcast",
          "createdAt": "2023-01-31T18:15:51Z",
          "updatedAt": "2023-01-31T18:16:30Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "To clarify, the current draft doesn't specify how you're supposed to use streams outside of SETUP.\r\n\r\nI propose:\r\n\r\nEach control stream would start with a SETUP message (like H3 SETTINGS). Any messages for a broadcast (CATALOG/SUBSCRIBE) must use the same (bidirectional?) control stream. The publisher can create any number of unidirectional data streams to send OBJECTs.",
          "createdAt": "2023-01-31T18:19:36Z",
          "updatedAt": "2023-01-31T18:26:54Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Possible duplicate now with #138 -- can we merge them?",
          "createdAt": "2023-04-21T19:33:19Z",
          "updatedAt": "2023-04-21T19:33:19Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Duplicate of #138 ",
          "createdAt": "2023-05-05T19:50:21Z",
          "updatedAt": "2023-05-05T19:50:21Z"
        }
      ]
    },
    {
      "number": 82,
      "id": "I_kwDOG2Ho4M5dRIWL",
      "title": "Broadcast URI in Object message",
      "url": "https://github.com/moq-wg/moq-transport/issues/82",
      "state": "CLOSED",
      "author": "kpugin",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently Object message specify Broadcast URI for every object - that's going to be pretty big overhead, especially for low bitrate videos and audio. This one of the current problems for example with fMP4 and according to some analysis overhead just from 1 frame CMAF chunks can be 10+ %",
      "createdAt": "2023-01-31T17:58:55Z",
      "updatedAt": "2023-05-05T19:56:13Z",
      "closedAt": "2023-05-05T19:56:13Z",
      "comments": [
        {
          "author": "grmocg",
          "authorAssociation": "NONE",
          "body": "Two concerns to address:\r\n1- how to address this thing without too much waste on the wire\r\n2- how to consistently address this thing such that we don't waste lots of space in memory and also waste compute remapping things in relays.",
          "createdAt": "2023-02-02T00:20:30Z",
          "updatedAt": "2023-02-02T00:20:30Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Given this never changes for the track, I don't see why every audio packet would need a URI. It also seems for the level of where MoQ works and the different applications, a track URI is more what we want than the broadcast, of course the application may have a concept of broadcast, but it seems at the MoQ layer is more working at the track level. ",
          "createdAt": "2023-03-12T16:03:12Z",
          "updatedAt": "2023-03-12T16:03:12Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "This has been addressed in #98. The URL in the WebTransport CONNECT is used to identify the track bundle (aka broadcast) and all tracks/objects are scoped to it. Effectively it's a lookup table now based on the WebTransport session.\r\n\r\nThere's a seperate discussion how the Track ID is scoped. I think it should be relative to the track bundle, but I've heard a few opinions that it should be global or even scoped to the CDN. The bigger the scope, the more bytes you need for the ID, and the more bytes of overhead for each OBJECT. Unless there's a lookup table somewhere else on the wire (catalog?).",
          "createdAt": "2023-03-17T20:22:48Z",
          "updatedAt": "2023-03-17T20:23:45Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "can we close this ?",
          "createdAt": "2023-04-07T21:26:04Z",
          "updatedAt": "2023-04-07T21:26:04Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "> can we close this ?\r\n\r\n+1 \r\n\r\n@kpugin are you good here?",
          "createdAt": "2023-04-21T19:32:30Z",
          "updatedAt": "2023-04-21T19:32:30Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "OBJECT message now contains a \"track id\" varint rather than the full URL",
          "createdAt": "2023-05-05T19:56:13Z",
          "updatedAt": "2023-05-05T19:56:13Z"
        }
      ]
    },
    {
      "number": 83,
      "id": "I_kwDOG2Ho4M5dRxTk",
      "title": "Improve startup latency",
      "url": "https://github.com/moq-wg/moq-transport/issues/83",
      "state": "OPEN",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Handshake",
        "Parked"
      ],
      "body": "Overview of the current draft.\r\n\r\nIngest\r\n```\r\n--> client CONNECT   url=auth\r\n--> client SETUP     role=producer\r\n<-- server CONNECT   status=200\r\n<-- server SETUP     role=consumer\r\n--> client CATALOG   broadcast=superbowl track=a track=b track=c\r\n<-- server SUBSCRIBE broadcast=superbowl track=b\r\n--> client OBJECT    broadcast=superbowl track=b\r\n```\r\n\r\nDistribution\r\n```\r\n--> client CONNECT   url=auth\r\n--> client SETUP     role=consumer\r\n<-- server CONNECT   status=200\r\n<-- server SETUP     role=producer\r\n<-- server CATALOG   broadcast=superbowl track=a track=b track=c\r\n--> client SUBSCRIBE broadcast=superbowl track=b\r\n<-- server OBJECT    broadcast=superbowl track=b\r\n```\r\n\r\nIf we can avoid blocking on the SETUP, then that can reduce a round trip in the ingest case. If we can push OBJECTs before the SUBSCRIBE, especially if there's only one track, then that will reduce a round trip too.",
      "createdAt": "2023-01-31T20:15:51Z",
      "updatedAt": "2024-02-19T23:30:48Z",
      "closedAt": null,
      "comments": [
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The question to ask is what information can you move out of the CONNECT and SETUP so that the they can just be overlapped with the messages below. As far as I can tell, all of info \r\n\r\nIngest 0 RTT\r\n--> client PUBLISH url=auth role=producer broadcast=superbowl track=a track=b track=c\r\n--> client OBJECT \r\n\r\nDistribution 2 RTT \r\n--> client SUBSCRIBE catalog role=consumer url=auth\r\n<-- server CATALOG   broadcast=superbowl track=a track=b track=c\r\n--> client SUBSCRIBE broadcast=superbowl track=b role=consumer url=auth\r\n<-- server OBJECT    \r\n",
          "createdAt": "2023-04-07T21:19:52Z",
          "updatedAt": "2023-04-07T21:19:52Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "This seems to be fine suggestion. There are some nuances, but we are at the point where we can start thinking about reducing the round trips",
          "createdAt": "2023-05-21T19:52:42Z",
          "updatedAt": "2023-05-21T19:52:42Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't see anything in the existing docs that prevent pipelining, assuming one knows what to SUBSCRIBE to prior to connecting.  Clearly adding a catalog request adds at least one round trip.\r\n\r\nShould we add editorial text that makes it clear that when prior information is available, the goal is to enable 0-RTT Subscriptions?",
          "createdAt": "2023-10-18T00:12:02Z",
          "updatedAt": "2023-10-18T00:12:02Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "We can pipeline now that there's a single control stream. CONNECT/SETUP/SUBSCRIBE cooould be sent in the first flight in theory. However, stuff like negotiating versions/extensions in SETUP will force an RTT unless SUBSCRIBE is the same across all offered versions/extensions.\r\n\r\nThe catalog request is specific to the media layer so I wouldn't mention that. And I can totally envision a layer on top of MoqTransport where the tracks are pre-negotiated; like a simple RTMP replacement with a \"video\" and \"audio\" track. Or possibly a \"default\" track that is fetched in parallel with the catalog.",
          "createdAt": "2023-10-18T00:55:04Z",
          "updatedAt": "2023-10-18T00:55:57Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment: \r\n\r\nNow that SETUP has version-specific parameters, it is possible to encode version specific initial messages as a SETUP parameter to reduce startup latency - eg: \r\n\r\nIngest:\r\n```\r\nC->S\r\nClientSetup\r\n ROLE: x\r\n PATH: y\r\n INITIAL_ANNOUNCE: {v1 announce message}\r\n\r\nS->C\r\nServerSetup\r\nAnnounceOK\r\nSubscribe\r\n```\r\nDistribution (where track name is known):\r\n\r\n```\r\nClientSetup\r\n ROLE: x\r\n PATH: y\r\n INITIAL_SUBSCRIBE: {v1 subscribe message}\r\n\r\nS->C\r\nServerSetup\r\nSubscribeOk\r\n\r\nUni Stream:\r\n Object\r\n```\r\n\r\nThis one is a little fraught since the uni stream may arrive before ServerSetup, so the client may not know how to parse it yet if multiple versions were offered.  Maybe that's ok?  It's still a win compared to waiting the full RTT.\r\n",
          "createdAt": "2023-11-10T12:30:27Z",
          "updatedAt": "2023-11-10T12:30:27Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not a fan of smuggling version-specific messages into `SETUP`. If an extension modified `ANNOUNCE`/`SUBSCRIBE`, then we would also need version+extension messages for every permutation. It gets messy quickly and it feels like there should be a better way.\r\n\r\nHere's some other ideas too. Using this example (contribution) handshake with the current draft, ignoring the QUIC handshake:\r\n```\r\n--> CONNECT url=https://live.twitch.tv\r\n<-- CONNECT status=OK\r\n--> SETUP versions=1,2,3 extensions=59,382,41\r\n<-- SETUP version=3 extensions=41\r\n--> ANNOUNCE twitch.tv/kixelated\r\n<-- SUBSCRIBE twitch.tv/kixelated track=video\r\n--> OBJECT track=video id=0\r\n(3.5 RTTs)\r\n```\r\n\r\n\r\n## 0. Move SETUP into the WebTransport CONNECT\r\nAvoids a round trip by combining with the previous flight. Would require IETF and W3C cooperation but I think this would be super useful for other applications. Encoded either into a HTTP header or perhaps the CONNECT body.\r\n\r\nThis would only remove a round trip for WebTransport without a similar QUIC extension, like \"application parameters\" sent alongside \"transport parameters\".\r\n\r\n```\r\n--> CONNECT url=https://live.twitch.tv body=SETUP\r\n<-- CONNECT status=OK body=SETUP\r\n--> ANNOUNCE ...\r\n<-- SUBSCRIBE ...\r\n--> OBJECT ...\r\n(2.5 RTTs)\r\n```\r\n\r\n## 1. Move version/extension negotiation to ALPN.\r\nVerbose, but would remove a round trip by combining with the previous flight. There would be no more SETUP message.\r\n\r\nHowever initial flow control limits, like max subscribes, would have to be non-zero. Extension negotiation would also be relegated to booleans, which frankly I'm not opposed to as we can get rid of unknown-length parameters.\r\n\r\n```\r\n--> CONNECT url=https://live.twitch.tv alpn=moq-transport;versions=1,2,3;extensions=59,382,41\r\n<-- CONNECT status=OK alpn=moq-transport;version=3;extensions=41\r\n--> ANNOUNCE ...\r\n<-- SUBSCRIBE ...\r\n--> OBJECT ...\r\n(2.5 RTTs)\r\n```\r\n\r\n# 2. Move version negotiation into ALPN, use separate handshake for extensions\r\nSame thing, but with a simpler ALPN. You can use the base functionality of the version until the SETUP completes, just like HTTP/3 SETTINGS. There would be no version negotiation in SETUP.\r\n\r\n```\r\n--> CONNECT url=https://live.twitch.tv alpn=moq-transport;versions=1,2,3\r\n<-- CONNECT status=OK alpn=moq-transport;version=3\r\n--> ANNOUNCE ...\r\n--> SETUP extensions=59,382,41\r\n<-- SUBSCRIBE ...\r\n<-- SETUP extensions=41\r\n--> OBJECT ...\r\n(no extensions: 2.5 RTTs)\r\n(required extensions: 3.5 RTTs)\r\n```\r\n\r\n# 3. Require that `ANNOUNCE`/`SUBSCRIBE` are backwards compatible\r\nIf a draft specifies that future versions MUST use the same wire encoding, then you can send messages in the same flight as `SETUP`. Any new fields would go into `params`. I would not advise this until the protocol is super stable.\r\n\r\n```\r\n--> CONNECT url=https://live.twitch.tv\r\n<-- CONNECT status=OK\r\n--> SETUP ...\r\n--> ANNOUNCE twitch.tv/kixelated params=(extensions)\r\n<-- SETUP ...\r\n<-- SUBSCRIBE twitch.tv/kixelated track=video params=(extensions)\r\n--> OBJECT ...\r\n(2.5 RTTs)\r\n```\r\n\r\n# 4. Encode the `ANNOUNCE` into the path\r\nKinda gross, but it's an option if we specify a schema that MUST be backwards compatible, like Ted's proposal.\r\n\r\n```\r\n--> CONNECT url=https://live.twitch.tv/?announce=twitch.tv/kixelated\r\n(implicit: ANNOUNCE twitch.tv/kixelated)\r\n<-- CONNECT status=OK\r\n--> SETUP ...\r\n<-- SETUP ...\r\n<-- SUBSCRIBE ...\r\n--> OBJECT ...\r\n(2.5 RTTs)\r\n```\r\n\r\n# 5. Implicit `ANNOUNCE`\r\nIf a scheme is negotiated out of band, a service can encode enough information in the URL to implicitly perform the announce (including auth). The client would still send an explicit ANNOUNCE message as a fallback, but if the server supports the implicit announce then it will remove a round trip.\r\n\r\nI know people don't like implicit announces, but this is basically what we're already doing with distribution. A client can be told to connect to a URL and SUBSCRIBE to a track namespace, without waiting for the server to ANNOUNCE that namespace. This is the opposite, the client is told to connect to a URL and the server can SUBSCRIBE to a namespace, without waiting for the client to ANNOUNCE said namespace. \r\n\r\nAnyway this is possible today, and will always be an option while ANNOUNCE remains optional. I imagine we'll see a lot of this in practice, kind of like how like HTTP applications often encode auth into the URL instead of using the official `Authorization` headers.\r\n\r\n```\r\n--> CONNECT url=https://ingest.twitch.tv/kixelated\r\n(implicit: ANNOUNCE twitch.tv/kixelated)\r\n<-- CONNECT status=OK\r\n--> SETUP ...\r\n<-- SETUP ...\r\n<-- SUBSCRIBE ...\r\n--> OBJECT ...\r\n--> ANNOUNCE ... (explicit)\r\n(implicit: 2.5 RTTs)\r\n(explicit: 3.5 RTTs)\r\n```",
          "createdAt": "2023-11-11T03:59:47Z",
          "updatedAt": "2023-11-11T07:48:26Z"
        }
      ]
    },
    {
      "number": 84,
      "id": "I_kwDOG2Ho4M5dSxj2",
      "title": "Support capabilities and separate it from Catalog",
      "url": "https://github.com/moq-wg/moq-transport/issues/84",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-02-01T00:28:55Z",
      "updatedAt": "2023-08-08T05:37:50Z",
      "closedAt": "2023-08-08T05:37:50Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Do you think capabilities would make more sense in the SETUP message? How would we encode it? (pls don't say SDP)",
          "createdAt": "2023-02-01T22:12:43Z",
          "updatedAt": "2023-02-01T22:12:43Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@suhasHere  - can you provide more context and detail for this issue, specifically around what you mean by \"support capabilities\"? Are you referring to capabilities of the client to consume the content being broadcast (i.e decode HEVC, render Dolby Atmos etc) or capabilities to understand the catalog format? ",
          "createdAt": "2023-02-27T19:02:46Z",
          "updatedAt": "2023-02-27T19:02:46Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Let me try and get the use case here for this bug:\r\n\r\nImagine the client is a very generic MoQ device. It has a camera that can send at H.264 many resolution/framerates. It also has a document/desktop share that can do H.264 and AV1 and high resolutions and range of framerates, It has stereo and mono micrphones etc. It can also display 1 or more stream and do client side composition. ( I'm more or less desicrbin the Cisco Desk Pro sitting on my desk but it could just as well be OBS). \r\n\r\nIt is connecting to some service such as twitch/webex. I am assuming that webex will construct a catalog that tells the the client what to publish and what to subscribe to. \r\n\r\nThe questions is how does the webex service know enough about the devices capabilities to construct a catalog that makes sense in this case. I think we need to sort out some solution to this. ",
          "createdAt": "2023-04-07T21:09:52Z",
          "updatedAt": "2023-04-07T21:09:52Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The type of solution I would favor is client can describe it capabilities in something that looks a lot like a subset of a catalog message. ",
          "createdAt": "2023-04-07T21:10:44Z",
          "updatedAt": "2023-04-07T21:10:44Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> am assuming that webex will construct a catalog that tells the the client what to publish and what to subscribe to.\r\n> \r\n> The questions is how does the webex service know enough about the devices capabilities to construct a catalog that makes sense in this case. I think we need to sort out some solution to this.\r\n\r\nI think the answer here is that the client (which knows its own capabilities), is the one responsible for constructing its own catalog. It knows all that it can produce and it puts that in a catalog and sends it to webex. Webex may then forward that unmodified to all subscribers, or it may filter it in order to standardize features (i.e remove AV1 across all publishers). There may be some application business logic around what each Webex publisher must provide, but that would be an out-of-band communication and enforcement that is handled by Webex, not MoQ . I don't think MoQTransport has to build in a complex discovery negotiation in which anonymous publishers can be interrogated by a subscriber.",
          "createdAt": "2023-04-07T22:52:10Z",
          "updatedAt": "2023-04-07T22:52:10Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Since we're moving catalog out to https://github.com/wilaw/MoQ, do we still need client capabilities defined in the base protocol?",
          "createdAt": "2023-04-21T19:31:44Z",
          "updatedAt": "2023-04-21T19:31:44Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "we can close this  issue and handle it elsewhere",
          "createdAt": "2023-08-08T05:37:50Z",
          "updatedAt": "2023-08-08T05:37:50Z"
        }
      ]
    },
    {
      "number": 85,
      "id": "I_kwDOG2Ho4M5dSx8n",
      "title": "Move Catalog details to its own spec",
      "url": "https://github.com/moq-wg/moq-transport/issues/85",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Today the protocol specifies the format of the catalog message. Should we keep it opaque and have an extension spec to define container specific catalog formats",
      "createdAt": "2023-02-01T00:30:45Z",
      "updatedAt": "2023-05-05T19:50:48Z",
      "closedAt": "2023-05-05T19:50:48Z",
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "If we remove CATALOG, how would we deal with INIT segments?",
          "createdAt": "2023-02-01T19:41:44Z",
          "updatedAt": "2023-02-01T19:41:44Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "INIT segments could be in the catalog itself, kind of like how you can base64 them in DASH.",
          "createdAt": "2023-02-01T22:11:58Z",
          "updatedAt": "2023-02-01T22:11:58Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Is this a duplicate of #66?",
          "createdAt": "2023-02-03T01:17:19Z",
          "updatedAt": "2023-02-03T01:17:19Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Agree with @kixelated .. If the container type is CMAF, the init segment is part of Catalog for a given track. This issue is proposing moving format specific catalog definition to companion spec IIUC from the discussions",
          "createdAt": "2023-02-13T01:29:41Z",
          "updatedAt": "2023-02-13T01:29:41Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Is this a duplicate of #66",
          "createdAt": "2023-04-21T19:30:10Z",
          "updatedAt": "2023-04-21T19:30:10Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Duplicate of #66 ",
          "createdAt": "2023-05-05T19:50:48Z",
          "updatedAt": "2023-05-05T19:50:48Z"
        }
      ]
    },
    {
      "number": 87,
      "id": "I_kwDOG2Ho4M5dZtXh",
      "title": "1 producer received per broadcast? multiple producers received per broadcast",
      "url": "https://github.com/moq-wg/moq-transport/issues/87",
      "state": "OPEN",
      "author": "vr000m",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "NotTransport"
      ],
      "body": "There seems to be a strong assumption to have 1 publisher in a broadcast. \r\n\r\nFor use-cases in which there are multiple broadcasters, is the viewer watching one broadcast or several? There is a bandwidth/fairness consequence of a viewer watching multiple broadcasts.\r\n\r\nFor example: NFL Red zone.\r\n\r\nESPN is ingesting several broadcasts, each game could be its own broadcast. some one could be watching just one of the games, however, it is possible for a viewer watching Red zone get simultaneous games, the priority of these individual feeds maybe equal. In this case the relay and the viewer can co-ordinate a way to get all/some of the streams depending on the user-experience.\r\n\r\nOr another similar example is video conferencing, such as, town halls, fitness, newscasts, etc. where there may be a few speakers and several more viewers.",
      "createdAt": "2023-02-01T23:29:54Z",
      "updatedAt": "2023-10-18T02:55:18Z",
      "closedAt": null,
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "In general we need to acknowledge multiple publishers within a MoQ MediaSession and how it gets, identified and delivered",
          "createdAt": "2023-02-01T23:38:37Z",
          "updatedAt": "2023-02-01T23:38:37Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Speaking as an individual: this ties to what Ted called a composition -- which represents what the viewer is actually watching.  I think we agree that a viewer can be watching something with multiple simultaneous publishers.  Where there might be disagreement is to what degree that needs to be captured in the transport protocol.  The NFL Red Zone case could also be accomplished by having each game as a separate broadcast (received over one or many QUIC connections), with the application handling the composition.\r\n\r\nWhat are the tradeoffs for having multiple broadcasts in a single session vs one broadcast per session with multiple sessions?",
          "createdAt": "2023-02-03T17:20:56Z",
          "updatedAt": "2023-02-03T17:20:56Z"
        },
        {
          "author": "vr000m",
          "authorAssociation": "NONE",
          "body": "The biggest advantage of a single session or multiple sessions is how the congestion control(s) acts or interacts across these QUIC connections. \r\n\r\nIn case of a bandwidth limitation, all the video streams that make up the composite cannot be received. In this case, some degradation choices need to be made: lower frame resolution or frame rate (skipping some frames) for some or all videos that make up the broadcast. \r\n\r\nIn one world, the relay which is broadcasting the composited videos understands the underlying priority of the frames from one broadcast and the other and can manage the priority queue of packets/frames.\r\n\r\nIn another world, the client which is receiving several broadcasts and compositing on the client side, it can unilaterally decide which video streams to receive, and which frames to not to subscribe to (by cancelling the streamIDs). \r\n\r\nPersonally, in the latter case, I like the client being able to decide (independently from the relays) which videos in the composite it wants to  degrade, however, I also like the simplicity of a composite broadcast, because  relays may benefit from knowing which set of video streams are related and can cache them appropriately.\r\n\r\n",
          "createdAt": "2023-02-04T03:28:21Z",
          "updatedAt": "2023-02-04T03:28:21Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I also like the simplicity of a composite broadcast, because relays may benefit from knowing which set of video streams are related and can cache them appropriately.\r\n\r\n@vr000m  - can you clarify what `cache them appropriately` means? If a relay knows streams are related, I can imagine how it might prioritize resources between those streams in the face of congestion, however why would it cache them differently compared to unreleated streams? Caching is for the benefit of other (parallel or subsequent) sessions, not the session that triggers the initial request.  ",
          "createdAt": "2023-02-27T18:58:08Z",
          "updatedAt": "2023-02-27T18:58:08Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, \"broadcast\" is certainly not the best terminology.\r\n\r\nMy intention is that a \"broadcast\" is a collection of tracks that share a common presentation timestamp and prioritization number space. This implies that a single encoder (source) produces a broadcast, although it doesn't rule out transcoding if it uses the same number space (ie. timestamp passthrough).\r\n\r\nA \"composition\" is a collection of multiple broadcasts presented to the viewer. These can be synchronized based on program time (ie. wall clock) but absolutely not based on the presentation timestamp (PTS). This is completely out of scope of the transport.\r\n\r\n---\r\n\r\nNow let's go to your NFL example. First off, we have multiple camera feeds. These are separate encodes, and in this terminology, start out as separate \"broadcasts\".\r\n\r\nThe studio decodes each feed, synchronizes based on program time (wall clock), and does \"server-side compositing\". In the current terminology, this means creating a new \"broadcast\" for each game that could have any number of tracks (ex. translations, captions, camera angles). These tracks could be prioritized against each other, for example audio > video, or even main feed > sideline feed. The idea is that there's an authority who can indicate what content is more important.\r\n\r\nIf a viewer is watching a single game, then they receive a single broadcast. But what if a viewer wants to watch multiple games? The server doesn't know how to prioritize or synchronize (wall clock skew) between these two broadcasts as they were encoded at separate sources. There's two options:\r\n\r\n1. Client-side compositing. The viewer subscribes to two separate broadcasts (possibly over different connections) and chooses how to render them side by side.\r\n2. Server-side compositing. The server transcodes, or at the very least, rewrites timestamps/priorities to interleave both broadcasts. The viewer can then subscribe to a single broadcast.\r\n\r\nIn the real-time latency world, 99% of the time multiple feeds are combined using client-side compositing. There's too much cost/latency introduced by server-side compositing. But in the higher latency world, 99% of the time it's done by server-side compositing. It's easier and more network efficient to transcode all feeds into a single feed.\r\n\r\nA problem with the current draft is that there's no way to prioritize unrelated broadcasts when using client-side compositing. The prioritization is decided by the sender/source so it can be propagated through relays. The viewer could influence last mile delivery but that's not really done today. For example, a viewer watching two HLS broadcasts. They'll both equally compete for bandwidth; there's no way to tell broadcast A to back off first during congestion.",
          "createdAt": "2023-03-02T22:34:40Z",
          "updatedAt": "2023-03-02T22:35:57Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What do need to update in the warp draft to capture the above discussion ?",
          "createdAt": "2023-04-07T21:01:51Z",
          "updatedAt": "2023-04-07T21:01:51Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> This is a generic problem with multiple connections, TCP, QUIC or otherwise.\r\n> \r\n> There are things that could be done here, such as communicating a max sending rate to the peer, asking the peer to use a less than best effort congestion controller (ie: LEDBAT++), but I would only tackle that if we think this is a critical problem for MoQ to solve.\r\n\r\nI think this issue is concerns muxing. If I have N input broadcasts/connections, can I combine them into 1 output broadcast/connection?\r\n\r\nA previous version of the draft said \"yes\" if they're part of the same broadcast ID (bundle). That way you can use stream prioritization as QUIC will prioritize relative to the broadcast. However, this did really work with send_order since it's local to the encoder, and I think this issue was filed back then in response.\r\n\r\nThe current version of the draft keeps things vague. You can have any number of tracks for any number of broadcasts with any number of prioritization schemes... and results will vary.\r\n\r\nI don't know if this issue has any concrete action items though. Maybe just close it?",
          "createdAt": "2023-07-24T21:03:37Z",
          "updatedAt": "2023-07-24T21:03:57Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, I misunderstood this issue.\r\n\r\nI'm happy to close it, but it sounds like it's definitely NotTransport, so I marked it as such for now.",
          "createdAt": "2023-07-24T23:58:54Z",
          "updatedAt": "2023-07-24T23:58:54Z"
        }
      ]
    },
    {
      "number": 88,
      "id": "I_kwDOG2Ho4M5dZ0MI",
      "title": "Failover strategy when QUIC is unavailable",
      "url": "https://github.com/moq-wg/moq-transport/issues/88",
      "state": "CLOSED",
      "author": "hardie",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "ianswett"
      ],
      "labels": [
        "Editorial",
        "Needs PR"
      ],
      "body": "Issue raised at interim on Feb 1, 2023:\r\n\r\nDoes the protocol need to define a failover if QUIC is not available on a specific path.  If so, is it the same failover in all cases?",
      "createdAt": "2023-02-01T23:51:51Z",
      "updatedAt": "2023-10-17T12:53:24Z",
      "closedAt": "2023-10-17T12:53:24Z",
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Note that WebTransport does provide a failover to HTTP/2.",
          "createdAt": "2023-02-02T15:43:31Z",
          "updatedAt": "2023-02-02T15:43:31Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "We need a answer for Raw QUIC too",
          "createdAt": "2023-02-13T22:34:50Z",
          "updatedAt": "2023-02-13T22:34:50Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We discussed this in chartering and came down on a hard no. It just makes things too complicated. Yep, the webtransport version of it might work fine on TCP and we are not out to break that but it is not a design goal. This is about media over QUIC and QUIC is over UDP. \r\n\r\nThe CDNs may internally do whatever they do but that is a black box. ",
          "createdAt": "2023-04-07T20:59:49Z",
          "updatedAt": "2023-04-07T20:59:49Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that this is out of scope, based on my reading of the charter, which says \"can be used over raw QUIC or WebTransport.\"\r\n\r\nI would like to either close with no action or we can add editorial text that notes that all paths may not support QUIC.",
          "createdAt": "2023-07-24T12:42:17Z",
          "updatedAt": "2023-07-24T12:42:17Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "It was decided that a sentence or two about this, including a note that the appropriate fallback may be something entirely different from MoQ (ie: DASH/HLS/etc) depending upon the application and deployment.",
          "createdAt": "2023-07-24T23:43:49Z",
          "updatedAt": "2023-07-24T23:43:49Z"
        }
      ]
    },
    {
      "number": 101,
      "id": "I_kwDOG2Ho4M5g6vP1",
      "title": "Track Definition is incomplete",
      "url": "https://github.com/moq-wg/moq-transport/issues/101",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently track is defined to have init segment , which might not be true for all the use-cases\r\nAlso track Ids are undefined and in order to support multi-host distribution systems , we need to describe how tracks from multiple tenants are differentiated within and across distribution networks.",
      "createdAt": "2023-03-15T18:01:58Z",
      "updatedAt": "2023-05-05T19:57:08Z",
      "closedAt": "2023-05-05T19:57:07Z",
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "> Currently track is defined to have init segment , which might not be true for all the use-cases\r\n\r\nI don't believe this is true.  Almost all encodings require some form of prior knowledge in order to decode their bitstream (e.g. even something as simple as a raw PCM audio requires knowing a sampling rate and the number of channels).\r\n\r\n> Also track Ids are undefined and in order to support multi-host distribution systems , we need to describe how tracks from multiple tenants are differentiated within and across distribution networks.\r\n\r\nCould you elaborate on the scenario you have in mind here?  Currently, the track IDs are scoped to a track bundle.  If the application needs to combine tracks from multiple bundles, it currently has two options:\r\n1. Solve the problem entirely at the application layer: have the application receive the list of bundles it needs to separately, and then subscribe to them individually.\r\n2. Recombine multiple track bundles into a single bundle somewhere in the distribution chain.  This is tricky since this technically requires the bundler to alter the catalog, but we assume the catalog is generally opaque and can be encrypted.",
          "createdAt": "2023-03-15T18:47:31Z",
          "updatedAt": "2023-03-15T18:47:31Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> I don't believe this is true. Almost all encodings require some form of prior knowledge in order to decode their bitstream (e.g. even something as simple as a raw PCM audio requires knowing a sampling rate and the number of channels).\r\n> \r\n> >\r\n\r\nThis is what is in the current draft -\r\n\"A media track in Warp is a combination of an init object and a sequence of media object groups.\" \r\nthe base transport draft should not  define about requiring  an init object. Also  \"Init Object\" isn't defined and is very specific to container format and media.  OTOH, the sample rate, number of channels seems to be part of manifest/catalog/ or something equivalent to SDP for example",
          "createdAt": "2023-03-16T23:57:16Z",
          "updatedAt": "2023-03-17T00:24:28Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> Could you elaborate on the scenario you have in mind here? Currently, the track IDs are scoped to a track bundle.\r\n\r\nIIUC the draft-04 on \"track bundle\" doens't say that today and I feel a bundle shouldn't scope or define the naming of the track. \r\n\r\nA track bundle, is group of tracks that share certain properties. A bundle can have tracks from multiple emitters. Its application's choice.  For a large application, it is totally possible to have 100s of tracks ( conference that want's to render hollywood squares) and application can create multiple bundles based on the local policy by splitting these tracks and the transport shouldn't constrain application's choice.\r\n\r\nIf the properties of trackIds are undefined,  then more than one publisher from different applications and domains can create tracks with name \"audio\"  and when an Object with trackId \"audio\" traverses through the Relays within a distribution network and across distribution networks , there is not much disambiguating information to decide on what to do with track called \"audio\" \r\n",
          "createdAt": "2023-03-17T00:04:08Z",
          "updatedAt": "2023-03-17T00:26:17Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "> IIUC the draft-04 on \"track bundle\" doens't say that today and I feel a bundle shouldn't scope or define the naming of the track.\r\n\r\n@suhasHere is correct, the current language says only that a track ID needs to be unique within the track-bundle.  They can also be *more* unique than that, globally even as 62 bits will allow.  \r\n\r\nIt seems like the question is \"should they be required to be globally unique?\"",
          "createdAt": "2023-03-17T01:40:56Z",
          "updatedAt": "2023-03-17T01:40:56Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "The contents of the init payload depends on the format. If there's no initialization payload required, then just send 0 bytes.\r\n\r\nAnd yeah, I agree with @afrind verbatim.",
          "createdAt": "2023-03-17T19:14:34Z",
          "updatedAt": "2023-03-17T19:14:34Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Although I will add that we should switch track ID from a varint to a string, so it can be used to encode more information (and possibly global uniqueness).",
          "createdAt": "2023-03-17T19:22:02Z",
          "updatedAt": "2023-03-17T19:22:39Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Seems to be a bunch things mixed together in this one. Might be better to split into multiple issues. \r\n\r\n1 issue seems to be we need a globally unique track name of some sort.  (I think that is seperate from the TrackID that might be a short integer that is unque only the the quic connection and gives us a short reference to the longer global name. \r\n\r\n2 issue has to do with init sequence. I think I was thinking that for say an simple PCM audio track, the catalog would say the sample rate and sample size. But Victors comment that no this could be the init might be the right way to think about it. I can see how that would work and not clear to me which is best. I hope that gets explored in the content / format / catalog drafts. ",
          "createdAt": "2023-04-07T20:56:46Z",
          "updatedAt": "2023-04-07T20:56:46Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Has #121, plus the discussion to move INIT into media formats resolved the discussion in this issue?",
          "createdAt": "2023-04-21T19:27:14Z",
          "updatedAt": "2023-04-21T19:27:14Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Track definition has been updated.",
          "createdAt": "2023-05-05T19:57:07Z",
          "updatedAt": "2023-05-05T19:57:07Z"
        }
      ]
    },
    {
      "number": 102,
      "id": "I_kwDOG2Ho4M5g6wqk",
      "title": "Refreshing Subscriptions",
      "url": "https://github.com/moq-wg/moq-transport/issues/102",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We need to support subscription refreshes to ensure liveness and also signal explicit consent. The latter will be needed from security perspective and also protecting relay from resource exhaustions.\r\nThe protocol should also recommend what the Relays should do in such cases",
      "createdAt": "2023-03-15T18:06:17Z",
      "updatedAt": "2023-08-08T05:41:46Z",
      "closedAt": "2023-08-08T05:41:46Z",
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Consent freshness can be provided via QUIC itself, we just don't do that by default.  See w3c/webtransport#174 for some discussion we had regarding consent freshness in WebTransport (the short answer is that the server can send a PATH_CHALLENGE regularly).\r\n\r\nIs there any specific reason you want this to be done at a subscription level?",
          "createdAt": "2023-03-15T19:07:46Z",
          "updatedAt": "2023-03-15T19:07:46Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the reference victor .. This is an explicit request from the client telling to Relay of the continuiing interest for a given set of subscriptions and to avoid Relays from needing to hold onto the subscription.\r\n\r\n",
          "createdAt": "2023-03-16T20:27:10Z",
          "updatedAt": "2023-03-16T20:27:10Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "It makes sense that a relay would need to reap upstream subscriptions when all the downstream subscribers are gone.  Is it better to automatically expire subscriptions and require the client to refresh, or automatically extend subscriptions and require the client to unsubscribe, and terminate all active subscriptions when the underlying WebTransport session or  QUIC connection closes?\r\n\r\nWhat are the pros and cons of each approach?  Should the base protocol support both modes?",
          "createdAt": "2023-03-16T21:39:26Z",
          "updatedAt": "2023-03-16T21:39:26Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> and terminate all active subscriptions when the underlying WebTransport session or QUIC connection closes?\r\n\r\nThe control stream PR proposes a solution for this. Subscriptions of one or more tracks, are tied to a control stream and when that streams closes, it closes all the linked media transfer state.",
          "createdAt": "2023-03-17T00:08:36Z",
          "updatedAt": "2023-03-17T00:08:36Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> Is it better to automatically expire subscriptions and require the client to refresh\r\n\r\nRelays always have a choice to terminate any subscription if the local policy decides. In those cases, if a client is still interested , it should have to renew/refresh the subscription if it has not already done. It does cause media disruptions at the clients and having a explicit mechanism to renew will be useful.\r\n\r\nIt is good security feature for relays to be told I am still interested in receiving media so to prevent DDOS of relay's resources for maintaining the needed state.",
          "createdAt": "2023-03-17T00:11:57Z",
          "updatedAt": "2023-03-17T00:27:16Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "As an individual:\r\n\r\nContinual subscription sounds expensive to me, so I'd prefer that not be the only mode.  I think there are tradeoffs to explicit cancellation client vs implicit cancellation.  If the publisher controls the implicit subscription timeout and they can set it to t = ~infinity it's kind of the same thing.",
          "createdAt": "2023-03-17T02:36:33Z",
          "updatedAt": "2023-03-17T02:36:33Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> If the publisher controls the implicit subscription timeout and they can set it to t = ~infinity it's kind of the same thing.\r\n\r\nI was not suggesting publisher control the subscription timeout.  Subscriptions renewal periods are paced apart, say 5-10 seconds and the protocol needs to recommend a value.\r\n\r\nAlso no matter what is set, Relays can overwrite if they see those values are meaningless.  \r\nShould we make this a MUST option or Not, I am fine to go either way as long as the protocol supports that behavior. Since it will be important from security perspective.",
          "createdAt": "2023-03-17T02:56:37Z",
          "updatedAt": "2023-03-17T02:57:07Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "We don't need to refresh subscriptions.\r\n\r\n**QUIC has an idle timeout**. This is meant to detect severed connections, even if no media is being transferred. You could set it as low as 5-10s to get the same user experience as your periodic subscriptions, but without any involvement from the application.\r\n\r\n---\r\n\r\n**QUIC has a congestion window**. The sender will stop sending packets if they're not being acknowledged. Here's what it looks like when the connection is severed without a  CONNECTION_CLOSE:\r\n \r\n<img width=\"395\" alt=\"Screen Shot 2023-03-17 at 9 55 39 AM\" src=\"https://user-images.githubusercontent.com/432854/225969339-c75aeb0d-f32b-4048-9734-33d545dea28d.png\">\r\n\r\nThe sender keeping sending media (green) for 800ms before hitting the congestion window (purple), then it will no longer send any more media until it receives an acknowledgement. This is far more responsive than an idle timeout, which is still used to eventually terminate the connection.\r\n\r\nNote that QUIC datagrams are congestion controlled and are subject to this congestion window.\r\n\r\n---\r\n\r\n**QUIC streams have flow control**. The QUIC library will only increase MAX_DATA when the application reads from streams. That means even if there's a bug in the application, like a fatal error causing it to hang, then there will still be back-pressure and the sender will be blocked. This is even more resilient than a periodic refresh, especially because that code would likely be run in it's own thread.\r\n\r\nNote that QUIC datagrams are NOT flow controlled. Maybe your periodic subscription stems from this difference?",
          "createdAt": "2023-03-17T17:52:08Z",
          "updatedAt": "2023-03-17T17:52:08Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Leveraging QUIC transport features seems like it works to help the relays reap dead subscribers when they step into an elevator.  Are there other scenarios that need coverage like:\r\n\r\n1.  We kicked Bob out of the meeting so he's no longer allowed to get any tracks.\r\n2. You stopped paying for your subscription to this streaming service so we're going to stop serving this content \r\n\r\nIn HTTP CDNs this kind of reauthorization tends to be slow (eg: the URLs have an expiration time signed in).  Is that a problem we need to solve better in moq?",
          "createdAt": "2023-03-17T18:17:11Z",
          "updatedAt": "2023-03-17T18:17:11Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Reneging authorization is certainly a reason to require refreshing subscriptions. @suhasHere I think this is the problem you're trying to solve, especially since you have an auth token in the SUBSCRIBE message. If so, could you rename the issue so it focuses on the problem, and not a possible solution?\r\n\r\n---\r\n\r\nThe current draft punts authorization to the WebTransport CONNECT. There's no way to refresh that request, so the relay would just terminate the session with an unauthorized error code.\r\n\r\nBut how does a CDN know when a session is authorized or no longer authorized? It's undefined in the current draft and up to the application.\r\n\r\nThis is also how HTTP CDNs work. There may be millions of viewers connected to a CDN, but they all deduplicate into a single request to the origin. Effectively, the CDN is responsible for authentication, usually just because the URL is unguessable but sometimes via a signed token.\r\n\r\nWe absolutely need the ability to fan out authentication in order to scale. The origin is not capable of handing millions of requests per second, especially if authentication is performed via a subscription every few seconds. And we still need some form of authentication in order to connect to the CDN edge in the first place, especially if media is pushed in order to reduce TTV.\r\n\r\nMy recommendation would be an optional standard. Some form of token that you provide to the CDN as part of the WebTransport CONNECT, which has an expiration time and some mechanism for the CDN to verify/refresh it. If the CDN is required to perform a callout to another URL, then that authentication service could be decoupled from the origin. I'm sure some standard like this already exists but I'm not aware of the space, @wilaw do you know?",
          "createdAt": "2023-03-17T20:14:33Z",
          "updatedAt": "2023-03-17T20:17:35Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "All the renewal option is telling \" I am still interested in the subscription \" as an explicit signal from the application to the Relays. This is not tied to the transport options, but those options can help tear down stale subscriptions. The same is with relay local policies. \r\n\r\nOn how the subscriptions renewal gets authorized - that's a tangent and we can solve it as separate issue.",
          "createdAt": "2023-03-17T23:55:01Z",
          "updatedAt": "2023-03-17T23:55:01Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry, I got too excited and leapt to conclusions.\r\n\r\n@suhasHere what problem are you solving? Why would an unsubscribe message be insufficient?",
          "createdAt": "2023-03-18T03:38:03Z",
          "updatedAt": "2023-03-18T03:38:03Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One way or another we have to meet the requirement that the sever can know when to clean up state. If that is done purely by the QUIC connection going away, well  I guess that could work as long as it has appropriate keep alive but it would be nice to make this fairly easy for architectures where the load balancer in front of the server terminates the QUIC, the TLS. Be good to see some explicit proposal for how this work on the raw QUIC cases. ",
          "createdAt": "2023-04-07T20:50:22Z",
          "updatedAt": "2023-04-07T20:50:22Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> we have to meet the requirement that the sever can know when to clean up state.\r\n\r\nIf we follow the architectural precept that any node only publishes in response to a subscribe and we have an \"unsubscribe\" message, then we have a simple system that would clean up automatically\r\n\r\nIf an edge relay ends up having no subscribers for a track, either due to all subscribers sending it an unsubscribe (clean) or their connection timing out or dropping, then the edge relay would send an unsubscribe to its parent. This process would work its way up the tree until eventually the publisher would stop sending content because it had no subscribers. ",
          "createdAt": "2023-04-07T23:00:12Z",
          "updatedAt": "2023-04-07T23:00:12Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "See also #132 about adding explicit unsubscribe.",
          "createdAt": "2023-04-18T20:11:54Z",
          "updatedAt": "2023-04-18T20:11:54Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "@suhasHere The current draft allows for `expires` in SUBSCRIBE OK.  We're missing UNSUBSCRIBE but there's a separate issue tracking that.  Is this sufficient to close?",
          "createdAt": "2023-05-26T00:17:24Z",
          "updatedAt": "2023-05-26T00:17:24Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@afrind yes, we have tackle unsubscribe in #132 ",
          "createdAt": "2023-08-08T05:41:46Z",
          "updatedAt": "2023-08-08T05:41:46Z"
        }
      ]
    },
    {
      "number": 103,
      "id": "I_kwDOG2Ho4M5hEOWK",
      "title": "Track bundle definition need not be same as Catalog",
      "url": "https://github.com/moq-wg/moq-transport/issues/103",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Current spec as \"The track bundle contains a catalog indicating the available tracks.\"\r\n\r\nThis seems very constraining. A catalog lists multiple tracks and a track bundle groups the tracks based on the prioritzation requirement. \r\n\r\nLinking catalog as 1:1 mapping to track bundle, will cause all the tracks in a catalog needs to be used OR one should send multiple catalogs based on the prioritization requirements. I feel we are again trying to force an application behavior, which should be avoided that we are building toolset for various applications",
      "createdAt": "2023-03-17T00:19:56Z",
      "updatedAt": "2023-07-24T21:44:10Z",
      "closedAt": "2023-07-24T21:44:10Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "As an individual:\r\n\r\n> Linking catalog as 1:1 mapping to track bundle, will cause all the tracks in a catalog needs to be used \r\n\r\nAs I read the draft, a track bundle is defined as the set of tracks available at a given WebTransport URL, and the catalog contains (in some way) the ids of those tracks.  I didn't read that all tracks defined in a catalog MUST be subscribed to, the application can subscribe to a subset.  Placing tracks in the same bundle will allow the publisher to prioritize the tracks in the bundle relative to each other.\r\n\r\n> OR one should send multiple catalogs based on the prioritization requirements.\r\n\r\nSince tracks prioritized against each other belong in the same catalog, the only reason for multiple catalogs is groups of tracks that are not related.  I think an application using this draft would accomplish this by making a WebTransport session to each independent track-bundle URL (maybe over the same QUIC connection), each would have an independent catalog.  Is this design problematic and if so, can you explain why?\r\n\r\nAs Chair:\r\n\r\n> I feel we are again trying to force an application behavior, which should be avoided that we are building toolset for various applications\r\n\r\nI think everyone is in agreement that we are trying to build a toolset to support multiple applications.  Rather than make a generic statement like \"we are again trying to force an application behavior\", please give an example of an application that cannot be built with any given proposed design.",
          "createdAt": "2023-03-17T05:31:29Z",
          "updatedAt": "2023-03-17T05:31:29Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@afrind  may be my read of this statement is wrong \"The track bundle contains a catalog indicating the available tracks.\" This means that catalog is scoped to a track bundle  and not that tracks in the bundle coming from a catalog. They are 2 different requirements .. Former implies there is a catalog  per track bundle , which is what I was referring to as a application choice. Other applications can download a catalog that has 100 tracks and setup 20 different webTransport sessions with each bundle having 5 tracks in it . \r\n\r\nJust want to double check, are these both application choices supported ?\r\n\r\n\r\n\r\n",
          "createdAt": "2023-03-17T06:32:24Z",
          "updatedAt": "2023-03-17T06:35:43Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "As an individual:\r\n\r\nI read track-bundle as a hop-by-hop entity rather than an end-to-end entity.  A relay could be receiving N track bundles, mixing up the tracks between them and publishing M different track bundles to its subscribers.  Each track bundle has a catalog that identifies the available streams in the bundle, so in that example, the relay is creating the new downstream catalogs.  The set of available tracks in a bundle can change over time, via updates to the catalog.\r\n\r\nOr another way: WebTransport Session = Track Bundle = 1 Catalog of available tracks\r\n\r\nSo yes, I think both options are available: one where a receiver subscribes to all tracks in a catalog, and one where a receiver subscribes to a subset, and can open multiple WebTransport sessions to the same URL with different subsets.\r\n\r\nWhat the draft doesn't define today is an entity containing a \"composition\" -- one that contains tracks from different WebTransport URLs.  I think about such an entity like an HTML page that has links to resources from anywhere.  It's an important tool, but not one defined by HTTP.  In my individual opinion, this is out of scope for the base protocol.",
          "createdAt": "2023-03-17T15:44:44Z",
          "updatedAt": "2023-03-17T15:44:44Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> Each track bundle has a catalog that identifies the available streams in the bundle\r\n\r\ncatalog is a larger container of tracks and bundles are groups of tracks which happened to mapped to WT when WT is the transport.  It shouldn't matter if it is composition or emissions, it will help if we think of concepts as\r\n- catalogs have list of tracks\r\n- catalogs are retrieved from a moq session url ( can be emission or composition)\r\n- clients group subset of tracks listed in the catalog as  bundles\r\n\r\nI am not sure the gains of having a catalog per bundle .. ",
          "createdAt": "2023-03-17T16:26:15Z",
          "updatedAt": "2023-03-17T16:26:15Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "First off, I think it's a great idea to move catalog into its own track (#66). That would enable you to have multiple catalogs in the same track bundle and would make consuming catalogs optional.\r\n\r\nAnd I absolutely agree that applications should be able to distribute a catalog/composition out-of-band. But should it be mandatory to have a catalog in-band?\r\n\r\nI resonate with @wilaw's comment: https://github.com/kixelated/warp-draft/issues/66#issuecomment-1415092508\r\n\r\n> IMO the CATALOG message and its response should exist in the base protocol and be mandatory to implement on the part of the publisher and relays. For the client, its optional. The majority of clients would use it. Those that can receive the catalog out-of-band would not need to use it. I envisage CATALOGS not being static in the life of a stream. They should update when the mix of content being produced by the publisher changes (i.e a webex user suddenly starts sharing their desktop). To that end, even a client that starts with an out-of-band catalog would still want to SUBSCRIBE to CATALOG updates, so that it can be apprised of any future changes to the subscription IDs on offer. I can also imagine dynamic ad insertion opportunities being signaled by CATALOG changes. Additionally, a CATALOG update to say there is no more content being published would be a clean way to terminate a broadcast.\r\n\r\nTo add to that, it seems impossible to implement a generic endpoint like VLC/OBS/etc unless there is a required catalog track or message.",
          "createdAt": "2023-03-17T16:48:25Z",
          "updatedAt": "2023-03-17T16:50:49Z"
        },
        {
          "author": "hardie",
          "authorAssociation": "COLLABORATOR",
          "body": "I think there are two different meanings of catalog in play here.  To use a\nvery old fashioned example, a department store catalog has a huge number of\navailable items, but no customer would ever get all of them in a single\norder.  They make a selection and the list of things that they selected\ncould also be called a catalog (a catalog of the order, rather than of the\ngoods in the department store).\n\nIf I'm reading this correctly, everyone agrees that\n\nWebTransport Session = Track Bundle\n\nThe question is whether the track bundle represents \"The set of things\navailable for selection\" (the standard English commercial meaning of\ncatalog)  or \"An enumerated list of those things which are now in a single\npriority domain\" (aka, the tracks selected from the larger set).\n\nWith no particular hat on, I think the discussion among the participants\nsounds like \"enumerated list of those things now in a single priority\ndomain\" is the right third term for Web Transport Session = Track Bundle =\nX.   Whether X is called \"catalog\" or not seems to be the point of\ndisagreement.\n\nI may have this wrong, of course, but that's what it looks like from my\nperspective.\n\nTed\n\nOn Fri, Mar 17, 2023 at 4:26\u202fPM Suhas Nandakumar ***@***.***>\nwrote:\n\n> Each track bundle has a catalog that identifies the available streams in\n> the bundle\n>\n> catalog is a larger container of tracks and bundles are groups of tracks\n> which happened to mapped to WT when WT is the transport. It shouldn't\n> matter if it is composition or emissions, it will help if we think of\n> concepts as\n>\n>    - catalogs have list of tracks\n>    - catalogs are retrieved from a moq session url ( can be emission or\n>    composition)\n>    - clients group subset of tracks listed in the catalog as bundles\n>\n> I am not sure the gains of having a catalog per bundle ..\n>\n> \u2014\n> Reply to this email directly, view it on GitHub\n> <https://github.com/kixelated/warp-draft/issues/103#issuecomment-1474091956>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAKVXZHOEZW2IAYLQRCOJOLW4SGDFANCNFSM6AAAAAAV54JSIQ>\n> .\n> You are receiving this because you are subscribed to this thread.Message\n> ID: ***@***.***>\n>\n",
          "createdAt": "2023-03-17T17:44:54Z",
          "updatedAt": "2023-03-17T17:44:54Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah exactly Ted. My thought is that:\r\n\r\nA *catalog* describes a track bundle. \"Here's a list of tracks available on the WebTransport session.\"\r\n\r\nA *composition* describes multiple track bundles. \"Here's a list of multiple tracks, which are available from separate WebTransport sessions at these URLs\"\r\n\r\n\r\nThere is absolutely room to combine the two into a single entity. It just gets a little awkward when composition updates and 3rd party clients are thrown into the picture. \r\n\r\nMy proposal is that this definition of \"catalog\" is part of the transport draft while composition is punted to the application or part of a separate draft.",
          "createdAt": "2023-03-17T18:03:18Z",
          "updatedAt": "2023-03-17T18:06:06Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks Ted, keeping on building the elementary transport tools in mind , i was proposing the equation to be\r\n\r\n\"Web Transport Session = Track Bundle \" and not add in catalog in that equation\r\n\r\nYes in some cases, a catalog = track bundle and that is fine as application implementation choice and transport need not enforce that relationship.",
          "createdAt": "2023-03-17T20:18:31Z",
          "updatedAt": "2023-03-17T20:18:31Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "As an individual:\r\n\r\nMaybe we need to drop the names for a minute and see if we can agree on concepts:\r\n\r\nA *zibbermap* is a list of tracks sent by the publishing endpoint of a WebTransport session to the receiving endpoint.  The receiving endpoint can subscribe to 0 - all of these tracks *in this session*.  \r\nIt may not be exhaustive: an endpoint can try subscribing to a track ID in this session that it got out of band and that *might* work.\r\nThe *zibbermap* doesn't include any track IDs that *can't be subscribed to in this session*.  A list of track-IDs from several different WebTransport URLs is called a *wheeblist*.  A *zibbermap* can be thought of as a subset of a *wheeblist* where the WebTransport URLs of all track IDs match the current session's URL.  The reason for defining a specialized construct *zibbermap* is that it is highly relevant to the receiving endpoint, and it might be confusing to receive information about other tracks in other places.",
          "createdAt": "2023-03-17T22:19:00Z",
          "updatedAt": "2023-03-17T22:19:00Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> If I'm reading this correctly, everyone agrees that WebTransport Session = Track Bundle\r\n\r\nPerhaps I'm an outlier but in my reading there is not yet complete agreement on this point.  The direct consequence of this assumption is that MoQ Objects rely upon the WebTransport session they are transmitted within for their identification. Consider the case of a web conference vendor that can easily have 200,000 concurrent conference sessions, and a game streamer another 200,000. For a distribution vendor distributing both, every hop between every pair of intermediaries along the distribution path needs to establish 400,000 WebTransport connections in order to correctly relay using MoQ. These unique WebTransport sessions per end-user must be maintained all the way to the respective origins.\r\n\r\nIt\u2019s not the number of WebTransport sessions that is necessarily concerning, it\u2019s the rigid requirement that there is a 1:1 mapping between the content bundles (which are application defined)  and the transport (which is  network vendor maintained). What if the distribution vendor wants to shard these bundles across 1, or 1,000, or 100,000 WebTransport sessions for memory, performance or hardware requirements? Or they are not using WebTransport and only using Quic? They should have the flexibility to innovate in that regard, but to have to use 400,000  (in this example) for MoQ to work is a strict requirement and we should think that through carefully before mandating it. \r\n\r\nThis inflexibility exists in return for the convenience of not putting sufficient information in the headers of each object to route them independently of the WebTransport or Quic sessions. \r\n\r\nAn alternate approach is therefore to put enough information in each object header to make if \u201csufficiently unique\u201d such that object can be transferred independently of the underlying Webtransport session and/or QUIC connection. This does not require a GUID in every object, but rather some lower level of uniqueness. The varint that is identifying the WebTransport session within the Quic connection could equally be placed in the object headers.\r\n\r\nVarious schemes for this have been proposed, along with the option for a vendor to implement a dictionary and header rewrite to reduce the bits across the wire within their network. It seems these should at least be considered as an equally viable and perhaps preferred solution to the WebTrans session == track-bundle requirement.\r\n\r\n",
          "createdAt": "2023-03-17T22:29:39Z",
          "updatedAt": "2023-03-17T22:29:39Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Will, if I may clarify, today bundle is defined per broadcast/emission IIUC. So that would make total WT ~= 200,000 conferences * number of emissions per conference .   I may have wrongly read the current draft and would love to get further clarification of my understanding.\r\n\r\n\r\nAgree with Will that, Even though we don't mandate a relay behavior, we shouldn't be constraining the design choices. May be we can solve the prioritization across tracks/connections with priorities ??  Regardless, we need to explore the thinking here ",
          "createdAt": "2023-03-17T23:16:40Z",
          "updatedAt": "2023-03-17T23:16:40Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Let me explain on the ML. I'm writing the email about track bundles now.",
          "createdAt": "2023-03-17T23:17:30Z",
          "updatedAt": "2023-03-17T23:17:30Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So thanks Luke for your ML description of track bundles. That cleared things up a bit. \r\n\r\nI'm on board with the simple but flexible construct that a \"bundle\" is a collection of tracks available under a single WebTransport session. This represents content generated under a consistent prioritization and orchestration domain. We need this because we can only guarantee relative stream prioritization within a WebTransport session and not between pooled WebTransport sessions. One of these tracks is called \"catalog\" and it describes the other tracks, providing for each the info the client will need for selection, subscription and initialization.\r\n",
          "createdAt": "2023-03-21T05:23:54Z",
          "updatedAt": "2023-03-21T05:23:54Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't see why any of this is tied to a WebTrasport or what that would mean in the raw Quic case. \r\n\r\nI'm having a very hard time understanding if this bug is even still relevant given the Japan discussion. Could we close this bug and open one or more specific bugs that are get to heart of the issue. ",
          "createdAt": "2023-04-07T20:42:26Z",
          "updatedAt": "2023-04-07T20:42:26Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "@suhasHere are we good to close?  The track bundle name is gone from the spec.",
          "createdAt": "2023-05-26T00:16:19Z",
          "updatedAt": "2023-05-26T00:16:19Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@afrind  yes we can close this ",
          "createdAt": "2023-07-24T21:44:10Z",
          "updatedAt": "2023-07-24T21:44:10Z"
        }
      ]
    },
    {
      "number": 104,
      "id": "I_kwDOG2Ho4M5hNwcp",
      "title": "Multiple OBJECTs per stream",
      "url": "https://github.com/moq-wg/moq-transport/issues/104",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I was replying to @huitema's email inline, but I think this is a separate discussion and should be forked off.\r\n\r\n> Send order effectively implies that the ordering is performed by the\r\n> application at the time of writing on a stream. But if you write\r\n> multiple objects of different priorities on the same stream, you get\r\n> variations of head of line blocking, in which a high priority object is\r\n> waiting for error correction on a low priority object sent previously.\r\n\r\n\r\nIt's not possible for two OBJECTs to share a stream but use different priority values. The ability to drop or prioritize is only possible at the stream level within QUIC. In theory you could have diminishing values over time, for example the send order increasing as the stream progresses, but that becomes difficult to signal to the QUIC layer.\r\n\r\nwarp-02 specified the stream priority in a single [HEADERS](https://www.ietf.org/archive/id/draft-lcurley-warp-02.html#name-headers) message at the start of each stream. This was eventually renamed to [OBJECT](https://www.ietf.org/archive/id/draft-lcurley-warp-03.html#name-object), but it seems like we lost some context along the way. My intention was that there's a single set of priorities/dependencies per data stream.\r\n\r\nFor the sake of argument, let's revert to warp-02 and make this explicit. Introduce the concept of control stream(s) and data streams, and data streams MUST start with a HEADERS message (just like HTTP/3). We'll move \"send order\" (and Christian's proposed \"priority\") from OBJECT to HEADERS.\r\n\r\n```data stream: HEADERS + OBJECT [+ OBJECT...]```\r\n\r\n\r\nWhy would you ever have two OBJECTs on the same stream? At this point, each OBJECT only contains an ID and a payload.\r\n\r\nMy first thought is that it's to delimit frame/slice boundaries. However, Warp works by punting that responsibility to a container within the payload, because frankly the relay does not need to know anything about the underlying media (or even that it is media). Let fMP4, TS, or a [raw container](https://datatracker.ietf.org/doc/html/draft-mzanaty-moq-loc-00) signal frame/slice boundaries to decoder.\r\n\r\nMy second thought is that it's a misunderstanding about how caches work. @suhasHere claimed in an object model discussion that OBJECT messages need to be atomic so they can be cached, which would explain why there's so many fixed length OBJECTs. However this isn't true; a CDN can both serve and cache a stream even with an unknown length. This is how chunked-transfer works in HTTP and it's the backbone of LL-DASH (and LHLS).\r\n\r\nMy third thought is it's for timestamps. However just like frame/slice boundaries, this can be punted to the container. I'm becoming increasingly convinced that a relay should not know about media timestamps, although it does need a TTL at some point. And of course the TTL applies to the entire stream (can't drop parts of a stream) so it would need to be in HEADERS.\r\n\r\nAnd my final thought is that it's for addressability. In theory, you could subscribe to objects by ID and ignore any prior objects on the same stream. However, this would be bizarre, because objects would only be on the same stream if they are dependencies. We're coming to the consensus that you subscribe based on groups anyway to guarantee decodability. So... punt the ID to the HEADERs message too?\r\n\r\n\r\nIs there some other rationale that I'm missing?",
      "createdAt": "2023-03-19T15:48:33Z",
      "updatedAt": "2023-03-21T17:28:44Z",
      "closedAt": "2023-03-21T17:28:44Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I propose we add the restriction that there's only a single priority per stream. Which means there's only a single OBJECT per stream, or we create a separate message to contain that priority (HEADERS). The stream priority should be at the start of the stream so it can be accessed immediately.",
          "createdAt": "2023-03-19T15:53:46Z",
          "updatedAt": "2023-03-19T15:53:46Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "#105 does a better job explaining the issue.",
          "createdAt": "2023-03-21T17:28:44Z",
          "updatedAt": "2023-03-21T17:28:44Z"
        }
      ]
    },
    {
      "number": 105,
      "id": "I_kwDOG2Ho4M5haueV",
      "title": "Multiple OBJECTs per stream with different priorities",
      "url": "https://github.com/moq-wg/moq-transport/issues/105",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Object Model"
      ],
      "body": "In the current draft, there's no concept of stream mapping. There's also no limit to the number of messages on a stream, so a sender could send multiple OBJECT messages on the same stream. Each OBJECT message contains a sendOrder indicating the priority.\r\n\r\nThe problem is that prioritization occurs at the stream level in QUIC. It gets really weird when you share a stream with any OBJECT message.\r\n\r\nHere's some examples. The sendOrder of each object is in parentheses. \r\n\r\n- OBJECT (1) + OBJECT (1): This works fine\r\n- OBJECT (1) + OBJECT (2): This requires a QUIC library that can prioritize at stream offsets.\r\n- OBJECT (2) + OBJECT (1): This is impossible.\r\n\r\nI think the outcome is pretty clear; messages must only be sent on streams if they share the same sendOrder. We miiiiight be able to support descending priorities but it's difficult in most implementations.",
      "createdAt": "2023-03-21T17:23:04Z",
      "updatedAt": "2024-01-31T00:31:32Z",
      "closedAt": "2024-01-31T00:31:31Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "My proposal is to include the sendOrder as a header at the start of every stream.\r\n\r\nI would go a step further and say we should have the concept of data streams and control streams like HTTP/3. The first byte indicates the stream type.\r\n\r\n- Control streams are always maximum priority.\r\n- Data streams start with a header (ex. HEADERS) that indicates the sendOrder. There could be one or more payloads that follow (ex. DATA)\r\n\r\nThis has the side effect of making it easier to parse. In my MoQ player, I forward the stream to a decoder thread once I detect data. I'm actually not able to deal with trailing control messages, because that would require sending the stream back to the main thread.",
          "createdAt": "2023-03-21T17:28:08Z",
          "updatedAt": "2023-03-21T17:35:11Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "We've clarified that control messages and objects don't mix.  Do you want to keep this issue open to track the issue with sending multiple OBJECTs on the same stream with different sendOrder?  If so can you retitle and clarify the ask?",
          "createdAt": "2023-11-03T20:52:25Z",
          "updatedAt": "2023-11-03T20:52:25Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> We've clarified that control messages and objects don't mix. Do you want to keep this issue open to track the issue with sending multiple OBJECTs on the same stream with different sendOrder? If so can you retitle and clarify the ask?\r\n\r\nYeah will do.",
          "createdAt": "2023-11-03T22:39:47Z",
          "updatedAt": "2023-11-03T22:39:57Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "In draft-02, you cannot specify multiple objects on the same stream with different priorities.",
          "createdAt": "2024-01-31T00:31:31Z",
          "updatedAt": "2024-01-31T00:31:31Z"
        }
      ]
    },
    {
      "number": 107,
      "id": "I_kwDOG2Ho4M5h71Mv",
      "title": "Stabilizing the handshake format",
      "url": "https://github.com/moq-wg/moq-transport/issues/107",
      "state": "CLOSED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "If we are going to ship experimental versions of MoQ (which we should), those probably should be interoperable on a handshake level (meaning that a server can accept two clients speaking different iterations of MoQ).  We currently have the following format in the draft:\r\n\r\n```\r\nSETUP Parameter {\r\n  Parameter Key (i),\r\n  Parameter Value Length (i),\r\n  Parameter Value (..),\r\n}\r\n\r\nClient SETUP Message Payload {\r\n  Number of Supported Versions (i),\r\n  Supported Version (i) ...,\r\n  SETUP Parameters (..) ...,\r\n}\r\n\r\nServer SETUP Message Payload {\r\n  Selected Version (i),\r\n  SETUP Parameters (..) ...,\r\n}\r\n```\r\n\r\nAstute reader will notice that this negotiation mechanism is similar to [a certain other IETF protocol](https://tlswg.org/tls13-spec/draft-ietf-tls-rfc8446bis.html#name-supported-versions).\r\n\r\nThe question I want to explicitly ask here is: are we okay with this format?  We obviously can change it later down the line, but that would be tricky since we'd create an incompatibility (and we also don't have the Alt-Svc escape hatch that QUIC used).",
      "createdAt": "2023-03-28T01:56:23Z",
      "updatedAt": "2023-04-06T15:59:43Z",
      "closedAt": "2023-04-06T15:59:43Z",
      "comments": [
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Seems like a down the road issue, but sure , this would work to for now and we can make sure we  rethink it as we get closer to done. I had assumed we would have a MoQ ALPN too. Would that be part of this ?",
          "createdAt": "2023-03-31T01:57:11Z",
          "updatedAt": "2023-03-31T01:57:11Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": ">  we would have a MoQ ALPN too.\r\n\r\nThis doesn't work for the WebTransport case, which will use \"h3\" ALPN.  Perhaps there could be the ALPN equivalent in the CONNECT headers?",
          "createdAt": "2023-04-03T17:38:30Z",
          "updatedAt": "2023-04-03T17:38:30Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "> Seems like a down the road issue, but sure , this would work to for now and we can make sure we rethink it as we get closer to done. I had assumed we would have a MoQ ALPN too. Would that be part of this ?\r\n\r\nNo, I was mostly concerned about this for MoQ over WebTransport.  For MoQ over raw QUIC, it's actually entirely possible to just use ALPN for version negotiation (which is what H/3 does).\r\n\r\n----------\r\n\r\nI am closing this, since it appears we did have a very rough agreement at 116 (or at least no one seemed to object).",
          "createdAt": "2023-04-06T15:59:40Z",
          "updatedAt": "2023-04-06T15:59:40Z"
        }
      ]
    },
    {
      "number": 108,
      "id": "I_kwDOG2Ho4M5iJanw",
      "title": "Junk test - delete later ",
      "url": "https://github.com/moq-wg/moq-transport/issues/108",
      "state": "CLOSED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "delete later ",
      "createdAt": "2023-03-29T22:41:15Z",
      "updatedAt": "2023-03-29T22:42:00Z",
      "closedAt": "2023-03-29T22:41:51Z",
      "comments": [
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "just testing - ignore ",
          "createdAt": "2023-03-29T22:42:00Z",
          "updatedAt": "2023-03-29T22:42:00Z"
        }
      ]
    },
    {
      "number": 109,
      "id": "I_kwDOG2Ho4M5iLFqb",
      "title": "Support track as independent component of the data model",
      "url": "https://github.com/moq-wg/moq-transport/issues/109",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "suhasHere"
      ],
      "labels": [],
      "body": "MoQ should focus on delivering tracks and conceptual grouping of tracks can be built atop of it. \r\n\r\n\r\nThis would need\r\n- Track Ids to be fully specified within on Subscribe and Publish Requests\r\n- Allows tracks to specify authorization scope for its namespace.\r\n- Control Streams/Messages mapped to Subscribe/Publish of tracks\r\n- Allow tracks to grouped for identification or other purposes in application specified way\r\n\r\nThe transport should provide necessary tools to help support different applications requirements.\r\n",
      "createdAt": "2023-03-30T07:33:47Z",
      "updatedAt": "2023-05-05T19:58:11Z",
      "closedAt": "2023-05-05T19:58:11Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "As an individual:\r\n\r\n> might not need information at the session level.\r\n\r\nCan you clarify what you think is the missing information?  All that's specified now is the endpoint you are connecting to.  You already need the hostname and the port just to make the QUIC connection so all that we're talking about is a path, or is there more?  Is it authentication information?\r\n\r\n>  it feels like an application choice to decide what and how to bundle or not\r\n\r\nI agree, but as I read it there's very little difference between \"no bundle\" and \"one bundle with all the tracks\".  How do you see these two options as different?  I think it might be simpler to have a single model (bundle/track/group/object) rather than having optional layers.\r\n\r\n> Allowing track identifiers to be self contained, shall enable uniform protocol operation within and across distribution networks.\r\n\r\nI'm ok with track identifiers that are self contained.  The object model Luke presented today only said that tracks need to be unique within a bundle, it didn't say they couldn't be *more* unique than that.  So perhaps we're close to agreement here?  I think we'll need a transport-scoped identifier to refer to a track that is not globally unique, but that's basically a compression scheme that we can work out later.\r\n\r\nI can envision a world where a bundles are named by URLs and when a track is named by a URL that shares a prefix with the enclosing bundle you can subscribe to it with a relative rather than absolute ID.  Again -- it's an optimization we can work out later.",
          "createdAt": "2023-03-30T08:42:22Z",
          "updatedAt": "2023-03-30T08:42:22Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@afrind I did update the issue to reflect the requirements/discussions from the slides presented today.",
          "createdAt": "2023-03-30T15:39:12Z",
          "updatedAt": "2023-03-30T15:39:12Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @suhasHere.\r\n\r\nAs an individual:\r\n\r\nFirst, at a high level, I've come to agree that tracks should be the top level component of the *object model*, in as much as we think about the object model as end-to-end, and cacheable.  We've stated a requirement to split and merge tracks from different bundles so they seem more ephemeral to me.  I think some applications might use bundles end-to-end but it doesn't have to be a requirement.\r\n\r\nTaking these one by one:\r\n\r\n> Track Ids to be fully specified within on Subscribe and Publish Requests\r\n\r\nI am OK with this. \r\n\r\n> Allows tracks to specify authorization scope for its namespace.\r\n\r\nI'm not sure I understand this one, do you mean something like a track ID can have a domain?\r\n\r\n> Control Streams/Messages mapped to Subscribe/Publish of tracks\r\n\r\nI agree the draft does need some refinement of how control streams and messages work, but I'm sure how it relates to this issue (track independence).  Can you clarify how they are coupled or can we move that to a separate issue?\r\n\r\n> Allow tracks to grouped for identification or other purposes in application specified way\r\n\r\nThe draft already allows for grouping of tracks in an application specified way (bundles).  I think you are asking for a decoupling of the bundle identifier and the track identifier?  If that's the ask I'm ok with it.",
          "createdAt": "2023-03-30T22:14:26Z",
          "updatedAt": "2023-03-30T22:14:26Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n> > Allows tracks to specify authorization scope for its namespace.\r\n\r\nI will try to steal the name that Mo suggested for a bit\r\nTrack Prefix = provider reference (https://acme.tv/session123). This is what you get from Catalog or the one in connect url when using WT session.\r\n\r\nTrack Suffix = small string that you append to the prefix to get the full track name. Example would be \"audio\"\r\n\r\nTrack Name = Track Prefix + Track Suffix ( https://acme.tv/session123/audio)\r\n\r\nTrack Id = a varint identifier that goes in every object header\r\n\r\nThe subscribe and publish requests carry the TrackName. I understand it is some duplication of bytes when using WT, but given its a control message that is not a concern. This will let the subscribe work with fully specified track names and every hop knows what to do with it and it is uniform across distribution networks.\r\n\r\nWe can have some caveats that mentions what to do if the track prefix of the track name know from a different context.\r\n\r\nI like to start from small building blocks and build larger things out of it. This will keep the protocol work across multiple use-cases and transport usages.\r\n\r\nMore details here on the ML (https://mailarchive.ietf.org/arch/msg/moq/20trhc_UsLnupHDcf2eeZb2we3E/)",
          "createdAt": "2023-03-30T23:20:50Z",
          "updatedAt": "2023-03-30T23:20:50Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "> The subscribe and publish requests carry the TrackName.\r\n\r\nWhat happens if I connect to `https://example.org/stream`, and request a track that belong to, say, `https://acme.tv/stream` instead of example.org?",
          "createdAt": "2023-03-30T23:36:16Z",
          "updatedAt": "2023-03-30T23:36:16Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We need to agree on the series of names and sub names and where they are in the protocol to get to unique name for the object. The relays have to have some way to keep track of what goes where when multiple applications use the same relay. \r\n\r\nI don't care much about what the exact hierarchy is as long as it is clear.  It sounded to me like it was turning into roughly something along lines of \r\n\r\nsome name for Application URL (note might not the same as connect URL ) \r\n-> priority domain \r\n   -> trackID\r\n      ->  GroupID\r\n         -> ObjectID \r\n         \r\n         ",
          "createdAt": "2023-03-31T01:21:06Z",
          "updatedAt": "2023-03-31T01:21:06Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, I agree Cullen. To summarize this issue into two options:\r\n\r\n1. A track is a member of a single priority domain. (nested component)\r\n2. A track can be a member of any priority domain. (indepdendent component)",
          "createdAt": "2023-03-31T02:06:24Z",
          "updatedAt": "2023-03-31T02:06:24Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "In my opinion, this clashes with #117.\r\n\r\nIf track is the top level in the object model, then it's undefined how tracks are clustered. A relay needs some way of knowing what tracks are pooled together, either to create multiple QUIC connections, or sessions within a QUIC connection.\r\n\r\nHow does a relay learn this grouping?",
          "createdAt": "2023-03-31T23:38:44Z",
          "updatedAt": "2023-03-31T23:38:44Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd like to see a design sketched out where each track has a priorityDomain property.  Each track is in exactly 1 priortyDomain. Then describe how any devices that sends tracks uses the priorityDomain to decide how the object gets mapped onto the underlying transport. ",
          "createdAt": "2023-04-01T00:25:20Z",
          "updatedAt": "2023-04-01T00:25:41Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On the topic of if a track can be in multiple priroties domains, I don't see how that would work. We are going to want to say \"if object A and B are in same priority domain, send in same bundle\".\r\n\r\nIf a track A was in in two priority domains 1 and 2, and track B was in priority domains 2 and 3. And track C was just in 3. I no longer see how we construct what bundle to use for each track. It seems like a track needs to be in exactly one",
          "createdAt": "2023-04-01T00:31:11Z",
          "updatedAt": "2023-04-01T00:31:11Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I want to step back here a bit more. What is the use-case?\r\n\r\nFrom what I can piece together, it sounds like the use-case is sharing content between broadcasts. In Yokohama, Cullen briefly mentioned two WebEx conferences sharing the same Youtube video. The goal is to share a cache within the CDN.\r\n\r\nTed also mentioned on the mailing list an example where two sports broadcasters receive and publish the exact same stadium feed. Again the goal is to share a cache within the CDN.\r\n\r\nIn both cases, this would be implementing by subscribing to track URLs with dramatically different prefixes. In the conferencing case, the CDN would primarily serve tracks from a webex.com domain while occasionally it would serve tracks from a youtube.com domain over the same connection.\r\n\r\n\r\nIs there anything I'm missing?  Because I don't think this will even solve those use-cases.\r\n",
          "createdAt": "2023-04-12T19:30:18Z",
          "updatedAt": "2023-04-12T19:31:15Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "The use case as I understand it has more to do with relays that are mixing and matching tracks from different \"broadcasts\".  Eg in a conference there are N participants each \"broadcasting\" M different tracks and a relay may be selecting subgroups of the tracks for each viewer of the conference.  In this way, the track may not be bound to the broadcast it originated in as far as the data-model goes.",
          "createdAt": "2023-04-18T17:53:03Z",
          "updatedAt": "2023-04-18T17:53:03Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Can this be closed now that #121 has merged, or are we waiting to remove bundle entirely?",
          "createdAt": "2023-04-21T19:25:59Z",
          "updatedAt": "2023-04-21T19:25:59Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Tracks are now an independent component of the data model, possibly pending some cleanup of text related to bundles.",
          "createdAt": "2023-05-05T19:58:11Z",
          "updatedAt": "2023-05-05T19:58:11Z"
        }
      ]
    },
    {
      "number": 110,
      "id": "I_kwDOG2Ho4M5iLJvl",
      "title": "Prioritization schemes needs flexibilty",
      "url": "https://github.com/moq-wg/moq-transport/issues/110",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "suhasHere"
      ],
      "labels": [],
      "body": "Current spec requires, when tracks are part of the bundle,  they would some sort of round robin ordering between them and send order based ordering inside the bundle. \r\n\r\nThis brings 3 things\r\n- Idea of pooling since bundle == WT\r\n- Round robin as the natural ordering - May be \r\n- Send order as the forward preference \r\n\r\nThere are alternate possible proposals that would allow object priorities and not tied to bundle or the WT session but operate across all tracks within a QUIC connections.\r\n\r\n",
      "createdAt": "2023-03-30T07:46:30Z",
      "updatedAt": "2023-05-05T20:08:56Z",
      "closedAt": "2023-05-05T20:08:56Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "As an individual:\r\n\r\n > Idea of pooling since bundle == WT\r\n\r\nThis is true in the draft now, ans I agree we should be using an abstraction that is not transport specific in the data model.  In my mind, a bundle is fundamentally a unit of pooling.  They are for cases where you want to pull two sets of tracks and want the scheduler to apply a higher level of  *between them*.  \r\n\r\n > Round robin as the natural ordering - May be\r\n\r\nIf you caught [WebTransport issue 102 ](https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/102) discussion yesterday, we talked about a few different ways one could prioritize between pooled flows. (obviously the context here is WT but generalizes to bundle).  Round robin is one scheme, but I agree there are others (eg: weighted RR or even strict ordering).\r\n\r\n> Send order as the forward preference\r\n\r\nI also think we want flexibility in prioritization signaling at this stage.  I wonder if we could take a page out of the HTTP book and replace sendOrder(i) with something that is both interoperable and has room for experimentation and extension. \r\n\r\n>  object priorities and not tied to bundle or the WT session but operate across all tracks within a QUIC connections\r\n\r\nSame observation as in #109 -- if you are scoping your priorities to the entire QUIC connection, that's the same to me as \"this QUIC connection has a single bundle\".  Do you have another use for bundles besides this?",
          "createdAt": "2023-03-30T08:56:17Z",
          "updatedAt": "2023-03-30T08:56:17Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> This is true in the draft now, ans I agree we should be using an abstraction that is not transport specific in the data model. In my mind, a bundle is fundamentally a unit of pooling. They are for cases where you want to pull two sets of tracks and want the scheduler to apply a higher level of _between them_.\r\n\r\nPooling as a construct for prioritization domain with send order is one way to set the forwarding decisions but there are other ways as well ,like, with object priorities proposal Christian presented. \r\n\r\nFor my understanding, If an entire QUIC connection is a single bundle,  does it mean that  a relay node can take tracks from multiple bundles and put them in a single egress QUIC connection ? Also if one is allowed to do so , I am not too sure utility of the bundle at that point. \r\nIIUC, for the relays , bundle needs to be optional and in many cases the ingress and egress flows at Relays vary depending on various factors that is outside the control of bundle.\r\n",
          "createdAt": "2023-03-30T12:22:01Z",
          "updatedAt": "2023-03-30T15:51:51Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> I also think we want flexibility in prioritization signaling at this stage. I wonder if we could take a page out of the HTTP book and replace sendOrder(i) with something that is both interoperable and has room for experimentation and extension.\r\n\r\nI suggested this to Luke, but might be worth exploring to see if it make sense. \r\nIf Forward_Preference (yes a new name for just discussion sake :-)) field of the object header is set as varint, then I think same field can be used for strict priorities (0-7) value and also some form of increasing send_order .. might need more thinking, but just a strwaman here\r\n\r\n",
          "createdAt": "2023-03-30T12:24:26Z",
          "updatedAt": "2023-03-30T12:24:26Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "As an individual:\r\n\r\n> Pooling as a construct for prioritization domain with send order is one way to set the forwarding decisions but there are other ways as well ,like, with object priorities proposal Christian presented.\r\n\r\nI think this comes down to what abstraction layers applications will need to simply express the priorities of multiple coexistent flows. Probably these ideas are isomorphic or close to isomorphic with each other, so they relays could send the packets in the ~right order regardless of the scheme chosen.  The relay just needs to know what data to send next, or drop, etc.  However, HTTP/2 showed that the abstractions and APIs matter a lot, and if senders of media can't easily express the priority they need, they may not use the prioritization system to its full advantage.\r\n\r\n> For my understanding, If an entire QUIC connection is a single bundle, does it mean that a relay node can take tracks from multiple bundles and put them in a single egress QUIC connection ? \r\n\r\nIn my thinking a QUIC connection is one *or more* bundles.  Yes a relay can take tracks from multiple bundles and egress them in a single QUIC connection.  The scenarios draft example works -- two conference participants each with 1 QUIC connection sending 1 bundle to a relay with a mixer selecting and merging them together into an egress connection of another participant.\r\n\r\n> Also if one is allowed to do so , I am not too sure utility of the bundle at that point.\r\n\r\nI think my best example where I need something like bundle for prioritization is on a QUIC connection between two relays carrying media streams from different conferences: Yes within each conference there's an understanding of how to prioritize tracks and objects, but at a high level there is no prioritization between them - every conference gets an equal share of the bandwidth.  \r\n\r\n> If Forward_Preference (yes a new name for just discussion sake :-)) field of the object header is set as varint, then I think same field can be used for strict priorities (0-7) value and also some form of increasing send_order .. might need more thinking, but just a strwaman here\r\n\r\nNo naming bikesheds :D  I think something with more structure than a single integer would be more interoperable, but I don't have a preference on the shape right now.",
          "createdAt": "2023-03-30T21:42:52Z",
          "updatedAt": "2023-03-30T21:42:52Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think my best example where I need something like bundle for prioritization is on a QUIC connection between two relays carrying media streams from different conferences: Yes within each conference there's an understanding of how to prioritize tracks and objects, but at a high level there is no prioritization between them - every conference gets an equal share of the bandwidth.\r\n\r\nThat is one possible way a relay might want to do such allocation. Its more nuanced than that. I feel we are forcing ourselves into a corner by expecting bundles to be carried end to end. Its relay's choice.  \r\n\r\nSince we are using WT sessions and they are mapped to bundle, we are now extending a requirement for every hop to carry the WT sessions from ingress to egress (1:1) to retain the bundle/prioritization domain. This is further leading to have pooling requirement.\r\n\r\nIf i look from QUIC perspective,  I am dealing with streams and priorities. There are  ways to address the prioritization across all the tracks within a QUIC connection without requiring the bundle as presented yesterday. We have implemented it and it does work as well. \r\n\r\n\r\n I am not opposing  to WT usage and I support it. But the fact that we are enforcing the prioritization domain bound to it and the list of further downstream requirements off it at evert hop is very restricting.  \r\n\r\n\r\nMay be a compromise is,  we carry an bool flag that indicates every hop to bundle or not to bundle things together and describe the implications. As you pointed out, Relays look at object header field called \"see this to decide what to do next\" and other than that rest is all application level semantics, which may or may not be needed.\r\n",
          "createdAt": "2023-03-30T22:00:12Z",
          "updatedAt": "2023-03-30T22:02:43Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "As an individual:\r\n\r\n> That is one possible way a relay might want to do such allocation. Its more nuanced than that. I feel we are forcing ourselves into a corner by expecting bundles to be carried end to end. Its relay's choice.\r\n\r\nI don't think bundles are end-to-end - maybe that's the sticky point?  I'm making a comment in #109.  I'm not sure who else might agree.\r\n\r\n> WT\r\n\r\nI never said WT you said WT :D I'm trying to reframe the language to be transport independent as much as possible.\r\n\r\n> This is further leading to have pooling requirement.\r\n\r\nSupporting pooling is a requirement for Meta's use cases at least (I've heard Will express for Akamai also) so we can't ignore those.  I agree we shouldn't *require* implementations to support > 1 bundle on a connection if they don't want to.\r\n\r\n",
          "createdAt": "2023-03-30T22:12:27Z",
          "updatedAt": "2023-03-30T22:12:27Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The way I head Meta use case expressed before could be solved with things other than pooling so I'm not sure I know what that use case. I think it would be very good if that use case could be explicitly described in a few sentences here. ",
          "createdAt": "2023-03-30T23:02:50Z",
          "updatedAt": "2023-03-30T23:02:50Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "As an individual:\r\n\r\n> I think it would be very good if that use case could be explicitly described in a few sentences here.\r\n\r\nThis is one:\r\n\r\n> I think my best example where I need something like bundle for prioritization is on a QUIC connection between two relays carrying media streams from different conferences: Yes within each conference there's an understanding of how to prioritize tracks and objects, but at a high level there is no prioritization between them - every conference gets an equal share of the bandwidth.\r\n\r\nThe other was mentioned on the list (playing and prefetching multiple unrelated videos in feed simultaneously, sharing bandwidth with different high level priority). \r\n\r\n> The way I head Meta use case expressed before could be solved with things other than pooling \r\n\r\nPooling is not the only way to solve this problem I suppose.  But removing a way to prioritize an entire set of tracks together at a high level will (I think) dramatically complicate the problem for senders to express the right priority.",
          "createdAt": "2023-03-30T23:13:49Z",
          "updatedAt": "2023-03-30T23:13:49Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> I never said WT you said WT :D I'm trying to reframe the language to be transport independent as much as possible.\r\n\r\nI understand, the reason i linked it is due to the requirements comes from having to have separate WT sessions pooled over one QUIC connection.If one uses object priorities, we can still get a priority schemes that is fair (incremental=false and incremental=true). \r\n\r\n> Pooling is not the only way to solve this problem I suppose. But removing a way to prioritize an entire set of tracks together at a high level will (I think) dramatically complicate the problem for senders to express the right priority.\r\n\r\nPooling allows each track to have certain forwarding preference.  You can reach the same end goal without pooling too. Round robin is not always the best way to go between these pools either. As i referred to, it is more nuanced than this. \r\n\r\n",
          "createdAt": "2023-03-30T23:44:01Z",
          "updatedAt": "2023-03-30T23:44:01Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So there is a key think I want to understand about what people think the requirement for fairness is. Imagine the following case:\r\n\r\nA, B, C are sending video to a single relay R and . X and Y are receiving the video from R. \r\n\r\nA is sending a track to X, B is sending a track to X, and C is sending a track to Y.  The only congested link is a shared link coming out or R to both X and Y. \r\n\r\nSo do X and Y get equal amounts of bandwidth, or does X get twice as much bandwidth as Y because it has tracks from two senders ( A and B ) while Y has only data from one sender ( X )? \r\n\r\nWe have to understand what we are trying to accomplish here or we are just going to to go around in circles. ",
          "createdAt": "2023-03-31T01:14:21Z",
          "updatedAt": "2023-03-31T01:14:21Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "As a priority enthusiast:\r\n\r\nDo X and Y share a QUIC connection?  As I read your example it doesn't sound like it.  I don't think this this wg is working on prioritizing flows across different QUIC connections on the same link, but rather on prioritizing data within a single QUIC connection.  So in that case, the congestion controllers of the QUIC connections decide how bandwidth is allocated to each.\r\n\r\nPooling comes into play if you extend the above example to have two relays R1 and R2, connected by a single QUIC connection carrying video for A, B and C together.  ",
          "createdAt": "2023-03-31T01:26:59Z",
          "updatedAt": "2023-03-31T01:26:59Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, in my example I mean to have X and Y are separate clients and not on same computer much less same QUIC connection. But they shared the congested link coming out of R. \r\n\r\nI agree with Alan's analysis of what will happen here but I was more trying to sort out what  we were trying to have happen as it seemed like Luke wanted the prioritization to be such that the bandwidth was allocated as a fraction of number of senders not receivers. \r\n",
          "createdAt": "2023-03-31T02:06:52Z",
          "updatedAt": "2023-03-31T02:06:52Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "We should loosen up the text for now to enable experimentation. In fact maybe we put the prioritization scheme/mode on the wire (for a collection of tracks).\r\n\r\nBut I strongly believe we'll need a specific prioritization scheme between tracks at some point. It cannot be optional and up to the relays.",
          "createdAt": "2023-03-31T23:31:28Z",
          "updatedAt": "2023-03-31T23:31:28Z"
        },
        {
          "author": "acbegen",
          "authorAssociation": "NONE",
          "body": "> So do X and Y get equal amounts of bandwidth, or does X get twice as much bandwidth as Y because it has tracks from two senders ( A and B ) while Y has only data from one sender ( X )?\r\n> \r\n> We have to understand what we are trying to accomplish here or we are just going to to go around in circles.\r\n\r\nThis is something we refer to as \"utility fairness.\" If you say \"fairness\" only, people assume fairness in terms of bitrate/bandwidth - which is far from ideal in many cases. The problem here is that maybe Y will fan out downstream and the total number of receivers for C will be way more than two. Unless you have explicit signaling, there is no way for R to know this, and hence, make the right decision. @afrind's scenario (R1 and R2) is practical but is certainly not the only scenario we will ever face. And bundling as it stands now does not seem to help with most other scenarios.",
          "createdAt": "2023-04-07T12:02:49Z",
          "updatedAt": "2023-04-07T12:02:49Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Being discussed as part of #139 ",
          "createdAt": "2023-04-21T19:32:32Z",
          "updatedAt": "2023-04-21T19:32:32Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "@suhasHere - should we merge/close this issue then?",
          "createdAt": "2023-04-21T19:44:00Z",
          "updatedAt": "2023-04-21T19:44:00Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm going to mark this closed based on 139.",
          "createdAt": "2023-05-05T20:08:56Z",
          "updatedAt": "2023-05-05T20:08:56Z"
        }
      ]
    },
    {
      "number": 111,
      "id": "I_kwDOG2Ho4M5iLPAS",
      "title": "Objects can be individually cached and served (A way to GET one or more objects)",
      "url": "https://github.com/moq-wg/moq-transport/issues/111",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "suhasHere"
      ],
      "labels": [
        "Needs PR",
        "Subscribe"
      ],
      "body": "Some use-case like  catchup , go back to a given object for layer refresh or server the game state from a given object , and similar scenarios ,  would need a name to ask for the object. \r\nIt would be good for the protocol to be able to subscribe to not just track and group, but also object.\r\n\r\n",
      "createdAt": "2023-03-30T07:59:51Z",
      "updatedAt": "2023-10-23T18:19:15Z",
      "closedAt": "2023-10-23T18:19:15Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "As an individual:\r\n\r\n+1.  An application should be able to request a single object.  Maybe even a byte range of an object but I would punt that until an actual use case materializes.",
          "createdAt": "2023-03-30T08:59:53Z",
          "updatedAt": "2023-03-30T09:02:47Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Can you elaborate on the use-case?\r\n\r\nResumption after a connection is severed makes sense. We need to solve that for both the contribution and distribution use-case. @vasilvv has some strong opinions here.\r\n\r\nI don't quite understand the second use-case. Why would a consumer need to refetch a single object, but none of the objects it could depend on? It only makes sense when there's a hole in the group, but why did that happen and how does the subscriber know about it?",
          "createdAt": "2023-03-31T23:26:09Z",
          "updatedAt": "2023-03-31T23:26:27Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "And to be clear, I also think we should have a GET equivalent, but I want to make sure I understand the ask.",
          "createdAt": "2023-03-31T23:32:37Z",
          "updatedAt": "2023-03-31T23:32:37Z"
        },
        {
          "author": "acbegen",
          "authorAssociation": "NONE",
          "body": "> It only makes sense when there's a hole in the group, but why did that happen and how does the subscriber know about it?\r\n\r\nThe encoder might have skipped some frames due to input loss or another issue, but maybe they are available from a redundant encoder and you would like to \"fill the gaps\"? The subscriber only sees the gap, it does not need to know the dependency structure.",
          "createdAt": "2023-04-07T11:42:56Z",
          "updatedAt": "2023-04-07T11:42:56Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Two uses cases I am thinking, both on distribution side:\r\n\r\nUse case A: \r\n* client join a session that is in progress and wants to join Track A. The client wants to start playing before the next the GOP starts so it subscribes to Track A with the most recent group and wants to get *all* the objects in the group. \r\n\r\nUse case B: \r\n* client is watching Track A  and has received all the objects up to group 123 object 45 and looses wifi and switched to 5G. At this point it forms a new subscription to Track A but it wants to start at group 123 object 46 because it already has the stuff before that. If it had to wait to received all the stuff in group 123 over again, it would add delay as it switched networks. \r\n\r\nThere are some more uses from scalable codecs but if we can solve the above two cases, we will probably solve the toher uses cases as well. ",
          "createdAt": "2023-04-07T20:35:20Z",
          "updatedAt": "2023-04-07T20:35:20Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the solution to this is simply that the Subscribe can have some sort of flag that indicates if the clients wants just future objects, or if wants to catch up on all the objects in the current group, or wants all the objects after some particular objectID ",
          "createdAt": "2023-04-07T20:37:37Z",
          "updatedAt": "2023-04-07T20:37:37Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "There isn't a way to GET a single object - you can SUBSCRIBE to the track starting from that object, and perhaps issues an UNSUBSCRIBE after that.  I'm going to leave this open for now.",
          "createdAt": "2023-05-05T20:08:01Z",
          "updatedAt": "2023-05-05T20:08:01Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Will suggested solving this as part of #245 and have both a start group and end group.",
          "createdAt": "2023-10-04T20:54:15Z",
          "updatedAt": "2023-10-04T20:54:15Z"
        }
      ]
    },
    {
      "number": 112,
      "id": "I_kwDOG2Ho4M5iLQsj",
      "title": "Relay behavior needs to be specified",
      "url": "https://github.com/moq-wg/moq-transport/issues/112",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "suhasHere"
      ],
      "labels": [],
      "body": "Current spec lacks relays interaction within the protocol. It is very hard for a relay implementor to get an idea on how to build a useful relay. \r\n\r\nWe need to specify behavior on\r\n- how to use tracks to identify the origin \r\n- describe policy enforcement behavior\r\n- describe how to provide appropriate congestion response \r\n- non-normatively describe implications of protocol design options (bundles/tracks)\r\n- may be some more\r\n\r\nWe need to have some basic information captured in the base transport.\r\n\r\n",
      "createdAt": "2023-03-30T08:04:26Z",
      "updatedAt": "2023-05-26T23:30:18Z",
      "closedAt": "2023-05-26T23:30:18Z",
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "PRs #67 #95  has some aspects of it. They may need some cleanup,  but it would be good to get to next steps on getting relays behavior specified in the base transport. ",
          "createdAt": "2023-03-30T23:01:42Z",
          "updatedAt": "2023-03-30T23:01:42Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I think I've stated my position before, but I don't remember which issue or PR it was, so I will restate it now.\r\n\r\nAs a general principle, the protocol should behave the same (or as close as possible) regardless of whether a receiver is subscribing to a relay or to the publisher directly.  Similarly, the encoder should behave the same regardless of whether it is publishing to a relay or to a receiver directly.\r\n\r\nIn the light of the principle above, how much of the text in those PRs is actually necessary, or needs to be generalized to include non-relays?",
          "createdAt": "2023-03-30T23:42:45Z",
          "updatedAt": "2023-03-30T23:42:45Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with Victor that mostly is the same as point to point but I think you still have to specify quite a bit about what happen with things like priority when you are transferring things from multiple incoming connections to multiple outgoing connections. ",
          "createdAt": "2023-03-31T01:26:12Z",
          "updatedAt": "2023-03-31T01:26:12Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "> priority when you are transferring things from multiple incoming connections to multiple outgoing connections\r\n\r\nWouldn't that be more of an implementation detail?  E.g. if you're a CDN, your priority may depend on the nature of business relationship between different subscribers and publishers.",
          "createdAt": "2023-03-31T01:59:36Z",
          "updatedAt": "2023-03-31T01:59:36Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, the issue seems to be that there's not enough editorial text for relay. We should add some more for sure but I agree with Victor; this draft should focus on the hop-to-hop transport.",
          "createdAt": "2023-03-31T02:03:29Z",
          "updatedAt": "2023-03-31T02:03:50Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No we agreed to make relays part of this WG. We need to adopt a draft that aligned with the architecture and requirements in the charter. We keep running into issues that the clients need to deal with to talk to a relay and we need to cover those in the base draft. I agree that most things are the same but there are many things that you can't just add in later with relays if you don't have them form the start.",
          "createdAt": "2023-03-31T02:08:40Z",
          "updatedAt": "2023-03-31T02:10:46Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> No we agreed to make relays part of this WG. We need to adopt a draft that aligned with the architecture and requirements in the charter.\r\n\r\nSorry, to clarify the transport MUST be designed to support relays. We should make sure that all of the functionality needed by a relay is addressed (separate issues please).",
          "createdAt": "2023-03-31T02:13:54Z",
          "updatedAt": "2023-03-31T02:13:54Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "> I agree that most things are the same but there are many things that you can't just add in later with relays if you don't have them form the start.\r\n\r\nI agree, but I assume we would treat those things as individual issues.  What I am trying to understand is: what are the specific changes requested in this particular issue?",
          "createdAt": "2023-03-31T02:28:00Z",
          "updatedAt": "2023-03-31T02:28:00Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "To clarify what I am trying to say here.  I am trying to separate \"MoQ design requirements that arise from supporting relays\" and \"text specific to how relays work\"; we definitely need to address the former, but I am not sure how much of the latter we actually need.",
          "createdAt": "2023-03-31T02:38:00Z",
          "updatedAt": "2023-03-31T02:38:00Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I enumerated some specific CDN/relay specific use-cases and requirements in: #117 #118 #119 #120. I think I got the important ones, but you should probably file some more. I've spent a long time working on CDNs so hopefully it's helpful?\r\n\r\nI agree with Victor. I think we should have a normative transport draft and at least a non-normative scenarios/requirements/use-cases draft. Of course the transport draft MUST support relay use-cases, but for example it shouldn't elaborate on how CDNs are typically architected. The issues I filed should really go into that use-cases draft.",
          "createdAt": "2023-04-01T05:54:35Z",
          "updatedAt": "2023-04-01T05:54:54Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "@suhasHere Did #126 and #127 resolve this issue?  if not maybe close this and open a more specific one?",
          "createdAt": "2023-05-26T00:14:59Z",
          "updatedAt": "2023-05-26T00:14:59Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this for now based on above PRs.  You can reopen or open a new issue to track additional relay requirements.",
          "createdAt": "2023-05-26T23:30:18Z",
          "updatedAt": "2023-05-26T23:30:18Z"
        }
      ]
    },
    {
      "number": 113,
      "id": "I_kwDOG2Ho4M5iLRgM",
      "title": "Move the streaming format description outside the base spec",
      "url": "https://github.com/moq-wg/moq-transport/issues/113",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is reflecting the discussions on having a separate spec describe the streaming format (cmaf, webcodecs based format) \r\n",
      "createdAt": "2023-03-30T08:06:37Z",
      "updatedAt": "2023-05-05T19:52:40Z",
      "closedAt": "2023-05-05T19:52:40Z",
      "comments": [
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 on doing this. ",
          "createdAt": "2023-04-07T20:26:41Z",
          "updatedAt": "2023-04-07T20:26:41Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm going to work on splitting the warp draft into a transport only section. Will started the media half here: https://github.com/wilaw/MoQ\r\n\r\nI want these to be in the same GitHub repo eventually. Should we do that now or wait for adoption?",
          "createdAt": "2023-04-10T17:55:26Z",
          "updatedAt": "2023-04-10T17:55:26Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "See also #66, maybe one of these can be closed as a duplicate?",
          "createdAt": "2023-04-21T19:28:04Z",
          "updatedAt": "2023-04-21T19:28:04Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Duplicate of #66 and related to #146",
          "createdAt": "2023-05-05T19:52:40Z",
          "updatedAt": "2023-05-05T19:52:40Z"
        }
      ]
    },
    {
      "number": 114,
      "id": "I_kwDOG2Ho4M5iLTpz",
      "title": "Native QUIC and WT support",
      "url": "https://github.com/moq-wg/moq-transport/issues/114",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@vasilvv has agreed to write a starter PR on this. I am documenting the issue for tracking purposes.\r\n\r\nThanks @vasilvv ",
      "createdAt": "2023-03-30T08:12:35Z",
      "updatedAt": "2023-04-21T19:23:13Z",
      "closedAt": "2023-04-21T19:23:12Z",
      "comments": [
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I hoping to see a raw quic Connect message that has about the same semantic content of the part of the HTTP connect we are using and something that deals with error code that is sent when a web transport is terminated. As far as I can tell, the rest of the protocol should be the same between the two. ",
          "createdAt": "2023-04-07T20:26:19Z",
          "updatedAt": "2023-04-07T20:26:19Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed via #135.",
          "createdAt": "2023-04-21T19:23:12Z",
          "updatedAt": "2023-04-21T19:23:12Z"
        }
      ]
    },
    {
      "number": 115,
      "id": "I_kwDOG2Ho4M5iLW4j",
      "title": "Catalog needs to describe track details further",
      "url": "https://github.com/moq-wg/moq-transport/issues/115",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Catalog spec should provide track and media info \r\n\r\nProvide track identifier information\r\n\r\nMinimal Media info on the lines of bitrate, samplerate, codec name, resolution and similar quality information per track.\r\n\r\nDetails to identify the Container format.\r\n\r\nWill Law has agree to work on expanding the catalog spec. Documenting the issue here, until we decide a right home for it.\r\n\r\n\r\n\r\n",
      "createdAt": "2023-03-30T08:21:40Z",
      "updatedAt": "2023-05-05T20:00:28Z",
      "closedAt": "2023-05-05T20:00:28Z",
      "comments": [
        {
          "author": "acbegen",
          "authorAssociation": "NONE",
          "body": "Why reinvent the wheel? Have a look at what DASH MPD provides and do more or less what it does :)",
          "createdAt": "2023-04-07T11:32:17Z",
          "updatedAt": "2023-04-07T11:32:17Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ali - can you point us at the right thing to be reading or referring to for dash mpd. I want to get my head around if it would work the audio conferencing type use cases. I'm also assuming we will have multiple types of catalogs and this could be one of them. ",
          "createdAt": "2023-04-07T20:21:58Z",
          "updatedAt": "2023-04-07T20:21:58Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, there's already a ton of existing \"catalog formats\" out there. For example: SDP, M3U8, DASH, MP4 (moov), etc.\r\n\r\nI don't think we should define our own until we full understand the problems with these existing standards.",
          "createdAt": "2023-04-10T17:52:12Z",
          "updatedAt": "2023-04-10T17:52:12Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Based on agreement at 116 to move this out of base protocol, do you want to move this issue to the https://github.com/wilaw/MoQ repo?",
          "createdAt": "2023-04-21T19:28:56Z",
          "updatedAt": "2023-04-21T19:28:56Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm closing this issue - please open one against the wilaw/MoQ repo if doesn't meet your requirements.",
          "createdAt": "2023-05-05T20:00:28Z",
          "updatedAt": "2023-05-05T20:00:28Z"
        }
      ]
    },
    {
      "number": 116,
      "id": "I_kwDOG2Ho4M5iQtSu",
      "title": "junk test ",
      "url": "https://github.com/moq-wg/moq-transport/issues/116",
      "state": "CLOSED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-03-31T01:57:46Z",
      "updatedAt": "2023-03-31T01:58:19Z",
      "closedAt": "2023-03-31T01:58:19Z",
      "comments": [
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I can not tag this issue ",
          "createdAt": "2023-03-31T01:58:16Z",
          "updatedAt": "2023-03-31T01:58:16Z"
        }
      ]
    },
    {
      "number": 117,
      "id": "I_kwDOG2Ho4M5iW1t4",
      "title": "CDN: Pooling",
      "url": "https://github.com/moq-wg/moq-transport/issues/117",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I'm surprised this wasn't filed already.\r\n\r\n**Problem**: Within a CDN, there may be hundreds of thousands of simultaneous broadcasts. Establishing a QUIC connection between each node for each broadcast is prohibitively expensive and makes it difficult to coordinate limited resources (ex. congestion control, flow control, prioritization).\r\n\r\nAdditionally, prioritization works within the context of a QUIC connection. Tracks within the same broadcast MUST be sent over the same QUIC connection in order to be priortized, which means we need some way to force some minimal pooling between specific tracks.",
      "createdAt": "2023-03-31T23:05:34Z",
      "updatedAt": "2023-08-07T21:19:36Z",
      "closedAt": "2023-08-07T21:19:36Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "We could take a few different approaches here. \r\n\r\nThe first way is to make QUIC connections cheaper. If there was some way to fork a QUIC connection, so the 1RTT handshake can be skipped, then it might be good enough to have a separate connection per broadcast.\r\n\r\nThe second way is to share a QUIC connection. Each broadcast would need some sort of sandbox to avoid starving each other. This is what WebTransport aims to do with session IDs, although the capsule design is gross.",
          "createdAt": "2023-03-31T23:15:37Z",
          "updatedAt": "2023-03-31T23:15:37Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Regardless of the approach, we need some way of identifying when tracks must be delivered over the same connection and prioritized. A relay needs to know when to create or reuse an existing connection/session for each track.",
          "createdAt": "2023-04-01T00:08:32Z",
          "updatedAt": "2023-04-01T00:08:32Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agree with the problem and just to put more detail. Many existing CDN have their own ways of distributing the data inside the CDN and my not even want to use QUIC for that at all. What we need to make sure we have is enough data in the transport that the CDN can fairly deal with all this information and make sure that if you look at the CDN as a black box from the outside, the box as a whole has appropriate behavior for all the clients using it. \r\n\r\nAs we end up defining our priority scheme, I think it will become clear what information needs to be in the transport such that the CDN black box can provide fair behavior.  That might mean that tracks need a property like priorityGroup if the CDN forwarding is based on something like a sendOrder counter where you can't compare sendOrders from different publishers. \r\n\r\nI feel like as we refine the priority bug, it will become clearer what we need to do with this bug. ",
          "createdAt": "2023-04-07T20:18:41Z",
          "updatedAt": "2023-04-07T20:18:41Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "#139 carries some discussions around this.",
          "createdAt": "2023-04-21T19:34:45Z",
          "updatedAt": "2023-04-21T19:34:45Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing because there's no action item. Pooling is a massive discussion.",
          "createdAt": "2023-08-07T21:19:36Z",
          "updatedAt": "2023-08-07T21:19:36Z"
        }
      ]
    },
    {
      "number": 118,
      "id": "I_kwDOG2Ho4M5iW7gu",
      "title": "CDN: Deduplication",
      "url": "https://github.com/moq-wg/moq-transport/issues/118",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "**Problem**: A CDN is only works due to deduplication. In the HTTP world, an edge node receives millions of requests, with different URLs and headers, and is able to figure out how to deduplicate them into far fewer upstream requests. This reduces the work for each upstream hop making it feasible for individual origin hosts to effectively serve millions of requests.\r\n\r\nIn the MoQ world, we need to deduplicate subscriptions. If there are 100 viewers connected to a CDN edge and SUBSCRIBE for the same broadcast, then ideally that would translate into a single SUBSCRIBE call upstream. ",
      "createdAt": "2023-03-31T23:47:02Z",
      "updatedAt": "2023-08-07T21:19:13Z",
      "closedAt": "2023-08-07T21:19:13Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "In order to do this, the edge relay needs enough information to know when subscriptions can be deduplicated. In the HTTP world, this is handled by bespoke business logic (based on the URL and some headers).\r\n\r\nAs part of that process, the edge relay needs to deduplicate/remove any user-specific information. Importantly, that includes authentication; a relay edge must be able to authenticate per-session tokens in order to deduplicate. Otherwise it could serve unauthorized data from the cache.",
          "createdAt": "2023-03-31T23:52:59Z",
          "updatedAt": "2023-03-31T23:52:59Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "My proposal is to adopt the existing HTTP world. As part of signing up for a CDN, the application configures the business logic required to both authorize, remap, and deduplicate incoming subscriptions. Maybe we could standardize something but I figure that's been tried already in the HTTP world.\r\n\r\nI would like to see authorization performed as part of connecting to the CDN edge. I'm okay with delaying authentication until a token in the SUBSCRIBE message, so long as it's understood that this token must be authenticated/stripped at a CDN edge.",
          "createdAt": "2023-03-31T23:58:56Z",
          "updatedAt": "2023-04-01T00:04:59Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "HTTP was not designed for caches ( they were added much later ) which results in this being a bit crazy - luckily we can design this right from the start. \r\n\r\nFrom a data model point of view we are asking who can receive a copy of a given object because tis what we transfer or who is allowed to publish a give object. Each track has a globally unique name, and the object is inside a group inside that track. I think this is why it is critical we authorize both publish and subscribe at a track level of granularity. We might also need to authorize at the connect level but I don't think that has the level of granularity to allow a given client to be able to subscribe to a track but not be allowed to publish to that same track.  \r\n\r\nI agree on de-duplication. I think the track name + groupID + objectID gives a unique name of the object that allows the CDN to both cache and deduplicated. \r\n\r\nAll that said, I think I come to the same conclusion as you that the client needs to include a token that the CDN can validate and that the token can be tied to the track name. I think we can use the same token as are often used in HTTP and we don't even need to get into what the tokens are, just that the transport caries them and the CDN uses to validate. ",
          "createdAt": "2023-04-07T20:12:19Z",
          "updatedAt": "2023-04-07T20:12:19Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing because there's no action item.",
          "createdAt": "2023-08-07T21:19:13Z",
          "updatedAt": "2023-08-07T21:19:13Z"
        }
      ]
    },
    {
      "number": 119,
      "id": "I_kwDOG2Ho4M5iXCCc",
      "title": "CDN: End-to-end congestion",
      "url": "https://github.com/moq-wg/moq-transport/issues/119",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "**Problem**: ISPs and transit providers run congested networks. The CDN is able to provide better quality of service by using an uncongested private network. The distance traffic travels outside of the CDN network is colloquially known as \"first and last mile\".\r\n\r\nThere's a lot of focus in the industry on first and last mile congestion. This is generally the right approach; WebRTC primarily focuses on the first hop (encoder responds to congestion) while HLS/DASH primarily focuses on the last hop (player ABR in response to congestion).\r\n\r\nHowever there's very little that is done if congestion occurs at an intermediate hop. As a result, CDNs need to over-provision backbone networks to avoid any congestion significantly degrading the user experience. It also rules out transferring media over lossy links, such as between CDNs or between cloud providers.",
      "createdAt": "2023-04-01T00:27:42Z",
      "updatedAt": "2023-08-07T21:18:46Z",
      "closedAt": "2023-08-07T21:18:46Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "My proposal is to enable relays to perform the congestion response as the end viewer. At a minimum, media is prioritized/dropped at every hop with the same mechanism. I would also like to explore using some form of ABR at each hop.",
          "createdAt": "2023-04-01T00:30:50Z",
          "updatedAt": "2023-04-01T00:35:30Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "By ABR here, do you mean if their was a high, med, low bitrate stream for the same thing, that transport between relays would priorities med  over high ?  ( if so I agree and I think all the designs have that ) \r\n",
          "createdAt": "2023-04-01T00:35:25Z",
          "updatedAt": "2023-04-01T00:35:25Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, prioritizing tracks is one way of performing ABR: \"please send me 360p **_and_** 720p, preferring 360p if there's congestion\".\r\n\r\nBut I would also like to explore a relay being able to request individual tracks, as requesting all of them will use more bandwidth: \"please send me 360p **_or_** 720p, preferring 720p if there's no congestion\". ",
          "createdAt": "2023-04-01T00:39:19Z",
          "updatedAt": "2023-04-01T05:11:24Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The challenge in chaining together a series of ABR decisions is that the further down the chain you go, the more unstable it becomes. We will need clear signalling to instruct downstream entities that a certain bitrate is being abandoned, otherwise that entity will have hard a hard time separating a temporary delay/gap in data from a permanent switch away.  ",
          "createdAt": "2023-04-04T16:34:37Z",
          "updatedAt": "2023-04-04T16:34:37Z"
        },
        {
          "author": "acbegen",
          "authorAssociation": "NONE",
          "body": "> Yeah, prioritizing tracks is one way of performing ABR: \"please send me 360p **_and_** 720p, preferring 360p if there's congestion\".\r\n> \r\n> But I would also like to explore a relay being able to request individual tracks, as requesting all of them will use more bandwidth: \"please send me 360p **_or_** 720p, preferring 720p if there's no congestion\".\r\n\r\nI don't think this is the right way of doing this. First of all, whatever the upstream relays decide to do will affect everybody downstream (other relays or ultimate receivers). The utility of each track also is different. That is, maybe one track is being consumed by 1M clients as opposed to another one being consumed by only ten clients. How do we expect an upstream relay to do the right thing here? By default, sacrificing several low-concurrency streams for one high-concurrency stream makes sense, or maybe it does not. What I am saying is that if we look at this from a \"resource optimization\" problem, individual relays cannot possibly make optimal decisions. Rather, CMCD/CMSD type of signaling may be quite useful to help situations like this.",
          "createdAt": "2023-04-07T11:21:33Z",
          "updatedAt": "2023-04-07T11:21:33Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Let me describe something I don't want to have happen then let me propose the direction I think we should go:\r\n\r\nSay client P1 publishes to relay R1 that sends to relay R2 that sends to subscriber S2 and subscriber S3. P1 is sending 360P and 720P video. To start with both S2 and S3 have decided to only subscribe to the 720P and everything is going fine with no congestion.  At some point we start to have congestion between R1 and R2. \r\n\r\nWhat I don't want is a solution where R2 is only getting 720P from R1 to start with, then when the congestion starts, S2 decided to get 360P but S3 stays on 720P and that causes R2 to start getting *both* 360P and 720P from R1. That would not be OK - the response to congestion between R1 and R2 can not be to increase the bandwidth uses between R1 and R2.\r\n\r\nThere are many ways to avoid this problem. I would favor a simple approach that is not optimal in all cases but works in all cases. Later we can pick a more complicated way. ",
          "createdAt": "2023-04-07T20:02:12Z",
          "updatedAt": "2023-04-07T20:02:12Z"
        },
        {
          "author": "acbegen",
          "authorAssociation": "NONE",
          "body": "> What I don't want is a solution where R2 is only getting 720P from R1 to start with, then when the congestion starts, S2 decided to get 360P but S3 stays on 720P and that causes R2 to start getting _both_ 360P and 720P from R1. That would not be OK - the response to congestion between R1 and R2 can not be to increase the bandwidth uses between R1 and R2.\r\n\r\nOr, S2 experiences congestion and shifts down to 360p (S3 still stays on 720p) but when R2 starts getting both 360p and 720p, R2 starts experiencing congestion. That might lead to S3 experiencing problems, too. S3 becomes the \"loser\" in this scenario.",
          "createdAt": "2023-04-07T22:06:39Z",
          "updatedAt": "2023-04-07T22:06:39Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Say client P1 publishes to relay R1 that sends to relay R2 that sends to subscriber S2 and subscriber S3. P1 is sending 360P and 720P video. To start with both S2 and S3 have decided to only subscribe to the 720P\r\n\r\nI think we should architect a distribution system in which a publisher does not send media without being explicitly asked for it. In other words, the scenario described here would not happen, because if S2 and S3 where both subscribing to 720P, then R2 would only subscribe to 720P from R1  and P1 would only publish 720P in response to R1's subscribe.\r\nThe reason for this is scale and economics. In a distribution tree of thousands of servers, pushing all bitrates of every broadcast to every node results in a large increase in mid-mile bandwidth, with much of it wasted. With a sufficient subscriber cohort  each node would quickly end up be pulling all bitrates anyway, but at least it would be efficient with every object moving over the network being consumed by an end-subscriber.\r\n\r\nFor those who want the \"instant on\" effect you can achieve for end-subscribers by pushing all content to the edge relay, it can be delivered by having agents who subscribe to bitrates on the true subscribers behalf. These agents can seed the edge network cache ahead of end-subscriber demand. This creates an instant-on effect without breaking the simple tenant of \"don't publish until you get a subscribe\".\r\n",
          "createdAt": "2023-04-07T22:38:44Z",
          "updatedAt": "2023-04-07T22:38:44Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with Cullen. I don't want a situation where a relay MUST receive all renditions in order to operate. Leaving the choice of rendition solely up to the end viewers means the CDN cannot be flexible in response to congestion.\r\n\r\nWe should assume that relays may be congested. I love Victor's example of a CDN edge on a cruise ship. The last \"mile\" is flawless, while the congestion primarily occurs in the hops between relays (ship to satellite).",
          "createdAt": "2023-04-10T17:43:41Z",
          "updatedAt": "2023-04-10T17:43:41Z"
        },
        {
          "author": "gwendalsimon",
          "authorAssociation": "NONE",
          "body": "> I think we should architect a distribution system in which a publisher does not send media without being explicitly asked for it. In other words, the scenario described here would not happen, because if S2 and S3 were both subscribing to 720P, then R2 would only subscribe to 720P from R1 and P1 would only publish 720P in response to R1's subscribe. \r\n\r\nI am not sure the definition of \"publish\" is clear here. It can mean 1/ publicly announcing that multiple qualities are available, 2/ preparing (encoding and packaging) all these qualities, 3/ sending all qualities to the relay that subscribes to any of these qualities. \r\n\r\nIn most of today's ABR systems, the origin server does 1 and 2 but it does not 3.  It would indeed be weird to waste network resources for unrequested content. Some systems also implement Just-in-Time (JIT) systems to execute 2 upon request only, with the same argument that it would be weird to waste CPU/GPU resources for unrequested content.\r\n\r\nAnyway, here the publisher \"announces\" that it can do bot 360p and 720p, It may be not \"sending\" both streams to R1 at the beginning of this use case but, if S2 starts requesting 360p while S3 still requests 720p, then both subscriptions will arrive to the P1. who will then \"send\" both streams.",
          "createdAt": "2023-04-13T07:10:27Z",
          "updatedAt": "2023-04-13T09:14:21Z"
        },
        {
          "author": "gwendalsimon",
          "authorAssociation": "NONE",
          "body": "> I agree with Cullen. I don't want a situation where a relay MUST receive all renditions in order to operate. Leaving the choice of rendition solely up to the end viewers means the CDN cannot be flexible in response to congestion.\r\n\r\nYou re-open here a well-known debate: client-based adaptive streaming vs. server-based adaptive streaming. Today's ABR is client-based. The community has developed multiple tools to mitigate the problems caused by this client-based approach:\r\n1/ server recommendation:  MPEG DASH has developed SAND (Server And Network Assisted Delivery) where a server sends messages to every client to recommend which quality to fetch next. More recently, CMSD is based on the same approach: the server indicates a recommended profile to every client. Then each client can decide to follow this recommendation or not. In the use-case, it would mean that R2 sends a message to S2 and S3 to recommend 360p instead of 720p. But S3 may ignore it and stick to 720p. I don't see any mechanism like it in MoQ yet.\r\n\r\n2/ manifest manipulation: some servers simply remove a quality from the manifest. If the manifest is regularly updated at the client side, then the highest profile is no longer \"announced\". In this use case, it would mean that the relay could decide to remove tracks from catalog when the path between P1 and itself is not good enough. Not sure it is possible.\r\n\r\n3/ server delivery: the server serves 360p even if the subscriber requested a 720p stream. It may crash the client.\r\n\r\n> What I don't want is a solution where R2 is only getting 720P from R1 to start with, then when the congestion starts, S2 decided to get 360P but S3 stays on 720P and that causes R2 to start getting _both_ 360P and 720P from R1. That would not be OK - the response to congestion between R1 and R2 can not be to increase the bandwidth uses between R1 and R2.\r\n\r\nWith a pure client-based ABR approach, I don't see how you can prevent this to happen. It is what happens in ABR systems by the way.\r\n\r\nThe aforementioned server-client-based ABR approaches fix it but none of these solutions is really elegant imho.\r\n\r\n",
          "createdAt": "2023-04-13T07:31:46Z",
          "updatedAt": "2023-04-13T07:31:46Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Going to close this because there's no action item and it's better suited for a requirements draft. I do think ABR over the backbone is useful, but kind of difficult to implement. Either way it should be in it's own issue.",
          "createdAt": "2023-08-07T21:18:45Z",
          "updatedAt": "2023-08-07T21:18:45Z"
        }
      ]
    },
    {
      "number": 120,
      "id": "I_kwDOG2Ho4M5iXcYv",
      "title": "CDN: Routing",
      "url": "https://github.com/moq-wg/moq-transport/issues/120",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Related to #118 \r\n\r\n**Problem**: CDNs serve a huge number of broadcasts, far more than can reasonably fit on every edge host. The solution in the HTTP world is to fetch content on demand on a cache miss. These cache misses are expensive compared to a cache hit (fetches from upstream), so there's incentive to minimize the number of hosts that are eligible to serve specific content in order to maximize the cache hit ratio.\r\n\r\nThis significantly complicates routing. Viewers need to subscribe to eligible edge nodes which need to subscribe to eligible relays over the backbone. At least within Twitch, there's an dedicated service to determine this eligibly on a per-host and per-datacenter basis.\r\n\r\nIt's also difficult to determine the best path to an origin. Network routing protocols are typically pretty good at this but operate at the IP layer (L3), requiring some form of application routing (L7) in order to perform deduplication and caching (exception: multicast). This is further complicated by the fact that L7 caching/routing may use more resources than it's worth (ex. 1 viewer broadcasts) and L3 routing may be desirable for specific hops.",
      "createdAt": "2023-04-01T05:48:31Z",
      "updatedAt": "2023-08-07T21:17:16Z",
      "closedAt": "2023-08-07T21:17:16Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "My proposal is to leave routing up to the application and CDN. Frankly it's just too difficult to prescribe anything.\r\n\r\nA URL schema could be justified (ex. emitter domain in first part of the path) but I don't think it's sufficient to replace application-defined routing.",
          "createdAt": "2023-04-01T05:52:59Z",
          "updatedAt": "2023-04-01T05:56:43Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I concur on leaving routing within a distribution network (CDN) up to the CDN. CDNs will compete on how to best route MoQ traffic and that optimality is a function of their network topology, network resources (memory, compute, connectivity) and competing loads. It is dynamic in nature and different for each network. \r\n\r\nWhat MoQ does need to standardize are consistent identification, addressing and authorization schemes for content, as well as propagation of prioritization intent. The routing itself should be left to the deploying entities. ",
          "createdAt": "2023-04-04T16:20:18Z",
          "updatedAt": "2023-04-04T16:20:18Z"
        },
        {
          "author": "acbegen",
          "authorAssociation": "NONE",
          "body": "There are many other things that might affect the routing decisions and we cannot possible describe all the possible ways or the best way of doing it. So, yes, this responsibility falls to the CDNs - not MOQ WG.",
          "createdAt": "2023-04-07T11:14:35Z",
          "updatedAt": "2023-04-07T11:14:35Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agree - what we need to have in MoQ is simply the info that CDN need to determine routing. From a requirements point of view I think that means: info to authorize and bill for a pub or sub. For pub, the upper bound on the desired time to live of for the object. Of course the CDN might kill the object much sooner but if they are billing for storage, it is nice for the client to set an upper bound. ",
          "createdAt": "2023-04-07T19:51:27Z",
          "updatedAt": "2023-04-07T19:51:27Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "The Announce proposal (#150 / #123) is related to this issue.  I don't think it's intended to replace intra CDN routing, inter-CDN routing or CDN-to-static-origin routing, but attempts to solve the distributed publishing/dynamic origin case.",
          "createdAt": "2023-05-05T20:11:59Z",
          "updatedAt": "2023-05-05T20:11:59Z"
        },
        {
          "author": "nikolay167",
          "authorAssociation": "NONE",
          "body": "Hey!\r\n\r\nWe are a CDN provider, And we also have support of QUIC.\r\n\r\nIf want to test anything dont hesistate to let me know :)",
          "createdAt": "2023-05-09T19:28:42Z",
          "updatedAt": "2023-05-09T19:28:42Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We seem to be on agrement on this and matches the daft. Can we close it ?",
          "createdAt": "2023-05-20T23:01:36Z",
          "updatedAt": "2023-05-20T23:01:36Z"
        }
      ]
    },
    {
      "number": 131,
      "id": "I_kwDOG2Ho4M5i5bBa",
      "title": "Overhead for audio only conference ",
      "url": "https://github.com/moq-wg/moq-transport/issues/131",
      "state": "OPEN",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "NotTransport"
      ],
      "body": "We need to work to get the number of bytes sent for a use case like clubhouse to relatively efficient. ( I am thinking something similar to RTP ) \r\n\r\n",
      "createdAt": "2023-04-07T21:29:02Z",
      "updatedAt": "2023-11-10T12:44:15Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I marked this NotTransport because I don't believe this is a transport issue.  Unless this is an issue implying moq-transport should support datagrams, in which case let's say so explicitly.",
          "createdAt": "2023-10-16T23:51:51Z",
          "updatedAt": "2023-10-16T23:51:51Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> I marked this NotTransport because I don't believe this is a transport issue. \r\n\r\n+1\r\n\r\n> Unless this is an issue implying moq-transport should support datagrams, in which case let's say so explicitly.\r\n\r\nDatagrams would slightly increase the overhead actually, since QUIC can coalesce multiple STREAM frames into a single packet.",
          "createdAt": "2023-10-17T04:10:06Z",
          "updatedAt": "2023-10-17T04:10:06Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment:\r\n\r\n+1 that this measurement is very useful, an interested party asked me for the same.  \r\n\r\nCan we assign someone who is able to send audio over moqt-01 (perhaps @suhasHere or @jordicenzano) to compute the current overhead with their implementation?  This data may inform further work we need to do.",
          "createdAt": "2023-11-10T12:44:14Z",
          "updatedAt": "2023-11-10T12:44:14Z"
        }
      ]
    },
    {
      "number": 132,
      "id": "I_kwDOG2Ho4M5jAPps",
      "title": "Add support for unsubscribe on tracks",
      "url": "https://github.com/moq-wg/moq-transport/issues/132",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "suhasHere"
      ],
      "labels": [
        "Implementation Blocker",
        "Needs Discussion"
      ],
      "body": "As pointed about by @afrind  https://github.com/kixelated/warp-draft/pull/122#discussion_r1160819780, it useful to have explicit unsubscribe on tracks. \r\n\r\nThis will come in handy across these flowsl\r\n1. Client has subscribes to HD quality and it wants to get to SD quality and is not interested in HD quality anymore\r\n2. Client is no longer interested in certain tracks being published and wants to unsubscribe only those tracks\r\n",
      "createdAt": "2023-04-10T16:06:20Z",
      "updatedAt": "2023-10-16T21:00:55Z",
      "closedAt": "2023-10-16T21:00:55Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "+1",
          "createdAt": "2023-04-10T17:36:07Z",
          "updatedAt": "2023-04-10T17:36:07Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just to add details from the call. I heard people say we needed all of:\r\n\r\n1. Way for server or relay to end a subscription and let the client know \r\n2. Way for the client to end \r\n\r\nI will add in a slight detail that when we do get around to adding this to the draft, we want to consider the sequencing of ending a subscription and starting a new one. If a client is subscribed to HD and wants to move down to SD for lack of bandwidth reasons, we do not want a situation where both HD and SD are being sent for extended times during the transition. ",
          "createdAt": "2023-04-22T14:20:42Z",
          "updatedAt": "2023-04-22T14:20:42Z"
        },
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "+1. Client should be able to end the subscription of a track.",
          "createdAt": "2023-06-05T06:07:32Z",
          "updatedAt": "2023-06-05T06:07:32Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So to start discussion on this ....\r\n\r\nif A subscribes to B, we need a few things:\r\n1) a way for A to stop that subscription B\r\n2) a way for B to stop the subscription \r\n\r\nWhat I don't want is if A makes a single subscribes to B for a specific set of objects, to be able to unsubscribe for some of those objects but not all. If A wants to that, it needs to end stop the first subscription and at same time start a new subscription for the subset of objects. \r\n\r\n",
          "createdAt": "2023-07-27T21:23:48Z",
          "updatedAt": "2023-07-27T21:23:48Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Going to flag this as a blocker because you can't implement any basic media functionality without it (ex. ABR, pausing, track selection).",
          "createdAt": "2023-08-07T21:45:06Z",
          "updatedAt": "2023-08-07T21:46:56Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Proposal mirror QUIC's `STOP_SENDING`.\r\n\r\n```\r\nSUBSCRIBE_STOP Message {\r\n  track_id (i),\r\n  error_code (i)\r\n}\r\n```\r\n\r\nThis assumes the receiver chooses the `track_id` to fix #145. Otherwise, there's a race condition pending receipt of `SUBSCRIBE_OK` so you need the full name:\r\n```\r\nSUBSCRIBE_STOP Message {\r\n  track_namespace (b),\r\n  track_name (b),\r\n  error_code (i)\r\n}\r\n```\r\n\r\nThe sender would still need to issue a `SUBSCRIBE_ERROR` to officially terminate the subscription, mirroring QUIC's `RESET_STREAM` and effectively acting as an acknowledgement. Otherwise it's not valid to issue an identical `SUBSCRIBE` (ex. reusing the `track_id`) until this message is received otherwise as it causes race conditions (can elaborate). I personally don't think we should reuse IDs anyway (mirroring QUIC stream IDs) but again that clashes with the desire to use consistent IDs as mentioned in #145.\r\n\r\nThe error code is somewhat useless in `SUBSCRIBE_STOP` just like `STOP_SENDING`, but it might be useful for some applications. It's mostly there to be echoed by the `SUBSCRIBE_ERROR`. I'm perfectly fine removing this error code and registering a \"cancelled by peer\" code instead.",
          "createdAt": "2023-08-07T22:08:30Z",
          "updatedAt": "2023-08-07T22:10:28Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> if A subscribes to B, we need a few things:\r\n> \r\n> 1. a way for A to stop that subscription B\r\n> 2. a way for B to stop the subscription\r\n\r\nAs proposed above:\r\n1. A issues `SUBSCRIBE_STOP`, causing B to issue `SUBSCRIBE_ERROR` with the provided error code.\r\n2. B issues `SUBSCRIBE_ERROR`.",
          "createdAt": "2023-08-07T22:13:11Z",
          "updatedAt": "2023-08-07T22:13:11Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "#203 has a on going discussions that are closely related to the general issue... copying the text for reference here\r\n\r\n\r\nWe need few things in general between announcements and subscriptions\r\n\r\n1. Cease the announcement\r\n\r\n```\r\nANNOUNCE_CEASE {\r\n  Track Namespace\r\n   ....\r\n}\r\n```\r\n\r\nThis is an explicit signal from the publisher that it is no longer interested \r\nin sending media for the announced tracks.  This is sent to the relay to trigger subscription cancellation downstream and clean up local relay state.\r\n\r\n2. Terminate the Subscription\r\n\r\n```\r\nSubscribe Terminate {\r\n  Track Namespace\r\n   Reason { ..... }\r\n}\r\n```\r\nSubscribe Terminate can be sent to indicate the subscription is stopping and  each receiving entity will forward the same to downstream and clean up local subscription state. If it is the consumer, it stop media pipeline and so on.\r\n\r\n\r\n3. Unsubscribe\r\nFor subscribers to explicitly indicate that they are no longer interested in a given track , they will send\r\n\r\n```\r\nUnscubscribe {\r\nTrack Namespace\r\n....\r\n}\r\n```\r\n\r\nHere is some flows on the same https://github.com/moq-wg/moq-transport/issues/203#issuecomment-1659553999",
          "createdAt": "2023-08-08T05:30:31Z",
          "updatedAt": "2023-08-08T07:07:37Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "UNSUBSCRIBE / UNANNOUNCE is in the draft now, and we're going to add a SUBSCRIPTION END/FIN (#203).  \r\n\r\n@suhasHere Can this be closed?",
          "createdAt": "2023-10-11T18:28:27Z",
          "updatedAt": "2023-10-11T18:28:27Z"
        }
      ]
    },
    {
      "number": 133,
      "id": "I_kwDOG2Ho4M5jAVHR",
      "title": "Add support for specifying start point for Subscription",
      "url": "https://github.com/moq-wg/moq-transport/issues/133",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "suhasHere"
      ],
      "labels": [],
      "body": "Allowing a way to specify the start point ( right group number and object number) will allow subscriptions to support use-case such as\r\n- Catch up from the right place in the track\r\n- Replay from a specific point in the track\r\n\r\nThis will be a follow up to #122 ",
      "createdAt": "2023-04-10T16:26:39Z",
      "updatedAt": "2023-05-05T20:06:05Z",
      "closedAt": "2023-05-05T20:06:05Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for listing some use-cases. I agree that an optional group ID would be good in the SUBSCRIBE message.\r\n\r\nI'm not sure that including an object ID is necessary though. It miiight be useful if a connection is severed half-way through a group, but that seems very fringe. Are there other use-cases or can we punt it for now?",
          "createdAt": "2023-04-10T17:35:40Z",
          "updatedAt": "2023-04-10T17:35:40Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "duplicate of #111",
          "createdAt": "2023-04-10T19:51:47Z",
          "updatedAt": "2023-04-10T19:51:47Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "SUBSCRIBE REQUEST has parameters that allow the receiver to specify the start point.",
          "createdAt": "2023-05-05T20:06:05Z",
          "updatedAt": "2023-05-05T20:06:05Z"
        }
      ]
    },
    {
      "number": 136,
      "id": "I_kwDOG2Ho4M5j3x5P",
      "title": "Messages during handshake",
      "url": "https://github.com/moq-wg/moq-transport/issues/136",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Handshake"
      ],
      "body": "It's unclear what messages are allowed to be sent or received during the SETUP handshake. Here's my intuition:\r\n\r\nUntil receiving the SETUP, the **client**:\r\n1. MUST NOT send messages\r\n2. MUST buffer any received messages.\r\n\r\nUntil receiving the SETUP, the **server**:\r\n1. MUST NOT send messages.\r\n2. MUST NOT receive messages.\r\n\r\nThe client needs to buffer messages because the server is unaware of when the client receives the SETUP. There's no equivalent to HANDSHAKE_DONE, and adding something like that would add an RTT anyway.",
      "createdAt": "2023-04-19T20:18:08Z",
      "updatedAt": "2023-11-07T13:16:41Z",
      "closedAt": "2023-11-07T13:16:41Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "A potential optimization exists if the message encoding if the same for all supported versions (invariants). For example, if the client only advertises support for versions 1,2,3 and those versions share the same SUBSCRIBE encoding and meaning. This seems unlikely, given a separate version was created in the first place, and seems very brittle.\r\n\r\nIf this was the case, then the client could process any invariant messages immediately and buffer the others. However, the client still couldn't send messages unless the server buffered any received messages.",
          "createdAt": "2023-04-19T20:26:00Z",
          "updatedAt": "2023-04-19T20:26:00Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "The most flexible optimization would be the one where you could encode the SUBSCRIBE_REQUEST for every version you offer as a field in SETUP parameters.  TLS does not do exactly that, but there are some things in ClinetHello that are only applicable for certain versions.",
          "createdAt": "2023-04-20T02:20:56Z",
          "updatedAt": "2023-04-20T02:20:56Z"
        }
      ]
    },
    {
      "number": 137,
      "id": "I_kwDOG2Ho4M5j37N5",
      "title": "Control message ordering",
      "url": "https://github.com/moq-wg/moq-transport/issues/137",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "ianswett"
      ],
      "labels": [
        "Control Streams"
      ],
      "body": "The current draft specifies that control messages may be sent over separate streams. This means that control messages will arrive in an unknown order.\r\n\r\nThis can create divergent behavior if messages depend on any form of ordering. The simplest example if sending a SUBSCRIBE message followed by a later UNSUBSCRIBE message on a separate stream. If the UNSUBSCRIBE arrives first for whatever reason (packet loss or poor prioritization), then it has a completely different meaning.\r\n\r\nThe current draft adds some advisory text that control messages should be on the same stream if ordering is required. I think we should put all control messages on the same stream, so ordering is enforced and the behavior is deterministic.",
      "createdAt": "2023-04-19T20:45:47Z",
      "updatedAt": "2023-10-16T17:19:06Z",
      "closedAt": "2023-10-16T17:19:06Z",
      "comments": [
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think life will be way easier if all control messages are reliable and in order. So +1 on single control stream. \r\n\r\nOne of my arguments for this is the difficulty in even testing our of order control messages. ",
          "createdAt": "2023-04-28T15:59:10Z",
          "updatedAt": "2023-04-28T15:59:10Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Will be fixed by the PR that fixes #138 ",
          "createdAt": "2023-10-09T16:24:11Z",
          "updatedAt": "2023-10-09T16:24:11Z"
        }
      ]
    },
    {
      "number": 138,
      "id": "I_kwDOG2Ho4M5j37ma",
      "title": "Proposal: Control and data streams",
      "url": "https://github.com/moq-wg/moq-transport/issues/138",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "ianswett"
      ],
      "labels": [
        "Needs PR",
        "Control Streams"
      ],
      "body": "### Current\r\nThe client creates a bidirectional stream and sends the SETUP message. The server replies with its own SETUP message on the same stream. Afterwards, both endpoints can create any number of unidirectional streams containing any non-SETUP messages.\r\n\r\n### Problems\r\n- #105 Messages with different priorities should not be mixed in the same stream, which means control messages should never be mixed with data messages.\r\n- #136 Messages can't be sent or have to be buffered until the receipt of the SETUP message.\r\n- #137 Control messages over separate streams arrive in an unknown order.\r\n\r\n### Proposed\r\n- The client creates a single bidirectional control stream. The control stream MUST start with a SETUP message, followed by any number of control messages (ex. SUBSCRIBE).\r\n- The sender creates unidirectional data streams. The data streams MUST only contain OBJECT messages.\r\n\r\n**Pros**:\r\n- Partially fixes #105. Control messages are no longer intermingled with with data messages, and the control stream MUST always be the highest priority.\r\n- Fixes #136. Endpoints no longer have to buffer messages, as QUIC will automatically make sure SETUP arrives before any other control messages. Data streams MUST NOT be created until receipt of SETUP.\r\n- Fixes #137. Control messages arrive in a specified, deterministic order.\r\n\r\n**Cons**:\r\n- Head-of-line blocking between control messages, which sometimes may not be desired.",
      "createdAt": "2023-04-19T20:46:59Z",
      "updatedAt": "2023-10-16T17:19:05Z",
      "closedAt": "2023-10-16T17:19:05Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "> The sender creates unidirectional data streams\r\n\r\nWhile I was reading the requirements draft, I found some use cases mentioning bidirectionality.  Is it expected/supported that there can be data flowing in both directions (eg: a p2p call)?",
          "createdAt": "2023-04-19T21:06:54Z",
          "updatedAt": "2023-04-19T21:06:54Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> > The sender creates unidirectional data streams\r\n> \r\n> While I was reading the requirements draft, I found some use cases mentioning bidirectionality. Is it expected/supported that there can be data flowing in both directions (eg: a p2p call)?\r\n\r\nYeah, my intent is that there's a \"sender\" and a \"receiver\" per track. The ROLE param in the SETUP message indicates if an endpoint (client/server) intends to send tracks, receive tracks, or both.\r\n\r\nIn the bidirectional case, both endpoints would say ROLE=BOTH. Then they could independently PUBLISH or SUBSCRIBE to tracks.\r\n\r\nAlternatively, we could say that tracks may be bidirectional... but I don't think that makes any sense.",
          "createdAt": "2023-04-19T21:29:49Z",
          "updatedAt": "2023-04-19T21:29:49Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We can simply say that data objects MUST NOT be sent over control streams, and remove any reference to whether data streams should be unidirectional or bidirectional. It doesn't matter and we can leave it to the end-points discretion. ",
          "createdAt": "2023-04-21T00:11:12Z",
          "updatedAt": "2023-04-21T00:11:12Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "The proposal above aligns pretty well with the idea in #96 , more specifically this [section ](https://github.com/kixelated/warp-draft/blob/7bb5ee97309d6dbd98818d02c833981686476305/draft-lcurley-warp.md#control-and-data-channels)\r\n\r\nI like the separation of control stream and data streams, the latter being unidirectional streams.\r\n",
          "createdAt": "2023-04-21T06:14:00Z",
          "updatedAt": "2023-04-21T06:15:10Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like the proposal for this.  \r\n\r\nI view the HOL blocking of control messages a feature not a bug. More specifically, I think that some of our messages need to be delivered in order. Specifically if a client is trying to stop and high res video subscription and start a low res subscription, it would be good to ensure that the subscribe to the low res track does not happen until after the end the end subscription to the high res track has happened.  Sending the un-subscribe then subscribe on one quic stream allows these to be sent and same time to server ( we don't need a round trip between them ) but still be delivered in order. \r\n\r\nI think it needs to be clear that multiple control messages can be outstanding at once. For example can send multiple subscribes before getting the response to the first subscribe. ",
          "createdAt": "2023-04-22T15:34:14Z",
          "updatedAt": "2023-04-22T15:34:14Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> The proposal above aligns pretty well with the idea in #96 , more specifically this [section ](https://github.com/kixelated/warp-draft/blob/7bb5ee97309d6dbd98818d02c833981686476305/draft-lcurley-warp.md#control-and-data-channels)\r\n> \r\n> I like the separation of control stream and data streams, the latter being unidirectional streams.\r\n\r\nI would like to write up a PR based on the above ( basically resurrecting #96) that pertains to the control channels.  ",
          "createdAt": "2023-07-06T04:05:42Z",
          "updatedAt": "2023-07-06T04:05:42Z"
        },
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "I like the idea of seperation of control stream and data stream.",
          "createdAt": "2023-07-06T07:18:49Z",
          "updatedAt": "2023-07-06T07:18:49Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "WG is ok with a single stream, with no critical use cases for multiple.\r\n\r\nA single stream makes it easier to change bitrates 'atomically'.\r\n\r\nPeople don't want Object messages allowed on the same stream as control messages.\r\n\r\nPeople noted that this means the only bidi stream is used for the control stream in practice, and all unidirectional streams are used for objects, but people don't want to bake that into the spec.\r\n",
          "createdAt": "2023-10-05T20:25:05Z",
          "updatedAt": "2023-10-05T20:25:05Z"
        }
      ]
    },
    {
      "number": 139,
      "id": "I_kwDOG2Ho4M5j-NtP",
      "title": "Need to specify object priorities as an alternative to send order",
      "url": "https://github.com/moq-wg/moq-transport/issues/139",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The current draft proposes that the transmission of objects be controlled by a \"send order\" (a.k.a. delivery order) property. This is very questionable, because the complete ordering using a send order property is only one of the plausible solutions for managing transmission. Other solutions are possible, and may result in better management of multiple tracks. For example, allocating priorities to layers in a layered encoding scheme allows both ordering of objects within a track and relative ordering of objects between tracks, without requiring fine grained coordination between the publishers of different tracks. I think that this has to be resolved before adoption by the working group.\r\n\r\nI have discussed this topic privately with Suhas and then with Luke. I understand why Luke was initially pushing for the \"send order\" approach: it feels simpler than trusting relays to apply the right logic based on multiple parameters. But it is essentially a compressed encoding of a set of different properties, such as relative sending order of tracks, layers, groups, and object order within a group, with questions such as:\r\n\r\n* if several video tracks are competing, should the choice to keep just the 720p layer or also try the 1080p layers be coordinated among tracks?\r\n* Within a track, should a new group take complete precedence over the previous group? Or should the relay finish sending the 720p layer of the old group before starting the 1080p layer of the new group?\r\n* Within a track, should there be some kind of timeout between groups, such as stop sending anything from group 5 if it is more than 200ms behind group 6? Or is that 2 seconds? Or 0 ms? \r\n\r\nWith just a send order property, it is indeed possible to create a single send order for a bundle of tracks, but that requires coordination between the emitters of the tracks. The typical policy will also require some gymnastic with numbers: object with higher group IDs should typically be sent before objects with lower group ID, but within a group objects with lower group IDs should be sent first. If we follow the \"lower send order first\" convention, we end up encoding the send order as:\r\n\r\nlayer priority | max_group_number - group_number | object_number_within_group\r\n---- | ---- | ----\r\n\r\nThis kind of ordering requires allocating enough bits to each component, which means knowing in advance the maximum number of groups within a session and the maximum number of objects within a group. For real time applications, this is problematic, because the session time is not bounded. It also feels redundant, as we already encode the group-id and the object-id as properties of each object. Attaching a layer prority to the object feels simpler than trying to jam it into a single send order property. (We would also save 3 or 4 bytes per packet, which is nice even if not a big priority.)\r\n\r\nWhen multiple tracks compete, specifying a send order across tracks is harder, if only because we cannot assume that group numbers are allocated consistently across multiple tracks. Typically, we would want something like:\r\n\r\n* consistent priority marking across tracks in a bundle\r\n* send highest priority objects first, but do round robin allocation between tracks at a given priority level\r\n* use group number and object number to select the next object to transmit within a track.\r\n\r\nThe \"round robin\" part is quite hard to do with a single \"send order\". It might be possible if a single emitter sends all tracks within a bundle, but we cannot make that hypothesis for real time conferences, with multiple participants each contributing a couple of tracks. Yet we would want the \"bundle\" to group all tracks within the conference, so that for example participants can obtain all the tracks except their own through a single QUIC connection. In contrast, the \"round robin within a priority level\" is trivially implemented if a track is mapped to a set of streams, with one stream per group and priority layer. \r\n\r\nBottom line: we need an option to encode a priority number per object -- we might also call it a layer number. That should an alternative to encoding a send order.",
      "createdAt": "2023-04-20T18:59:13Z",
      "updatedAt": "2023-05-26T23:24:11Z",
      "closedAt": "2023-05-26T23:24:10Z",
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "This is something that was discussed at IETF116 about prioritization schemes.  It would help to document sendOrder , object priorities based schemes and commentary that spells the pros/cons like above as part of Section 7 for draft-05.\r\n\r\nThis will give WG a single place to start looking at the options being discussed, follow and contribute as we develop these  further.\r\n\r\nI would also like to note that, layer number is fine, however it might be better if its called more generic that is applicable across media types.",
          "createdAt": "2023-04-21T04:59:03Z",
          "updatedAt": "2023-04-21T06:41:44Z"
        },
        {
          "author": "hardie",
          "authorAssociation": "COLLABORATOR",
          "body": ">\n> Bottom line: we need an option to encode a priority number per object --\n> we might also call it a layer number. That should an alternative to\n> encoding a send order.\n>\n\n(personal hat on)\n\nDuring the discussions in Japan, I thought I heard support for introducing\na metavariable here; essentially, a way for a track to carry the\ninformation about the type of ordering used within the track and for the\ntrack bundle to indicate how the overarching priority among tracks should\nbe handled.  The approach of using per track ordering types allows us to\nadapt in the future if there are new types of media (e.g. AR/VR) with\nfundamentally different types of priority.  A registry of those would allow\nboth relatively simple priorities and complex ones to coexist.\n\nI confess I didn't actually understand how to construct a useful track\nbundle priority scheme without a great deal of complexity.  There are some\nsimple versions (prioritizing audio over video, for example) that work with\njust an ordered list of the tracks, but there are lots of others where\ngetting a useful answer starts to look like it requires a turing-complete\nsyntax. Introducing a second metavariable here might allow us to punt the\nproblem down the road a bit, by letting us do the simple ordered track type\nnow as an exemplar, but push the more complex version down the road.  I\nworry if we do that, though, that we will start to see a very early split\nin client capabilities which will dim the usefulness of the overall system.\n\n(personal hat off)\n\n(chair hat on)\n\nIn general, I don't think the document needs to solve this problem at this\npoint; it can describe the problem and list it as an item to be determined\nby the working group during the course of the work.  For document adoption,\nthis doesn't need to be done.\n\n(chair hat off)\n\n> Message ID: ***@***.***>\n",
          "createdAt": "2023-04-21T10:49:32Z",
          "updatedAt": "2023-04-21T10:49:32Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@hardie just to confirm, having the options (sendOrder/object priorities) for prioritization schemes listed in one place will be beneficial for adoption since it gives sufficient starting place to start thinking about challenges in supporting unified use-cases and why these options exists.\r\n\r\nI personally believe this will help with driving inputs from both sides of the aisle.",
          "createdAt": "2023-04-21T14:10:48Z",
          "updatedAt": "2023-04-21T14:16:29Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\r\nTed, I understand your concern about not delaying adoption until every aspect of the proposal gets consensus. If we did that, we would never adopt. But if we do adopt with the proposed \"send order\" text, we enshrine a proposal that does not actually work for the \"real time conference\" scenarios. If we want fast adoption, then we should leave the whole point of scheduling and ordering as TBD, and remove from the draft the text about \"send order\".\r\n\r\nMy point is that for the common case of multiple senders using the same software, the \"priority\" scheme works much better than the proposed \"send order\" scheme. To approximate the desired property of \"round robin between senders\", the relatively simple ordering by:\r\n\r\nlayer priority | max_group_number - group_number | object_number_within_group\r\n-- | -- | --\r\n\r\n... does not work, because different tracks of equal priority may very well have different group numbering. A track that restarts groups frequently will end up with higher group numbers, and thus will be send before the other tracks. This might be compensated somewhat by computing the priority based on the time stamp of the start of the group:\r\n\r\nlayer priority | max_time_stamp - group_time_stamp | object_number_within_group\r\n-- | -- | --\r\n\r\n... but even with that, the track that restarts groups often will still end up with better service share than the other tracks. \r\n\r\nOne solution might be to use a time stamp per object, but that does not work well because our desire that objects within the same track and the same layer be sent in order. On the other hand, the solution of having streams per groups and layers is easy to implement and solve most of the problem -- although more work is needed for handling smooth transitions between groups.\r\n\r\nSo, yes, I would be fine with either having two documented alternatives, or just removing the send order text.\r\n\r\n\r\n",
          "createdAt": "2023-04-21T15:01:45Z",
          "updatedAt": "2023-04-21T15:01:45Z"
        },
        {
          "author": "hardie",
          "authorAssociation": "COLLABORATOR",
          "body": "On Fri, Apr 21, 2023 at 4:01\u202fPM Christian Huitema ***@***.***>\nwrote:\n\n> Ted, I understand your concern about not delaying adoption until every\n> aspect of the proposal gets consensus. If we did that, we would never\n> adopt. But if we do adopt with the proposed \"send order\" text, we enshrine\n> a proposal that does not actually work for the \"real time conference\"\n> scenarios. If we want fast adoption, then we should leave the whole point\n> of scheduling and ordering as TBD, and remove from the draft the text about\n> \"send order\".\n>\n\nThat's basically what I meant by \"it can describe the problem and list it\nas an item to be determined by the working group during the course of the\nwork.\"  Whether it leaves one or both proposals in at the moment, it needs\nto note that this will be decided by the working group; either or both can\nget marked as \"a proposal for X is\".  It just needs to be clear that the\nhigh order bit is \"TBD\".\n\nregards,\n\nTed\n\n\n\n\n> My point is that for the common case of multiple senders using the same\n> software, the \"priority\" scheme works much better than the proposed \"send\n> order\" scheme. To approximate the desired property of \"round robin between\n> senders\", the relatively simple ordering by:\n> layer priority max_group_number - group_number object_number_within_group\n>\n> ... does not work, because different tracks of equal priority may very\n> well have different group numbering. A track that restarts groups\n> frequently will end up with higher group numbers, and thus will be send\n> before the other tracks. This might be compensated somewhat by computing\n> the priority based on the time stamp of the start of the group:\n> layer priority max_time_stamp - group_time_stamp\n> object_number_within_group\n>\n> ... but even with that, the track that restarts groups often will still\n> end up with better service share than the other tracks.\n>\n> One solution might be to use a time stamp per object, but that does not\n> work well because our desire that objects within the same track and the\n> same layer be sent in order. On the other hand, the solution of having\n> streams per groups and layers is easy to implement and solve most of the\n> problem -- although more work is needed for handling smooth transitions\n> between groups.\n>\n> So, yes, I would be fine with either having two documented alternatives,\n> or just removing the send order text.\n>\n> \u2014\n> Reply to this email directly, view it on GitHub\n> <https://github.com/kixelated/warp-draft/issues/139#issuecomment-1517966894>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAKVXZB5D5ITM3A3XX3HP4DXCKOOJANCNFSM6AAAAAAXF4754U>\n> .\n> You are receiving this because you were mentioned.Message ID:\n> ***@***.***>\n>\n",
          "createdAt": "2023-04-21T15:31:11Z",
          "updatedAt": "2023-04-21T15:31:11Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "My inclination will be \"either we should document both the alternatives as experimental or none\" to avoid confusions for WG members reading and willing to contribute. No matter what path we pick, totally agree,  its all will be still under a banner of TBD ",
          "createdAt": "2023-04-21T16:14:49Z",
          "updatedAt": "2023-04-21T16:25:29Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think there are some key things we agreed on in Japan.  \r\n\r\n1) The issue of which packet to send next is largely the same for clients and relays and we should describe this in one place in the moq-transport draft client section and point at it the relay section along with any parts that were somehow different for relays\r\n\r\n2) We should describe the process in a very algorithmic way \r\n\r\n3) all the information used by the algorithm needs to be available to the relay from the object information \r\n\r\nI don't think we should have the draft be a blank sheet of paper on this because it is hard to understand how anything works without a place holder for this. I think we should write up two proposals for this in the draft then mark it as TBD to choose one.  \r\n\r\n(I'm actually hopeful that when they are both written down, I can convince people that the huitema proposal meets the needs best and we can all get behind that one but I am fine adopting the a draft with two proposal and no decision between the two. )",
          "createdAt": "2023-04-22T14:44:04Z",
          "updatedAt": "2023-04-22T14:44:04Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As a note on max group size.... \r\n\r\nSurveillance cameras produce video for years on the same session at high frame rates and short GOP sequences. \r\n\r\nIt is common for \"video conferences\"  between ops control rooms to run for many days. Teams do things like just stand up a permanent video call between two conferences rooms they use to work in. \r\n\r\nIt might be possible to come up with some logic for group numbers wrapping so we did not need as many bits. ",
          "createdAt": "2023-04-22T14:47:23Z",
          "updatedAt": "2023-04-22T14:47:23Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just for info, I keep this little table relating the frequency of a signal to the number of bits required to encode it, and specifically the maximum duration of a QUIC connection:\r\n\r\nBits used in groups | Video (conf) | Video (surv) | Audio\r\n-- | -- | -- | --\r\nPeriod(sec) | 30 | 2 | 0.02\r\nFrequency (Hz) | 0.033 | 0.5 | 50\r\nBeats per minute | 2 | 30 | 3000\r\nBeats per hour | 120 | 1800 | 180000\r\nBeats per day | 2880 | 43200 | 4320000\r\nBeats per year | 1051920 | 15778800 | 1577880000\r\nbits for one\u00a0 year | 20.005 | 23.911 | 30.555\r\nbits for one century | 26.648 | 30.555 | 37.199\r\nMinutes for 6 bits | 32 | 2.1 | 0.021\r\nHours for 14 bits | 137 | 9 | 0.091\r\nYears for 30 bits | 1021 | 68 | 0.680\r\nYears for 62 bits | 4.4E+12 | 2.9E+11 | 2.9E+09\r\n\r\nThe QUIC varint format can encode 62 bit numbers, which are quite bit. We may have an overhead problem, but as far as group are concerned we do not have a capacity problem. The main concern is for mixing audio in this scheme -- 50 frames per second, one frame per group.\r\n\r\nIn the high definition video cases, the QUIC connection will become limited by the \"max data\" parameter of QUIC flow control, which would reach 2^62 after about 300,000 years. That's not a huge concern.\r\n\r\nTo go back to compact encoding of priorities in a single \"send order\". To accommodate the \"decreasing value\" logic, if the connection is up for a century, we probably will want to set the \"max group\" value to something like 40 bits. Not very compact, but that means an 8 bytes varint property for every object.",
          "createdAt": "2023-04-22T15:29:50Z",
          "updatedAt": "2023-04-22T15:44:44Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "From my reading the discussion, I do agree with some hacks or provisions, we can solve the max group size problem. but I would like to take a step back and see are we trying to solve a problem which may cease to exist depending on the approach",
          "createdAt": "2023-04-22T18:09:14Z",
          "updatedAt": "2023-04-22T18:09:14Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we have some kind of rough consensus on the following algorithm\r\n\r\n1) priorities or ordering only works across multiple tracks if these tracks are part of the same \"bundle\". That's actually pretty much the definition of the bundle concept: a set of tracks that have been composed so the nodes can send them in a coordinated way. \r\n\r\n2) within a bundle, we expect a coordinated handling of priorities or lawyers. In layered encoding, we always have a partial ordering of layers within a track (in the mathematical sense of partial ordering, i.e., a tree of dependencies, not a straight line). The partial ordering can be transformed into a complete ordering by imposing application preferences such as \"frame rate first\" or \"definition first\". Once we have a complete ordering of layers within a track, we can assume that coordinated emitters can do a coordinated assignment of priorities to layers, so that these priorities can be applied across multiple tracks.\r\n\r\n3) Within a track, we have multiple groups. Within a group, we have multiple layers. Layers with \"highest priority\" should always be sent before layers with lower priority. The priority values are typically set to \"lower priority number first\", as in PRI-0 before PRI-1, PRI-2 before PRI-3, etc.\r\n\r\n4) Within a track, a group and a layer, we assume newer objects have dependencies on older objects. The consensus here is a bit rough, because some coding schemes allow for \"restart points\", such as \"PRI-2 frames only have dependency to other PRI-2 frames sent after the PRI-2 restart point\". This will probably be debated further as we gain experience. For now, we can simply assume that objects can only have dependencies on \"object in the same group sent before on the same layer or on high priority layers\".\r\n\r\n4) Within a track, we have a rough consensus that objects in the next group shall be sent before objects in the previous group. This is only a rough consensus, because there are situations when waiting for the previous group to complete results in better experience. But we could take that as a starting point for now.\r\n\r\n5) We cannot assume that group numbers are allocated in a coordinated way across tracks. Given that, we cannot assume that group numbers can be used to set the relative priority of objects belonging to different tracks.\r\n\r\nOur challenge is to define a scheduling algorithm that works with these constraints and produces the expect results in a deterministic way. The algorithm may combine assigning objects to streams, which guarantees that objects on the same stream will be received in order. The algorithm may assume assigning priorities or send orders to streams, which guarantees that higher priority streams will be sent before lower priority ones. The algorithm may say something about what to do with streams of same priority, i.e., use FIFO, or Round Robin, or maybe weighted round robin, depending on what the stack supports.",
          "createdAt": "2023-04-22T18:51:47Z",
          "updatedAt": "2023-04-22T18:51:47Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks Christian, I wonder if we have rough consensus on point 1 above. IIUC, we decided to revisit bundle at IETF 116 because we didn't think that is always possible to ensure that end to end or we need to work out specifics or we can solve this uniformly across tracks with priorities",
          "createdAt": "2023-04-22T23:27:48Z",
          "updatedAt": "2023-04-22T23:46:07Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Ooops, somehow I didn't see this issue until now.\r\n\r\n\r\n> With just a send order property, it is indeed possible to create a single send order for a bundle of tracks, but that requires coordination between the emitters of the tracks.\r\n\r\nI think that's true for any prioritization scheme. There has to be some entity that knows how to coordinate tracks from separate sources. Even a simple rule of audio > video is not true for all tracks, nor does a relay even know if a track is audio or video.\r\n\r\nMaybe a track could choose from a registry of prioritization schemes, but this only works if the tracks from separate sources have have agreed to use the same scheme. And even then, a prioritization scheme that prioritizes newer group IDs only works when tracks have aligned group IDs, which again requires cooperation (ex. same group duration).\r\n\r\n\r\n> 1. priorities or ordering only works across multiple tracks if these tracks are part of the same \"bundle\". That's actually pretty much the definition of the bundle concept: a set of tracks that have been composed so the nodes can send them in a coordinated way.\r\n\r\nYeah exactly. I just don't see how a relay can prioritize tracks unless some entity has coordinated them already.\r\n\r\n\r\n> I confess I didn't actually understand how to construct a useful track\r\nbundle priority scheme without a great deal of complexity.  There are some\r\nsimple versions (prioritizing audio over video, for example) that work with\r\njust an ordered list of the tracks, but there are lots of others where\r\ngetting a useful answer starts to look like it requires a turing-complete\r\nsyntax. Introducing a second metavariable here might allow us to punt the\r\nproblem down the road a bit, by letting us do the simple ordered track type\r\nnow as an exemplar, but push the more complex version down the road.  I\r\nworry if we do that, though, that we will start to see a very early split\r\nin client capabilities which will dim the usefulness of the overall system.\r\n\r\nThat's my thought process too. You start headed down this slippery slope, where you either need a registry of prioritization schemes for every use-case, or you need a turing-complete templating scheme. The more complicated we make it, the more \"correct\" the prioritization scheme becomes.\r\n\r\nUltimately though, relay support is the highest priority for any prioritization scheme (pun intended). Anything even remotely complicated will NOT be adopted by the wider ecosystem (ex. HTTP/2 priorities). I think being \"correct\" in every use-case is never going to be feasible.\r\n\r\nMy solution with send order is to punt the scheming to the entity to creates a bundle, so it's dirt simple for a relay to support. I think there's room in the middle, but I struggle to figure out what that looks like.\r\n\r\n> But if we do adopt with the proposed \"send order\" text, we enshrine a proposal that does not actually work for the \"real time conference\" scenarios. If we want fast adoption, then we should leave the whole point of scheduling and ordering as TBD, and remove from the draft the text about \"send order\".\r\n\r\nI don't understand why send order doesn't work for real-time conferencing scenarios.\r\n\r\nThe formulas you've posted make sense as possible prioritization schemes. When variables are known at encode time (ex. layer, group, object, timestamp, etc), then the send order can be computed by the encoder and written on the wire. If there's a variable that's NOT known at encode time (ex. current wall clock timestamp, queued object count) then we need a formula computed by each relay, but I'm skeptical if those are necessary.\r\n\r\nIt's fair to say that send order makes it difficult for tracks to be muxed, although that's not a problem specific to real-time conferencing.",
          "createdAt": "2023-04-25T22:07:33Z",
          "updatedAt": "2023-04-25T22:07:33Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I thought maybe there's a world where we use send order within a track, and scale/offset that send order between tracks. \r\nYou could write this formula on the wire (gross) so you could mux tracks by adding a new `case` statement. \r\n\r\nFor example:\r\n```\r\nstream.send_order = switch object.track {\r\n  case video: object.send_order / 60\r\n  case audio: 44100 * object.send_order / 1024 + 3s\r\n  case ad: object.send_order / 30 + 6432s\r\n}\r\n```\r\n\r\nBut the muxer still needs very specific information about how send order is computed for each track so it can coordinate them. For example, if:\r\n\r\n```\r\nvideo.send_order = object.group << 24 + object.layer << 16 - object.sequence\r\n```\r\n\r\nUgh then the switch statement above is wrong, because the audio send order needs to be left shifted by 24. The muxer needs to know this formula to interleave send orders, and even then it's extremely difficult to perform this interleaving in the first place. I think this is always going to be a problem, even with a turing-complete templating language. Plus tracks that increase/decrease send order over time are fundamentally incompatible.\r\n\r\n\r\nSo I want to rule out interleaving the priority of uncoordinated tracks. We can only interleave tracks that use compatible prioritization schemes (ie. send order formulas). This is a bundle, and between bundles, we only have the ability to use absolute (video > audio) or relative prioritization (audio = 2x video).",
          "createdAt": "2023-04-25T22:26:57Z",
          "updatedAt": "2023-04-25T22:30:09Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "And frankly, maybe we only need absolute and relative priorities between tracks. I thought I was clever by interleaving the send order between tracks, but I'm unconvinced that it actually makes a significant difference.\r\n\r\nFor example, I was using this at Twitch:\r\n```\r\naudio.send_order = timestamp - 3s\r\nvideo.send_order = timestamp\r\n```\r\n\r\nThe idea was audio is generally more important than video... unless you went through a tunnel for 10s. In which case I would rather deliver the latest video frame instead of audio from more than 3s ago.\r\n\r\nBut I was never able to validate this assumption, and frankly it's such an edge case that it barely matters anyway. Absolute prioritization between audio and video would work just fine. In fact relative prioritization between audio and video (even round-robin) would probably work too, since audio is smaller than video.\r\n\r\nWhat about an absolute priority per track, and send order within each track? A relative priority is more difficult to implement, and frankly relative prioritization is usually wrong. The receiver could signal the track priority in the SUBSCRIBE message.",
          "createdAt": "2023-04-25T22:50:13Z",
          "updatedAt": "2023-04-25T22:52:14Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I was assuming absolute priorities, as in \"audio track has absolute priority P1, 15fps video has P2, 30fps video has P3\". If multiple tracks assign the same priorities the same way, then the corresponding streams are processed in parallel, round-robin way. That could work with user choices as well, as in \"streams in track A have priority P1+X, P2+X, P3+X\", but I really wonder whether we need that kind of complexity.\r\n\r\nThe problem is indeed transitions between groups, which are kind of internal to the track. At some point the relays will have to shed load, which may imply \"reset the streams for the old group if they are not all sent already\". So maybe P1 and P2 are all sent, but P3 is lagging, so some of P3 gets dropped.\r\n\r\nThis works well if there are multiple tracks with the same scheme. They do not have the same group boundaries, so the decision to reset some old track happens at different moments, but the result is still \"P1 and P2 are all sent, but P3 is lagging, so some of P3 gets dropped for all tracks\".",
          "createdAt": "2023-04-26T00:48:13Z",
          "updatedAt": "2023-04-26T00:48:13Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> I was assuming absolute priorities, as in \"audio track has absolute priority P1, 15fps video has P2, 30fps video has P3\". If multiple tracks assign the same priorities the same way, then the corresponding streams are processed in parallel, round-robin way. That could work with user choices as well, as in \"streams in track A have priority P1+X, P2+X, P3+X\", but I really wonder whether we need that kind of complexity.\r\n> \r\n> The problem is indeed transitions between groups, which are kind of internal to the track. At some point the relays will have to shed load, which may imply \"reset the streams for the old group if they are not all sent already\". So maybe P1 and P2 are all sent, but P3 is lagging, so some of P3 gets dropped.\r\n> \r\n> This works well if there are multiple tracks with the same scheme. They do not have the same group boundaries, so the decision to reset some old track happens at different moments, but the result is still \"P1 and P2 are all sent, but P3 is lagging, so some of P3 gets dropped for all tracks\".\r\n\r\nYeah, and you still need the tracks to coordinate with these sorts of prioritization scheme. A track that purposely decides to use P3 will find itself losing bandwidth to a track that does not. This might not be intentional, such as an IPPPPP track accidentally being higher priority than an IBPBPB track because it does not support priority layers.\r\n\r\nBut a track could be higher priority on purpose. I'm thinking the main broadcast track in an NFL broadcast, which would always get bandwidth over the sideline or reaction track. These tracks would have to be intentionally encoded use P4+, aware to the possibility that they will be bundled with the more important broadcast track at some future hop.\r\n\r\nI'm coming around to the belief that tracks from multiple sources being interleaved together is just a recipe for disaster. There's too many assumptions and moving pieces, and the side-effects won't be obvious due to the transient nature of congestion. I think only a single source (or explicitly coordinated sources) can make the sort of prioritization decision required to result in a positive outcome.",
          "createdAt": "2023-04-26T01:51:08Z",
          "updatedAt": "2023-04-26T01:52:15Z"
        },
        {
          "author": "hardie",
          "authorAssociation": "COLLABORATOR",
          "body": "On Wed, Apr 26, 2023 at 1:48\u202fAM Christian Huitema ***@***.***>\nwrote:\n\n> I was assuming absolute priorities, as in \"audio track has absolute\n> priority P1, 15fps video has P2, 30fps video has P3\". If multiple tracks\n> assign the same priorities the same way, then the corresponding streams are\n> processed in parallel, round-robin way. That could work with user choices\n> as well, as in \"streams in track A have priority P1+X, P2+X, P3+X\", but I\n> really wonder whether we need that kind of complexity.\n>\n> (Individual hat on)\n\n\"if multiple tracks assign the same priorities the same way\" is the key\nstatement and the corresponding question is how do you ensure that they\ndo?  There are three choices that are relatively common:  there is always a\nsingle entity per user experience  assigning them and the entity guarantees\nthis ;  there is a single standardized way to make the assignment; or the\nmethod of assignment is chosen from a known set and explicit (e.g. an IANA\nregistry name is in the metadata for the overall set of tracks.)  The other\nmethod we have discussed (templating) makes explicit the different\nassignment mechanisms without registries and with more degrees of freedom\nbut at the cost of a lot of complexity.\n\nMy experience with q-values leads me to believe that people end up treating\npurely ordinal values as if the intervals among the values were fixed,\nwhich is not a guaranteed property of an ordinal list (I got three bids for\nmy prized sow:  1000, 800, 300.  The order is clear, but the intervals are\nnot the same).  I worry that something similar could happen here for\npriorities assigned by different parties but with different implicit\nmeanings.  I think that means we always want an explicit meaning for the\npriority scheme.\n\nTo put this another way:  every party to the exchange should have the same\nunderstanding of how the queues will be serviced based on the priority\nvalues assigned.  I personally think that means a small number of\nregistered schemes, always explicitly called out.  That lets different\nparties assign the priorities with the same understanding (Source A and\nSource B only have to agree on Priority Scheme, not on a more complex\ncoordination), it lets the protocol evolve to use different priority\nschemes for different types of media and/or user experiences, and it lets\nyou see instantly if there is a complex case (Audio tracks from source A\nuse the registered send-order priority while the timed text uses a\nregistered scheme that decays based on clock time).\n\nI don't think we can simplify the use cases to always have a single entity\nassigning the priorities for all tracks, and I am pretty sure we can pick a\nsingle priority method that satisfies everyone.\n\n(reminder, individual hat)\n\n> The problem is indeed transitions between groups, which are kind of\n> internal to the track. At some point the relays will have to shed load,\n> which may imply \"reset the streams for the old group if they are not all\n> sent already\". So maybe P1 and P2 are all sent, but P3 is lagging, so some\n> of P3 gets dropped.\n>\n> This works well if there are multiple tracks with the same scheme. They do\n> not have the same group boundaries, so the decision to reset some old track\n> happens at different moments, but the result is still \"P1 and P2 are all\n> sent, but P3 is lagging, so some of P3 gets dropped for all tracks\".\n>\n> \u2014\n> Reply to this email directly, view it on GitHub\n> <https://github.com/kixelated/warp-draft/issues/139#issuecomment-1522603113>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAKVXZCCRIUQV6ND7XVYFA3XDBWFPANCNFSM6AAAAAAXF4754U>\n> .\n> You are receiving this because you were mentioned.Message ID:\n> ***@***.***>\n>\n",
          "createdAt": "2023-04-26T08:35:42Z",
          "updatedAt": "2023-04-26T08:35:42Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well, we have a classic issue there:\r\n\r\n1) Coordination between tracks is possible, but only between tracks that adhere to the same prioritization logic. \r\n\r\n2) If tracks pretend to be adhering to the logic but don't, the results are unpredictable.\r\n\r\n3) If there are bugs in the logic chosen by the coordinated tracks or its implementation by emitters, the results are unpredictable.\r\n\r\n4) If tracks do adhere to the same logic but the network of relays don't believe them and use their own logic, the results are also unpredictable.\r\n\r\n5) if relays mix track that are not coordinated as if they were, the results are indeed unpredictable.\r\n\r\nIt seems to me that the solution has two components:\r\n\r\n* there is some property of each track stating which prioritization scheme it is using\r\n* there is an authority saying, \"for the purpose of this session, track A, B and C can be mixed using prioritization scheme X\"\r\n\r\n\r\n",
          "createdAt": "2023-04-26T15:37:11Z",
          "updatedAt": "2023-04-26T15:37:11Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As of now, it is pretty clear that we won't quickly get consensus on this subject, and that waiting for that would delay draft adoption too much. I entered PR #149 to state that, and leave the debate unsolved for now.",
          "createdAt": "2023-04-27T20:37:16Z",
          "updatedAt": "2023-04-27T20:37:36Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> As of now, it is pretty clear that we won't quickly get consensus on this subject, and that waiting for that would delay draft adoption too much. I entered PR #149 to state that, and leave the debate unsolved for now.\r\n\r\n#149  is a good starting point on this topic. I think we should get it merged to slow down the adoption",
          "createdAt": "2023-04-27T21:27:13Z",
          "updatedAt": "2023-04-27T21:27:13Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think we should get it merged to slow down the adoption\r\n\r\n@suhasHere : to clarify : did you mean *speed up* the adoption, or you are asking to spend more time on this issue before adoption?",
          "createdAt": "2023-04-27T22:32:41Z",
          "updatedAt": "2023-04-27T22:32:41Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "@huitema : are you OK with closing this now that the DISCUSS has merged?",
          "createdAt": "2023-05-05T20:03:55Z",
          "updatedAt": "2023-05-05T20:03:55Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Both proposals are in the draft.",
          "createdAt": "2023-05-26T23:24:10Z",
          "updatedAt": "2023-05-26T23:24:10Z"
        }
      ]
    },
    {
      "number": 140,
      "id": "I_kwDOG2Ho4M5kAWuG",
      "title": "Supporting a publisher outputting multiple media formats simultaneously",
      "url": "https://github.com/moq-wg/moq-transport/issues/140",
      "state": "OPEN",
      "author": "wilaw",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "NotTransport"
      ],
      "body": "In the current workflow, the client requests a catalog using a reserved name and that catalog specifies which media format it represents using an IANA registered ID. There can only be one catalog, and hence one media format, for a given content bundle. \r\n\r\nWhat happens if the publisher wants to publish content via two different media formats simultaneously? Should we allow this and if so, how can we enable the identification of the formats that are available? \r\n\r\nDoes the client need to be able to ask which formats are available for a given resource before requesting the catalog for that format? \r\n\r\n",
      "createdAt": "2023-04-21T05:05:17Z",
      "updatedAt": "2023-10-17T01:22:28Z",
      "closedAt": null,
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "this issue made me think that we need to define following terms in the transport spec\r\n- media format\r\n- media container format\r\n- catalog format\r\n\r\nI wonder if `meida format` is too generic a term ?",
          "createdAt": "2023-04-21T06:17:50Z",
          "updatedAt": "2023-04-21T06:17:50Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In discussing this with @kixelated we came up with several different solutions\r\n\r\n1. We continue what works for HLS and DASH today, which is that the client knows what format it expects before it begins playback. The connection URL to the publisher dictates what format is used by the catalog and only one catalog. IN a world where we have MoQ formats also called HLS and DASH (for simplicity), this would look like:\r\n\r\nClient connects to `https://cdn.example.com/hls/some/path`\r\nA 'catalog' subscription returns a catalog in hls format\r\n\r\nClient connects to `https://cdn.example.com/dash/some/path`\r\nA 'catalog' subscription returns a catalog in dash format\r\n\r\n\r\n2. We create reserved catalog names for each media format. They can specify these names as part of their IANA reservation. \r\n\r\nClient connects to `https://cdn.example.com/some/path`\r\nA subscription to \"catalog-hls' returns a catalog in hls format\r\nA subscription to \"catalog-dash' returns a catalog in the dash format\r\n\r\n3. The publisher returns a master catalog that lists all the media formats and their tracks that it is producing. \r\nClient connects to `https://cdn.example.com/some/path`\r\nA subscription to 'catalog' returns a catalog with the following pseudo-structure\r\n\r\n```\r\nCatalog {\r\n    Formats [\r\n        { hls : tracks [ ..] }\r\n        { dash : tracks [ ..] }\r\n    ]\r\n}\r\n```\r\n\r\n\r\n\r\n",
          "createdAt": "2023-04-21T15:42:47Z",
          "updatedAt": "2023-04-21T15:42:47Z"
        },
        {
          "author": "hardie",
          "authorAssociation": "COLLABORATOR",
          "body": "On Fri, Apr 21, 2023 at 4:42\u202fPM Will Law ***@***.***> wrote:\n\n> In discussing this with @kixelated <https://github.com/kixelated> we came\n> up with several different solutions\n>\n>    1. We continue what works for HLS and DASH today, which is that the\n>    client knows what format it expects before it begins playback. The\n>    connection URL to the publisher dictates what format is used by the catalog\n>    and only one catalog. IN a world where we have MoQ formats also called HLS\n>    and DASH (for simplicity), this would look like:\n>\n> Client connects to https://cdn.example.com/hls/some/path\n> A 'catalog' subscription returns a catalog in hls format\n>\n> Client connects to https://cdn.example.com/dash/some/path\n> A 'catalog' subscription returns a catalog in dash format\n>\n(personal hat)\n\nBoth BCP 56 and BCP 190 strongly urge protocol designers not to assume that\nyou can define path elements as specific to a particular usage of HTTP\n(Section 3.2 of BCP 56 and BCP 190 Section 2.3).  Other than .well-known,\nthis approach has to be a hint or it's probably a non-starter.\n\nregards,\n\nTed\n\n\n>    1. We create reserved catalog names for each media format. They can\n>    specify these names as part of their IANA reservation.\n>\n> Client connects to https://cdn.example.com/some/path\n> A subscription to \"catalog-hls' returns a catalog in hls format\n> A subscription to \"catalog-dash' returns a catalog in the dash format\n>\n>    1. The publisher returns a master catalog that lists all the media\n>    formats and their tracks that it is producing.\n>    Client connects to https://cdn.example.com/some/path\n>    A subscription to 'catalog' returns a catalog with the following\n>    pseudo-structure\n>\n> Catalog {\n>     Formats [\n>         { hls : tracks [ ..] }\n>         { dash : tracks [ ..] }\n>     ]\n> }\n>\n> \u2014\n> Reply to this email directly, view it on GitHub\n> <https://github.com/kixelated/warp-draft/issues/140#issuecomment-1518017619>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAKVXZGCKFOWGO3GTXH6DXTXCKTIFANCNFSM6AAAAAAXGMCBNQ>\n> .\n> You are receiving this because you are subscribed to this thread.Message\n> ID: ***@***.***>\n>\n",
          "createdAt": "2023-04-21T16:55:43Z",
          "updatedAt": "2023-04-21T16:55:43Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Why can't we either specify in SETUP message or add as Track Request Parameter to identify the format needed ?",
          "createdAt": "2023-04-22T00:14:06Z",
          "updatedAt": "2023-04-22T00:14:06Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "wow - I wish we called this something different than media format. I thought this bug was going to be about if I could output AV1 and AV2 and the same time. We absolutely need to be about have a client that supports AV1 and AV2 be able to do both or we have no way to transitions from AV1 to AV2 before all clients support AV2. \r\n\r\nI suspect we have the same issues here, if a system is trying to move from an old format say DASH  to something new like QuicDASH, you will want publishes to be able to publish both during the transition and the old clients to subscribe to the old and clients that support both to subscribe to the new. ",
          "createdAt": "2023-04-22T14:16:11Z",
          "updatedAt": "2023-04-22T14:16:11Z"
        }
      ]
    },
    {
      "number": 142,
      "id": "I_kwDOG2Ho4M5kFG5h",
      "title": "Rename the protocol",
      "url": "https://github.com/moq-wg/moq-transport/issues/142",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "During authors call, it was agree to use `moq-transport` as the name for the protocol. ",
      "createdAt": "2023-04-21T20:37:59Z",
      "updatedAt": "2023-07-24T21:48:42Z",
      "closedAt": "2023-07-24T21:48:34Z",
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "I can propose a PR on this change . any thoughts?",
          "createdAt": "2023-04-21T20:38:55Z",
          "updatedAt": "2023-04-21T20:38:55Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's hold off until the outstanding PR list is close to 0 to prevent heinous merge conflicts.  You have several stale PRs you can close.",
          "createdAt": "2023-04-21T21:48:58Z",
          "updatedAt": "2023-04-21T21:48:58Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I like `moq-transport` for the generic pub/sub transport. \r\n\r\nBut I don't know what we should call the media document that Will is working on. I propose `moq-media` although it's redundant if moq is an acronym...",
          "createdAt": "2023-04-22T00:19:04Z",
          "updatedAt": "2023-04-22T00:19:04Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "And yeah, let's rename the draft as part of the PR that removes all references to media.",
          "createdAt": "2023-04-22T00:19:33Z",
          "updatedAt": "2023-04-22T00:19:33Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The redundancy of moq-media does not bother me. I like the simplicity of moq-transport (which is not a transport) and the moq-media (which is nuts if you expand the acronym). They will make it easy for people to google for what they are looking for and understand what they are likely to find in the draft. ",
          "createdAt": "2023-04-22T14:11:05Z",
          "updatedAt": "2023-04-22T14:11:05Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I want to close this issue because #197 landed, but I think there's some agreement that we want to keep iterating. ",
          "createdAt": "2023-05-26T23:23:22Z",
          "updatedAt": "2023-05-26T23:23:22Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I am going to close this for now, but it can be re-opened if there are strong opinions.",
          "createdAt": "2023-07-24T21:48:34Z",
          "updatedAt": "2023-07-24T21:48:34Z"
        }
      ]
    },
    {
      "number": 143,
      "id": "I_kwDOG2Ho4M5kFcJ7",
      "title": "Should PUBLISH be a separate message?",
      "url": "https://github.com/moq-wg/moq-transport/issues/143",
      "state": "CLOSED",
      "author": "afrind",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "PUBLISH (as defined in #123) conveys the name of an available track to the recipient, and PUBLISH_OK gives the publisher permission to begin sending OBJECT messages for that track.\r\n\r\nMy read is that this interchange:\r\n\r\n-> PUBLISH\r\n<- PUBLISH_OK \r\n-> OBJECT(track data)\r\n\r\nCan also be accomplished without PUBLISH via the following sequence:\r\n\r\n<- SUBSCRIBE catalog\r\n-> SUBSCRIBE_OK\r\n-> OBJECT(catalog)\r\n<- SUBSCRIBE\r\n-> SUBSCRIBE_OK\r\n-> OBJECT(track data)\r\n\r\nThere are a couple differences worth highlighting:\r\n\r\n1) PUBLISH can contain per-track authorization credentials, but it's not clear where those go in SUBSCRIBE-only approach\r\n2) PUBLISH_ERROR provides an explicit signal that the recipient DOES NOT want the named track.  In the SUBSCRIBE-only method, the absence of a SUBSCRIBE conveys no information.\r\n3) The PUBLISH message doesn't have the same amount of metadata about the track that is conveyed in the catalog, and may not be sufficient for the recipient to decide if they want it or not.\r\n4) SUBSCRIBE-only requires that the recipient (possibly a recipient at the end of a relay chain) parse the catalog",
      "createdAt": "2023-04-21T22:01:17Z",
      "updatedAt": "2023-05-05T20:02:23Z",
      "closedAt": "2023-05-05T20:02:23Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "> <- SUBSCRIBE catalog\r\n> -> SUBSCRIBE_OK\r\n\r\nI'll also note if we define a special Track ID for catalog, and assume catalog tracks are implicitly subscribed, then these messages can be omitted in the above exchange.",
          "createdAt": "2023-04-21T22:07:42Z",
          "updatedAt": "2023-04-21T22:07:42Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Its important to also note at what leg is this handshake happening \r\n\r\n- is it between end-user client and edge relay\r\n- is it between 2 components that implement moq relay functionality ( no access to catalog)\r\n- is it happening between 2 moq relays that are from different distribution networks ( no access to catalogs or concept of bundle/grouping of things for connecting the authz to the connection)\r\n\r\nOnly in first case, a catalog is accessible and only by the end user client.  Again tying the catalog access to the track access will be what some applications want and but that his shortcomings too\r\n- A catalog authorized for an end-user client would not have sufficient information for the relay to know if the track being published is indeed part of the catalog. \r\n\r\nI think making tracks as central component will help resolve many of the above use-cases and deployments. However, If certain controlled deployments can shortcut authz to catalog to imply authz to all the tracks from an end-point, that is still possible. But it is application design but not protocol level consideration though",
          "createdAt": "2023-04-21T22:27:25Z",
          "updatedAt": "2023-04-21T22:29:11Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "The proposed PUBLISH in #127 is a method of track discovery. Fun fact, I originally proposed something similar in #43 before settling on #63.\r\n\r\nI think it falls short for two reasons:\r\n\r\n### 1. Insufficient track properties\r\nFor distribution, we're all in agreement that there's a catalog to describe the tracks. The player parses the catalog and the rich media information it contains, deciding if it wants to subscribe to a track based on properties such as codec/resolution/bitrate/etc.\r\n\r\nHowever for contribution, when using this PUBLISH message, only the track name is available to describe each track. The receiver somehow needs to decide if it wants to subscribe to said track (via a PUBLISH OK) and the only option is to parse the track name. This is acceptable (albeit gross) when both sides agree on a naming schema, but it's not acceptable for generic implementations (ex. OBS).\r\n\r\n\r\n### 2. Race conditions\r\nA moq endpoint will usually publish multiple tracks in parallel. There would be multiple PUBLISH messages sent in parallel, potentially over the same control stream.\r\n\r\nHowever, this introduces a whole class of race conditions, as packet loss can cause messages to arrive out of order (multiple control streams) or with significant delay. The receiver is unaware of the number of total tracks being published, and yet has to make a decision on if it wants to reply OK to each publish. For example, a client may PUBLISH h264 and PUBLISH av1, indicating the capability to support either codec, and the receiver could make a completely different decision based on when these messages arrive over the network.",
          "createdAt": "2023-04-22T00:50:00Z",
          "updatedAt": "2023-04-22T00:50:28Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "The CATALOG message in the current draft is meant to address both of these issues.\r\n\r\n1. It includes the track name and a track description (init segment).\r\n2. All tracks are contained in the same message (no races).\r\n\r\n\r\nWe should absolutely send the catalog over a track as part of #66. But I think it's the only thing we should push unless we can figure out a way to deal with the issues I've described.\r\n\r\nAs to how to push the catalog on startup, I think there's a few options:\r\n\r\n1. The consumer SUBSCRIBEs to a well-known catalog track name (\"catalog\").\r\n2. The producer PUBLISHs a well-known catalog track name (\"catalog\").\r\n3. The producer sends OBJECTs with a well-known track ID (0).\r\n\r\n\r\nMy vote is not 2, unless we can justify other situations where a dedicated PUBLISH message would be used. I kind of like 3; think of it like an automatic subscription when SETUP contains ROLE=publisher.",
          "createdAt": "2023-04-22T01:09:41Z",
          "updatedAt": "2023-04-22T01:25:32Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> Its important to also note at what leg is this handshake happening\r\n> \r\n> * is it between end-user client and edge relay\r\n> * is it between 2 components that implement moq relay functionality ( no access to catalog)\r\n> * is it happening between 2 moq relays that are from different distribution networks ( no access to catalogs or concept of bundle/grouping of things for connecting the authz to the connection)\r\n> \r\n> Only in first case, a catalog is accessible and only by the end user client. Again tying the catalog access to the track access will be what some applications want and but that his shortcomings too\r\n> \r\n> * A catalog authorized for an end-user client would not have sufficient information for the relay to know if the track being published is indeed part of the catalog.\r\n> \r\n> I think making tracks as central component will help resolve many of the above use-cases and deployments. However, If certain controlled deployments can shortcut authz to catalog to imply authz to all the tracks from an end-point, that is still possible. But it is application design but not protocol level consideration though\r\n\r\nYou raise some good points, but I do think that _something_ has to parse the catalog so the relay can return a PUBLISH OK.\r\n\r\nIf I'm running an ingest edge with no access to the catalog, I can't blindly reply PUBLISH OK to every PUBLISH REQUEST. I would forward the PUBLISH REQUEST to some origin server that would have access to the catalog, so it can decide if the track is worth ingesting. That way the broadcaster could make multiple tracks available, such as different codecs or renditions, and the ingest origin can choose which ones to receive. There's not enough bandwidth to push all available tracks.\r\n\r\nNow hypothetically, if the origin has the catalog (pushed via some mechanism), then for the tracks where it would reply with PUBLISH OK, then it would send SUBSCRIBE instead. Semantically they're the same thing; please send me this track name using this track ID. I think that's a clean design, and fixes a few problems with current ingest protocols (mostly RTMP) since the receiver is in charge.",
          "createdAt": "2023-04-22T01:22:19Z",
          "updatedAt": "2023-04-22T01:26:24Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "TL;DR of message ahead: The Relays can't read the catalog inside the object message and they need some way of knowing what client to route a subscribe too. \r\n\r\nOK, so reading this I have a much better idea of why people are thinking different things. \r\n\r\nThe first issue is I don't think we all have the same view of what entity creates the catalog in the ingest case. I will start a separate issue on that. See #144 \r\n\r\nThe next issue  is really what is the difference of object with a catalog and and the publish message. If you look at the first message in this issue, it illustrates how they carry similar information. However there is one big difference. The relay can not read the information inside the payload of the object so it can not read or parse the catalog. That is a good thing given we want may have multiple types of catalogs. Deploying new catalog types should not be stalled by waiting for the chicken and egg problem of getting CDNs to support them. That leads to ossification of the catalog format. \r\n\r\nHere is why that matters. Image a CDN with many relays. A ton of clients connect to that CDN for the same webex meeting. Now something subscribes to one of the tracks URIs. The CDN has no clue of which one of the clients can publish that specific track. Even if it did, it does not know of all the which CDN node that right client for that track is attached to. \r\n\r\nIt seems to me that the key requirement here is we need some way for the CDN to know which tracks any given client connected to the CDN can publish. There are multiple ways to solve this but the PUBLISH message is a simple way that is:\r\n1) very symmetric to the subscribe, and like the subscribe can be a place to support per track authorization \r\n2) have very low RTT before the client can start sending data \r\n\r\nTo be very crisp on what the problem with the catalog based flow is in the first message of this issue., The 4th message in the 2nd flow is \"<- SUBSCRIBE\" but the CDN has no clue which of the many clients connected to it to send the subscribe for a given track URI to. \r\n\r\nEven in a case with no relays, I think you send up wanting something that allows the a load balancer to do things like send audio to a different server than video.  ( Longer story on why but most the major web conferencing systems process the the audio and the video on different servers ). ",
          "createdAt": "2023-04-22T14:08:25Z",
          "updatedAt": "2023-04-22T14:08:25Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "as pointed out in another thread, PUBLISH may be wrong name for this message as it is more an indication of intent to publish and the publish is when the OBEJCT gets sent ",
          "createdAt": "2023-04-22T16:51:06Z",
          "updatedAt": "2023-04-22T16:51:06Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> as pointed out in another thread, PUBLISH may be wrong name for this message as it is more an indication of intent to publish and the publish is when the OBEJCT gets sent\r\n\r\nYeah, I think PUBLISH is 0-RTT while ANNOUNCE is 1-RTT",
          "createdAt": "2023-04-22T18:03:55Z",
          "updatedAt": "2023-04-22T18:03:55Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Just on the name, pr #123 names it as PUBLISH_REQEST and not PUBLISH. PUBLISH_REQUEST is a transaction and is 1-RTT as described\r\n",
          "createdAt": "2023-04-22T18:29:44Z",
          "updatedAt": "2023-04-23T04:22:16Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> However for contribution, when using this PUBLISH message, only the track name is available to describe each track. The receiver somehow needs to decide if it wants to subscribe to said track (via a PUBLISH OK) and the only option is to parse the track name. This is acceptable (albeit gross) when both sides agree on a naming schema, but it's not acceptable for generic implementations (ex. OBS).\r\n\r\nPUBLISH REQUEST as described in #123 doesn't say that the end-point doesn't have access to the catalog. It is assumed that catalog is the starting point (as is the case with subscribes) and track list to send publish_request is coming from the catalog.  We can add an explicit note if that makes things clear. Also send PUBLISH OK is a implicit subscription from the peer for that track and we don't require another SUBSCRIBE coming in from that peer.",
          "createdAt": "2023-04-23T04:26:13Z",
          "updatedAt": "2023-04-23T04:30:51Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> > However for contribution, when using this PUBLISH message, only the track name is available to describe each track. The receiver somehow needs to decide if it wants to subscribe to said track (via a PUBLISH OK) and the only option is to parse the track name. This is acceptable (albeit gross) when both sides agree on a naming schema, but it's not acceptable for generic implementations (ex. OBS).\r\n> \r\n> PUBLISH REQUEST as described in #123 doesn't say that the end-point doesn't have access to the catalog. It is assumed that catalog is the starting point (as is the case with subscribes) and track list to send publish_request is coming from the catalog. We can add an explicit note if that makes things clear. Also send PUBLISH OK is a implicit subscription from the peer for that track and we don't require another SUBSCRIBE coming in from that peer.\r\n\r\nIf the endpoint already has access to the catalog, then it already knows all of the track names. It should issue a SUBSCRIBE message directly instead of waiting for an optional PUBLISH_REQUEST to announce each track name.\r\n\r\nThe PUBLISH message can only add value when the endpoint does NOT have access to the catalog. For the sake of argument, what if the PUBLISH_REQUEST message contained the entire catalog? It would be a strict upgrade, as it would include both the track name and a media description for each track.",
          "createdAt": "2023-04-24T21:16:26Z",
          "updatedAt": "2023-04-24T21:19:07Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I think some of the disagreement stems from the question: \"what does a relay do if it does not have access to the catalog?\"\r\n\r\nAn edge relay would forward the PUBLISH_REQUEST message to the next hop. This would continue until it reaches an endpoint that can parse the request, ie. the origin. The origin then issues a SUBSCRIBE/PUBLISH_OK (they're effectively the same message) for the track that propagates back to the broadcaster.\r\n\r\nThe same is true if we include the catalog in the PUBLISH_REQUEST message. The only difference is that a relay has more information now, as it has both the track name and a detailed media descriptor that is optional to parse.",
          "createdAt": "2023-04-24T21:24:53Z",
          "updatedAt": "2023-04-24T21:25:55Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> If the endpoint already has access to the catalog, then it already knows all of the track names. It should issue a SUBSCRIBE message directly instead of waiting for an optional PUBLISH_REQUEST to announce each track name.\r\n\r\nHere the client endpoint is the publisher and not the subscriber. Say a video end-point producing media in a conference call or a relay producing to another relay where the peer relay has no catalog access. ",
          "createdAt": "2023-04-24T21:38:58Z",
          "updatedAt": "2023-04-24T21:49:46Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> The same is true if we include the catalog in the PUBLISH_REQUEST message. The only difference is that a relay has more information now, as it has both the track name and a detailed media descriptor that is optional to parse.\r\n\r\nCatalog might be end to end encrypted too and a relay may not be even able to parse the catalog. Also catalog parsing is expensive at high scales and at every relay hop.",
          "createdAt": "2023-04-24T21:40:38Z",
          "updatedAt": "2023-04-24T22:31:33Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "@suhasHere : Can you give some example end-to-scenarios involving PUBLISH_REQUEST?\r\n\r\nI see that PUBLISH_REQUEST contains a subset of the contents of the catalog (currently only track name) and it is efficiently relay readable.  It's therefore possible for any relay to issue a PUBLISH_OK before any consuming endpoint with catalog access could issue a SUBSCRIBE.  Is that the intent?\r\n\r\nI think @kixelated's question is how would a generic relay decide which tracks to allow when all it knows is their name?",
          "createdAt": "2023-04-25T00:44:28Z",
          "updatedAt": "2023-04-25T00:44:28Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> how would a generic relay decide which tracks to allow when all it knows is their name?\r\n\r\nBy design so far, Relays don't know anything about application level details regarding tracks (such as descriptors, media information and so on). \r\nFor deciding if a track should be allowed or not, They need to look at the authorization information for the track in the publish_request \r\n",
          "createdAt": "2023-04-25T02:40:14Z",
          "updatedAt": "2023-04-25T14:18:46Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "@suhasHere : Can you give some example end-to-scenarios involving PUBLISH_REQUEST (including how you envision the publisher acquiring various authorization tokens)?",
          "createdAt": "2023-04-25T15:45:39Z",
          "updatedAt": "2023-04-25T15:45:39Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> @suhasHere : Can you give some example end-to-scenarios involving PUBLISH_REQUEST (including how you envision the publisher acquiring various authorization tokens)?\r\n\r\nAuthorization token can be obtained via the catalog or some out of band mechanisms, either of which is not in scope for this spec. May be I am missing something ?",
          "createdAt": "2023-04-25T16:03:38Z",
          "updatedAt": "2023-04-25T16:04:05Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "@suhasHere : I understand the proposed mechanics.  I'm asking for an end-to-end (application-level) example to help illustrate the usage of this message.",
          "createdAt": "2023-04-25T16:05:12Z",
          "updatedAt": "2023-04-25T16:05:12Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> > The same is true if we include the catalog in the PUBLISH_REQUEST message. The only difference is that a relay has more information now, as it has both the track name and a detailed media descriptor that is optional to parse.\r\n> \r\n> Catalog might be end to end encrypted too and a relay may not be even able to parse the catalog. Also catalog parsing is expensive at high scales and at every relay hop.\r\n\r\nThe CATALOG message, as it currently stands is a tuple of the track name and a payload depending on the track format. A relay that does not understand the track format, or does not care to parse it, could still use the track name and just forward the contents.\r\n\r\nI would still like to move the catalog to a track, but as it currently stands, the CATALOG message is the same as PUBLISH_REQUEST but contains more information.",
          "createdAt": "2023-04-25T18:48:13Z",
          "updatedAt": "2023-04-25T18:48:13Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> > how would a generic relay decide which tracks to allow when all it knows is their name?\r\n> \r\n> By design so far, Relays don't know anything about application level details regarding tracks (such as descriptors, media information and so on). For deciding if a track should be allowed or not, They need to look at the authorization information for the track in the publish_request\r\n\r\nI think you're confusing authorization and track selection. \r\n\r\nA generic client like OBS will connect to `live.twitch.tv` via a connect URL. I propose it would include the auth token in that URL, although feasibly the client could send same token for each PUBLISH_REQUEST.\r\n\r\nThe problem is that the client (ex. OBS) and server (ex. live.twitch.tv) don't necessarily agree on what tracks  should be sent. This is partly a matter of exchanging compatibilities, but both the client and server also have  limited resources. There needs to be some sort of negotiation, allowing either side to say NO prior to transferring any content. This has nothing to do with authorization, and everything to do with negotiating limited resources.\r\n\r\nThe CDN MUST avoid propagating unsupported or unrequested OBJECTs through the network. It uses resources, such as limited backbone capability. There needs to be some entity that decides that a resource should be transferred at each hop based on downstream demand.\r\n\r\nThis is the premise behind HTTP CDNs. The origin does NOT push resources to all edges. Instead, the each node waits until there's a request (SUBSCRIBE) and propagates that request to the origin, deduplicating along the way. This ensures that there's at least one consumer for a particular resource to avoid wasting resources.\r\n\r\nThis should be our default world-view for MoQ; no media is transferred until requested.\r\n\r\n---\r\n\r\nHowever, a HTTP CDN is allowed to pre-fetch content if 1) it has extra resources and 2) it understands the relationship between resources. This is a potentially wasteful process, but may improve the responsiveness if a resource is eventually requested.\r\n\r\nIf we extrapolate this to the MoQ world, this means an ingest server may SUBSCRIBE to tracks before they are requested downstream. This doesn't require the catalog, only the track name, but the catalog does contain useful information about the relationship between track (ex. renditions).\r\n\r\nThe PUBLISH_REQUEST message is trying to perform the similar functionality. It's meant to push tracks so they are available a few hops early. However, the broadcaster cannot be in control of deciding if a CDN wants a track. The CDN absolutely needs the ability to select what tracks are transferred and when.",
          "createdAt": "2023-04-25T19:52:59Z",
          "updatedAt": "2023-04-25T20:03:22Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I no longer understand what everyone is trying to say here. Can we put this on the agenda for Friday. I think we could make progress on this. ",
          "createdAt": "2023-04-25T22:34:43Z",
          "updatedAt": "2023-04-25T22:34:43Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "@fluffy : I added an agenda item to discuss publish use cases in general, which cover some of this discussions here, in 144 and PR 123.\r\n\r\nI think it would help guide the discussion if we had written examples showing the following use cases working at the message level:\r\n\r\n1. Client broadcasting a live-stream through a CDN/Caching/Relay Network to N subscribers\r\n2. Clients publishing as part of a media conference through a CDN/Caching/Relay Network\r\n\r\nEssentially taking what is in the scenarios draft (2.2 - 2.4) and moq-transport (6.5) and filling in the next level of detail including the ordering of messages from all participants.  I asked @kpugin and @kixelated to look at 1), maybe @suhasHere you can look at 2)?",
          "createdAt": "2023-04-25T22:53:59Z",
          "updatedAt": "2023-04-25T22:53:59Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(For Friday) I think our workflow can be much simpler if we implement a basic tenet that **a publisher doesn't send anything over the wire unless it first gets a subscription request for it**. Additionally, the CATALOG track already describes the availability of content from the publisher. We don't need extra methods to signal publish intent. \r\n\r\n1. Publisher connects to a server, prepares a catalog track, but doesn;t send it. It just waits. This is efficient. We don't want bytes moving over our network if no one is subscribing to them. \r\n2. Client connects to CDN edge and subscribes to the catalog track. This subscription request is relayed through each node until it reaches the publisher.\r\n3. The publisher begins sending the catalog track over the wire. It is relayed up through each node until it reaches the client. The nodes cache the catalog track so that future subscribes don't need to go back to the original publisher.\r\n4. The client reads the catalog and subscribes to additional content. Once the publisher receives these subscription requests, it pushes the content over the wire. This content is relayed up to the client. \r\n5. When a client no longer wants to receive a track, it sends a UNSUBSCRIBE request to the sender (or closes its connection, which is an implicit unsubscribe for all tracks initiated within that connection). These UNSUBSCRIBE messages cascade back to the publisher. Once it no longer has an audience for its content, it stops pushing content over the wire.\r\n\r\nAny authorization for what a client is allowed to publish should be handled by application defined access control. We don't need an explicit message for that. This is exactly what we propose for clients when they subscribe . We envisage a token which defines which tracks they may consume. Symmetrically, a similar token can be used on the publish side to define what a publisher may publish. We don't propose a SUBSCRIBE-REQUEST handshake and I don;t believe we need a PUBLISH-REQUEST handshake either. \r\n\r\n",
          "createdAt": "2023-04-25T22:55:17Z",
          "updatedAt": "2023-04-25T22:55:17Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> I no longer understand what everyone is trying to say here. Can we put this on the agenda for Friday. I think we could make progress on this.\r\n\r\nMy fault for the wall of text.\r\n\r\n> (For Friday) I think our workflow can be much simpler if we implement a basic tenet that **a publisher doesn't send anything over the wire unless it first gets a subscription request for it**. Additionally, the CATALOG track already describes the availability of content from the publisher. We don't need extra methods to signal publish intent.\r\n> \r\n> 1. Publisher connects to a server, prepares a catalog track, but doesn;t send it. It just waits. This is efficient. We don't want bytes moving over our network if no one is subscribing to them.\r\n> 2. Client connects to CDN edge and subscribes to the catalog track. This subscription request is relayed through each node until it reaches the publisher.\r\n> 3. The publisher begins sending the catalog track over the wire. It is relayed up through each node until it reaches the client. The nodes cache the catalog track so that future subscribes don't need to go back to the original publisher.\r\n> 4. The client reads the catalog and subscribes to additional content. Once the publisher receives these subscription requests, it pushes the content over the wire. This content is relayed up to the client.\r\n> 5. When a client no longer wants to receive a track, it sends a UNSUBSCRIBE request to the sender (or closes its connection, which is an implicit unsubscribe for all tracks initiated within that connection). These UNSUBSCRIBE messages cascade back to the publisher. Once it no longer has an audience for its content, it stops pushing content over the wire.\r\n> \r\n> Any authorization for what a client is allowed to publish should be handled by application defined access control. We don't need an explicit message for that. This is exactly what we propose for clients when they subscribe . We envisage a token which defines which tracks they may consume. Symmetrically, a similar token can be used on the publish side to define what a publisher may publish. We don't propose a SUBSCRIBE-REQUEST handshake and I don;t believe we need a PUBLISH-REQUEST handshake either.\r\n\r\n+100\r\n\r\nI will note that a transcoder or archiver might be the consumer. To the client, it would look like it's pushing data, because the server immediately issued a SUBSCRIBE for the catalog and some tracks. However this is optional, and like Will said, we don't want to push any bytes over the network until necessary.\r\n\r\nHere are some examples where we do NOT want the broadcasting client pushing media:\r\n\r\n- The broadcast has 0 viewers.\r\n- The conference call is empty.\r\n- The backup feed is inactive (ex. satellite truck).\r\n- The track properties are unsupported (ex. codec, bitrate, etc).\r\n- The track has an alternative (ex. OPUS instead of AAC).\r\n- The broadcast does not require the CDN yet (ex. multi-CDN).\r\n\r\nIn all of these cases, the broadcaster is unaware of these conditions; they're solely determined by demand. It should be up to the CDN to determine what to subscribe to, rather than the broadcaster deciding what to publish.",
          "createdAt": "2023-04-25T23:23:05Z",
          "updatedAt": "2023-04-25T23:23:05Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> a publisher doesn't send anything over the wire unless it first gets a subscription request for it\r\n\r\nThis is application decision/choice and not the transport requirement. \r\n\r\n",
          "createdAt": "2023-04-26T16:33:15Z",
          "updatedAt": "2023-04-26T16:35:11Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> > a publisher doesn't send anything over the wire unless it first gets a subscription request for it\r\n> \r\n> This is application decision/choice and not the transport requirement.\r\n\r\nI want this to be a transport requirement. Using HTTP terminology, the server can't push a response until it gets a request.\r\n\r\nWe should leave the door open for something like PUBLISH as an RTT optimization between coordinated endpoints. But much like HTTP Push, I don't see how it would work with generic endpoints and CDN fanout. ",
          "createdAt": "2023-04-26T17:05:08Z",
          "updatedAt": "2023-04-26T17:05:08Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "This is a pub/sub transport and one can easily emulate HTTP like approach on top of it .. We need to keep the flexibility for application to innovate with either of the approaches. ",
          "createdAt": "2023-04-26T17:51:25Z",
          "updatedAt": "2023-04-26T17:51:25Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@suhasHere  - what behavior do you want to productize that you feel cannot be enabled with a pub-after-sub architecture? ",
          "createdAt": "2023-04-26T21:08:09Z",
          "updatedAt": "2023-04-26T21:08:09Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n> We envisage a token which defines which tracks they may consume. Symmetrically, a similar token can be used on the publish side to define what a publisher may publish.\r\n\r\nThat is what is proposed in the PR today, there is a token in the publish_request that let's relay know what a publisher can publish. ",
          "createdAt": "2023-04-27T04:55:57Z",
          "updatedAt": "2023-04-27T04:55:57Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> @suhasHere - what behavior do you want to productize that you feel cannot be enabled with a pub-after-sub architecture?\r\n\r\nit is very typical in a conferencing scenario for a conference participant to join in and send media even if no receiver has joined yet. The idea is , as more people join in they get the media instantly from multiple publishers (avoids latency). If there are N publishers, one need not wait for N end to end subscribe roundtrips to each such publisher in order  to get media delivered, otherwise.\r\n\r\nThis is just one use-case and we haven't see all the possible applications one can innovate. \r\n\r\nAlso publish_request is telling Relays about authorization status for a given publisher for the track name. \r\n\r\nEven for the case of subscribe-then-publish,  the media producer still needs to prove that it is authorized to publish before sending OBJECT messages.\r\n\r\n",
          "createdAt": "2023-04-27T05:07:22Z",
          "updatedAt": "2023-04-27T07:01:36Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> it is very typical in a conferencing scenario for a conference participant to join in and send media even if no receiver has joined yet. \r\n\r\nWho are they sending it to if there are no receivers? Your origin? If so, you could accomplish that quite easily by having the origin issue a subscribe request to each participant. \r\n\r\n> If there are N publishers, one need not wait for N end to end subscribe roundtrips to each such publisher in order to get media delivered\r\n\r\nThose N subscribes would happen in parallel. And they would only need to happen for the first participant attached to each node. Statistically, most participants would find the streams already pulled to either the edge node or a parent node. \r\n\r\n> Even for the case of subscribe-then-publish, the media producer still needs to prove that it is authorized to publish before sending OBJECT messages.\r\n\r\nBut once a connection has been accepted , any intermediary or endpoint can send data down a QUIC stream, whether they are authorized to or not. Isn't it true that the authorization enforcement must therefore happen at the receiver? With a sub-then-pub approach, the receiver can throw away any incoming data it has not previously issued a subscription for. A participant connecting to a conferencing solution would be given an access token. That token would be parsed by the edge node (or the origin if it is connected directly) and it would specify which tracks the node can subscribe-to from that participant. ",
          "createdAt": "2023-04-27T08:08:27Z",
          "updatedAt": "2023-04-27T08:08:27Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I want to focus on one point from WIll's post that says\r\n\r\n>  \"Client connects to CDN edge and subscribes to the catalog track. This subscription request is relayed through each node until it reaches the publisher.\"\r\n\r\nThe question is how to do this. The CDN receives a subscribe to a given catalog track named Foo. The CDN has lots of of clients that can publish,  and they are connected to many different relays in the CND. The CDN needs to know how to get this subscription to the right relay and have it send it to the right client.  In our implementation the way we find that client is by having the publisher say \"I am willing to publish on track name Foo\".  The CDN keeps that information in its distributed routing table and when a request to subscribe to that track comes to the CDN, the CDN knows where to send that subscription. \r\n",
          "createdAt": "2023-04-27T14:07:37Z",
          "updatedAt": "2023-04-27T14:07:37Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The question is how to do this. \r\n\r\nI envisage it working in the same way that an edge server, who is asked to HTTP GET /foo.mp4, knows how to retrieve it from the millions of origin servers that the CDN is connected to. IN the HTTP case, the request has accompanying  HOST + PATH information that the CDN uses to map to a particular origin. That is part of the configuration of the CDN that was established when it was engaged and authorized to deliver foo.mp4. In the MoQ case, the subscription would be to something similar to `example.com/some/path/foo` (per our ongoing discussions for track names). The MoQ CDN would have a routing table which tells it how to go to either a forward relay in the same CDN, or to the correct origin. \r\n\r\n> In our implementation the way we find that client is by having the publisher say \"I am willing to publish on track name Foo\". The CDN keeps that information in its distributed routing table and when a request to subscribe to that track comes to the CDN, the CDN knows where to send that subscription.\r\n\r\nI appreciate that this is how QUICR may work today.  I am concerned about the scalability of that model in a multi-tenant CDN in which every edge node must hold a _dynamic_ table of the potential tracks that can be published by every publisher connected to every customer of that CDN. On a global scale, consistency in updates is a challenge. Much of the traffic flowing over that CDN will be to update these tables for content that may never actually be consumed. That seems inefficient. Additionally, you don't have the concept of the \"catalog\", which is the offer from the publisher on what it can produce. It is literally a list of the tracks it is willing to publish and is a substitute for the offer mechanism you describe above. This is a useful construct, functioning as a contract between the source and the end clients. It is conveniently distributed as a track, opaque to the CDN. In the pub-after-sub model, the CDN only has to hold static routing tables for content domains at the edge. The dynamic nature of what each client may publish is handled by catalog tracks and their updates. \r\n\r\n",
          "createdAt": "2023-04-28T04:40:39Z",
          "updatedAt": "2023-04-28T04:40:39Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Even in the publish request case, i don't see the table is dynamic as defined above. The endpoint has a catalog and it is sending publish request based on that list. The tables are as dynamic/static as it is with subscribe case.\r\n\r\nThe same publish request now works uniformly across all hops and there is no need for catalog understanding by relay nodes either.",
          "createdAt": "2023-04-28T05:33:13Z",
          "updatedAt": "2023-04-28T05:34:10Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> I want to focus on one point from WIll's post that says\r\n> \r\n> > \"Client connects to CDN edge and subscribes to the catalog track. This subscription request is relayed through each node until it reaches the publisher.\"\r\n> \r\n> The question is how to do this. The CDN receives a subscribe to a given catalog track named Foo. The CDN has lots of of clients that can publish, and they are connected to many different relays in the CND. The CDN needs to know how to get this subscription to the right relay and have it send it to the right client. In our implementation the way we find that client is by having the publisher say \"I am willing to publish on track name Foo\". The CDN keeps that information in its distributed routing table and when a request to subscribe to that track comes to the CDN, the CDN knows where to send that subscription.\r\n\r\nThis sounds like a gossip protocol. A producer connects to any CDN edge, announces that they are an origin for specific tracks, and then expects the CDN to serve subscriptions for those tracks from any edge.\r\n\r\nIn the HTTP world, this would be analogous to sending a PUT to the nearest akamai edge with the contents of `google.com/index.html`, and some way to prove you are actually Google. It certainly could work, although it's certainly not how CDNs are architected.",
          "createdAt": "2023-04-28T05:39:41Z",
          "updatedAt": "2023-04-28T05:41:30Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm closing this issue since there are no proposals for PUBLISH REQUEST at this time. #123 is now calls it ANNOUNCE, and I think it has value, and #150 tracks details related to the ANNOUNCE proposal.",
          "createdAt": "2023-05-05T20:02:23Z",
          "updatedAt": "2023-05-05T20:02:23Z"
        }
      ]
    },
    {
      "number": 144,
      "id": "I_kwDOG2Ho4M5kG-dk",
      "title": "Who creates the Catalog in an ingest case ",
      "url": "https://github.com/moq-wg/moq-transport/issues/144",
      "state": "CLOSED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "\r\nI think people are imagining different things for how the catalog is created. \r\n\r\nAs an example to motivate this, a generic OBS client used for ingest with a 4K camera could generate video at many different resolutions yet the application it is sending the video to can probably only use a handful of different resolutions. For example, webex could accept a main video stream at say 3 different resolutions or a content share stream at 4 different resolutions. (this is an over simplification of webex for this example).  Webex can not transcode in cloud if is doing E2E encryption. The OBS client needs some way to find out what video resolution are acceptable, and can then send this.  \r\n\r\nThe key issue is that the generic client needs to know what the application wants, and it gets that via the Catalog. The applications not the generic client needs to create the catalog. This is how it works in the subscription case and I am proposing how that it should work the same way in the ingest case. \r\n\r\nIn RTMP the server would send the Invoke message to tell the the OBS client what to do. If we want MOQ to be a replacement of RTMP, we need some functionally like this. \r\n\r\nMy proposal for how this work is the webex cloud site gets a catalog to the client in one of two ways. It can send it out of band in some HTTP before things start, or it can provide a URL where the OBS client can subscribe to the catalog. \r\n\r\nGiven how much is already implemented, I feel like I might be missing something in my understanding  of how this would work if the generic OBS client created the catalog. Very open to any solution to this problem. ",
      "createdAt": "2023-04-22T13:45:36Z",
      "updatedAt": "2023-09-27T18:07:25Z",
      "closedAt": "2023-09-27T18:07:25Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for recognizing the disconnect. The encoder must create the catalog unless there's a sophisticated capabilities exchange. \r\n\r\nThe main reason being is that the catalog contains encoding parameters, such as codec, profile, resolution, bitrate, etc. The ingest server can't just tell the generic broadcast client (ex. OBS) what to encode, because it may not be supported or feasible. This is especially important when hardware encoding and low-powered devices are involved.",
          "createdAt": "2023-04-22T16:22:51Z",
          "updatedAt": "2023-04-22T16:22:51Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "There was some discussion about media capabilities in #5. I do think there's a lot of overlap between announcing tracks and announcing capabilities. (ex. SDP...)",
          "createdAt": "2023-04-22T16:36:14Z",
          "updatedAt": "2023-04-22T16:36:14Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I get the example of some hardware encoder on a mobile phone is going to range of quirks but I will note that with WebRTC, we found these were far less than people thought they would. But agreeing with example use case you are raising. \r\n\r\nI was thinking the catalog would say  send me H.264 720P30 at 1.5 Mbps  and then in the init segment for the track, it would have \"AVC baseline profile 4:2:2 Level 3.2 but using CABAC\"",
          "createdAt": "2023-04-22T18:18:54Z",
          "updatedAt": "2023-04-22T18:18:54Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> Thanks for recognizing the disconnect. The encoder must create the catalog unless there's a sophisticated capabilities exchange. \n> \n> \n> \n> The main reason being is that the catalog contains encoding parameters, such as codec, profile, resolution, bitrate, etc. The ingest server can't just tell the generic broadcast client (ex. OBS) what to encode, because it may not be supported or feasible. This is especially important when hardware encoding and low-powered devices are involved.\n\nI suspect we are trying to solve a specific application level problem at the transport level. Having capabilities exchange is fine (it will be the case for all real-time flows, probably true for other usecases too) and can be defined elsewhere. \n\nThe only invariant here is - publisher has list of tracks (say from catalog) and based on that it can either request to publish or in some closed scenarios start sending media objects ( which is again application choice) \n\nWe need to support protocol semantic for the above. #123 is a start place for that.",
          "createdAt": "2023-04-22T18:19:02Z",
          "updatedAt": "2023-04-22T18:19:02Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "@suhasHere the distinction is very important.\r\n\r\nIf the encoder creates the catalog, then the contribution and distribution functionality the same. The encoder/transcoder advertises the list of available tracks, and the origin/player chooses which ones to subscribe to. There's a very clear set of responsibilities for the producer and consumer regardless of the endpoint.\r\n\r\nIf the origin creates the catalog instead, then we need separate PUBLISH/SUBSCRIBE messages like #123 has proposed. This actually forks the protocol, based on if the endpoint is before or after the origin. A MoQ library on the contribution side (ex. OBS -> ingest) does not work the same way on the distribution side (ie. CDN -> VLC).",
          "createdAt": "2023-04-25T18:16:00Z",
          "updatedAt": "2023-04-25T18:16:34Z"
        },
        {
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "body": "> In RTMP the server would send the Invoke message to tell the the OBS client what to do. If we want MOQ to be a replacement of RTMP, we need some functionally like this.\r\n\r\nTo be fair, that's not how Meta RTMP ingest works, I wonder if Twitch or Youtube use RTPM Invoke?",
          "createdAt": "2023-04-28T14:38:50Z",
          "updatedAt": "2023-04-28T14:38:50Z"
        },
        {
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "body": "> The OBS client needs some way to find out what video resolution are acceptable, and can then send this.\r\n\r\nI agree, this is a problem and in the past we tried to work with OBS folks on some sort of API that would allow server to \"configure\" OBS encoder, unfortunately it didn't go far enough. Putting this \"configuration API\" inside of MoQ protocol as @fluffy proposing sounds like good idea. I wonder, though, if that needs to be part of MoQ spec or it can be out of band protocol?",
          "createdAt": "2023-04-28T14:42:35Z",
          "updatedAt": "2023-04-28T14:42:35Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yah, this thread has made this all clearer to me. I was blurring the configuration \"figure out what to send\" and the \"say what you are sending\".  I think you are convincing me that a catalog is simply a report of what is being sent and is not part of of the figuring out what to send. ",
          "createdAt": "2023-04-28T15:56:13Z",
          "updatedAt": "2023-04-28T15:56:13Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "@fluffy is this good to close then?",
          "createdAt": "2023-07-21T18:38:49Z",
          "updatedAt": "2023-07-21T18:38:49Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think there is still a bunch of stuff to be sorted out on this but it is starting to get covered in the drafts and I don't think we need this issue anymore. I would propose close this. ",
          "createdAt": "2023-07-21T18:46:40Z",
          "updatedAt": "2023-07-21T18:46:40Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing per @fluffy ",
          "createdAt": "2023-09-27T18:07:25Z",
          "updatedAt": "2023-09-27T18:07:25Z"
        }
      ]
    },
    {
      "number": 145,
      "id": "I_kwDOG2Ho4M5kQoWT",
      "title": "Receiving unknown OBJECT messages (who creates the track-id)",
      "url": "https://github.com/moq-wg/moq-transport/issues/145",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Needs PR",
        "Subscribe"
      ],
      "body": "#141 adds a `Track ID` field. This is used to compress a long string (in SUBSCRIBE) into a short varint (in OBJECT).\r\n\r\nThe problem is that the mapping from string to varint is indicated in the SUBSCRIBE_OK message, which is sent in parallel with OBJECT messages. This introduces a race condition, where packet loss will cause SUBSCRIBE_OK to arrive late. The receiver will be unable to associate OBJECT messages with tracks until the arrival of the SUBSCRIBE_OK.\r\n\r\nA correct implementation must buffer any OBJECT messages with unknown track IDs for an indefinite amount of time. Any other implementation will error or skip media due to decode errors. This also introduce a risk of resource exhaustion, for example if the stream containing SUBSCRIBE_OK is reset.",
      "createdAt": "2023-04-24T21:37:07Z",
      "updatedAt": "2024-01-31T00:46:55Z",
      "closedAt": "2024-01-31T00:46:54Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "My proposal is to move the `Track ID` to the SUBSCRIBE message. The OBJECT sender MUST use a `Track ID` in a received SUBSCRIBE message. This means the receiver will never receive an unknown or unrequested OBJECT.",
          "createdAt": "2023-04-24T21:40:25Z",
          "updatedAt": "2023-04-24T21:40:25Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I know @wilaw wants the sender to be able to choose the `Track ID`, but that makes this race condition unavoidable. The only way to prevent it is to operate like QPACK; a literal track name is used until the SUBSCRIBE_OK is somehow acknowledged.\r\n\r\nThe argument is that the sender should choose the Track ID so it could use the same ID across multiple connections. There's a claim that this would improve edge efficiency, but I am extremely doubtful. My time spent profiling QUIC stacks makes me believe that per-hop IDs (ex. QUIC connection ID, QUIC steam ID, HTTP/3 QPACK, WebTransport session ID) contribute an insignificant amount to CPU usage.",
          "createdAt": "2023-04-24T21:47:27Z",
          "updatedAt": "2023-04-24T21:47:39Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "At a high level, all the nodes needs to be able to handle unknown objects - its true regardless of trackId issue.\r\n\r\nMay be we need a way is to define the following in the text\r\n- send full track-names + trackId multiple times for the initial X time units after subscribe_ok, over a separate message or a variation of the object message\r\n- drop unknown objects after Y time units (this is needed independent of track id concerns)\r\n\r\nWe need some text on handling such cases as recommendations from security perspective too. ",
          "createdAt": "2023-04-24T22:36:29Z",
          "updatedAt": "2023-04-24T23:16:08Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "As an Individual:\r\n\r\nIn many ways this ID is to moq what the QUIC stream ID is to HTTP/3 - and for those, there is a simple, unilateral, and deterministic way to choose.  Maybe that is a good model to follow?  Do we want to allow re-use of Track IDs for different tracks over the life of a connection?\r\n\r\n > A correct implementation must buffer any OBJECT messages with unknown track IDs for an indefinite amount of time. \r\n \r\nThere's an alternative, which is that the sender uses the subscriber's track ID until the client sends an explicit message acknowledging the new ID (NEW_OBJECT_ID_OK).  Then the server switches to the new ID, and the client has to accept OBJECTs with either ID for some period of time, but it would never have to accept unknown IDs.",
          "createdAt": "2023-04-25T00:03:20Z",
          "updatedAt": "2023-04-25T00:03:20Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> At a high level, all the nodes needs to be able to handle unknown objects - its true regardless of trackId issue.\r\n\r\nI don't understand what you mean. The receiver should always be able to identify which the track each OBJECT belongs to, and it should have agreed to receive that track in the first place.\r\n\r\n> - send full track-names + trackId multiple times for the initial X time units after subscribe_ok, over a separate message or a variation of the object message\r\n\r\nThis is basically QPACK, although it sends the literal until an explicit acknowledgement, which is more fault-tolerant than a timer.\r\n\r\n> - drop unknown objects after Y time units (this is needed independent of track id concerns)\r\n\r\nWhile receivers need the ability to drop OBJECTs in the first place, I don't want to degrade the user experience further. This is a solvable problem.",
          "createdAt": "2023-04-25T17:22:52Z",
          "updatedAt": "2023-04-25T17:30:18Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> In many ways this ID is to moq what the QUIC stream ID is to HTTP/3 - and for those, there is a simple, unilateral, and deterministic way to choose. Maybe that is a good model to follow? Do we want to allow re-use of Track IDs for different tracks over the life of a connection?\r\n\r\nYeah, I would like each SUBSCRIBE message to contain an incrementing `Subscription ID`. The OBJECT, SUBSCRIBE_OK, SUBSCRIBE_ERROR, and UNSUBSCRIBE messages would reference the `Subscription ID`, not the full track name. The ability to reuse subscription IDs seems pointless and potentially problematic (much like QUIC stream IDs).\r\n\r\n> There's an alternative, which is that the sender uses the subscriber's track ID until the client sends an explicit message acknowledging the new ID (NEW_OBJECT_ID_OK). Then the server switches to the new ID, and the client has to accept OBJECTs with either ID for some period of time, but it would never have to accept unknown IDs.\r\n\r\nHere's what that would look like:\r\n```\r\n-> SUBSCRIBE 1 foo/bar\r\n<- SUBSCRIBE_OK 1 = 5\r\n<- OBJECT 1\r\n-> SUBSCRIBE_OK_ACK 1 = 5\r\n<- OBJECT 5 \r\n```\r\n\r\nBut it won't quite work because both endpoints could simultaneously decide to use the same ID.\r\n\r\n```\r\n-> SUBSCRIBE 1 foo/bar\r\n-> SUBSCRIBE 5 oh/no   <- SUBSCRIBE_OK 1 = 5\r\n```\r\n\r\nTo fix this, we would have to shard the IDs, ie. sender uses even IDs. Alternatively, the receiver could refuse to send the SUBSCRIBE_OK_ACK when a collision is detected.\r\n\r\nAlthough frankly, I'm not sure why the receiver would ever send a SUBSCRIBE_OK_ACK. It's an optional message that just makes things more complicated for both endpoints, necessitating multiple hashmap keys. I would personally never implement it.",
          "createdAt": "2023-04-25T17:45:10Z",
          "updatedAt": "2023-04-25T17:47:35Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "While these suggestions are valid, I don't understand the benefit of letting the sender choose the track ID rather than the receiver. It's a near zero performance improvement that is immediately cannibalized by the extra complexity.",
          "createdAt": "2023-04-25T17:59:23Z",
          "updatedAt": "2023-04-25T17:59:23Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I know @wilaw wants the sender to be able to choose the Track ID, but that makes this race condition unavoidable. \r\n\r\n@wilaw has thought about this and now agrees that the advantage of a receiver choosing the trackID is to dispense with the SUBSCRIBE_OK_ACK and make for a simpler subscribe handshake. It also removes the requirement for the receiver to buffer unknown objects, as the OP has pointed out.  For efficiency,  I think I could implement a hashing scheme to avoid hierarchical nodes changing trackIDs at every hop. I know others think this may not be a performance gain, but I'd still like some way to implement it if I choose. \r\n\r\nOption A: receiver hinting, sender authoritative\r\n\r\n\r\n> -> SUBSCRIBE 1 foo/bar // receiver indicating that 1 should be used\r\n> <- SUBSCRIBE_OK 1  = 5 // sender responds nope, I'd like to use 5\r\n> <- OBJECT 5 // sender uses new ID right away\r\n> -> SUBSCRIBE 5 oh/no   // receiver asking if 5 is available\r\n> -> SUBSCRIBE_OK_ACK 1 = 5\r\n> <- SUBSCRIBE_OK 5 = 6 // sender responds nope, I'd like to use 6 because I know I have already allocated 5. \r\n> -> SUBSCRIBE_OK_ACK 5 = 6\r\n> <- OBJECT 6\r\n\r\n\r\n\r\nOption B: receiver authoritative\r\n\r\n> -> SUBSCRIBE 1 foo/bar // receiver indicating that 1 must be used\r\n> <- SUBSCRIBE_OK 1  // sender responds yes, I'll do that. \r\n> <- OBJECT 1 // sender uses 1 \r\n> -> SUBSCRIBE 5 oh/no   // receiver indicating that 5 must be used\r\n> <- SUBSCRIBE_OK 5  // sender responds yes, I'll do that. \r\n> <- OBJECT 5 // sender uses 5\r\n\r\nOf the two, I prefer B.\r\n\r\nIf congestion causes the SUBSCRIBE_OK to arrive after the object, then no harm because the receiver will know how to interpret the trackID since it asked for it. This raises three corollaries that we need to deal with:\r\n1. Do we even need the SUBSCRIBE_OK message? It's not adding value other than giving the receiver some confidence that its subscribe message was received. Perhaps we could assume it has been received and approved, unless a SUBSCRIBE_REJECTED or other type of message is sent? \r\n2. What should the receiver do with an object with a trackID that it never asked for? Should it send a UNKNOWN_TRACKID message to the sender to inform it that it is using an unrequested ID?\r\n3. What should the sender do if it is asked to use a trackID that is already in use? I'd suggest it go ahead and use it and let the receiver, which is the entity making the mistake, deal with the conflict. \r\n\r\n\r\n\r\n",
          "createdAt": "2023-04-25T19:56:30Z",
          "updatedAt": "2023-04-25T19:56:30Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> For efficiency, I think I could implement a hashing scheme to avoid hierarchical nodes changing trackIDs at every hop. I know others think this may not be a performance gain, but I'd still like some way to implement it if I choose.\r\n\r\nThat's a cool idea, and a good reason why the receiver should be able to choose a subscription ID instead of it incrementing by one. Within the CDN network: `subscription.id = hash_u64(track.name)`. \r\n\r\nThat being said, you'll still want* some way of dealing with collisions. It also only works if you're allowed to subscribe, unsubscribe, and resubscribe with the same ID, which gets racey.\r\n\r\n> 1. Do we even need the SUBSCRIBE_OK message? It's not adding value other than giving the receiver some confidence that its subscribe message was received. Perhaps we could assume it has been received and approved, unless a SUBSCRIBE_REJECTED or other type of message is sent?\r\n\r\nIt's not needed at the moment, but I think we might want to throw some more information in there. I think the starting group sequence could be useful for the receiver to know (since it may receive another group sequence first).\r\n\r\nI would want the sender to be able to send a SUBSCRIBE_ERROR after a SUBSCRIBE_OK though. This would be used to signal when a subscription ends for any reason, such as expired authentication or a natural track end.\r\n\r\n\r\n> 2. What should the receiver do with an object with a trackID that it never asked for? Should it send a UNKNOWN_TRACKID message to the sender to inform it that it is using an unrequested ID?\r\n\r\nIMO close the connection with an error code. \r\n\r\n\r\n> 3. What should the sender do if it is asked to use a trackID that is already in use? I'd suggest it go ahead and use it and let the receiver, which is the entity making the mistake, deal with the conflict.\r\n\r\nIMO close the connection with an error code.",
          "createdAt": "2023-04-25T20:53:45Z",
          "updatedAt": "2023-04-25T21:02:17Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this bug would better be named \"what creates the track-id\".  \r\n\r\nLet me outline the viable possibilities I see:\r\n\r\n- Option A: client picks the track-id and it is passed in subscribe or pub-interest to server \r\n\r\n- Option B: client suggests track-id,  and server picks the track-id. Client waits to get track-id before sending any objects \r\n\r\n- Option C:  client suggests,  and server picks track-id. Object send before the track-id is known to client are sent with full track-name. This would mean subscribed needs a 3 way handshake. \r\n\r\n ",
          "createdAt": "2023-04-28T16:14:20Z",
          "updatedAt": "2023-04-28T16:14:20Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On the pro's / con's of the three options we have:\r\n\r\n1. Option A and C allow the media to not be delayed 1 RTT to start flowing. Note that 1 RTT to the CDN edge may not actually be a very big deal given how many RTT to set up the media in the first place. But clearly 0-RTT is a an awesome goal. \r\n\r\n2. Option B and C let the relay choose. There are a bunch of reason for this but to me, one of the high order bits is we are trying to slot into small modification to existing CDN system and this allows the CDN to use these bits to map to identifiers they already have. For CDN's that want the bits to be unique across the CDN, they can do that. For CDN that don't care, they can use whatever the client suggested and not have to deal with the hassle of sending track-names as suggested in option C. \r\n\r\nThe extra hassle of option C over A seems worth it to me to give CDNs the flexibility. For CDNs that don't want to use this,  well they can just implement Option A. For clients, I don't see much extra work between A and C. ",
          "createdAt": "2023-04-28T16:20:47Z",
          "updatedAt": "2023-04-28T16:20:47Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Trying to summarize my somewhat crappy recollection of old conversations on this. \r\n\r\nOn some CDNs, it is very desirable to have a unique identifier that is the CDN can use for deciding how to forward a given object or chunk of bytes from that object. On other CDNs it might not matter.  In some cases this can make it easier to map on to existing HTTP CDNs. \r\n\r\nThis argues for staying with the current solution of server picks the ID.  This raises the question of deal with what happens with receiving an object before the message that has the ID.   \r\n\r\nA variety solutions have been discussed for this. \r\n\r\n1. buffer received objects until the ID is received - no one loves this but you might have to do it for other reasons anyway \r\n2. three way handshake so the object is not sent before ID \r\n3. send ID on same QUIC stream as first object in the group \r\n4. look at other ways to solve this problem of media before ID \r\n\r\nThe client people point out, the ID could be shorter if they are unique only across the stream not unique across multiple clients and that the relay can just keep a mapping table of trackID and session flow to whatever ID they wish was the trackID. However some of the relay side people argue that is hard to make work with HA as the HA solution need the client to pass the relay the ID they can use to lookup and recover the HA state and track ID is perfect for that. \r\n\r\nAnother solution that was discussed was the client proposes a ID, if it is OK with the relay it uses it, if the relay is not OK with the proposed ID, it rejects the SUBSCRIBE with an error and provided an alternative ID that the client uses in a second SUBSCRIBE.  There is a PR for this somewhere. It may be a good middle ground. \r\n",
          "createdAt": "2023-07-25T00:02:05Z",
          "updatedAt": "2023-07-25T00:02:05Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Okay, talking to Alan I realized that this issue is far more widespread than I realized and doesn't require any packet loss.\r\n\r\nLet's assume the application writes the SUBSCRIBE_OK on stream 5. The QUIC library does not send a packet yet, either due to pacing, congestion control, or something like Nagle's algorithm. The application then writes the first OBJECT on stream 31.\r\n\r\nThe problem is that STREAM frames can be coalesced into the same QUIC packet in an undefined order, and when received will be flushed to the application in an undefined order. Even a QUIC sender encodes in priority order (not required), it depends on the QUIC receiver emitting to the application in priority order, which is possible with a callback-based API but not a wakeup-based API (ie. multi-threaded). The SUBSCRIBE_OK is tiny so the STREAM frame will almost always be coalesced with other STREAM frames.\r\n\r\nAnd this is assuming the control stream is higher priority than the data streams. If that's not done, then it's extremely likely that the N data streams will arrive before the 1 control stream, especially because the control stream will be at the bottom of the round-robin stack.",
          "createdAt": "2023-08-04T20:08:35Z",
          "updatedAt": "2023-08-04T20:08:35Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Couple of observations \r\n1. Control streams must always be sent at a higher priority\r\n2.  I am inclined to work towards a implementation that supports the proposal from Cullen here :https://mailarchive.ietf.org/arch/msg/moq/bRFK0DQB3XBBaYGD_GsOJNZ9neg/ ( as referred to above https://github.com/moq-wg/moq-transport/issues/145#issuecomment-1648778532)\r\n\r\nThis will give us client picking the TrackId and also allowing the flexibility where the server can choose to TrackId. ",
          "createdAt": "2023-08-07T04:53:57Z",
          "updatedAt": "2023-08-07T04:53:57Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "\"A more flexible protocol is more complex to specify and implement; variations, especially those that are not commonly used, can create potential interoperability hazards. In the absence of strong reasons to be flexible, a simpler protocol is more likely to successfully interoperate.\" ([RFC 9413](https://www.rfc-editor.org/rfc/rfc9413.html#name-flexible-protocols))\r\n\r\nWe'd need a strong reason to support both.  So far I've heard a lot of good arguments in favor of the subscriber picking the ID, mostly because this means that the receiver doesn't have to deal with unknown IDs.  I seem to recall one argument in favor of the other approach (server wanting to store state in the subscription ID for incoming objects), but I believe we did resolve it (server acts as a subscriber in those contexts, so it can pick the ID under \"subscriber picks\" design).  If there are other arguments I am forgetting, please document them here.",
          "createdAt": "2023-08-07T10:16:40Z",
          "updatedAt": "2023-08-07T10:16:40Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> (server wanting to store state in the subscription ID for incoming objects), but I believe we did resolve it (server acts as a subscriber in those contexts,\r\n\r\nI am not sure if it got resolved or not. The current design in the spec is valid for one of the use-cases where the server announces a certain track and multiple subscribers request for the same track (say active speaker).  I do see merits with client/subscriber picking up the trackId too .. ",
          "createdAt": "2023-08-07T16:00:36Z",
          "updatedAt": "2023-08-07T16:29:35Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> 1. Control streams must always be sent at a higher priority\r\n\r\nUnfortunately, this doesn't matter much, since QUIC can coalesce multiple STREAM frames into a single packet. The small  SUBSCRIBE_OK will likely be received in the same packet as the first chunk of the OBJECT. In fact, even with multiple packets, QUIC libraries will use something like `recvmmsg` to receive and process multiple packets at once. The receiving QUIC library will then flush these to the application in an undefined order. \r\n\r\nIt's implementation dependent, but this will almost certainly result in a race. A single-threaded library like [Quiche](https://docs.rs/quiche/latest/quiche/struct.Connection.html#method.readable) might iterate based on stream ID, last received frame, or even random order. A multi-threaded library will almost certainly race, as they work by issuing a thread wakeup to the application thread blocked on the stream read.\r\n\r\nSo even with correct prioritization and zero packet loss, this race will occur on most QUIC implementations.\r\n\r\n> This will give us client picking the TrackId and also allowing the flexibility where the server can choose to TrackId.\r\n\r\nCan you or Cullen elaborate more what you mean by \"flexibility\"? It sounds like this is a performance concern, but I don't think it's been clearly stated why. In SF, Cullen briefly mentioned that this is a hardware concern, but a written description of the issue would help.\r\n\r\nNote that I'm proposing that the **_receiver_** chooses the `track_id`, regardless of if they are a server or client. You could still use the same `track_id` within your network if relays are deterministic. However, I'm still skeptical of the performance argument sans multicast QUIC.",
          "createdAt": "2023-08-07T19:20:11Z",
          "updatedAt": "2023-08-07T19:20:11Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just a note for myself that I don't think we have come to consensus in WG on this yet. ",
          "createdAt": "2023-10-03T15:08:04Z",
          "updatedAt": "2023-10-03T15:08:04Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Interim notes: There was consensus that the current draft has an issue that should be fixed.\r\n\r\nPreviously a compromise solution was to reject if the server wants to pick and then the client subscribes with that ID.\r\n\r\nChristian will write up a proposal for using two IDs (client and server) in the initial Objects until the subscriber knows the ID.",
          "createdAt": "2023-10-04T20:34:26Z",
          "updatedAt": "2023-10-04T20:34:26Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual comment: \r\n\r\nI reviewed #262, but wanted to keep this longer comment on the issue instead of the PR.  I may have rambled.  Bear with me.\r\n\r\nI have implemented a relay where each subscriber may be using a different track ID.  It has a little loop when forwarding an object, like this:\r\n\r\n```\r\nfor each moq_session, out_track_id in subscribers:\r\n  # override track_id in the object header with the per-subscriber one\r\n  moq_session.publish(out_track_id, obj_header, payload)\r\n```\r\n\r\nIn Christian's proposal, since not all subscribers will have confirmed the publisher chosen track id when an upstream object arrives and needs forwarding, I'm not sure the loop changes meaningfully.  I suppose I can have two loops, one over subscribers that are using the upstream track_id for this subscription and one not?  But I have a hard time seeing the win:\r\n\r\n```\r\nfor each moq_session in confirmed_subscribers:\r\n  # obj_header has the right track ID already, no override, yay!\r\n  moq_session.publish(obj_header, payload)\r\n\r\nfor each moq_session, out_track_id in unconfirmed_subscribers:\r\n  # these subscribers haven't confirmed using server chosen yet, pass the override\r\n  moq_session.publish(out_track_id, obj_header, payload)\r\n```\r\n\r\nWhat about cached objects?\r\n\r\nWhen the object is coming from cache, there may not be an upstream track ID anymore.  I'm not sure what track ID the relay would propose in Subscribe Ok in this case - does it make sense to cache the upstream track ID?  It's possible different objects in the same track were retrieved over different subscriptions (failover) so I think not.  So the 'serve from cache' path also needs to use the different track ID per subscriber path.  \r\n\r\nUpstream Track ID Collisions\r\n\r\nThere is also the case where the track ID being used by the relay's upstream for a given track is already taken on a particular downstream session.  This can happen when the relay routes subscriptions to two or more different upstreams:\r\n\r\n```\r\nS1 -- track \"A\" id = 1 -\\ \r\n                          R ------- C\r\nS2 -- track \"B\" id = 1 -/ \r\n```\r\n\r\nOne of these tracks also needs a per-subscriber track ID, even if we make no changes to the draft.  Maybe this is why hashing the track name is mentioned above -- that solves some things, though it would seem like it's sacrificing some of the compressive benefit of these IDs, and compressing a full-track-name is their primary function.\r\n\r\nClients publishing via Relays\r\n\r\nI believe clients and servers need to have independent number spaces for proposed vs publisher chosen track IDs (eg odd/even) to avoid a different type of race condition (see my comment on the PR).  Maybe I'm wrong, but if not this would mean that `C1 -- R -- C2` can never reuse a track ID, since C1 -> R would publish on track IDs with the opposite parity from R -> C2.\r\n\r\nCan we estimate the benefits?\r\n\r\nThe proponents of publisher chosen IDs have cited both memory and performance as potential reasons for requiring this (please add other reasons if I missed them).\r\n\r\nFor memory it can save 8 bytes per subscription with confirmed ID.  Is there any back-of-the-envelope math indicating this adds up to something significant?  What's the target number of active subscriptions per-server (1M, 10M, 100M, 1B)?\r\n  \r\nFor performance, we can write a benchmark comparing the cost writing the same object header +  payload vs unique object headers per payload for say, 100,000 subscribers.  What's the target for number of objects forwarded per-second per-server?\r\n\r\nIf we have rough numbers showing we cannot meet performance goals that would be a compelling reason to add the SUBSCRIBE CONFIRM.",
          "createdAt": "2023-10-05T03:15:05Z",
          "updatedAt": "2023-10-05T03:15:05Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry misclick on my phone ",
          "createdAt": "2023-10-05T03:42:42Z",
          "updatedAt": "2023-10-05T03:42:42Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": " > The proponents of publisher chosen IDs have cited both memory and performance as potential reasons for requiring this (please add other reasons if I missed them).\r\n> \r\n> For memory it can save 8 bytes per subscription with confirmed ID. Is there any back-of-the-envelope math indicating this adds up to something significant? What's the target number of active subscriptions per-server (1M, 10M, 100M, 1B)?\r\n\r\nSubscriber IDs are only going to use 1-2 bytes if they increment from 0 like QUIC stream IDs. This is beyond inconsequential. The only time it might matter is if there's an attack involving spurious subscriptions, in which case I would like to see `MAX_SUBSCRIBES` regardless.\r\n\r\nNote that the publisher could choose to cache the object using a 8 byte VarInt. It could then use memcopy to set the ID on a per subscription basis. This will slightly increase the OBJECT overhead on the wire, but so will using a random hash for the subscription ID (nearly 8 bytes on average).\r\n\r\nAnd like Victor said in the meeting, this is a performance non-issue if your QUIC library supports something like `iov` for writes. Each QUIC stream would share a pointer to the underlying OBJECT payload. The only difference is that the OBJECT header would be different per subscription, but again you could use iov to avoid any copies.\r\n\r\nThat's actually supported by Quinn and I use it on moq-rs. QUIC streams share a `Bytes` struct which is ref counted under the hood. I don't bother doing it with the OBJECT header though because it's like 4 bytes long and it's fine to make a copy.\r\n\r\nIf your QUIC library doesn't support `iov`, well then you're making a copy per QUIC stream anyway, even if the bytes are identical. This publisher side optimization is ONLY relevant if your QUIC library accepts a single pointer for the entire stream payload.",
          "createdAt": "2023-10-05T04:04:06Z",
          "updatedAt": "2023-10-05T04:06:06Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I started migrating to the current draft but I gave up.\r\n\r\nWith #258 every subscription is stored in a lookup table. When I receive an `OBJECT` or `SUBSCRIBE_*` message, I use a lookup table to fetch the current state. This is possible because `SUBSCRIBE` contains the `track_id`:\r\n\r\n```rust\r\nstruct Publisher {\r\n  // maps from track_id to subscription\r\n  subscriptions: HashMap<VarInt, track::Publisher>,\r\n}\r\n```\r\n\r\nI started implementing the current draft where `SUBSCRIBE_OK` contains `track_id`, and this is what I think is needed:\r\n```rust\r\nstruct Publisher {\r\n  // maps from (namespace, name) to subscription\r\n  subscriptions: HashMap<(String, String), track::Publisher>,\r\n\r\n  // maps from track_id to (namespace, name) after receiving SUBSCRIBE_OK\r\n  aliases: HashMap<VarInt, Deferred<(String, String)>>,\r\n}\r\n```\r\n\r\n`Deferred` doesn't exist in Rust but my point is that it's an asynchronous lookup table.  I need to check if there's an entry in `aliases` or create one, which will be resolved when/if `SUBSCRIBE_OK` arrives. My `OBJECT` decoder will block until `SUBSCRIBE_OK` arrives, which might actually never happen if an attacker sends OBJECTs with random `track_id`s.\r\n\r\nIt's just a pain in the butt. The performance arguments are moot if you need to perform a 2nd lookup for each OBJECT. I think you can avoid it with separate lookup tables, but that adds more complexity. The complexity is completely avoided if the subscriber chooses the `track_id`.\r\n\r\n#305 replaces `(String, String)` with `VarInt` but it's otherwise the same problem. ",
          "createdAt": "2023-11-03T05:45:11Z",
          "updatedAt": "2023-11-03T05:47:10Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Conclusion of the session was to add a way to reject a SUBSCRIBE and provide a different track ID, and have a separate Track ID from Subscribe ID.",
          "createdAt": "2023-11-09T17:00:50Z",
          "updatedAt": "2023-11-09T17:00:50Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Draft-02 allows the publisher to request a different track alias.",
          "createdAt": "2024-01-31T00:46:54Z",
          "updatedAt": "2024-01-31T00:46:54Z"
        }
      ]
    },
    {
      "number": 146,
      "id": "I_kwDOG2Ho4M5kaa50",
      "title": "Changes to moq-transport draft to make it compatible with separate media draft(s)",
      "url": "https://github.com/moq-wg/moq-transport/issues/146",
      "state": "CLOSED",
      "author": "wilaw",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This issue tracks changes necessary in https://github.com/kixelated/warp-draft/ in order to turn it in to definition of a generic transport that is compatible with external media draft(s). Changes are listed per section of https://kixelated.github.io/warp-draft/draft-lcurley-warp.html per commit [c57d17c] on April 22nd.\r\n\r\n**Abstract**\r\nUpdate text to remove reference to \"media\" and instead describe moq-transport as a generic transport for moving tracks of objects.\r\n\r\n**1. Introduction**\r\nUpdate language to remove media, and update section definitions as appropriate.\r\n\r\n**1.1 Terms and definitions**\r\nRemove definitions for codec, container, decoder, decode timestamp, encoder,frame, i-frame, group of pictures, group of samples, presentation timestamp, variant. To save effort, these definitions can be copied over to the relevant media format spec(s). \r\n\r\n**2.1 Objects**\r\nRemove references to \"media objects\". The model should be completely agnostic to the payload. \r\n\r\n**2.2 Groups**\r\nRedefine to be non media dependent.\r\n\r\n**2.3 track**\r\nRedefine to be non media dependent.\r\nPerhaps give a non media example in additional to the existing media example. \r\n\r\n**2.5 Example**\r\nRemove - this example is relevant in the media format spec. \r\n\r\n**3 Motivation**\r\nIMO this whole section can be removed. It is not necessary when defining a protocol to describe the background motivation for doing so. This could be relegated to an informative appendix, or else omitted completely. \r\n\r\n**4.1 Media**\r\nRemove this section. \r\n\r\n**4.2 Send order**\r\nRewrite to remove media references. \r\n\r\n**4.4 Decoder**\r\nRename to \"receiver\" and make less media dependent. Remove references to frame synchronization. \r\n\r\n**9.2 Object**\r\nRemove reference to payload being a media bitstream. \r\n\r\n**9.3 Catalog**\r\nCatalog definition needs to be written . All the moq-transport spec needs is  normative statement about 1) the reserved naming of the catalog track and 2) that the start of the catalog object payload must hold a cleartext  varint that defines the IANA registered media format type . Everything else about the catalog contents will be defined by the media format spec. \r\n\r\n**10 Setup parameters**\r\nRemove reference to media (replace 'media' with 'content' or 'data')\r\n[\r\n](https://datatracker.ietf.org/doc/draft-law-moq-catalog/)**12 Containers**\r\nRemove this section. It will be defined by media format spec. \r\n\r\n**13.1 Resource exhaustion**\r\nMake media independent\r\n\r\n**14 IANA considerations**\r\nmoq-transport needs to define a new IANA registry for MOQ Media Formats (name tbd). See https://datatracker.ietf.org/doc/draft-law-moq-catalog/ section 5 for an example. \r\n\r\n**15 Appendix A Video encoding**\r\nRemove this entire appendix.\r\n\r\n**16 Appendix B: Object Examples**\r\nRemove. This can be added to the appropriate media format spec. \r\n",
      "createdAt": "2023-04-26T09:31:16Z",
      "updatedAt": "2023-05-26T23:55:21Z",
      "closedAt": "2023-05-26T23:55:20Z",
      "comments": [
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "At a quick skim of above.- looks about right to me. For me, this is all pretty much editorial and sure the editors will do a fine job of it. ",
          "createdAt": "2023-04-28T16:23:37Z",
          "updatedAt": "2023-04-28T16:23:37Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "How does #150 sound?",
          "createdAt": "2023-05-03T22:10:24Z",
          "updatedAt": "2023-05-03T22:10:24Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Did #156 address this issue?",
          "createdAt": "2023-05-26T00:12:29Z",
          "updatedAt": "2023-05-26T00:12:29Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "This is done.  We probably want an issue to discuss the changes @wilaw wanted to add in #175.",
          "createdAt": "2023-05-26T23:55:20Z",
          "updatedAt": "2023-05-26T23:55:20Z"
        }
      ]
    },
    {
      "number": 150,
      "id": "I_kwDOG2Ho4M5lBlMd",
      "title": "Proposal: ANNOUNCE catalog tracks",
      "url": "https://github.com/moq-wg/moq-transport/issues/150",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Needs Discussion"
      ],
      "body": "### Current\r\nThe publisher sends a CATALOG message is used to announce valid track names and an init payload. The init payload contains metadata used by the application to select acceptable tracks.\r\n\r\n### Problems\r\n- #66 The CATALOG message is specific to media, and should be made more generic to support other use-cases.\r\n- No support for multiple CATALOGs, including multiple formats or versions.\r\n- No support for CATALOG updates.\r\n\r\n### Proposed\r\n- Create a track for each catalog.\r\n  - All track contents are delegated to a separate draft, such as: https://github.com/wilaw/MoQ\r\n  - Note that the catalog may initialization information, so it may be required.\r\n- Create a registry of track formats.\r\n- The publisher(s) ANNOUNCEs the available track name and format pairs.\r\n  - Sent on the SETUP control stream with #138 to avoid a round trip.\r\n- The consumer(s) SUBSCRIBEs to the catalog track to learn more about track metadata.\r\n  - An endpoint may subscribe to all tracks to avoid this round trip.\r\n  - An application may negotiate out-of-bound to skip this round trip.\r\n- The consumer(s) SUBSCRIBEs to individual tracks.\r\n\r\n\r\n### Pros\r\n- Tracks are used for catalog transfer and updates.\r\n- Multiple catalogs formats can be offered simultaneously, describing the same data tracks.\r\n- The catalog format may be increased for major versions. (ex. moq v1 and moq v2)\r\n- The catalog is not required to determine the track format.\r\n- The transport protocol is media-agnostic.\r\n- Makes catalog transfer optional.\r\n\r\n### Cons\r\n- Requires a track format registry.\r\n- Leaks the format of each track.\r\n\r\n\r\n### Examples\r\n```\r\ncontribution-generic (client -> server):\r\n-> SETUP\r\n-> ANNOUNCE (name=catalog format=cmaf-init), (name=video format=cmaf-data), (name=audio format=cmaf-data)\r\n<- SETUP\r\n<- SUBSCRIBE id=1 name=catalog\r\n-> OBJECT id=1\r\n<- SUBSCRIBE id=2 name=video\r\n<- SUBSCRIBE id=3 name=audio\r\n-> OBJECT id=2\r\n-> OBJECT id=3\r\n(3 rtts)\r\n```\r\n\r\n```\r\ncontribution-all (client -> server):\r\n-> SETUP\r\n-> ANNOUNCE (name=catalog format=cmaf-init), (name=video format=cmaf-data), (name=audio format=cmaf-data)\r\n<- SETUP\r\n<- SUBSCRIBE id=1 name=catalog\r\n<- SUBSCRIBE id=2 name=video\r\n<- SUBSCRIBE id=3 name=audio\r\n-> OBJECT id=1\r\n-> OBJECT id=2\r\n-> OBJECT id=3\r\n(1.5 rtts)\r\n```\r\n\r\n```\r\ndistribution-generic (client -> server):\r\n-> SETUP\r\n<- SETUP\r\n<- ANNOUNCE (name=catalog format=cmaf-init), (name=video format=cmaf-data), (name=audio format=cmaf-data)\r\n-> SUBSCRIBE id=1 name=catalog\r\n<- OBJECT id=1\r\n-> SUBSCRIBE id=2 name=video\r\n-> SUBSCRIBE id=3 name=audio\r\n<- OBJECT id=2\r\n<- OBJECT id=3\r\n(3 rtts)\r\n```\r\n\r\n```\r\ndistribution-all (client -> server):\r\n-> SETUP\r\n<- SETUP\r\n<- ANNOUNCE (name=catalog format=cmaf-init), (name=video format=cmaf-data), (name=audio format=cmaf-data)\r\n-> SUBSCRIBE id=1 name=catalog\r\n-> SUBSCRIBE id=2 name=video\r\n-> SUBSCRIBE id=3 name=audio\r\n<- OBJECT id=1\r\n<- OBJECT id=2\r\n<- OBJECT id=3\r\n(2 rtts)\r\n```",
      "createdAt": "2023-05-03T22:08:13Z",
      "updatedAt": "2023-08-07T21:16:44Z",
      "closedAt": "2023-08-07T21:16:44Z",
      "comments": [
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@kixelated  - thanks for stubbing this out. I find that the ANNOUNCE messages proposed here are almost exact duplicates of the contents of the catalog. The purpose of the catalog is 3-fold:\r\n1. To list the track names that are available for subscription as part of the content \"bundle\"\r\n2. To describe all the attributes of the track that the client may need for track selection \r\n3. To provide initialization data for each track. \r\n\r\nBy having to ANNOUNCE each track, the client is duplicating what is already inside the catalog. The catalog IS the announcement of what the server is making available for subscription. \r\n\r\nThis proposal also assumes that \"formats\" can be scoped to \"tracks\". This works in the overly simplistic assumption that one \"format\" differs from another only in the container or codec that is used and that the tracks can be consumed independently of one another. In reality, tracks may be tied to one another. A current example would be SVC layers. A more advanced example would 3D environments where 10 tracks, in a hierarchical tree, must be consumed in order to receive the correct spatial vertex and shader information. We cannot describe the complexity of all of that, and the relationships, in ever expanding key-value pairs in ANNOUNCE messages. The role of the catalog is to abstract away all that complexity of what's in tracks and how tracks are related to one another and what tracks constitute the \"bundle\". \r\n\r\nI would propose an alternate solution that accommodates the complexity described above and that allows multiple concurrent streaming formats to be offered by the same publisher, with the same or lower RTT counts\r\n\r\n```\r\ndistribution-generic (client -> server), single streaming format:\r\n-> SETUP\r\n-> SUBSCRIBE id=1 name=catalog\r\n<- SETUP\r\n<- OBJECT id=1\r\n-> SUBSCRIBE id=2 name=video\r\n-> SUBSCRIBE id=3 name=audio\r\n<- OBJECT id=2\r\n<- OBJECT id=3\r\n(2 rtts instead of 3)\r\n```\r\n\r\nIn the rare case where a publisher wants to output two streaming formats simultaneously, the primary catalog would reference two other tracks which are themselves catalogs. It would look like this\r\n\r\n```\r\ndistribution-generic (client -> server):\r\n-> SETUP\r\n-> SUBSCRIBE id=1 name=catalog\r\n<- SETUP\r\n<- OBJECT id=1\r\n-> SUBSCRIBE id=2 name=catalog-for-format-A\r\n-> SUBSCRIBE id=3 name=catalog-for-format-B\r\n<- OBJECT id=2\r\n<- OBJECT id=3\r\n-> SUBSCRIBE id=4 name=A-video\r\n-> SUBSCRIBE id=5 name=B-video\r\n<- OBJECT id=4\r\n<- OBJECT id=5\r\n(3 rtts)\r\n```",
          "createdAt": "2023-05-03T23:43:06Z",
          "updatedAt": "2023-05-03T23:43:06Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Can someone explain what is client and sever in all these cases . ",
          "createdAt": "2023-05-04T01:03:29Z",
          "updatedAt": "2023-05-04T01:03:29Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "For my understanding on things below, here are the definitions I will be using\r\n\r\nDistribution Scenarios\r\n-----------------------\r\nEndpoint Consumer (client)\r\nDistribution Server/Conference Server (server)\r\n\r\nCouple of points or observations :\r\n\r\nfor end-point subscribers interested in receiving media from a conference or from a distribution server, I think I am leaning towards:\r\n\r\n - the invariant is, the consumer app knows the catalog trackId and it subscribes to it and rest of the steps from there on flows as defined by the contents  of the catalog\r\n- Also MoQ Transport should not mandate subscribing to the catalog as the first step, since it's application choice. Some applications may choose to get catalog obtained as part of out-of-band step too. \r\n\r\n",
          "createdAt": "2023-05-04T03:25:58Z",
          "updatedAt": "2023-05-04T14:21:00Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "I do think the contribution proposal is mixing capabilities exchange and catalog exchange all in the announce. Agree with @wilaw  that exposing internals of catalog will eventually cause announce to replicate the entire catalog and which is not useful for relays or will expose privacy sensitive information to them\r\n\r\nContribution Scenarios\r\n-----------------------\r\nEndpoint Producer like obs-client(client)\r\nIngest Server/Conference Server (server)\r\n\r\n\r\n```\r\ncontribution-generic (client -> server):\r\nOut of band (may be in or out of  moq-transport)\r\n-> Capabilities [media format info, quality info, ..]\r\n<- Catalog with tracks listed\r\n-> SETUP\r\n-> ANNOUNCE (track-0 + token, track-1 + token, track-2 + token)\r\n<- SETUP\r\n<- ANNOUNCE OK\r\n<- SUBSCRIBE id=X, track-0 // to get the catalog track and updates \r\n<- SUBSCRIBE id=y, track-1 \r\n<- SUBSCRIBE id=z, track-2 \r\n-> OBJECT id=X\r\n-> OBJECT id=y\r\n-> OBJECT id=z\r\n-> \r\n(2 rtts)\r\n```\r\n\r\nI am happy to help write the capability exchange text for MoQ if others are interested. ",
          "createdAt": "2023-05-04T03:29:13Z",
          "updatedAt": "2023-05-04T04:56:31Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> Can someone explain what is client and sever in all these cases .\r\n\r\nThe client sends CONNECT/SETUP and the server replies with CONNECT/SETUP. Otherwise, the protocol is bidirectional and there's no distinction between client or server. \r\n\r\n> By having to ANNOUNCE each track, the client is duplicating what is already inside the catalog. The catalog IS the announcement of what the server is making available for subscription.\r\n\r\nI would think ANNOUNCE as the generic transport catalog, advertising sub-protocols and entry points. For example, the MoQ protocol via the `catalog` track (format `0x1`) and/or a chat protocol via the `chat` track (format `0xff54`). \r\n\r\nAlternatively, we could have something like ALPN, where the protocol is announced in the SETUP message. The media and chat protocols would have to use separate WebTransport sessions which is probably fine.\r\n\r\n\r\n> This proposal also assumes that \"formats\" can be scoped to \"tracks\".\r\n\r\nThe intention is mainly to announce entry points. Advertising nested tracks, like video/audio in the example, might be useful but it should be optional. It only removes a RTT if the consumer is unequivocally willing to receive an announced track.\r\n\r\nI personally agree with your assessment that an endpoint should parse the media catalog, or delegate to an entity that has, before subscribing to a track. But I can also envision dumb relays that subscribe to everything instead of waiting for a downstream subscribe.\r\n\r\n\r\n> I would propose an alternate solution that accommodates the complexity described above and that allows multiple concurrent streaming formats to be offered by the same publisher, with the same or lower RTT counts\r\n\r\nThere's a few problems with that proposal:\r\n\r\n1. There's no way for the consumer to know the fully qualified name of the catalog track. (ex. `webex.com/meeting123/user456/catalog`)\r\n2. There's no way for a publisher to send an auth token per track.\r\n\r\nThese are the motivations behind PUBLISH in #127. This ANNOUNCE is basically a compromise between the current CATALOG message and the suite of PUBLISH messages.\r\n\r\nPersonally, I'm a huge fan of your approach and I did pitch it during the weekly call. It would require scoping track names and authentication to the session. I strongly prefer that over \"globally unique\" track names and authentication per track.\r\n\r\nAlso:\r\n\r\n3. There's no way to support multiple protocols over the same session. (ex. moq and chat tracks)\r\n\r\nI think this can be solved by throwing fields into the SETUP header. For example, `MOQ=3` would flag that the endpoint supports MoQ version 3, and that draft would specify the a consumer should immediately issue `SUBSCRIBE catalog`.",
          "createdAt": "2023-05-04T06:57:25Z",
          "updatedAt": "2023-05-04T07:03:51Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> There's no way for the consumer to know the fully qualified name of the catalog track. (ex. webex.com/meeting123/user456/catalog)\r\n\r\nThe consumer is given that. They have to be given something to \"play\". In fact they have to be given two pieces of information 1) the WebTransport or QUIC address to connect to the edge relay and 2) The content \"bundle\" that they want to play. In the case of WebTransport, these can both be supplied in the same URL. For example\r\n\r\n`https://cdn.example.com/accessToken/routingInfo/webex.com/meeting123/user456/catalog`\r\n\r\nThe first component `cdn.example.com/accessToken/routingInfo/` is used to connect to the edge relay and authenticate the connection. The remainder of the path `webex.com/meeting123/user456/catalog` is the content the client wishes to consume. Since the full path is sent in CONNECT, the server could immediately subscribe the client to the catalog track and send the catalog contents. This removes 1 RTT in the startup. \r\n\r\n> There's no way for a publisher to send an auth token per track.\r\n\r\nCouldn't the publisher add an auth token in each object that it sends? We'd want some sort of alias substitution to reduce the wire overhead, but this seems feasible. ",
          "createdAt": "2023-05-04T19:36:59Z",
          "updatedAt": "2023-05-04T19:36:59Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> Couldn't the publisher add an auth token in each object that it sends? We'd want some sort of alias substitution to reduce the wire overhead, but this seems feasible.\r\n\r\nPUBLISH_REQUEST or ANNOUNCE (as it is called now) , has auth token in it",
          "createdAt": "2023-05-04T20:58:38Z",
          "updatedAt": "2023-05-04T20:58:38Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing my proposals. Discussing the individual issues is more productive.",
          "createdAt": "2023-08-07T21:16:43Z",
          "updatedAt": "2023-08-07T21:16:43Z"
        }
      ]
    },
    {
      "number": 151,
      "id": "I_kwDOG2Ho4M5lC7Gh",
      "title": "ROLE doesn't support negotiation",
      "url": "https://github.com/moq-wg/moq-transport/issues/151",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Handshake"
      ],
      "body": "The SETUP message contains a ROLE parameter. In the current draft, the client specifies the value, indicating if the client will send data (0x1), if the server will send data (0x2), or if both endpoints will send data (0x3).\r\n\r\nA conferencing client supports the ability to send and receive media, and would always send role=0x3 because it supports both functionalities. However, it's unaware of the server functionality, and the server has no way of informing the client if it intends to send media. This matters because a generic client needs to know if it shows a black screen and/or should send a SUBSCRIBE message (ex. for /catalog).\r\n\r\nI propose that both endpoints send the ROLE parameter: 0x1 = publisher, 0x2 = consumer, 0x3 = both. This gives the server the ability to specify its own functionality.",
      "createdAt": "2023-05-04T05:04:48Z",
      "updatedAt": "2024-02-23T18:00:55Z",
      "closedAt": "2024-02-23T18:00:55Z",
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Wondering if we even need Role in the first place .. can it be changed mid-session ?\r\n\r\nSay the use-case\r\n- Participant in media conference joins as subscriber only since he is driving and want to listen in\r\n- Then at some point mid session , he wants to contribute and he now becomes as publisher and subscriber\r\n\r\nwhat is the expected flow in this case ?",
          "createdAt": "2023-05-05T00:55:17Z",
          "updatedAt": "2023-05-05T00:55:46Z"
        },
        {
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "body": "Current draft doesn't really explain what ROLE parameter is for, only that client needs to send it - what was original idea? Why not just always allow everyone to send and receive data?",
          "createdAt": "2023-05-05T15:47:04Z",
          "updatedAt": "2023-05-05T15:47:04Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It seems a better way to control if you can send and receive might just be if the client has the appropriate auth tokens for each role. I lean towards remove this if we don't need it, but if we need it, I have would be fine with a design where the client says which roles it is capable of , and the server response contains which roles it is allowed to do. ",
          "createdAt": "2023-05-05T16:25:36Z",
          "updatedAt": "2023-05-05T16:25:36Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I think ROLE is good for negotiating half-functionality.\r\n\r\n- If the remote endpoint cannot send media (ex. player), then sending a SUBSCRIBE is invalid.\r\n- If the remote endpoint cannot receive media (ex. OBS), then sending a ANNOUNCE/OBJECT is invalid.\r\n\r\nThis removes a burden on implementations, as most will only care about specific role. \r\n\r\n\r\n@suhasHere brings up a good point. If an endpoint _could_ switch roles, then it should advertise full functionality. That would include publishing an empty catalog which it can append it later when it wishes to publish tracks.",
          "createdAt": "2023-05-05T18:35:45Z",
          "updatedAt": "2023-05-05T18:38:01Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think I seem much use for the Role - it seems like something the application would know at a higher layer. But I have no objection to including it if others do see a need for it. It's not like it makes life harder for applications that don't use it. ",
          "createdAt": "2023-05-19T14:41:36Z",
          "updatedAt": "2023-05-19T14:41:36Z"
        },
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "If the ROLE is used to enforce the half-functionality, then it needs to be clear what should be done when invalid message is received. Sending a GOAWAY? Sending a generic error message? Does the connection need to be terminated? I think most of the time, application will just choose the full functionality in case of role switching on the fly and avoid the invalid response code(just ignore the invalid message).",
          "createdAt": "2023-06-05T07:57:14Z",
          "updatedAt": "2023-06-05T07:57:14Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh hey, I found a good use-case for ROLE.\r\n\r\nIf my client connects with ROLE=publisher, then the server knows that it should not send ANNOUNCE messages. The messages are useless and actually triggered a deadlock in my broadcaster, since the application was not reading them and overflowed the receive channel. The same would be true with the reverse; a subscriber will not be able to process any SUBSCRIBE messages.\r\n\r\nI like the ability to specify half-functionality. At the very least the library should support half-functionality (ex. automatically reply with ANNOUNCE_ERROR) but it's even better if it's enforced by the protocol.",
          "createdAt": "2023-08-22T19:47:57Z",
          "updatedAt": "2023-08-22T19:49:35Z"
        }
      ]
    },
    {
      "number": 152,
      "id": "I_kwDOG2Ho4M5lOhSD",
      "title": "Proposal: AUTH message",
      "url": "https://github.com/moq-wg/moq-transport/issues/152",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I propose combining authentication for distribution/contribution into a single mechanism.\r\n\r\n### Problem\r\nMETA: Should I file these as issues or do we have too many issues already?\r\n\r\n* Tracks typically share authentication, however authentication is currently performed per-track.\r\n  * #122 for SUBSCRIBE \r\n  * #123 for ANNOUNCE\r\n* These messages duplicate the authentication surface area.\r\n  * An implementation has to correctly implement authentication for both SUBSCRIBE and ANNOUNCE, or risk a security hole.\r\n  * Since they are almost identical, this will involve some copy-pasting.\r\n  * This will become worse if we add more messages that require authentication.\r\n* How authentication is actually performed is out of scope, thus any mechanism needs to be extensible. \r\n  * Adding a token to ANNOUNCE/SUBSCRIBE only handles a small subset of possible authentication approaches.\r\n  * Other authentication options will involve a more complex handshake (ex. challenges).\r\n* Per-track authentication can drift, causing situations where authentication for tracks expires at different times.\r\n  * For example, a relay may apply a fixed TTL to each SUBSCRIBE.\r\n  * If ABR occurs for video but not for audio, then the audio track will expire before the video track. This will cause up to TTL duration of video but no audio after authentication is revoked.\r\n\r\n\r\n### Proposal\r\nDelegate authentication to a dedicated AUTH message.\r\n\r\n0. The server MAY authenticate a session based on the CONNECT/SETUP URL.\r\n   - This is vendor specific and is quite limited.\r\n2. The client creates a control stream, which must start with SETUP. See: #138.\r\n3. Either endpoint MAY send an AUTH message over the control stream.\r\n   - Includes a unique ID\r\n   - Includes a schema from a registry.\r\n   - An agnostic relay MAY forward this message rather than parse it.\r\n4. The AUTH message applies to any future messages on the control stream.\r\n   - ie. ANNOUNCE for publishers\r\n   - ie. SUBSCRIBE for subscribers\r\n4. The other endpoint MUST respond with an AUTH_REPLY.\r\n   - Include the AUTH ID to avoid race conditions.\r\n   - An agnostic relay MAY forward this message rather than parse it.\r\n\r\n\r\nThe contents of the AUTH message are beyond my realm of expertise. The payload would depend on the schema.\r\n\r\n```\r\nAUTH {\r\n  ID (v)\r\n  Schema (v)\r\n  Payload Length (v)\r\n  Payload (..)\r\n}\r\n\r\nAUTH_REPLY {\r\n  ID (v)\r\n  Payload Length (v)\r\n  Payload (..)\r\n}\r\n```\r\n\r\nWe could define schema=0 as a token with an expiration duration. \r\n\r\n### Discuss\r\nIf an wishes to use multiple authentication schemes, it could either:\r\n1. Send multiple AUTH messages, all of which are simultaneously active.\r\n2. Send multiple AUTH messages, with SUBSCRIBE/ANNOUNCE including an AUTH ID (or 0 for unauthenticated).\r\n3. Create multiple control streams (aka \"sessions\"), and only the most recent AUTH message is active.\r\n\r\nThere may be fields that should be schema independent:\r\n1. \"expires\" could be exposed, so a relay would know when to reissue an AUTH. However this assumes the AUTH payload should not change, which is not true for many auth mechanisms.\r\n2. \"code\" / \"reason\" could be exposed, so we could share error messages between schemas.\r\n3. Nothing could be exposed, and all authentication can be delegated to another draft.\r\n   - Including how to encode the above fields into the payload.\r\n\r\n### Pros\r\n* Authentication is combined into a single message.\r\n* Ability to delegate to existing authentication schemes and other drafts.\r\n* Reduced size/duplication of SUBSCRIBE/ANNOUNCE messages.\r\n* Track authentication is synchronized.\r\n* A relay can forward AUTH messages upstream independent of SUBSCRIBE messages.\r\n   * ex. delegate AUTH to the origin, but coalesce with other subscriptions on OK.\r\n\r\n\r\n### Cons\r\n* Two more messages, and another draft to read.\r\n* Each of the options in discuss has a downside.",
      "createdAt": "2023-05-05T23:30:13Z",
      "updatedAt": "2023-06-08T21:19:55Z",
      "closedAt": "2023-06-08T21:19:54Z",
      "comments": [
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So however we do this, I think we need one section of the base draft that describes it and it would be the same code regardless of how many messages used it. \r\n\r\nFrom a requirements point of view, for many use cases, the authorization to publish has to be separate from the authorize to subscribe or else you have the case where any viewer can poison the cache. ",
          "createdAt": "2023-05-19T14:38:22Z",
          "updatedAt": "2023-05-19T14:38:22Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm going to close this because I don't really care too much about authentication to advocate for it. It's less useful now that there's a single ANNOUNCE per namespace, instead of ANNOUNCE per track. However I do want to see authentication fleshed out eventually.",
          "createdAt": "2023-06-08T21:19:54Z",
          "updatedAt": "2023-06-08T21:19:54Z"
        }
      ]
    },
    {
      "number": 153,
      "id": "I_kwDOG2Ho4M5lXjCu",
      "title": "Refactor to have general publisher/subscriber section",
      "url": "https://github.com/moq-wg/moq-transport/issues/153",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Editorial"
      ],
      "body": "",
      "createdAt": "2023-05-08T17:57:05Z",
      "updatedAt": "2023-10-18T02:44:40Z",
      "closedAt": "2023-10-18T02:44:40Z",
      "comments": [
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The easiest to review diffs on a change like this is if we did one PR that did not add or delete any text but only moved it. Then after that a PR that made the changes to text to fix up the text to make sense in after the move. We did when writing the JSEP draft and it made things way easier to review.  \r\n\r\nI am hoping the relay section is super short. ",
          "createdAt": "2023-05-19T14:34:10Z",
          "updatedAt": "2023-05-19T14:34:10Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Given there are adjacent sections about publisher and subscribers, I'm going to close this unless there's an issue that needs fixing: https://github.com/moq-wg/moq-transport/blob/main/draft-ietf-moq-transport.md#subscriber-interactions",
          "createdAt": "2023-10-18T02:44:40Z",
          "updatedAt": "2023-10-18T02:44:40Z"
        }
      ]
    },
    {
      "number": 154,
      "id": "I_kwDOG2Ho4M5ll8nK",
      "title": "Proposal: Full Track Name to include emitter information",
      "url": "https://github.com/moq-wg/moq-transport/issues/154",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As part of the announce message discussions, there has been discussions around using shortest common prefix to announce rather than listing all the tracks to keep the CDN table updates performance under control. \r\n\r\nSee Will Law's comment at https://github.com/kixelated/warp-draft/pull/123#discussion_r1188892031\r\n\r\n\r\nThe proposal is to extend Full Track Name to include reference to Emitter who is responsible for publishing the media as defined below\r\n\r\n\r\n\r\nIf we have full track name defined as \r\n```\r\nFull Track Name = Track Namespace + \"/\" + Emitter Id + \"/\" + Track Name\r\n```\r\nwhere emitter  is something like defined in https://datatracker.ietf.org/doc/html/draft-nandakumar-moq-arch-00#section-2.1.1\r\n\r\n\r\nIn that case Announce is defined as \r\n\r\n```\r\nAnnouce {\r\n   Track Reference,\r\n   [Params]\r\n}\r\n```\r\nwhere Track Reference is\r\n\r\n```\r\nTrack Reference = Track Namespace + \"/\" + Emitter Id\r\nor \r\nTrack Reference =  Full Track Name\r\n\r\n```\r\n\r\n\r\nThe same can be extended to Subscribes too, however to support granularity on subscription start point, one need to do it a the track level using Full track Name, which seems to be fine too.\r\n\r\n```\r\nSubscribe Request {\r\n  Track Reference,\r\n  Params\r\n}\r\n\r\n```",
      "createdAt": "2023-05-10T18:37:44Z",
      "updatedAt": "2023-08-08T05:34:30Z",
      "closedAt": "2023-08-08T05:34:30Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Commenting as an individual:\r\n\r\nIs either the namespace itself or the emitter ID used by the transport, or is a prefix string match sufficient at this level?  If either or both are required, then I prefer sending them as structured data rather than a string whenever possible, since it avoids having to parse out the bits.",
          "createdAt": "2023-05-12T16:18:39Z",
          "updatedAt": "2023-05-12T16:18:39Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "We talked about this on Friday, but I want to avoid splitting the track name into parts UNLESS those parts change how an endpoint operates. The application should be responsible for any schema if it wants to encode information in the track name.\r\n\r\nSo you should start with a proposal on what the emitter ID would be used for. It could be useful for some form of authentication scheme but that needs to be fleshed out first.",
          "createdAt": "2023-05-17T17:10:21Z",
          "updatedAt": "2023-05-17T17:13:55Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Has the consensus around track naming in #162 resolved this @suhasHere, or would you still like to see Emitter explicitly in FTN?",
          "createdAt": "2023-05-26T00:11:50Z",
          "updatedAt": "2023-05-26T00:11:50Z"
        }
      ]
    },
    {
      "number": 157,
      "id": "I_kwDOG2Ho4M5mR-3-",
      "title": "Proposal: Sync terminology between transport and arch draft",
      "url": "https://github.com/moq-wg/moq-transport/issues/157",
      "state": "OPEN",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Parked"
      ],
      "body": "PR #156  is updating the transport draft with few terminology , which is fine. However it would be nice to consider the roles/entities terminology defined in https://datatracker.ietf.org/doc/html/draft-nandakumar-moq-arch-00 \r\n\r\nIt would be good to drive these from security perspective and thus defining roles.\r\n\r\nProposal is to review the terminology in arch-00 spec and either bring in them once we are happy or refer to the arch spec as informative reference in the current spec.\r\n",
      "createdAt": "2023-05-18T17:21:46Z",
      "updatedAt": "2024-02-20T02:34:09Z",
      "closedAt": null,
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "For reference, here's the delta between the draft (including 156) and the arch draft:\r\n\r\n**Publisher**:\r\npublishes tracks and transmits objects over the network.\r\nvs\r\npublish MoQ Objects belonging to a given track using the MoQ Transport Protocol.\r\n\r\n**Subscriber:**\r\nrequests tracks and receives objects over the network.\r\nvs\r\nsubscribe to receive MoQ Objects corresponding to a track using the MoQ Transport Protocol.\r\n\r\n_These seem largely the same, just slightly different word choices._\r\n\r\n**Producer** - The initial publisher that encodes tracks and objects.\r\nvs\r\n**Emitter** - Trusted with E2E encryption keys for the media and operate on one or more uncompressed and unencrypted media.  They compress and possibly encrypt and transmit over one or more Data Streams.\r\n\r\n**Consumer** - The final subscriber that decodes tracks and objects.\r\nvs\r\n**Receiver** - Trusted with E2E keys and can transform the Encrypted Stream into Encoded Stream and decode the encoded stream to source stream for further consumptions\r\n\r\n_For Producer/Emitter and Consumer/Receiver - I'm not highly opinionated and possible bikeshed?  We can vote (hum?!) in the next authors call._\r\n\r\n_The main difference is the explicit mention of keys.  Do we need that in the transport draft, or is it sufficient perhaps to say these roles have access to the raw media (not opaque), considering some but not all tracks/objects will be e2e encrypted?_\r\n\r\n**Relay**:\r\nsubscribes to endpoints and publishes to other endpoints. Relays typically perform deduplication and caching as part of a distributed system.\r\nvs\r\nTrusted with E2E encryption keys.\r\nEntities performing Relay role implement store and forward behavior.  Such entities receives subscriptions and publishes data to the other endpoints that have subscribed to the named data.  They may cache the data as well for optimizing the delivery experience.  Since these entities are not trusted with the E2E keys, they cannot access unencrypted MoQ Object Payload, however they are allowed to access the MoQ Object Header.\r\n\r\n_These definitions are largely the same, with some additional examples in the arch version, plus the mention of keys.  The same question about keys applies._\r\n\r\nThe arch draft has 3 additional roles not mentioned here: Catalog Maker, Key Manager and Media Transformer.  I'm not sure these are needed in the base transport draft now that it has been pared back, but the informative text there is useful for understanding the overall system.\r\n\r\nThe working group hasn't spent a lot of time reviewing and discussing this architecture draft yet, so I'm wary of including a reference to it at this time may slow transport adoption.  If/when the wg puts it on the path to adoption, then references might be beneficial.",
          "createdAt": "2023-05-18T22:00:36Z",
          "updatedAt": "2023-05-18T22:00:36Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I have a slight preference for Consumer over Receiver. ",
          "createdAt": "2023-05-19T14:23:26Z",
          "updatedAt": "2023-05-19T14:23:26Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@afrind agreed.  Even for cases where they are not end to end encrypted, the roles does need to talk about it. Relay Role for example are not expected to access/modify raw media or cannot access the raw media. \r\nI am happy to amend the definitions in the arch spec to reflect non-e2ee cases\r\n\r\nDriving the terminology based on the roles will help us to reason about the system as we start add more details.",
          "createdAt": "2023-05-20T01:37:05Z",
          "updatedAt": "2023-05-20T01:37:17Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Consumer seems sensible, would someone like to write a PR?",
          "createdAt": "2023-07-24T21:25:49Z",
          "updatedAt": "2023-07-24T21:25:49Z"
        }
      ]
    },
    {
      "number": 158,
      "id": "I_kwDOG2Ho4M5mXh1t",
      "title": "Draft-05: Organize priority text into one section ",
      "url": "https://github.com/moq-wg/moq-transport/issues/158",
      "state": "CLOSED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "We have text spread in section 4.2 , 6.1, 6.2,  and 7 that seems like it should all be in just one place with pointers from the other locations. ",
      "createdAt": "2023-05-19T15:35:20Z",
      "updatedAt": "2023-05-26T23:20:36Z",
      "closedAt": "2023-05-26T23:20:36Z",
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "+1  .. my reading of the draft is that it is very confusing. I am happy to take a stab at refactoring.\r\n\r\nDepends on https://github.com/kixelated/warp-draft/pull/156",
          "createdAt": "2023-05-19T15:46:11Z",
          "updatedAt": "2023-05-19T16:04:07Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "This is done - Section 4.",
          "createdAt": "2023-05-26T23:20:36Z",
          "updatedAt": "2023-05-26T23:20:36Z"
        }
      ]
    },
    {
      "number": 159,
      "id": "I_kwDOG2Ho4M5mY0EA",
      "title": "Document full contribution and distribution flow",
      "url": "https://github.com/moq-wg/moq-transport/issues/159",
      "state": "OPEN",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "NotTransport"
      ],
      "body": "Here's what I think the full flow looks like. It hasn't been explicitly stated, and maybe that's the source of some disagreements.\r\n\r\n### Step 1 - Producer configuration\r\nA producer (ex. OBS) is given a few pieces of information:\r\n- `connect_url`: Used to establish the WebTransport/QUIC connection.\r\n- `track_namespace`: Used to identify the broadcast.\r\n- `auth`: Any authentication details that need to be provided.\r\n\r\n### Step 2 - Producer catalog\r\nThe producer creates a catalog that contains any number of tracks. Each track has:\r\n- `track_namespace`: (optional) if not provided, the track inherits the catalog namespace.\r\n- `track_name`: This is specific to the application (ex. \"audio\", \"video_480p\", etc).\r\n- `media_properties`: Indicates how media is encoded, and how tracks are related to each other.\r\n\r\n### Step 3 - Producer connect\r\nThe producer establishes the QUIC connection to the provided `connect_url`.\r\n\r\n### Step 4 - Producer announce\r\nWhen it is ready, the producer sends an ANNOUNCE containing: \r\n- `track_namespace`\r\n- `auth`\r\n\r\nThe server replies with ANNOUNCE OK. The broadcast is now ready for consumption.\r\n\r\n### Step 5 - Consumer configuration\r\nA consumer (ex. VLC) is given a few pieces of information:\r\n- `connect_url`\r\n- `track_namespace`\r\n- `auth`\r\n\r\n### Step 6 - Consumer connect\r\nThe consumer establishes the QUIC connection to the provided `connect_url`.\r\n\r\n### Step 7 - Consumer catalog\r\nThe consumer issues a SUBSCRIBE for the catalog:\r\n- `track_namespace`\r\n- `track_name`: `catalog` or `/` (TODO)\r\n- `auth`\r\n\r\n### Step 8 - Relay routing\r\nAny intermediate relay (optional with peer-to-peer) will route the SUBSCRIBE to the publisher. SUBSCRIPTIONS may be deduplicated and cached if the relay is able to perform authentication.\r\n\r\nThe producer replies with a SUBSCRIBE OK and transmits OBJECTs for the requested track. The OBJECTs flow back over the same connection as the SUBSCRIBE until they reach the consumer(s).\r\n\r\n### Step 9 - Consumer parses catalog\r\nThe consumer receives the catalog and parses it. For each track, it learns:\r\n- `track_namespace`\r\n- `track_name`\r\n- `media_properties`\r\n\r\n### Step 10 - Consumer subscribe\r\nThe consumer issues a SUBSCRIBE for each track it would like. These flow to the publisher and back as described in step 8.",
      "createdAt": "2023-05-19T20:24:17Z",
      "updatedAt": "2024-02-20T02:32:29Z",
      "closedAt": null,
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "This is very helpful and matches my understanding of what is in the draft.",
          "createdAt": "2023-05-19T20:30:42Z",
          "updatedAt": "2023-05-19T20:30:42Z"
        },
        {
          "author": "jordicenzano",
          "authorAssociation": "NONE",
          "body": "Thanks @kixelated , this helps a lot",
          "createdAt": "2023-05-26T15:53:19Z",
          "updatedAt": "2023-05-26T15:53:19Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Should we move this to a wiki or something?",
          "createdAt": "2023-10-03T23:47:11Z",
          "updatedAt": "2023-10-03T23:47:11Z"
        }
      ]
    },
    {
      "number": 160,
      "id": "I_kwDOG2Ho4M5mbKbL",
      "title": "Proposal: clarifying the semantics of the track names",
      "url": "https://github.com/moq-wg/moq-transport/issues/160",
      "state": "CLOSED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "(background: #70, probably more)\r\n\r\nAt the end of the last meeting, I've volunteered to write up a proposal that would let us make progress on the track name semantics.  I propose the following (in the form of individual numbered points, so that they are easier to comment on):\r\n\r\n1. (Observation) In order to subscribe to a track, the client in the current design needs at least three distinct pieces of information: _a connect URL_, _a track namespace_ and _a track name_.\r\n1. (Should be in the spec) The _connect URL_ tells the client how to establish a network connection.\r\n1. (Already in the spec) The _track name_ and the _track namespace_ are the two strings sent in the SUBSCRIBE request; together they are referred to as the _full track name_.\r\n1. (New definition) A single _MoQ server_ is an entity that is uniquely identified by a connect URL (that is to say, if two entities have different URLs, we consider them different servers).\r\n1. (New definition) Let us introduce a new term, _MoQ scope_.  A MoQ scope is defined to be a set of servers for which requesting the same full track name will result in the client subscribing to the same track with the same data on it.\r\n1. (Already in the spec, but clarified) It is up to the application building on top of MoQ to define how large the scope has to be.  An application that deals with connections between devices on a local network may limit the scope to a single connection.  An application that uses multiple CDNs to serve media may require the scope to be all of those CDNs.\r\n1. (New rule) The full track name is the only piece of information that a specific MoQ server uses to identify the track. It does not use any sort of header-based negotiation like HTTP provides with Vary/Accept/etc.  The connect URL is not used directly, but it does imply the scope for the name.\r\n1. (Corollary) A full track name can be used as a complete cache key (for a given scope).\r\n\r\n(Open problem: while a full track name might identify the track at a specific instance of time, at a later point in time that name could refer to a completely different track.  We should decide how we want to deal with that, but probably in a different issue)\r\n\r\n@fluffy @suhasHere @kixelated What do you think about this proposal? Does it address your concerns?",
      "createdAt": "2023-05-21T07:08:31Z",
      "updatedAt": "2023-05-24T19:05:46Z",
      "closedAt": "2023-05-24T19:05:46Z",
      "comments": [
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This proposal works for me. ( I could also live with even weaker versions). I have some nit picking on the way scope is defined but I agree with the idea of scope you are trying to get to here and the implications that the  track name. ",
          "createdAt": "2023-05-21T13:36:28Z",
          "updatedAt": "2023-05-21T13:36:28Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks Victor for writing this up. I also agree with the general direction here. One thing we can add in the PR text based on the above is identifying the purpose of full track namespace on its own , which you already have above.\n\nLook forward to review the PR text",
          "createdAt": "2023-05-21T13:46:36Z",
          "updatedAt": "2023-05-21T13:46:36Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Nit picking on scope: I am not trying to change what is in scope, just how it is defined. I agree with the proposal. \r\n\r\nI don't like using the term MoQ server for the way it used here. A connect URL look like moq.akamai.com and use geo DNS and / or anycast to refer to a crap load of servers, or a connect URL might refer to a specific set of edge load balancers in a specific cluster in an specific availability zone in a given region (stealing AWS terminology) and could be  moq-cluser-f.us-east1-1b.webex.com and even then that might be more than one server or it might look like TV-3889.moq-cast._udp.local. It just seems it will get very confused with the term \"Server\" we already have in the draft which is more a specific instance that terminated a TLS connection. \r\n\r\nPerhaps we could remove MoQ Sever as term and just talk about the \"scope\" of a namespace and define that as all the servers ( including relays ) where this will be published or subscribed too.  ",
          "createdAt": "2023-05-21T14:08:18Z",
          "updatedAt": "2023-05-21T14:08:59Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual comment:\r\n\r\nIn general, this proposal matches my thinking.  \r\n\r\nI do think there's power in being able to hand out the same \"virtual\" full track name to many clients and have the logic to resolve that to a real full track name on the server.  As I read this proposal, it would be explicitly disallowed by 7 and 8.  Perhaps it can still be supported by adding a SUBSCRIBE REDIRECT reply to a SUBSCRIBE message, though it costs 1 RTT to start the correct subscription.\r\n\r\nWe are also experimenting with server-side ABR in HTTP video delivery, where the client simply asks for the video and the server is dynamically switching between renditions based on available bandwidth measured at the transport.  I'm not sure how that can be done with moq following the rules laid out here?  Since every user may see a different sequence of bits, do they all need to subscribe to (or be redirected to) unique track names?  That would add complexity to our design and doesn't seem strictly necessary.\r\n\r\nI'd expect the full working group to have opinions on this topic regardless of what the authors choose, so I don't know that we need to completely resolve the issue this week.  If there isn't immediate consensus, I'd be ok if draft-05 had Victor's proposal and continuing to discuss the above issues in the working group.",
          "createdAt": "2023-05-21T16:31:55Z",
          "updatedAt": "2023-05-21T16:31:55Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "This works for me since the connect url MAY be used to determine the MoQ scope. +1 with Cullen to remove the \"MoQ Server\" definition.",
          "createdAt": "2023-05-21T16:58:44Z",
          "updatedAt": "2023-05-21T16:58:44Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Somewhere back Luke had asked me if I was OK with a connect URL of webex.akamai.com and namespace of just meeting1234 and I had said I did no see how that would work. I think with this scope framing, I now understand how that would work. So if akamai is bringing up a set of virtual relays that are only used by webex and these relays have there own connected UR,  and inside of that scope, then the namespace meeting1234 can provide enough information for the relays to work. \r\n\r\nSo having the \"connect URL MAY determine the MoQ scope\" does work for me. ",
          "createdAt": "2023-05-21T17:29:50Z",
          "updatedAt": "2023-05-21T17:29:50Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks like we have authors agreement on the general direction. Adding connect url MAY define scope is certain conditions is good to support use case that Luke has brought to considerations. \n\nAgree with Alan that we should get a Pr to clarify things listed in the discussions above.",
          "createdAt": "2023-05-21T17:57:10Z",
          "updatedAt": "2023-05-21T17:57:10Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Wrote #162, mostly based on the text above.  Please comment on specifics wording.\r\n\r\nA few comments on some points Alan has brought up:\r\n\r\n> Perhaps it can still be supported by adding a SUBSCRIBE REDIRECT reply to a SUBSCRIBE message, though it costs 1 RTT to start the correct subscription.\r\n\r\nIt doesn't necessarily have to be that way if you allow a reply to be \"name A got redirected to the name B, and you're now subscribed to the name B\".\r\n\r\n> We are also experimenting with server-side ABR in HTTP video delivery, where the client simply asks for the video and the server is dynamically switching between renditions based on available bandwidth measured at the transport. I'm not sure how that can be done with moq following the rules laid out here? Since every user may see a different sequence of bits, do they all need to subscribe to (or be redirected to) unique track names? That would add complexity to our design and doesn't seem strictly necessary.\r\n\r\nI believe Luke had a proposal where you could subscribe to multiple tracks that are interchangeable, and the server would perform ABR.  Regardless, there has to be some complexity here, since the CDN does not necessarily know which sets of tracks can be ABR switch between (since the catalog and the media bitstream are opaque), and, while on client<->CDN hop you would want a single version of the same media, on the CDN<->backend hop, you'd want to fetch many of those at once.",
          "createdAt": "2023-05-23T22:05:00Z",
          "updatedAt": "2023-05-23T22:05:00Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "> It doesn't necessarily have to be that way if you allow a reply to be \"name A got redirected to the name B, and you're now subscribed to the name B\".\r\n\r\nYes, I thought of that too.  Maybe we'll end up proposing something along these lines down the road.\r\n\r\n> Regardless, there has to be some complexity here\r\n\r\nFair enough.  To make it work the groups need to be synchronized between the tracks as well or it gets even more complicated.  This may be the kind of thing we build an extension for and bring it back to the WG after we figure it out.  \r\n\r\nAssuming we had \"subscribed-you-to-this-redirected-stream\" feature, that would solve the naming problem (eg: you subscribe to foo.com/video and we redirect+subscribe you to foo.com/<unique id>/video).",
          "createdAt": "2023-05-24T00:02:55Z",
          "updatedAt": "2023-05-24T00:02:55Z"
        }
      ]
    },
    {
      "number": 202,
      "id": "I_kwDOG2Ho4M5nC7Iz",
      "title": "Section 3.3: Cancellation",
      "url": "https://github.com/moq-wg/moq-transport/issues/202",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [
        "ianswett"
      ],
      "labels": [
        "Needs PR",
        "Subscribe"
      ],
      "body": "Section 3.3 currently says:\r\n\r\n\"3.3. Cancellation\r\n\r\n   A QUIC stream MAY be canceled at any point with an error code.  The\r\n   producer does this via a RESET_STREAM frame while the consumer\r\n   requests cancellation with a STOP_SENDING frame.\r\n\r\n   When using order, lower priority streams will be starved during\r\n   congestion, perhaps indefinitely.  These streams will consume\r\n   resources and flow control until they are canceled.  When nearing\r\n   resource limits, an endpoint SHOULD cancel the lowest priority stream\r\n   with error code 0.\r\n\r\n   The sender MAY cancel streams in response to congestion.  This can be\r\n   useful when the sender does not support stream prioritization.\r\n\r\n   TODO: this section actually describes stream cancellation, not\r\n   session cancellation.  Is this section required, or can it be\r\n   deleted, or added to a new \"workflow\" section.\"\r\n\r\n[BA]  While the meaning of STOP_SENDING is clear for frame/stream transport\r\n(e.g. stop sending the frame whose transmission is currently in progress),\r\nit is less clear when multiple frames are transported on the same QUIC\r\nstream.\r\n\r\nIn the case where multiple frames are being transmitted on a stream, the\r\nproblem is that STOP_SENDING does not indicate *which* frame the receiver\r\nhas given up on.  So how is the sender to interpret it?  For example, after\r\nresetting the stream, does the sender open a new stream?  If so, what\r\nframe(s) are to be transmitted on that new stream?\r\n\r\nTo address this ambiguity, an application-layer message(s) could be\r\ndefined, indicating exactly what the receiver wants the sender to do:\r\n\r\n* Stop (re-)transmission of a particular (named) frame.  The existing\r\nstream is reset and a new stream is opened for transmission of subsequent\r\nframes.\r\n\r\n* Stop transmission of layer(s). The receiver wishes to the sender to\r\nadjust the operating point, by stopping the transmission of one or more\r\ntemporal or spatial layers.  Only the layers that remain will be\r\ntransmitted on new stream(s).\r\n\r\nMailing list thread: https://mailarchive.ietf.org/arch/msg/moq/1Zi-IO12grZpEkrYw5c8aXyK9-M/",
      "createdAt": "2023-05-27T16:26:43Z",
      "updatedAt": "2023-10-16T17:23:59Z",
      "closedAt": "2023-10-16T17:23:59Z",
      "comments": [
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think subscribe hints solves the problem of what to start on by saying which object to start the new subscription on. It seems like the solutions to layers would be to put different layers on differenent streams. I would expect different layers to have different priorities which will then mean different streams. ",
          "createdAt": "2023-10-04T21:00:41Z",
          "updatedAt": "2023-10-04T21:00:41Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Attendees think there may be valid use cases of STOP_SENDING and RESET and it should not be disallowed.  But typically UNSUBSCRIBE could be used to accomplish the desired behavior.\r\n\r\nSTOP_SENDING and RESET do not change the state of subscriptions.",
          "createdAt": "2023-10-04T21:04:52Z",
          "updatedAt": "2023-10-04T21:04:52Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah the problem is when there's significant congestion, a player can fall behind on the active subscription. It needs a way of indicating that it is not waiting for group X any longer so the server should not send it, otherwise it's just a waste of bandwidth.\r\n\r\nMy proposal is to use STOP_SENDING to indicate you don't want something. This does mean that you can't put unrelated objects on the same stream, otherwise you might accidentally reset the wrong objects. \r\n\r\nex. If I no longer want to receive group X, I STOP_SENDING any QUIC streams containing group X. But that does prohibit sending group Y on the same QUIC stream, so it would prohibit sending the entire track on a single stream. But like you forfeited the ability to skip any content if you decided to do that.\r\n\r\nAlternatively, we could add a STOP_GROUP message or UNSUBSCRIBE_RANGE. Possibly we could RESUBSCRIBE with a new start group.",
          "createdAt": "2023-10-04T21:12:32Z",
          "updatedAt": "2023-10-04T21:14:07Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Resubscription works fine here. Since a new subscription  is supposed to override an existing subscription from the client, Relay can start sending from the new group.\r\n\r\nAlso I don't think we need to forfeit track per stream use-case. If someone is using track per stream, they exactly know what properties they are signing up for.\r\n\r\nMy proposal would be to Subscribe with new start_point",
          "createdAt": "2023-10-05T02:59:46Z",
          "updatedAt": "2023-10-05T02:59:46Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> Resubscription works fine here. Since a new subscription is supposed to override an existing subscription from the client, Relay can start sending from the new group.\r\n\r\nResubscribe only works if the content we don't want is at the head/tail, unless SUBSCRIBE supports ranges instead of a single start/end.\r\n\r\n> Also I don't think we need to forfeit track per stream use-case. If someone is using track per stream, they exactly know what properties they are signing up for.\r\n\r\nWe don't need to forfeit the use-case; the receiver would have to know that it can't cancel streams in this mode. Franky the application has already made a huge mistake if you're encountering congestion while sending all groups over the same stream.\r\n\r\n> My proposal would be to Subscribe with new start_point\r\n\r\nA UNSUBSCRIBE/SUBSCRIBE message doesn't work because it will cause redelivery of any duplicates. We would have to add RESUBSCRIBE or allow augmenting an existing SUBSCRIBE.",
          "createdAt": "2023-10-05T03:23:04Z",
          "updatedAt": "2023-10-05T03:23:04Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "@ianswett Agree that STOP_SENDING and RESET_STREAM do not change the state of subscriptions. I'd say the same for CLOSE_STREAM (see: https://datatracker.ietf.org/doc/draft-ietf-quic-reliable-stream-reset/). ",
          "createdAt": "2023-10-05T03:31:49Z",
          "updatedAt": "2023-10-05T03:31:49Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> A UNSUBSCRIBE/SUBSCRIBE message doesn't work because it will cause redelivery of any duplicates. We would have to add RESUBSCRIBE or allow augmenting an existing SUBSCRIBE.\r\n\r\nNot with Subscription hints though",
          "createdAt": "2023-10-05T04:47:32Z",
          "updatedAt": "2023-10-05T04:47:32Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> We don't need to forfeit the use-case; the receiver would have to know that it can't cancel streams in this mode. Franky the application has already made a huge mistake if you're encountering congestion while sending all groups over the same stream.\r\n\r\nYes , its application decision to prefer such a mode. Yes in such cases cancel will cancel the entire stream. But resubscription with a new start_point will help alleviate some.",
          "createdAt": "2023-10-05T04:49:33Z",
          "updatedAt": "2023-10-05T04:49:33Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "The group spent time discussing ideas around RESUBSCRIBE/SUBSCRIBE_UPDATE and multiple subscriptions.\r\n\r\n@kixelated brought up the fact that a relay may have to issue overlapping subscribes because it doesn't know whether a relative or absolute subscription is earlier.\r\n\r\nThis needs a new issue for multiple subscriptions and updating subscriptions.\r\n",
          "createdAt": "2023-10-09T17:41:35Z",
          "updatedAt": "2023-10-09T17:41:35Z"
        }
      ]
    },
    {
      "number": 203,
      "id": "I_kwDOG2Ho4M5nRo-f",
      "title": "Subscription end signal?",
      "url": "https://github.com/moq-wg/moq-transport/issues/203",
      "state": "CLOSED",
      "author": "afrind",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "afrind"
      ],
      "labels": [
        "Needs PR",
        "Implementation Blocker",
        "Needs Discussion",
        "Subscribe"
      ],
      "body": "Section 5.1 of the draft says:\r\n\r\n> A subscription remains active until it expires, until the publisher of the track stops producing objects or there is a subscription error\r\n\r\nFor the second case above, I think it would be useful to have an explicit signal from the publisher to signal the end of the track.  \r\n\r\nFor the third case, the text seems to hint (via a section reference) that if the subscription abruptly terminates with an error, the publisher can send SUBSCRIBE ERROR, but that section says:\r\n\r\n> A publisher sends a SUBSCRIBE ERROR control message in response to a failed SUBSCRIBE REQUEST.\r\n\r\nThe draft should clarify if this is allowed following a SUBSCRIBE OK.\r\n\r\nAlso +1 to adding UNSUBSCRIBE (#132).",
      "createdAt": "2023-05-30T17:26:03Z",
      "updatedAt": "2023-10-17T00:22:47Z",
      "closedAt": "2023-10-17T00:22:47Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 we should allow sending a SUBSCRIBE ERROR after a SUBSCRIBE OK.",
          "createdAt": "2023-06-09T18:38:45Z",
          "updatedAt": "2023-06-09T18:39:54Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I was assuming that the catalog change would be the way a track end was indicated then the client would unsubscribe. ",
          "createdAt": "2023-07-22T19:14:46Z",
          "updatedAt": "2023-07-22T19:14:46Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "As an individual:\r\n\r\n> I was assuming that the catalog change would be the way a track end was indicated then the client would unsubscribe.\r\n\r\nThis seems like a bit of a subtle signal and something more explicit using the Track ID would be preferable for me.",
          "createdAt": "2023-07-24T15:19:23Z",
          "updatedAt": "2023-07-24T15:19:23Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "I tend to incline towards Catalog indicating the status the more i think of it.\r\n\r\nCatalog is source of truth for tracks. Having a catalog update that indicates the following\r\n- Full Track Name\r\n- last_object_id field \r\n\r\nAlso if the catalog is ending, since the producer is going away, then include another optional field \r\n- finished or something \r\n\r\nThese would be sufficient and a clear way to identify the status end to end.",
          "createdAt": "2023-07-24T16:46:09Z",
          "updatedAt": "2023-07-24T16:46:09Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I think putting the FIN group/sequence in the catalog is clean. It does prohibit relays from cleanly terminating a broadcast early or rewriting group/object sequences, but I think that's fine?\r\n\r\nHowever, the wrinkle is that a sender MAY choose to not transmit a group/object. While I don't think this is explicitly stated in the draft, it's a requirement given that relays can only cache data for a finite amount of time. The viewer could get stuck waiting for the FIN group/sequence as signaled in the catalog, even though it is not forthcoming as the relay did not receive the object or already evicted it from the cache.",
          "createdAt": "2023-07-24T17:23:24Z",
          "updatedAt": "2023-07-24T17:24:16Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "As an individual:\r\n\r\nHaving an explicit signal outside the catalog will make it easier for relays to clean up track related state.  \r\n\r\nIf a publisher is done with a track, they can update the catalog, but it will need to propagate to all subscribers, who in turn need to issue an unsubscribe.  Only when all of them unsubscribe (which we still need) can a relay discard the entry in the forwarding table.\r\n\r\nIf the publisher also sends an explicit signal closing off the track, the relay can immediately clean up the state.",
          "createdAt": "2023-07-27T15:52:45Z",
          "updatedAt": "2023-07-27T15:52:45Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "We need few things. \r\n\r\n1. Cease the announcement\r\n\r\n```\r\nANNOUNCE_CEASE {\r\n  Track Namespace\r\n   ....\r\n}\r\n```\r\n\r\nThis is an explicit signal from the publisher that it is no longer interested \r\nin sending media for the announced tracks.  This is sent to the relay to trigger subscription cancellation downstream and clean up local relay state.\r\n\r\n2. Terminate the Subscription\r\n\r\n```\r\nSubscribe Terminate {\r\n  Track Namespace\r\n   Reason { ..... }\r\n}\r\n```\r\n\r\nOn subscribe end signal, each receiving entity will forward downstream and clean up local state. If it is the consumer, it stop media pipeline and so on.\r\n\r\n\r\n\r\n3. Unsubscribe\r\nFor subscribers to explicitly indicate that they are no longer interested in a given track , they will send\r\n\r\n```\r\nUnscubscribe {\r\nTrack Namespace\r\n....\r\n}\r\n```\r\n\r\n\r\nI am happy to write up a small PR as proposal if we think the general direction is fine.",
          "createdAt": "2023-07-27T16:48:42Z",
          "updatedAt": "2023-07-27T17:15:44Z"
        },
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "What is the difference between Cancel the subscription and Unsubscribe?",
          "createdAt": "2023-07-27T16:55:17Z",
          "updatedAt": "2023-07-27T16:55:17Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> What is the difference between Cancel the subscription and Unsubscribe?\r\n\r\nUnsubscribe is an explicit action from the subscriber and Cancel is the signal from the publisher. May be we should call it ``Subscribe Terminated`` instead ? I see cancel can be misleading",
          "createdAt": "2023-07-27T17:05:44Z",
          "updatedAt": "2023-07-27T17:05:44Z"
        },
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "Got it. Terminate is better than Cancel.\r\n\r\nOn Fri, Jul 28, 2023 at 1:05\u202fAM Suhas Nandakumar ***@***.***>\r\nwrote:\r\n\r\n> What is the difference between Cancel the subscription and Unsubscribe?\r\n>\r\n> Unsubscribe is an explicit action from the subscriber and Cancel is the\r\n> signal from the publisher. May be we should call it Subscribe Terminated\r\n> instead ? I see cancel can be misleading\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/moq-wg/moq-transport/issues/203#issuecomment-1654027818>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AA6IAE6KTZF3X4KYCKPK6HLXSKNXHANCNFSM6AAAAAAYUKNF2U>\r\n> .\r\n> You are receiving this because you commented.Message ID:\r\n> ***@***.***>\r\n>\r\n\r\n\r\n-- \r\nBest regards\r\nHang\r\n",
          "createdAt": "2023-07-27T17:10:08Z",
          "updatedAt": "2023-07-27T17:10:08Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> 2. Terminate the Subscription\r\n> \r\n> ```\r\n> Subscribe Terminate {\r\n>   Track Namespace\r\n>    Reason { ..... }\r\n> }\r\n> ```\r\n> \r\n> On subscribe end signal, each receiving entity will forward downstream and clean up local state. If it is the consumer, it stop media pipeline and so on.\r\n\r\nWe already have `SUBSCRIBE_ERROR` for the publisher to immediately terminate a subscription with a code/reason, so we could reuse that. However, the problem is _when_ the termination occurs.\r\n\r\nThe end of a broadcast would look like:\r\n```\r\n<- SUBSCRIBE 1 /foo\r\n-> OBJECT 1\r\n...\r\n-> OBJECT 64\r\n-> OBJECT 65\r\n-> SUBSCRIBE_ERROR 1 \"end of track\"\r\n```\r\n\r\nThere's a race, as the `SUBSCRIBE_ERROR` can arrive before the last objects due to retransmits or congestion control, severing the subscription early. Ideally we wait for all outstanding objects to get delivered _and then_ terminate the subscription.\r\n\r\nIn QUIC terminology, we need a `STREAM_FIN` in addition to our existing `RESET_STREAM`. The difficult part is determining which objects are still outstanding.",
          "createdAt": "2023-07-27T19:51:23Z",
          "updatedAt": "2023-07-27T19:52:48Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Do we want to distinguish a normal end of subscription (due to EOF), and an unexpected end (due to, e.g., a downstream server crashing)?  We do that normally in QUIC (fin vs reset), so it might make sense to do that here.",
          "createdAt": "2023-07-27T20:01:31Z",
          "updatedAt": "2023-07-27T20:01:31Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Image the case  where we have A sending to R sending to B. \r\n\r\nB subscribes to R. A sends ANNOUNCE to R. R subscribes to A. \r\n\r\nAt this point media is flowing from A to R to B. \r\n\r\nA temporary looses WIFI connectivity and reconnects over 5G with new IP. \r\n\r\nA sends an ANNOUNCE to R, R subscribes to the new A and perhaps tries to send an error to original ANNOUNCE and end subscribe but A will not get that as that QUIC connection is gone. \r\n\r\nOnce again data is flowing from A to R to B. \r\n\r\nI think it would be bad if the new ANNOUNCE, or an error on the QUIC connection from A to R  caused a termination or error of the subscribe between B and R. I'm think it is better for B to unsubscribe if it is not receiving the media it wold expect. \r\n\r\n",
          "createdAt": "2023-07-27T21:02:18Z",
          "updatedAt": "2023-07-27T21:02:18Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Having explicit messages reflecting the actions would be my inclination as well. \r\nI thought it might be beneficial to explain the role of the above proposed messages with few flow diagrams\r\n\r\n## 1. Ceasing the Announcement and triggering termination of subscriptions downstream\r\nHere is the happy path flow (it ignores Subscribe_OK and response flows to keep the flow focussed)\r\n\r\n```mermaid\r\nsequenceDiagram\r\n  Alice->>Relay: ANNOUNCE(webex.com/alice/hd-video)\r\n  Bob->>Relay: SUBSCRIBE( webex.com/alice/hd-video)\r\n  Relay->>Alice: SUBSCRIBE( webex.com/alice/hd-video)\r\n  loop media\r\n        Alice-->Bob: Media Exchange\r\n   end\r\n   Alice->>Relay: ANNOUNCE_CEASE(webex.com/alice/hd-video)\r\n   Relay->> Bob: SUBSCRIBE_TERMINATE( webex.com/alice/hd-video)\r\n   Relay->>Relay: Clean up local subscription state \r\n   Bob ->> Bob: Cleanup local subscription state\r\n```\r\n\r\n\r\n## 2. Subscriber explicitly unsubscribing to a tracl \r\n\r\n```mermaid\r\nsequenceDiagram\r\n  Bob->>Relay: SUBSCRIBE( webex.com/alice/hd-video)\r\n  Bob->>Relay: SUBSCRIBE( webex.com/alice/audio)\r\n  loop media\r\n        Relay-->Bob: Media Exchange (audio, hd-video)\r\n   end\r\n   Note left of Bob: Not interested in hd-video anymore\r\n   Bob->>Relay: UNSUBSCRIBE(webex.com/alice/hd-video)\r\n   loop media\r\n        Relay-->Bob: Media Exchange (audio)\r\n   end\r\n\r\n```\r\n\r\n## 3. Subscriptions terminated due to media producer lost connection\r\n\r\n```mermaid\r\nsequenceDiagram\r\n  Alice->>Relay: ANNOUNCE(webex.com/alice/hd-video)\r\n  Bob->>Relay: SUBSCRIBE( webex.com/alice/hd-video)\r\n  Relay->>Alice: SUBSCRIBE( webex.com/alice/hd-video)\r\n  loop media\r\n        Alice-->Bob: Media Exchange\r\n   end\r\n   Relay ->> Relay: Connection to Alice lost\r\n   Relay->> Bob: SUBSCRIBE_TERMINATE( webex.com/alice/hd-video, PUBLISHER_ERROR)\r\n   Relay->>Relay: Clean up local subscription state \r\n   Bob ->> Bob: Cleanup local subscription state\r\n```\r\n",
          "createdAt": "2023-08-01T04:38:12Z",
          "updatedAt": "2023-08-01T06:22:41Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Summary thoughts:\r\n - Want to support disconnection without propagation to all subscribers (ie: If there were two publishers)\r\n - Need a way to cleanly unsubscribe from a track (UNSUBSCRIBE) - Like STOP_SENDING?\r\n - Need a way to indicate that a relay is no longer the place to subscribe to for a track (ie: UNANNOUNCE)\r\n   + But UNANNOUNCE does not indicate an unsubscription.\r\n - Need a way to indicate the track is FIN'd and ending, could use the catalog or put in the protocol (or both)\r\n - Likely want a way to drain a relay, such as an HTTP GOAWAY style functionality. (Could be SUBSCRIBE_TERMINATE)\r\n - Timeouts do need to be handled, even if they're not the ideal/clean case.\r\n - Want to know whether the relay wants to stop publishing or the origin did, so a client can decide whether to re-sub.\r\n\r\nNOTE: Objects can be dropped, hard to know if they'll ever arrive.\r\n\r\nCullen will summarize a proposal.  Note that the relay doesn't really need to know about tracks or what its subscribing to.\r\n\r\nAn open issue is how to do FIN, whether it as part of Objects, only the catalog, a separate message, etc.",
          "createdAt": "2023-08-14T17:50:11Z",
          "updatedAt": "2023-08-14T17:50:11Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Rough notes on proposal in the call:\r\n\r\nThe catalog updates and says what the last message in a track is.  Catalogs are a way that endpoints can say there will never be more on a track. \r\n\r\nThe annouce has an equivalent un-Annouce message. It changes routing of future subscribes but does not change state of existing subscribes. \r\n\r\nThe entity that send an subscribe and send an un-subscribe\r\n\r\nThe entity that receives a subscribe can send a go-away which will let the entity that sent the subscribe go do something new  ( like subscribe to something else ). We might need to figure out what data goes in the go away to given info that the clients enough info to do the right thing. \r\n\r\nTimeout can happen, and connections disappearing, and we need to sort out what impact that has but that is not the primary way to cause flow of media to change. \r\n\r\nUpdate: Key issue here is when the relays see the go away, do they drop the related forwarding state for the subscription, or do they just forward the update to the subscribers and wait for the subscribers to remove the subscription. ",
          "createdAt": "2023-08-14T17:51:01Z",
          "updatedAt": "2023-08-14T17:55:53Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@ianswett @fluffy thanks for capturing the notes.\r\n\r\nI will work on set of small PRs to  capture some of the items from the summary.",
          "createdAt": "2023-08-14T18:08:07Z",
          "updatedAt": "2023-08-14T18:08:07Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The point I was trying to clarify on the last call  was that catalog already has a mechanism for a publisher to communicate to all subscribers that the track it has advertised as being available is no longer available. A clean FIN if you like. We can, as has been pointed out, create a control message which says the same thing. But then we have a weird asymmetry in which a publisher notifies clients of track availability through a catalog update but then uses control messages to do the reverse. For good design with clean encapsulation, we should seek symmetry in operation. We should either use control messages to advertise the availability/unavailability of tracks , or use catalogs, but not a hybrid of both. \r\n\r\n In my understanding of moq-transport, control messages have utility that is scoped to the current hop. They negotiate the format in which data will be exchanged on that hop and issue commands to subscribe/unsubscribe/announce etc. Those commands have no applicability to any other hops on the distribution chain. A catalog however is a contract between a publishers and all subscribers. Unlike control messages, it holds data that is not interpreted hop-by-hop and is intended for targets that can be many hops away. \r\n \r\nI think relays should be as simple as possible.  In my conception, they should not understand whether tracks are being published or not. Their job is to move objects. Their view of the world is around objects and they do not need to understand what tracks are. While of course we can build all sorts of track intelligence in to relays, I think if we can build a base protocol which is agnostic to tracks, then it will be scalable and robust, and cleverness with tracks can evolve in the streaming formats without affecting deployed networks of relays. ",
          "createdAt": "2023-08-18T21:02:44Z",
          "updatedAt": "2023-08-18T21:07:09Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed in Boston: Agree we should add a SUBSCRIBE FIN message with the \"final offset\"",
          "createdAt": "2023-10-04T20:47:04Z",
          "updatedAt": "2023-10-04T20:47:04Z"
        }
      ]
    },
    {
      "number": 204,
      "id": "I_kwDOG2Ho4M5nRuBS",
      "title": "SUBSCRIBE REQUEST ambiguity",
      "url": "https://github.com/moq-wg/moq-transport/issues/204",
      "state": "CLOSED",
      "author": "afrind",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "ianswett"
      ],
      "labels": [
        "Needs PR",
        "Subscribe"
      ],
      "body": "Assume a setup with two publishers, a single relay and one subscriber.\r\n\r\nP1 ANNOUNCE's track namespace fooba\r\nP2 ANNOUNCE's track namespace foo\r\n\r\nS1 sends a SUBSCRIBE REQUEST for Full Track Name `foobar`\r\n\r\nHow does the relay know whether `foobar` is Track Namespace: `foo` and Track Name: `bar`, or Track Namespace: `fooba` and Track Name `r`, and hence which publisher to route the subscribe to? \r\n\r\nI see a few possibilities:\r\n\r\n1) The relay should not allow this scenario (via namespace construction and/or authorization).  If so the draft should include text explaining that this is disallowed (normatively?) or \"bad things(tm)\" happen.\r\n\r\n2) Change SUBSCRIBE REQUEST to be able to disambiguate the Track Namespace from the Track Name.  This could be done by sending name and namespace in separate message fields, or having stricter rules for the structure of Full Track Name such that a relay can extract the constituent parts.\r\n\r\n3) Explicitly state that Full Track Names are matched to namespaces via \"longest prefix match\".",
      "createdAt": "2023-05-30T17:40:55Z",
      "updatedAt": "2023-10-16T20:56:03Z",
      "closedAt": "2023-10-16T20:56:03Z",
      "comments": [
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "Option 3 looks interesting. P1 can use a longer track namespace to steer the sub request from P2. Like a traffic engeering for content.",
          "createdAt": "2023-06-05T07:56:19Z",
          "updatedAt": "2023-06-05T07:56:19Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I like option 2.\r\n\r\nI don't agree with treating track namespace as merely a string prefix. Even if you go with option 3, there's still a race condition where a late ANNOUNCE will cause a SUBSCRIBE to an unintended track.\r\n\r\nI want to give the track namespace more properties so it's treated more like a broadcast identifier. A few folks are headed down this path without realizing it, such as proposing that there's a single catalog per track namespace. I don't see how that would even work if ANNOUNCE is used purely for routing like a BGP announcement.",
          "createdAt": "2023-06-09T18:36:38Z",
          "updatedAt": "2023-06-09T23:34:23Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "@suhasHere : are you saying you believe that the relay resolves the described ambiguity by using 'longest prefix' matched (eg: option 3)?  \r\n\r\n> all the Relays needs to do is to check if there is one or more matches and send it to the subscribers. \r\n\r\nAnother option I hadn't considered based on this comment is that the relay would send OBJECTs from *BOTH* publishers since they both match the Full Track Name.  This will break in the current design, since each publisher has their own Object Sequence and Group Sequence and when merged the consumer will be left with garbage.  It also violates the logic described that says a Full Track Name can be used as a cache key.",
          "createdAt": "2023-06-09T21:15:17Z",
          "updatedAt": "2023-06-09T21:15:17Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah that seems quite problematic @afrind.\r\n\r\nLet's say a relay have two connected publishers who send IN ORDER:\r\n\r\n```\r\npublisher1: ANNOUNCE webex.com\r\npublisher2: ANNOUNCE webex.com/meeting123\r\n```\r\n\r\nA subscriber connects and issues:\r\n\r\n```\r\nSUBSCRIBE webex.com/meeting123/john-cena\r\n```\r\n\r\nWhat happens next?\r\n1. The relay forwards the SUBSCRIBE to publisher 1.\r\n2. The relay returns SUBSCRIBE ERROR not_found\r\n3. The relay forwards the SUBSCRIBE to publisher 2.\r\n4. The relay forwards the SUBSCRIBE to publisher 1&2.\r\n\r\nThese are in the order of Alan's options. I added option 4 based on Suhas' comment.\r\n\r\n1. Would occur if the relay rejects publisher2's ANNOUNCE because of thr shared prefix.\r\n2. Would occur because the track namespace is an ID, not a prefix, and must fully match an ANNOUNCE.\r\n3. Would occur because publisher2 has the longer path prefix.\r\n4. Would occur because both publishers _could_ produce the requested track.\r\n\r\n\r\nAnd to throw a wrench in things, a third publisher joins.\r\n\r\n```\r\npublisher3: ANNOUNCE webex.com/meeting123/john-cena\r\n```",
          "createdAt": "2023-06-10T00:31:21Z",
          "updatedAt": "2023-06-10T00:37:53Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "There's also the case where the relay replies to the subscribe requests on behalf of the publisher(s), so it doesn't have to make the routing decision at subscription time. But it does need to decide where to forward OBJECTs when they arrive.",
          "createdAt": "2023-06-10T22:28:21Z",
          "updatedAt": "2023-06-10T22:28:21Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Implementing this now so I have some more thoughts.\r\n\r\nWe should explicitly support UNANNOUNCE and UNSUBSCRIBE, which implicitly occur when the connection is dropped.\r\n\r\n\r\n### Option 1\r\n\r\n```\r\nnamespaces: RadixTree<String, Namespace>\r\ntracks: RadixTree<String, Track> \r\n```\r\n\r\n* On ANNOUNCE, the relay MUST ensure that the namespace not a subset/superset of an existing ANNOUNCE.\r\n* On SUBSCRIBE, the relay looks up the track based on the prefix and appends itself to a list of subscribers. If not found, it looks up the namespace and creates a track entry if valid.\r\n* On UNSUBSCRIBE, the relay looks up the track based on the full name and removes itself from a list of subscribers.\r\n* On UNANNOUNCE, the relay deletes any namespaces and tracks matching the prefix.\r\n\r\nA radix tree is used for both so the relay can iterate through any values that match the given prefix. This is a global radix tree, similar to how QUIC connections are identified when variable length connection IDs are supported.\r\n\r\n\r\n### Option 2\r\n```\r\nupstreams: HashMap<String, Namespace>\r\ntracks: HashMap<Namespace, Track>\r\n```\r\n\r\n* On ANNOUNCE, the relay inserts the upstream into the upstreams hash map and errors on a duplicate.\r\n* On SUBSCRIBE, the relay looks up the namespace and then the track, creating an entry if not found.\r\n* On UNSUBSCRIBE, the relay looks up the namespace and then the track, deleting an entry if found.\r\n* On UNANNOUNCE, the relay deletes from the namespace and track hash map.\r\n\r\nThis is a strictly better than option 1. It provides the same functionality but faster, and without the restriction on namespace prefixes.\r\n\r\n### Option 3\r\nRuns into issues with ANNOUNCE. example:\r\n```\r\npublisher1: ANNOUNCE  webex.com\r\nconsumer1:  SUBSCRIBE webex.com/meeting123/hd\r\npublisher2: ANNOUNCE  webex.com/meeting123\r\nconsumer2:  SUBSCRIBE webex.com/meeting123/hd\r\n```\r\n\r\n`consumer1` and `consumer2` are subscribed to different publishers, despite using THE SAME NAME. This invalidates the claim that the track name is the cache key. We can't migrate `consumer1` to the new longer prefix from `publisher2` unless there's a guarantee they are producing the same content.\r\n\r\nA similar issue occurs when UNANNOUNCE is fired, when happens implicitly when the connection is dropped:\r\n```\r\npublisher1: ANNOUNCE  webex.com\r\npublisher2: ANNOUNCE  webex.com/meeting123\r\nconsumer1:  SUBSCRIBE webex.com/meeting123/hd\r\npublisher2: UNANNOUNCE webex.com/meeting123\r\n```\r\n\r\nEach subscription needs to keep reference to the track when the SUBSCRIBE was received, instead of doing a lookup based on full track name when each OBJECT is received. This will cause havok when resubscriptions occur, for example with ABR, as switching away from and back to a track MAY result in different content.\r\n\r\n### Option 4\r\nIt's not viable. The subscription would intermingle objects from separate publishers that happen share a prefix, all while using the same `track_id`. I really don't want to support subscribing based on wildcards or prefixes anyway.\r\n\r\nThis is also the slowest option, as there needs to be a global RadixTree that maps tracks to subscriptions on receipt of each object. All other options listed above would keep an array of subscribers per track, resolved using a (shardable) HashMap.",
          "createdAt": "2023-06-14T20:02:05Z",
          "updatedAt": "2023-06-14T20:10:50Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> 1. The relay should not allow this scenario (via namespace construction and/or authorization).  If so the draft should include text explaining that this is disallowed (normatively?) or \"bad things(tm)\" happen.\r\n\r\nI think this seems like the right approach. Having 2 producers with conflicting namespaces is a bad idea, unless the authz policy and application is somehow OK with the consequences.\r\n\r\nI have added #225  to clarify the thinking further",
          "createdAt": "2023-07-24T17:15:38Z",
          "updatedAt": "2023-07-24T21:30:36Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm of the view of two things 1) apps should not do this if it is a problem for that app usage of relay 2) relay should use the latest \"announce\" to override any earlier announces that are more specific ( or the same ) ",
          "createdAt": "2023-07-24T23:18:43Z",
          "updatedAt": "2023-07-24T23:18:43Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed at IETF 117: \r\n\r\nSupport in the room for changing \"Full Track Name\" from a single string to a tuple of Namespace and Track Name, and matching on Namespace exactly.",
          "createdAt": "2023-07-27T15:46:45Z",
          "updatedAt": "2023-07-27T15:46:45Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "IIRC, my recollection was not the same, also I don't think we concluded that the namespace match exactly. The discussion went over what the authz model defines and how that impacts the flow.\r\nI wonder how much the transport draft can mandate how a given relay application should implement the business rules. The transport draft must just indicate relay behavior and the course of actions to take for what happens when  \" if match succeeds vs match fails \", which is what is in the draft today already\r\n\r\n",
          "createdAt": "2023-07-27T16:34:58Z",
          "updatedAt": "2023-07-27T16:52:35Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Uh, my understanding of what we talking about what not at all removing Full Track Name - it was about we did not need to define a separator for concatenating things in a tuple.   I don't agree there was support for chaning Full Track Name to Namesapce and Track Name tuple and only doing full matches. That is not going to work for many of the use cases and not what we are discussing. ",
          "createdAt": "2023-07-27T16:48:04Z",
          "updatedAt": "2023-07-27T16:48:04Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I thought what came out of this discussion is \r\n\r\n1) we do not know how duplicate ANNOUNCE work even when the names are identical ( do we keep first, last , error etc ) \r\n\r\n2) once we figure that out, we can start to deal with the more complicated issue of partial match or overlapping \r\n\r\nPerhaps I have this recollection wrong but if so point me at right place in recording for that. ",
          "createdAt": "2023-07-27T16:51:44Z",
          "updatedAt": "2023-07-27T16:51:44Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "My motivation for ANNOUNCE was for the contribution case. A client like OBS will connect to the server, ANNOUNCE a new catalog track, and then the server will issue a corresponding SUBSCRIBE to get the data flowing.\r\n\r\n```\r\n-> ANNOUNCE webex.com/meeting123/suhas\r\n<- SUBSCRIBE webex.com/meeting123/suhas/catalog\r\n```\r\n\r\nThis is modeled after the QUICR PUBLISH_INTENT message, except that data doesn't flow until the other side issues a SUBSCRIBE.\r\n\r\nHowever, announcing a namespace prefix subverts this behavior:\r\n\r\n```\r\n-> ANNOUNCE webex.com\r\n<- SUBSCRIBE webex.com/catalog (ERROR)\r\n```\r\n\r\nThe relay doesn't know if an ANNOUNCE is a prefix for routing, or a single broadcast being published. The relay effectively needs a business agreement with each client to determine.\r\n\r\n I think we should split this ANNOUNCE functionality into separate messages if just for the sake of discussion:\r\n\r\n1. `PLS_SUBSCRIBE namespace track`\r\n2. `PLS_ROUTE namespace_prefix`",
          "createdAt": "2023-07-27T16:58:04Z",
          "updatedAt": "2023-07-27T16:58:35Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "In the case of `PLS_SUBSCRIBE`, a tuple makes perfect sense as it mirrors the arguments to SUBSCRIBE. This message would be primarily used for contribution to \"push\" a new broadcast. It also makes sense as a reconnect signal where the last message wins.\r\n\r\nIn the case of `PLS_ROUTE`, matching the longest prefix might make sense instead. I know very little about BGP but maybe there's some inspiration there. This message would primarily be used for inter-relay routing.",
          "createdAt": "2023-07-27T17:03:41Z",
          "updatedAt": "2023-07-27T17:04:03Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "> I don't agree there was support for chaning Full Track Name to Namesapce and Track Name tuple and only doing full matches. That is not going to work for many of the use cases and not what we are discussing.\r\n\r\nI assumed that full track name was a tuple already, and \"full track name as a concatenation\" was a notational convenience.  Now that I read the draft more carefully, it does send full track name in messages, rather than a tuple of track name and track NS.  As far as I'm concerned, this is a mistake -- I don't think this actually works, and I have no idea how one is supposed to implement that.\r\n\r\n> we do not know how duplicate ANNOUNCE work even when the names are identical ( do we keep first, last , error etc )\r\n\r\nI believe \"error\" is actually equivalent to \"keep first\" here.\r\n\r\nI think it's a safety vs practicality trade-off.  On one hand, if two different programs announce the same track, it will not work, since they will publish conflicting objects under the same name; if we disallow re-announcing, we will prevent that.  On the other hand, re-announcing makes reconnects more practical.",
          "createdAt": "2023-07-27T18:34:34Z",
          "updatedAt": "2023-07-27T18:34:34Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "@fluffy Sorry if I misread the room and/or the author's meeting.  Let's continue discussing.\r\n\r\n> we do not know how duplicate ANNOUNCE work even when the names are identical ( do we keep first, last , error etc )\r\n\r\nThat is being discussed in #225 / #227, let's keep this issue focused on the SUBSCRIBE REQUEST ambiguity?\r\n\r\n",
          "createdAt": "2023-07-27T18:44:50Z",
          "updatedAt": "2023-07-27T18:44:50Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual comment:\r\n\r\nJust to illustrate the problem further here, I wrote a short sketch of a generic relay (python syntax):\r\n\r\n```\r\ndef on_announce(self, session, announce):\r\n    self.announced_namespaces[announce.track_namespace] = session\r\n    return AnnounceOk(announce.track_namespace)\r\n\r\ndef on_subscribe(self, session, sub):\r\n    full_trackname = sub.full_trackname\r\n    subscribers = self.subscribers_by_trackname[full_trackname]\r\n    if subscribers is None:\r\n        # first subscriber\r\n\r\n        #### How do I find the session to serve the requested track? ####\r\n        upstream_session = self.session_for_trackname(full_trackname)\r\n        if upstream_session is None:\r\n            # no such namespace has been announced\r\n            return SubscribeError(sub.full_trackname, 404, \"no such namespace\")\r\n        upstream_track_id = upstream_session.subscribe(sub)\r\n        if !upstream_track_id:\r\n            return SubscribeError(sub.full_trackname, 502, \"subscribe failed\")\r\n        subscribers = []\r\n        self.subscribers_by_track_id[(upstream_session, upstream_track_id)] = \\\r\n            subscribers\r\n        self.subscribers_by_trackname[full_trackname] = subscribers\r\n\r\n    # Add to subscribers list\r\n    track_id = session.next_track_id()\r\n    subscribers.append((session, track_id))\r\n    return SubscribeOk(sub.full_trackname, track_id)\r\n\r\ndef on_object(self, session, object_header, object_payload):\r\n    subscribers = self.subscribers_by_track_id[\r\n        (session, object_header.track_id)]\r\n    if subscribers is None:\r\n        # Oops, no subscribers - unsubscribe??\r\n        pass\r\n\r\n    for downstream_session, downstream_track_id in subscribers:\r\n        object_header.track_id = downstream_track_id\r\n        downstream_session.publish(object_header, object_payload)\r\n```\r\n\r\nSo the concrete proposal I have is to change `SUBSCRIBE_REQUEST` to have two fields, track_namespace and track_name.  \r\n\r\nThen the first bit would change to:\r\n\r\n```\r\ndef on_subscribe(self, session, sub):\r\n    full_trackname = sub.track_namespace + sub.track_name\r\n    subscribers = self.subscribers_by_trackname[full_trackname]\r\n    if subscribers is None:\r\n        # first subscriber\r\n\r\n        upstream_session = self.announced_namespaces[sub.track_namespace]\r\n```\r\n\r\nThis is not to say the *every* relay has to do matches in this way.  By squishing the namespace and name together it's **not possible** to implement a relay that does exact matching.  If we put the tuple in `SUBSCRIBE_REQUEST`, a relay that wants non-exact matching rules based on full track name can always construct it by concatenating namespace and track_name together.\r\n\r\n@fluffy Can you say more about the use cases that would break with a change like this, or suggest an alternate way to implement an exact matching relay?",
          "createdAt": "2023-08-01T23:15:23Z",
          "updatedAt": "2023-08-01T23:15:23Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "In a recent editor's call there was some discussion, which split into three separate issues - capturing it here:\r\n\r\n1) SUBSCRIBE REQUEST should have a way to denote which part of the Full Track Name is the namespace.  Either a Track Namespace Length field or just transmitting Track Namespace and Track Name in two fields.  There was consensus to add this.\r\n\r\n2) Does relay matching behavior (eg: exact match vs longest prefix vs ??) need to be negotiated in band? (#252)\r\n\r\n3) Is there a way to subscribe to more than one track at a time (eg: wildcard subscribe, #253).\r\n\r\nI'd like to keep this issue focused on 1.  ",
          "createdAt": "2023-09-27T18:04:48Z",
          "updatedAt": "2023-09-27T18:04:48Z"
        }
      ]
    },
    {
      "number": 205,
      "id": "I_kwDOG2Ho4M5ntZTh",
      "title": "Relay send while receiving",
      "url": "https://github.com/moq-wg/moq-transport/issues/205",
      "state": "CLOSED",
      "author": "jordicenzano",
      "authorAssociation": "NONE",
      "assignees": [
        "ianswett"
      ],
      "labels": [
        "Needs PR"
      ],
      "body": "Should we mention that a relay should start sending object as soon as the object can be identified (after the header)?\r\n\r\nSince the draft points out latency as a big deal, it seems this is a must have if we want to cover ULL cases",
      "createdAt": "2023-06-03T22:15:44Z",
      "updatedAt": "2023-10-16T17:26:15Z",
      "closedAt": "2023-10-16T17:26:15Z",
      "comments": [
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "+1.",
          "createdAt": "2023-06-05T07:12:55Z",
          "updatedAt": "2023-06-05T07:12:55Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "It used to be in #148 but was removed. The text was pretty simple:\r\n> A sender SHOULD transmit incomplete objects to avoid incurring additional latency.\r\n\r\nI think [this was the conversation](https://github.com/moq-wg/moq-transport/pull/148#discussion_r1178341564) and the agreement was to put it into some non-existent latency section.",
          "createdAt": "2023-06-09T18:17:07Z",
          "updatedAt": "2023-06-09T18:17:30Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 We should add a recommendation text for Relays to address the request from @jordicenzano ",
          "createdAt": "2023-07-06T04:23:35Z",
          "updatedAt": "2023-07-06T04:23:35Z"
        }
      ]
    },
    {
      "number": 206,
      "id": "I_kwDOG2Ho4M5ntZz-",
      "title": "Length optimization on message syntax (bit in \"type\" byte)",
      "url": "https://github.com/moq-wg/moq-transport/issues/206",
      "state": "CLOSED",
      "author": "jordicenzano",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "Needs PR",
        "Wire Format"
      ],
      "body": "Since message (6.  Messages) will be the main piece of info of MOQ I think we should try to minimize its size. Assuming most of the messages send to the wire will be objects inside a quic stream, the length should be NOT needed. Could we use 1 bit in \"type\" to indicate if length is present, we could save some bytes without overcomplicating the protocol\r\n",
      "createdAt": "2023-06-03T22:20:13Z",
      "updatedAt": "2023-10-11T00:55:01Z",
      "closedAt": "2023-10-11T00:55:01Z",
      "comments": [
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "The length of a QUIC stream is only known after the FIN bit is received(ie the end of QUIC stream). Putting the length in the message header can ensure the size of stream is known at the beginning of the stream. ",
          "createdAt": "2023-06-05T03:28:39Z",
          "updatedAt": "2023-06-05T03:28:39Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "The size of an OBJECT is a varint so that's a single byte when 0. Even in the situation where you're sending an OBJECT per frame, that's what like 100 OBJECTs per second?. That's 100B/s while the media might average 375,000B/s (3Mb/s).\r\n\r\nBut yeah, we can optimize when the draft is closer to completion and things are more concrete. I like how QUIC STREAM frames are encoded, where the frame type indicates if fields are present (ex. length).",
          "createdAt": "2023-06-09T18:10:06Z",
          "updatedAt": "2023-06-09T18:10:34Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "This issue is related to the question of what types of lengths we'll support, and whether we'll support those that go to the end of a quic stream (aka infinite length).\r\n\r\n\"unknown\" payloads where they're a delimiter of some sort had no support, because you have to do extra parsing.\r\n\r\nThis issue is about two types: Object and Object + Length, which has support from the WG.\r\n\r\nMartin to roll into PR #255",
          "createdAt": "2023-10-05T20:07:00Z",
          "updatedAt": "2023-10-05T20:07:00Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "From Cambridge: Martin will put this in a separate PR once #255 lands",
          "createdAt": "2023-10-09T16:53:37Z",
          "updatedAt": "2023-10-09T16:53:37Z"
        }
      ]
    },
    {
      "number": 207,
      "id": "I_kwDOG2Ho4M5ntajj",
      "title": "What about live rewind or VOD use cases",
      "url": "https://github.com/moq-wg/moq-transport/issues/207",
      "state": "CLOSED",
      "author": "jordicenzano",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "Subscribe"
      ],
      "body": "With sentences like \"The publisher MUST start delivering the objects from the most recent group\" seems the the draft is only considering live edge for now. But perhaps we would want to tackle other cases like \"rewind\" or \"VOD\", those will probably add more complexity on the server side.\r\n\r\nJust some thoughts:\r\n- To tackle more use cases than live edge I think we should add timing information somewhere, and that info should be readable by the relay. If we do not have that, how the relay knows\r\n    - Which objects start sending and when to send them?\r\n    - How to align different tracks (ex: audio and video)\r\n",
      "createdAt": "2023-06-03T22:25:19Z",
      "updatedAt": "2023-10-09T16:21:48Z",
      "closedAt": "2023-10-09T16:21:48Z",
      "comments": [
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "Rewind or VOD can be implemented by setting the GROUP SEQUENCE Parameter and OBJECT SEQUENCE Parameter. And it will not add complexity on the server side since it is client driven.",
          "createdAt": "2023-06-05T03:49:20Z",
          "updatedAt": "2023-06-05T03:49:20Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Related to #245 ",
          "createdAt": "2023-10-04T20:48:14Z",
          "updatedAt": "2023-10-04T20:48:14Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this as being subsumed by #245.",
          "createdAt": "2023-10-09T16:21:48Z",
          "updatedAt": "2023-10-09T16:21:48Z"
        }
      ]
    },
    {
      "number": 208,
      "id": "I_kwDOG2Ho4M5oFml2",
      "title": "Streaming format negotiation",
      "url": "https://github.com/moq-wg/moq-transport/issues/208",
      "state": "OPEN",
      "author": "fiestajetsam",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "NotTransport"
      ],
      "body": "At June interim Wil Law presented the [WARP streaming format](https://datatracker.ietf.org/doc/slides-interim-2023-moq-08-sessa-warp-streaming-format/), which identifies itself within the payload using the first varint bytes. This is a concern as it implies:\r\n* All formats must at least start with a varint, and does not permit other formats to use different structures\r\n* It could impede negotiation for catalogue formats as it happens after at least one format is sent\r\n\r\nDiscussion in the chat suggested to provide the format in the transport as part of an ANNOUNCE, but instead of having it as part of the name, if it makes sense to use a varint include it as a separate field.",
      "createdAt": "2023-06-07T16:42:27Z",
      "updatedAt": "2023-10-18T02:53:58Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it's strange to include the catalog format/version inside the catalog itself. It means a subscriber has to request the catalog before it knows if it can parse it. \r\n\r\nHere's my proposal for \"track format\" as part of the ANNOUNCE (#150). It basically moves the track format/version varint to the ANNOUNCE message, allowing it to behave like a catalog of catalogs.\r\n\r\nAn alternative I kind of like is something @vasilvv has mentioned. We can use the track name to identify the catalog format, much like how an extension is used to identify a file format. For example, `ANNOUNCE catalog.moov catalog.m3u8` would advertise two possible catalog tracks.",
          "createdAt": "2023-06-09T04:43:41Z",
          "updatedAt": "2023-06-09T04:43:41Z"
        },
        {
          "author": "fiestajetsam",
          "authorAssociation": "NONE",
          "body": "@kixelated I don't think using \"file extensions\" like Victor suggested would be good for implementations - all the other data is part of a structure of some kind, but to separate catalog name from format you have to `split('.')` seems a kludge. I think ANNOUNCE might need a bit more thought on its structure and both sender/receiver behaviours - in particular being descriptive of what happens when a format is unsupported. I'm happy to make a PR.",
          "createdAt": "2023-06-09T08:05:57Z",
          "updatedAt": "2023-06-09T08:05:57Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "To clarify, my proposal was roughly:\r\n\r\n1. Every format has an associated catalog name (`/warp`, `/loc`, or, if we unify the catalog format, `/catalog_v1` or something).\r\n2. The client knows the names of the catalogs corresponding to formats that it supports, so it just sends something like `SUBSCRIBE /warp OR /loc OR /someotherformat`, and it will result in being subscribed to the first format that exists.\r\n\r\nNote that this does require a SUBSCRIBE message that allows requesting a list of multiple alternative tracks, but it keeps the ANNOUNCE message as-is.  An alternative would be having a list of available catalogs in ANNOUNCE, and only subscribing to one of those.\r\n\r\n> all the other data is part of a structure of some kind, but to separate catalog name from format you have to split('.') seems a kludge\r\n\r\nYou don't have to separate those, those are fixed strings.",
          "createdAt": "2023-06-09T09:03:46Z",
          "updatedAt": "2023-06-09T09:03:46Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry @vasilvv, I didn't meant to misrepresent your proposal. Let me try to summarize the options proposed so far.\r\n\r\n**How does the receiver learn about available catalog tracks?**\r\n  1. There's a fixed catalog track.\r\n  2. There's a fixed catalog track per format, and the receiver blindly subscribes to all supported formats.\r\n  3. The ANNOUNCE messages contains a list of tracks.\r\n\r\n**How is the track format encoded?**\r\n  1. The first few bytes of the track\r\n  2. The full name of the track.\r\n  3. The track name prefix/suffix.\r\n  4. A separate field in ANNOUNCE.\r\n\r\nAll of the proposal need some sort of track format registry.",
          "createdAt": "2023-06-09T17:46:21Z",
          "updatedAt": "2023-06-09T17:46:21Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I personally like making ANNOUNCE mandatory, sent immediately after SETUP when ROLE=publisher. At a minimum, the ANNOUNCE contains a list of catalog tracks and some way to identify the format.\r\n\r\nThat way receiver knows that a track both exists and is supported _prior_ to subscribing to it.",
          "createdAt": "2023-06-09T17:56:30Z",
          "updatedAt": "2023-06-09T17:56:30Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like Victor's proposal of each streaming format defining a unique name for its catalog. We can ensure uniqueness by having the catalog name being one of the registered attributes in the IANA table for MOQT Streaming Formats. \r\n\r\nSince a catalog is just a track, the ANNOUNCE does not have to specify the type of streaming format, it simply announces the name of the track, since the the name would then infers the type. \r\n\r\nFurther, if we enforce the convention that track names are relative to the catalog (or conversely that track names carry the catalog full track name as a prefix), then we have a concise mechanism for announcing multi-format content. Consider the case of a producer emitting two sets of content, one packaged for /warp and the other for /loc. \r\n\r\nThe total tracks it is producing would be:\r\nexample.com/alice/12345/warp\r\nexample.com/alice/12345/warp/video\r\nexample.com/alice/12345/warp/audio\r\nexample.com/alice/12345/loc\r\nexample.com/alice/12345/loc/abc/front\r\nexample.com/alice/12345/loc/abc/back\r\nexample.com/alice/12345/loc/abc/audio\r\n\r\nThe ANNOUNCE could then simply advertise the catalogs\r\n{\r\nexample.com/alice/12345/warp;\r\nexample.com/alice/12345/loc\r\n}\r\n\r\nIn fact, since relays don't need to understand catalog formats, the ANNOUNCE could just advertise the minimum common path for the all the content that client is publishing, which would be\r\n{\r\nexample.com/alice/12345/\r\n}\r\n\r\n\r\n\r\n",
          "createdAt": "2023-06-22T23:34:23Z",
          "updatedAt": "2023-06-22T23:34:23Z"
        },
        {
          "author": "alvestrand",
          "authorAssociation": "NONE",
          "body": "Note that reusing the \"track\" namespace for a set of standardized names now means that you have both a controlled namespace (the standard names) and an uncontrollled namespace (server chosen names) in the same protocol field.\r\n\r\nIf you want to do that, good practice is to reserve some prefix for one of the usages, so that they can never collide.\r\n",
          "createdAt": "2023-07-24T23:25:10Z",
          "updatedAt": "2023-07-24T23:25:10Z"
        }
      ]
    },
    {
      "number": 209,
      "id": "I_kwDOG2Ho4M5oPWU4",
      "title": "Naming: Track ID or Subscription ID or ?",
      "url": "https://github.com/moq-wg/moq-transport/issues/209",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Editorial",
        "Subscribe"
      ],
      "body": "I'm implementing moq-transport-00 now and ran into this. I thought we decided on a course of action but we must have gotten distracted with the actual important changes.\r\n\r\n### Problem\r\nThe `track ID` contained in the SUBSCRIBE OK message is used to map the full track name into an varint. However, as explained in #145, there's a race condition when the SUBSCRIBE OK message is delayed. OBJECTs will arrive and the receiver will have no idea what track they're for and will have to buffer them.\r\n\r\n### Proposal\r\nMove the `Track ID` from the `SUBSCRIBE OK` message to the `SUBSCRIBE` message. This moves the responsibility for choosing an ID from the sender to the receiver. The benefit is that a receiver never has to buffer OBJECTs waiting for a SUBSCRIBE OK, and can instead abort/discard unknown OBJECTs. The downside is that the sender has to use a different `Track ID` for each connection.\r\n\r\n`Full Track Name` would be removed from `SUBSCRIBE OK` and `SUBSCRIBE ERROR` since it would be redundant.",
      "createdAt": "2023-06-09T00:32:41Z",
      "updatedAt": "2024-02-07T03:07:17Z",
      "closedAt": "2024-02-07T03:07:17Z",
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "I personally don't see the naming is confusing in this case. Its still an alias for the track requested and it does indeed represents the track.\r\n\r\nIt may be good to split this in to 2 /3 issues . One for if we should rename and another on how an alias is generated and proposals to change the message (OK/ERROR) ??",
          "createdAt": "2023-06-09T03:30:52Z",
          "updatedAt": "2023-06-09T03:30:52Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> I personally don't see the naming is confusing in this case. Its still an alias for the track requested and it does indeed represents the track.\r\n\r\nIs the `Track ID` a property of the track? You can argue \"maybe\" when the sender chooses the ID, but it's a definitive \"no\" when the receiver chooses. Meanwhile, the `Track Full Name` is a actually a property of the track, and it is by definition the unique identifier (ID) for a track within a scope.\r\n\r\nBut it's just a name so it's fine to leave as is. The rename to `Subscription ID` will make more sense as we flesh out more subscription mechanisms like server-side ABR.",
          "createdAt": "2023-06-09T04:29:36Z",
          "updatedAt": "2023-06-09T18:42:21Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Here's how the flow would work if we add #132:\r\n```\r\nSUBSCRIBE   id=4 name=twitch.tv/kixelated/480p\r\nUNSUBSCRIBE id=4\r\nSUBSCRIBE   id=5 name=twitch.tv/kixelated/720p\r\nUNSUBSCRIBE id=5\r\nSUBSCRIBE   id=6 name=twitch.tv/kixelated/480p\r\n```\r\n\r\nI think it's confusing that `track_id=4` and `track_id=6` actually refer to the exact same track. That's why I claim it's a subscription identifier, and not a track identifier.\r\n\r\nAnd if we explicitly call it a `Subscribe ID`, then updating subscriptions becomes valid. I'm not sure if this is explicitly a good idea, but it would be nice for seamlessly switching between tracks at group boundaries. Otherwise the receiver has to guess the most recent group ID when switching between renditions.\r\n\r\n```\r\nSUBSCRIBE id=4 name=twitch.tv/kixelated/480p\r\nSUBSCRIBE id=4 name=twitch.tv/kixelated/720p\r\n```",
          "createdAt": "2023-06-09T18:50:23Z",
          "updatedAt": "2023-06-09T18:50:23Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "SUBSCRIBE id=4 name=twitch.tv/kixelated/480p\r\nSUBSCRIBE id=4 name=twitch.tv/kixelated/720p\r\n\r\n--> this will never work. You can't have 2 different tracks to have same trackId of 4. This is just a wrong implementation.\r\n\r\nIn the example\r\n```\r\nSUBSCRIBE   id=4 name=twitch.tv/kixelated/480p\r\nUNSUBSCRIBE id=4\r\nSUBSCRIBE   id=5 name=twitch.tv/kixelated/720p\r\nUNSUBSCRIBE id=5\r\nSUBSCRIBE   id=6 name=twitch.tv/kixelated/480p\r\n```\r\n\r\nonce id=4 is unsubscribed, the implementation need to clean up the context. When a new subscribe for the same name happens and get id=6, its the new alias for the same track.\r\n\r\nI still don't see why renaming is making anything less or more clearer. Its just an alias for an active track.\r\n\r\nAgain we are mixing 2 issues here - one renaming and another where the Id should be generated (in subscribe or subscribe_ok) . ",
          "createdAt": "2023-06-09T21:04:37Z",
          "updatedAt": "2023-06-09T21:04:37Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 to Suhas that what we call it and how it works are different issues.  Is this issue only to discuss naming and we can use 145 to discuss behavior?",
          "createdAt": "2023-06-09T21:34:06Z",
          "updatedAt": "2023-06-09T21:34:06Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry, I shouldn't have posted that example. I didn't even explain the problem it was trying to solve, and we can discuss that in a separate issue.\r\n\r\nLet's leave the name.",
          "createdAt": "2023-06-09T23:22:16Z",
          "updatedAt": "2023-06-09T23:22:16Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "And thinking about it some more, I've been calling it \"subscription ID\" in my code mostly because \"track ID\" is already used by CMAF.\r\n\r\n**MoQ Transport \"Track ID\":** A transient varint chosen by the subscriber scoped to the connection.\r\n**Warp \"Track ID\":** A int32 chosen by the encoder scoped to the catalog.\r\n\r\nThey're close enough that it's confusing to call them the same name.",
          "createdAt": "2023-06-09T23:31:16Z",
          "updatedAt": "2023-06-09T23:33:40Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It seems like a more stateless relay design would be better where if two subscriptions from different clients subscribed to the same track, the relay had the option of using the same ID for both of them. Not all relays would do this but it seems like some would want to be that way to map up with existing CDN implementations. Not sure what I think but definitely needs some brainstorming. ",
          "createdAt": "2023-07-22T19:13:24Z",
          "updatedAt": "2023-07-22T19:13:24Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "To make it clear that this issue will focus on naming, per Alan's suggestion, I retitled it and marked #145 as architectural",
          "createdAt": "2023-07-24T13:12:25Z",
          "updatedAt": "2023-07-24T13:12:25Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe this is likely OBE, but we can put it into the Subscribe category for Prague, particularly around having multiple simultaneous subscriptions.",
          "createdAt": "2023-10-17T01:21:26Z",
          "updatedAt": "2023-10-17T01:21:26Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this issue was only tracking what to call Track ID -- isn't it still terminology?",
          "createdAt": "2023-10-17T16:04:04Z",
          "updatedAt": "2023-10-17T16:04:04Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "As for naming, Track Name Alias was the most recent suggestion to replace Track ID.",
          "createdAt": "2023-11-05T19:04:14Z",
          "updatedAt": "2023-11-05T19:04:14Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the group has settled on Subscription ID (identifies a subscription) and Track Alias (identifies just a full track name) for now.",
          "createdAt": "2024-02-07T03:07:17Z",
          "updatedAt": "2024-02-07T03:07:17Z"
        }
      ]
    },
    {
      "number": 210,
      "id": "I_kwDOG2Ho4M5oQHB6",
      "title": "Track Request Parameters",
      "url": "https://github.com/moq-wg/moq-transport/issues/210",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Implementation Blocker",
        "Needs Discussion",
        "Wire Format",
        "Parameters"
      ],
      "body": "https://moq-wg.github.io/moq-transport/draft-lcurley-moq-transport.html#name-track-request-parameters\r\n\r\nFirst issue, it's in a weird section. The parameters mostly apply to 6.3 (all but one) but the section is in 6.6.1. \r\n\r\n<img width=\"298\" alt=\"Screenshot 2023-06-08 at 8 26 37 PM\" src=\"https://github.com/moq-wg/moq-transport/assets/432854/cc8de360-8a0a-4617-b6e4-629dd403f323\">\r\n\r\n\r\nSecond issue, the types are not defined. GROUP SEQUENCE and OBJECT SEQUENCE are presumably varints, while AUTHORIZATION information is presumably a varint size followed by bytes? The encoding needs to be specified otherwise it's impossible to implement.\r\n\r\nThird issue, and I hinted at it already, is that the parameters only apply to some messages and it's only mentioned at the very end. `This parameter is applicable in SUBSCRIBE REQUEST message`. The language is loose, and I'm not sure what I should do if I receive this parameter in an ANNOUNCE message.",
      "createdAt": "2023-06-09T03:36:05Z",
      "updatedAt": "2024-01-31T00:43:25Z",
      "closedAt": "2024-01-31T00:43:25Z",
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "on its placement,  +1, we should fix it.\r\n\r\nOn the params not applicable, we might want to add text to say, \" ignore the parameters that are not expected or unknown\" and this can be in general to all the parameters. This is very typical and allows extensibility and experimentation",
          "createdAt": "2023-06-09T03:48:52Z",
          "updatedAt": "2023-06-09T03:48:52Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> On the params not applicable, we might want to add text to say, \" ignore the parameters that are not expected or unknown\" and this can be in general to all the parameters. This is very typical and allows extensibility and experimentation\r\n\r\nI think we should have separate parameters for each message as the draft develops: SETUP Parameters, SUBSCRIBE Parameters, and ANNOUNCE Parameters. It made made sense to consolidate PUBLISH_INTENT and SUBSCRIBE_REQUEST together, but ANNOUNCE is quite different.\r\n\r\nIt's fine to copy-paste the only shared parameter (AUTHORIZATION INFO). It's just an opaque binary blob, and we might replace it anyway as part of leveraging existing authentication standards (something like #152).",
          "createdAt": "2023-06-09T04:17:24Z",
          "updatedAt": "2023-06-09T04:17:24Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "yeah that seems fine change. At  some point we did stat that way and decided to move it to its own section and we can always move it later, if needed to",
          "createdAt": "2023-06-09T15:28:33Z",
          "updatedAt": "2023-06-09T15:28:33Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Marked as `Implementation Blocker` because it's not specified how these parameters are encoded.",
          "createdAt": "2023-08-07T21:24:23Z",
          "updatedAt": "2023-08-07T21:24:23Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > On the params not applicable, we might want to add text to say, \" ignore the parameters that are not expected or unknown\" and this can be in general to all the parameters. This is very typical and allows extensibility and experimentation\r\n> \r\n> I think we should have separate parameters for each message as the draft develops: SETUP Parameters, SUBSCRIBE Parameters, and ANNOUNCE Parameters. It made made sense to consolidate PUBLISH_INTENT and SUBSCRIBE_REQUEST together, but ANNOUNCE is quite different.\r\n> \r\n> It's fine to copy-paste the only shared parameter (AUTHORIZATION INFO). It's just an opaque binary blob, and we might replace it anyway as part of leveraging existing authentication standards (something like #152).\r\n\r\nThe somewhat annoying bit about a per-message namespace is that we have tons of IANA registries. Editorially, I would be happy for each parameter/message instance but let's put it in the same namespace",
          "createdAt": "2023-10-05T18:52:57Z",
          "updatedAt": "2023-10-05T18:52:57Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe this is fixed by #256",
          "createdAt": "2023-10-05T18:55:16Z",
          "updatedAt": "2023-10-05T18:55:16Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If we converge on #256, yes this is fixed",
          "createdAt": "2023-10-05T18:57:05Z",
          "updatedAt": "2023-10-05T18:57:05Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we can close this now?  Draft-01 clearly specifies the types of the parameters, and #302 finishes removing OBJECT_SEQUENCE and OBJECT_GROUP.  Now all that's left is Auth, which is applicable to both messages that allow Track Request Parameters.",
          "createdAt": "2023-10-25T17:01:01Z",
          "updatedAt": "2023-10-25T17:01:01Z"
        }
      ]
    },
    {
      "number": 212,
      "id": "I_kwDOG2Ho4M5oZ2GR",
      "title": "SETUP message type",
      "url": "https://github.com/moq-wg/moq-transport/issues/212",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "vasilvv"
      ],
      "labels": [
        "Needs PR",
        "Implementation Blocker",
        "Handshake"
      ],
      "body": "There's a single SETUP message, but the contents change based on if the endpoint is a server or a client. [See the draft](https://moq-wg.github.io/moq-transport/draft-lcurley-moq-transport.html#name-setup).\r\n\r\nThis is difficult to implement in type safe languages. I would implement `ClientSetup` and `ServerSetup`, sharing the same ID. However, it's then difficult to implement a generic `decode` method as it needs to know the expected role to distinguish between the two.\r\n\r\nI propose a separate `ClientSetup` and `ServerSetup` message akin to how TLS has a separate `ClientHello` and `ServerHello`. Alternatively, implement #138 to reclassify SETUP and OBJECT as control and data stream headers respectively.",
      "createdAt": "2023-06-11T21:12:04Z",
      "updatedAt": "2023-10-23T17:16:30Z",
      "closedAt": "2023-10-23T17:16:30Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Hmm, so this isn't a problem in my code any longer since made SETUP a special message type. We should still figure out if both the client and server SETUP use the same ID, or separate IDs like TLS.",
          "createdAt": "2023-06-27T18:06:02Z",
          "updatedAt": "2023-06-27T18:06:02Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I still like the idea of, if these message are different, they should have different names as it will just be confusing if they do not. \r\n",
          "createdAt": "2023-07-27T20:13:31Z",
          "updatedAt": "2023-07-27T20:13:31Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreement these should be different message types, just like TLS.",
          "createdAt": "2023-08-07T17:12:57Z",
          "updatedAt": "2023-08-07T17:12:57Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Conveniently, message id=2 is currently not used. I propose ClientSetup = 1 and ServerSetup = 2.",
          "createdAt": "2023-08-07T21:23:12Z",
          "updatedAt": "2023-08-07T21:23:12Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Thinking about this a bit more, do we want to bake in the assumption that the client always speaks first into the protocol?  For raw QUIC, typically, the server would have 1-RTT keys first.",
          "createdAt": "2023-08-21T14:41:12Z",
          "updatedAt": "2023-08-21T14:41:12Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> Thinking about this a bit more, do we want to bake in the assumption that the client always speaks first into the protocol? For raw QUIC, typically, the server would have 1-RTT keys first.\r\n\r\nI would love to see something like HTTP/3 SETTINGS where both endpoints can send the message in parallel. That requires version negotiation at a lower level in something like ALPN though.\r\n\r\nThe SERVER SETUP would be sent first in native QUIC while the CLIENT SETUP could be sent first with WebTransport (in parallel with CONNECT).",
          "createdAt": "2023-08-21T16:43:57Z",
          "updatedAt": "2023-08-21T16:43:57Z"
        }
      ]
    },
    {
      "number": 213,
      "id": "I_kwDOG2Ho4M5oZ7_E",
      "title": "No encoding for GOAWAY",
      "url": "https://github.com/moq-wg/moq-transport/issues/213",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "kixelated"
      ],
      "labels": [
        "Needs PR",
        "Implementation Blocker",
        "Wire Format"
      ],
      "body": "The draft doesn't specify how to encode GOAWAY. [See the draft](https://moq-wg.github.io/moq-transport/draft-lcurley-moq-transport.html#name-goaway). At a minimum we need a new connect URL.",
      "createdAt": "2023-06-11T22:19:38Z",
      "updatedAt": "2023-10-19T02:49:05Z",
      "closedAt": "2023-10-19T02:49:05Z",
      "comments": [
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I can envisage a number of possible scenarios for GOAWAY:\r\n\r\n1. An edge relay that wants you to disconnect from the current relay but then reconnect using the same connect URL as was originally used. This is because DNS will be used to move the client to a different machine. In this case no connect URL is needed. \r\n2. An edge relay that wants you to disconnect from the current relay but then reconnect using a different connect URL to the same CDN. The CDN knows how to construct its own URLs and hence can generate this connect URL. IN this case  a connect URL should be included with the GOAWAY.\r\n3. An edge relay wants the client to disconnect completely from the CDN and resort to a fail-over CDN. In this case the client would have been provisioned with the fail-over connect URL so no connect URL need be transmitted by the edge server. \r\n\r\nSo we have cases where a connect URL is both present and absent with GOAWAY. It should therefore be an optional parameter. ",
          "createdAt": "2023-06-22T22:44:30Z",
          "updatedAt": "2023-06-22T22:44:30Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like the design where the GOAWAY has a URL that tells the client what to try next, it might be the same URL or it might be something different. Seems simple, flexible, and sort of what people expect. \r\n",
          "createdAt": "2023-07-27T20:15:21Z",
          "updatedAt": "2023-07-27T20:15:21Z"
        },
        {
          "author": "hardie",
          "authorAssociation": "COLLABORATOR",
          "body": "On Thu, Jul 27, 2023 at 9:15\u202fPM Cullen Jennings ***@***.***>\r\nwrote:\r\n\r\n> I like the design where the GOAWAY has a URL that tells the client what to\r\n> try next, it might be the same URL or it might be something different.\r\n> Seems simple, flexible, and sort of what people expect.\r\n>\r\n2 of  Will's 3 didn't require a connect-URL (one being semantically\r\n\"restart\" and three being semantically \"failover to preconfigured\r\nalternative\").  The tricky one is \"switch to nominated alternative\",\r\nbecause different CDNs will construct the URLs in ways that vary from each\r\nother, so it will be difficult to ensure that the failover really is to the\r\nsame CDN.  Even if you get into the public suffix list or dbound space,\r\nthere's going to be some CDN that has constructed itself in a way that\r\nmakes that less than obvious from inspection.   Unless you're going to\r\nallow them to nominate any alternative, working through what's allowed here\r\nis going to be tricky.\r\n\r\nI'd suggest getting GOAWAY \"restart\" and GOAWAY \"failover\" defined now,\r\nsince they are easy.  Put GOAWAY \"nominated alternative\" as a TBD until we\r\nget further along.\r\n\r\nJust my two cents as an individual who has been bitten by too-liberal URL\r\nslots (at the extreme the \"what to try next\" could be a tel URI with the\r\nsupport number, which is just not on, in my opinion).\r\n\r\nTed\r\n\r\n\r\n\u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/moq-wg/moq-transport/issues/213#issuecomment-1654500825>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AAKVXZCYJQBKULVB44WWXU3XSLD6LANCNFSM6AAAAAAZCTELMI>\r\n> .\r\n> You are receiving this because you are subscribed to this thread.Message\r\n> ID: ***@***.***>\r\n>\r\n",
          "createdAt": "2023-08-21T09:09:44Z",
          "updatedAt": "2023-08-21T09:09:44Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This should be relay to client message",
          "createdAt": "2023-10-05T19:48:06Z",
          "updatedAt": "2023-10-05T19:48:06Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would like to see the design support a make before break on the new connection in the gracefull move case. It sounded like Luke had ideas for that. ",
          "createdAt": "2023-10-05T19:49:51Z",
          "updatedAt": "2023-10-05T19:49:51Z"
        }
      ]
    },
    {
      "number": 214,
      "id": "I_kwDOG2Ho4M5opcK3",
      "title": "Draft version numbers",
      "url": "https://github.com/moq-wg/moq-transport/issues/214",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "kixelated"
      ],
      "labels": [
        "Needs PR",
        "Implementation Blocker"
      ],
      "body": "It's time to specify some version numbers so we can attempt interop.\r\n\r\nWe should do something like QUIC, where draft versions are prefixed with 0xff (or something?).",
      "createdAt": "2023-06-13T21:54:06Z",
      "updatedAt": "2023-09-25T16:46:57Z",
      "closedAt": "2023-09-25T16:46:57Z",
      "comments": [
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 The QUIC guys way over engineered this so I would be fine with just doing the same thing so we don't need to bike shed on it. ",
          "createdAt": "2023-06-13T22:08:06Z",
          "updatedAt": "2023-06-13T22:08:06Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For now, will go with lower bits are the draft number and upper bits are some fixed set of bits defined in the draft. Do roughly what QUIC did. ",
          "createdAt": "2023-08-07T17:08:37Z",
          "updatedAt": "2023-08-07T17:08:37Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Here's what I propose we copy:\r\n\r\nhttps://datatracker.ietf.org/doc/html/draft-ietf-quic-transport-32#section-15-10\r\n\r\n> Version numbers used to identify IETF drafts are created by adding the draft number to 0xff000000. For example, draft-ietf-quic-transport-13 would be identified as 0xff00000d.\r\n\r\nWe don't need semvar yet because each version WILL have breaking changes. I'd be totally fine with semvar for the final RFC, like one byte for the major/minor/revision. Although I also think that negotiating extensions is more flexible for a transport protocol, while semvar seems more useful for something intended for fanout like the catalog.",
          "createdAt": "2023-08-07T21:13:52Z",
          "updatedAt": "2023-08-07T21:14:50Z"
        }
      ]
    },
    {
      "number": 215,
      "id": "I_kwDOG2Ho4M5oxQ_n",
      "title": "Parameter encoding",
      "url": "https://github.com/moq-wg/moq-transport/issues/215",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Parameters (SETUP/ANNOUNCE/SUBSCRIBE) are currently encoded something like:\r\n\r\n```\r\nparam_1_id:    varint\r\nparam_1_size:  varint\r\nparam_1_value: bytes(size)\r\nparam_2_id:    varint\r\nparam_2_size:  varint\r\nparam_2_value: bytes(size)\r\n...\r\n```\r\n\r\nFirst off, it would be a good idea to centralize this encoding somewhere in the document. It's also quite difficult to read right now without a table of of IDs to name/type.\r\n\r\nSecond off, it would be nice if we could include the number of parameters in the encoding. Right now you have to infer the size of the parameters based on the remaining size of the message, counting the number of bytes remaining. It's not the worst, but it makes it more difficult to implement.\r\n\r\nI think it's marginally better to copy how TLS/MP4 work:\r\n```\r\nparams_size:   varint\r\nparam_1_id:    varint\r\nparam_1_size:  varint\r\nparam_1_value: bytes(size)\r\n...\r\n```",
      "createdAt": "2023-06-14T22:33:40Z",
      "updatedAt": "2023-06-27T18:15:50Z",
      "closedAt": "2023-06-27T18:15:50Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Although I'm a fan of the QUIC approach, where extensions need to be negotiated. The transport parameters still need to be generic (equivalent to SETUP) but after that, every message is strongly typed and no explicit size is on the wire.\r\n\r\nFor example, let's assume version 0 of this draft does not ship with server-side ABR. I would rather negotiate a \"server_abr\" extension in SETUP and use an explicit SUBSCRIBE_AUTO message, rather than add parameters to the existing SUBSCRIBE message. I can't emphasize how much impact such a small difference makes; it's the difference between strongly typed and weakly typed messages.\r\n\r\nAnnounce would look something like this:\r\n\r\n```\r\nmessage_type: varint\r\nnamespace_len: varint\r\nnamespace_str: str(len)\r\n*** optional_count: varint ***\r\noptional_1_id: varint\r\noptional_1_value: bytes(x)\r\noptional_2_id: varint\r\noptional_2_value: bytes(y)\r\n```\r\n\r\nCurrently it looks like:\r\n```\r\nmessage_type: varint\r\n*** message_size: varint ***\r\nnamespace_len: varint\r\nnamespace_str: str(len)\r\nparam_1_id: varint\r\n*** param_1_size: varint ***\r\nparam_1_value: bytes(size)\r\nparam_2_id: varint\r\n*** param_2_size: varint ***\r\nparam_2_value: bytes(size)\r\n```\r\n\r\nWe could go even further an encode the existence of optional fields into the type ID like QUIC (STREAM and ACK):\r\n\r\n```\r\nmessage_type_and_flags: varint\r\nnamespace_len: varint\r\nnamespace_str: str(len)\r\noptional_2_value: bytes\r\n```",
          "createdAt": "2023-06-14T22:44:25Z",
          "updatedAt": "2023-06-14T22:51:16Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Going to file a new issue that better explains the issue.",
          "createdAt": "2023-06-27T18:15:50Z",
          "updatedAt": "2023-06-27T18:15:50Z"
        }
      ]
    },
    {
      "number": 216,
      "id": "I_kwDOG2Ho4M5pL9oL",
      "title": "relay modifying payload",
      "url": "https://github.com/moq-wg/moq-transport/issues/216",
      "state": "CLOSED",
      "author": "gwendalsimon",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "NotTransport"
      ],
      "body": "Line 234 and line 598: \u201cA relay MUST NOT combine, split, or otherwise modify object payloads.\u201d I would argue against this statement. It is sometimes a good idea to let the edge (relay) modify the payload of the object. For example, it is possible to embed a watermark on the video content at the edge by applying some slight changes on the (compressed and encrypted) payload. More generally edge processing can preserve the scalability (only one version of the object is sent to the relay) while enabling personalization. \r\n\r\nBesides, the formulation at Line 773 \u201cpayload SHOULD NOT be processed by a relay\u201d is not consistent. Imho it would be a better formulation.",
      "createdAt": "2023-06-20T06:37:14Z",
      "updatedAt": "2024-02-19T22:15:50Z",
      "closedAt": "2024-02-19T22:15:50Z",
      "comments": [
        {
          "author": "hardie",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi Gwendal,\r\n\r\nNote that the proposed action will not work if the relay does not have the\r\nkeys for the object and that this use case is specified in the charter:\r\n\r\nMedia content may be end-to-end encrypted in certain use cases, where the\r\n\"end-to-end\" keys are available to media sources and consumers, but not\r\nrelays.\r\n\r\n\r\nOn Tue, Jun 20, 2023 at 7:37\u202fAM Gwendal Simon ***@***.***>\r\nwrote:\r\n\r\n> Line 234 and line 598: \u201cA relay MUST NOT combine, split, or otherwise\r\n> modify object payloads.\u201d I would argue against this statement. It is\r\n> sometimes a good idea to let the edge (relay) modify the payload of the\r\n> object. For example, it is possible to embed a watermark on the video\r\n> content at the edge by applying some slight changes on the (compressed and\r\n> encrypted) payload. More generally edge processing can preserve the\r\n> scalability (only one version of the object is sent to the relay) while\r\n> enabling personalization.\r\n>\r\n> Besides, the formulation at Line 773 \u201cpayload SHOULD NOT be processed by a\r\n> relay\u201d is not consistent. Imho it would be a better formulation.\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/moq-wg/moq-transport/issues/216>, or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AAKVXZET4RHGPDSCYES7IQDXMFAKPANCNFSM6AAAAAAZMZOHSI>\r\n> .\r\n> You are receiving this because you are subscribed to this thread.Message\r\n> ID: ***@***.***>\r\n>\r\n",
          "createdAt": "2023-06-21T09:01:09Z",
          "updatedAt": "2023-06-21T09:01:09Z"
        },
        {
          "author": "gwendalsimon",
          "authorAssociation": "NONE",
          "body": "Hi Hardie,\r\n\r\nIt is possible to modify the payload even if the relay does not have the encryption keys. \r\n\r\nFor example, in edge-embedded watermark (which applies to DASH/HLS today but it could apply on MoQ as well in the future), some metadata are produced in the video headend to indicate which bytes of the payload should be modified. This metadata takes into account the encryption. The relay extracts the metadata and modifies the payload **without decrypting/re-encrypting** the content.\r\n\r\nMore generally, it is up to the relay to not introduce mess in the content. I don't really understand why we would need to specifically forbid any action on the payload in MoQ. ",
          "createdAt": "2023-06-21T09:19:26Z",
          "updatedAt": "2023-06-21T09:19:26Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm actually coming around to agreeing with Gendal on this one. The normative statement that \"_A relay MUST NOT combine, split, or otherwise modify object payloads_.\" was derived from a desire to ensure that relays in 3rd party network could be trusted to transmit but not modify the content. This trust enables reliable scale through CDNs, which was the feature that the authors were seeking. However there are use-cases in which a content distributor may legitimately want a trusted relay network to modify or substitute the content on their behalf - **watermarking** and **per-session encryption** being two of them. \r\n\r\nSince these features a critical to modern media delivery, we need to allow for them in moq-transport. Therefore we should relax the normative relay requirement to one of these two options:\r\n\r\n_A relay MUST NOT combine, split, or otherwise modify object payloads unless it is executing a distribution function on behalf of the content distributor._ \r\n\r\nor\r\n\r\n_A relay SHOULD NOT combine, split, or otherwise modify object payloads._\r\n\r\n",
          "createdAt": "2023-06-22T21:41:16Z",
          "updatedAt": "2023-06-22T21:41:16Z"
        },
        {
          "author": "hardie",
          "authorAssociation": "COLLABORATOR",
          "body": "On Thu, Jun 22, 2023 at 10:41\u202fPM Will Law ***@***.***> wrote:\r\n\r\n> I'm actually coming around to agreeing with Gendal on this one. The\r\n> normative statement that \"*A relay MUST NOT combine, split, or otherwise\r\n> modify object payloads*.\" was derived from a desire to ensure that relays\r\n> in 3rd party network could be trusted to transmit but not modify the\r\n> content. This trust enables reliable scale through CDNs, which was the\r\n> feature that the authors were seeking. However there are use-cases in which\r\n> a content distributor may legitimately want a trusted relay network to\r\n> modify or substitute the content on their behalf - *watermarking* and *per-session\r\n> encryption* being two of them.\r\n>\r\n> Since these features a critical to modern media delivery, we need to allow\r\n> for them in moq-transport. Therefore we should relax the normative relay\r\n> requirement to one of these two options:\r\n>\r\n> *A relay MUST NOT combine, split, or otherwise modify object payloads\r\n> unless it is executing a distribution function on behalf of the content\r\n> distributor.*\r\n>\r\nIndividual contributor hat on:\r\n\r\nI don't think this makes a sufficient distinction--any relay is \"executing\r\na distribution function on behalf of the content distributor\".\r\n\r\nAs we have discussed before, there are different types of intermediaries.\r\nFrom my perspective the range is from \"relay\" which is about what it says\r\non the tin (sending things along) to back-to-back client/origin gateways\r\n(which have one \"side\" which are clients that have media keys and use that\r\nstatus to produce transformations, thus becoming new origins on the other\r\n\"side\").  For anything between the two (without the media keys but with a\r\ntransformation function), I think we have to define the functionality both\r\nin terms of requirements (and I don't see anything in\r\ndraft-ietf-moq-requirements at the moment) and, eventually, as on the wire\r\ncapabilities.  The business arrangements which lead to them are at\r\ndifferent layer (8, if I remember the t-shirt).\r\n\r\n As an example, it looks to me like per-session encryption from client to\r\nintermediary is going to come by default from using QUIC; if you have some\r\nother requirements for that encryption, I think we need more than a\r\nmodification of this text to justify it.\r\n\r\nChair hat on:\r\n\r\nAttempting to permit protocol behavior with reference to business\r\narrangements not visible in the protocol has not been a wild success in\r\nIETF contexts in the past, and the chances that any such design will\r\nattract objections from the IETF security review teams seems to me very\r\nhigh.  If the working group decides to go down that path, I will suggest\r\nthat we get an early security review so that we avoid a late surprise on a\r\ndesign point of this magnitude.\r\n\r\nTed\r\n\r\n> or\r\n>\r\n> *A relay SHOULD NOT combine, split, or otherwise modify object payloads.*\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/moq-wg/moq-transport/issues/216#issuecomment-1603351716>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AAKVXZHMEZJXDWBMAOSEVPLXMS3YPANCNFSM6AAAAAAZMZOHSI>\r\n> .\r\n> You are receiving this because you commented.Message ID:\r\n> ***@***.***>\r\n>\r\n",
          "createdAt": "2023-06-23T08:35:43Z",
          "updatedAt": "2023-06-23T08:35:43Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> As an example, it looks to me like per-session encryption from client to\r\n> intermediary is going to come by default from using QUIC; if you have some\r\n> other requirements for that encryption, I think we need more than a\r\n> modification of this text to justify it.\r\n\r\nBy per-session encryption, I meant an edge relay dynamically applying DRM to clear media segments as it delivers them to a client, using a key that is unique to that particular client. This is a common feature of some HTTP CDNs today. This payload encryption is quite distinct from the transport layer encryption afforded by QUIC. ",
          "createdAt": "2023-06-23T16:52:27Z",
          "updatedAt": "2023-06-23T16:52:27Z"
        },
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "I agree with Ted. The relay as a function does not process the media payload. But it can be co-located with other media-payload-aware processing function(client/producer/transcoder). For example, a CDN node can implement both the relay(media-payload-agnostic forward) function and producer(media-payload-aware processing) function.",
          "createdAt": "2023-06-25T03:06:55Z",
          "updatedAt": "2023-06-25T03:06:55Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "My mental model is that MoQ relays are like QUIC middleboxes. A \"relay\" MUST NOT combine/split/modify the payloads, much like a router MUST NOT combine/split/modify QUIC packets.\r\n\r\nThe rationale is that OBJECT boundaries can have semantic meaning to the application. An obvious example is that an application may decide that each frame is an OBJECT. This will break if a relay changes how OBJECTs are fragmented, much like how QUIC will break (short header) if a router decides to split/concatenate UDP packets. And of course, a relay can cause havok if it decides to modify any bytes.\r\n\r\nOf course, we must support transcoding and transmuxing that works in conjunction with the application. We could come up with a new name for this processor, but I think it makes more sense to think in terms of layers. It's the difference between a L3 load balancer and an L7 load balancer.\r\n\r\n- **A moq-transport relay** MUST NOT modify object payloads. (ex. L3)\r\n- **A moq-warp relay** MAY modify object payloads. (ex. L7)\r\n\r\nMy video and chat application could run on Akamai. By default it would use `moq-transport` mode, where all OBJECTs are transferred unaltered. I could optionally opt-into on a `moq-warp` mode and have Akamai add a watermark, although the chat tracks are still in `moq-transport` mode and MUST NOT be modified.",
          "createdAt": "2023-06-27T19:17:28Z",
          "updatedAt": "2023-06-27T19:19:15Z"
        },
        {
          "author": "gwendalsimon",
          "authorAssociation": "NONE",
          "body": "Would it be possible to distinguish between \r\n- a \"passive relay\": who MUST NOT modify object payload, i.e. media-payload-agnostic forward (from @VMatrix19000), i.e. a moq-transport relay (from @kixelated)\r\n- an \"active relay\": who MAY modify object payload, i.e. media-payload-aware forward, a moq-warp relay\r\n\r\nTo be honest, I don't see how we can define it...\r\n\r\nYet, in practice, it is often the case that the _publisher_ (or _producer_) owns not only the origin (_QUIC Server_) but also the _Relay_ (directly or indirectly). Forcing all relays to be passive brings a restriction to various (present and future) optimizations. It would lead a publisher to implement two separate client-server MoQ sessions (client-relay and relay-origin) just for implementing a simple edge-embedding watermark.\r\n\r\nDo you have any strong motivation for forcing all relays to be definitively passive? What if the draft simply omits these sentences? ",
          "createdAt": "2023-06-28T21:20:56Z",
          "updatedAt": "2023-06-28T21:21:31Z"
        },
        {
          "author": "hardie",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi Gwendal\r\n\r\nIn my personal opinion, the passive terminology isn't helpful.  I think\r\nLuke's point is that there are middleboxes that act at the \"MoQ transport\"\r\nlayer and they are limited to passing the bits as they get them; we call\r\nthem relays because that's what the verb \"relay\" means.  You could call\r\nthem exploders, distribution nodes, or something else as well.  Those don't\r\nneed a lot of coordination with the node creating the objects (there could\r\nbe several layers of relay between the origin and the one we're currently\r\ndealing with)\r\n\r\nThere are other middleboxes with other roles, but those require more\r\ncoordination with the publisher.  Those middleboxes need more coordination;\r\na middlebox that adds an AI-generated closed caption will need the audio\r\nmedia key, for example.\r\n\r\nI don't think anyone is saying that there can't be middleboxes which add\r\nwatermarks; we're saying that they are not transport relays.\r\n\r\nOn Wed, Jun 28, 2023 at 10:21\u202fPM Gwendal Simon ***@***.***>\r\nwrote:\r\n\r\n> Would it be possible to distinguish between\r\n>\r\n>    - a \"passive relay\": who MUST NOT modify object payload, i.e.\r\n>    media-payload-agnostic forward (from @VMatrix19000), i.e. who is a\r\n>    moq-transport relay (from @kixelated <https://github.com/kixelated>)\r\n>    - an \"active relay\": who MAY modify object payload, i.e.\r\n>    media-payload-aware forward, a moq-warp relay\r\n>\r\n> To be honest, I don't see how we can define it...\r\n>\r\n> Yet, in practice, it is often the case that the *publisher* (or *producer*)\r\n> owns not only the origin (*QUIC Server*) but also the *Relay* (directly\r\n> or indirectly). Forcing all relays to be passive brings a restriction to\r\n> various (present and future) optimizations. It would lead a publisher to\r\n> implement two separate client-server MoQ sessions (client-relay and\r\n> relay-origin) just for implementing a simple edge-embedding watermark.\r\n>\r\n> Do you have any strong motivation for forcing all relays to be\r\n> definitively passive? What if the draft simply omits these sentences?\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/moq-wg/moq-transport/issues/216#issuecomment-1612121268>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AAKVXZCLVJ6JIRRZWHP4PZDXNSN4FANCNFSM6AAAAAAZMZOHSI>\r\n> .\r\n> You are receiving this because you commented.Message ID:\r\n> ***@***.***>\r\n>\r\n",
          "createdAt": "2023-06-29T14:15:15Z",
          "updatedAt": "2023-06-29T14:15:15Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "I think, this goes back to us lacking a common agreement on the terminology . I did write up a first version of it in the arch spec here \r\n\r\nthings that can modify media payload are entities that are trusted to do so ( in the cases of e2e encryption, they are provided the keys or in DRM case, the content key is shared with such an entity)\r\n\r\n Thinking in terms of  entities and the roles they play from a security architecture perspective has been pretty helpful for defining things and scoping the requirements\r\n\r\nhere is the relevant section : https://datatracker.ietf.org/doc/html/draft-nandakumar-moq-arch-00#section-2\r\n\r\nI would love to develop this further to meet various use-cases, so please share your feedback. thanks",
          "createdAt": "2023-07-06T04:17:12Z",
          "updatedAt": "2023-07-06T12:45:04Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe this is out of scope for the transport draft.",
          "createdAt": "2023-07-24T13:03:30Z",
          "updatedAt": "2023-07-24T13:03:30Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think it is fine for a device to receive one track, modify it, and publish a *different* track. But I don't think we should call that a relay. \r\n\r\nI think we should restrict the relays to not looking into the payload. That will help us have a fast scalable design for relays and allow them to work in cases with E2E encryption. ",
          "createdAt": "2023-07-27T17:24:48Z",
          "updatedAt": "2023-07-27T17:25:56Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Objects are identified by a track, Group ID and Object ID, and all copies must be bitwise identical, as specified in #376 ",
          "createdAt": "2024-02-19T22:15:49Z",
          "updatedAt": "2024-02-19T22:15:49Z"
        }
      ]
    },
    {
      "number": 217,
      "id": "I_kwDOG2Ho4M5pL97l",
      "title": "relay forwarding objects",
      "url": "https://github.com/moq-wg/moq-transport/issues/217",
      "state": "OPEN",
      "author": "gwendalsimon",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "NotTransport"
      ],
      "body": "Line 572. \u201c[Relays] MUST only depend on the fields [for making forwarding decisions]\u201d. \r\n\r\nI am not sure to understand why we would like to restrict here the behavior of Relays to forward the Objects to subscribers.  We can imagine edge processing for the implementation of forwarding decisions based on third-party validation (possibly based on payload). Furthermore, this restriction is not necessary for the norm to be implemented.",
      "createdAt": "2023-06-20T06:38:24Z",
      "updatedAt": "2024-02-19T23:28:13Z",
      "closedAt": null,
      "comments": [
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The intent of the language here was that relays should only depend on being able to access the headers and not the body of the objects, as the body may be encrypted. However someone may want to build a relay that uses 3rd party logic , or that inspects the payload, in order to make forwarding decisions. I agree that this should not be prohibited by the protocol. We should relax the language to indicate that payloads MAY be encrypted and that relays MUST implement any prioritization instructions carried in the headers. The spec should make no normative statements about how relays make forwarding decisions. ",
          "createdAt": "2023-06-22T22:12:57Z",
          "updatedAt": "2023-06-22T22:12:57Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that this is too restrictive and yet unenforceable. \r\n\r\nThe intent is to say something like \"a router MUST only forward packets based on the IP header\". But what about the UDP/TCP header? What about the TLS header? What about the HTTP header? It's perfectly valid to use those iff a router supports those layers (aka a load balancer).\r\n\r\nI mentioned in the other issue, but we should treat moq-transport as just a layer. There may be other layers stacked on top and which should not be restricted. It's L3/L4/L7 all over again.",
          "createdAt": "2023-06-27T19:25:49Z",
          "updatedAt": "2023-06-27T19:26:58Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "I am always confused when we use the term Relay to mean more than one thing. My thinking so far is, these are the middleboxes who have no role with payload of the MOQ objects. Yes, it cannot be enforced and a implementation can do whatever it wants. However, when we define security properties, we need to be clear on Relay's role. OTOH middleboxes like SFUs, transcoders are more flexible to access payload and may be payload headers  based on the architecture and they fall into different category when defining the security of the system.",
          "createdAt": "2023-07-06T04:10:52Z",
          "updatedAt": "2023-07-06T04:10:52Z"
        }
      ]
    },
    {
      "number": 218,
      "id": "I_kwDOG2Ho4M5pMBqN",
      "title": "Editorial notes",
      "url": "https://github.com/moq-wg/moq-transport/issues/218",
      "state": "OPEN",
      "author": "gwendalsimon",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "Editorial"
      ],
      "body": "Here are some editorial notes on the document\r\n\r\n- Line 72. \u201c_MOQT is a generic protocol **is** designed to work_\u201d \r\n- Line 91-93. \u201c_The development of MOQT is driven by goals in a number of areas - specifically latency, the robustness of QUIC, workflow efficiency and relay support._\u201d This sentence is intriguing. What does the robustness of QUIC mean? Latency, workflow efficiency, relay support are not \u201careas\u201d or maybe area should be defined. (side note on the missing Oxford comma in this sentence)\r\n- The Section 1.1.1. Latency as a whole is very confusing. HTTP-based streaming is not designed for low latency mostly due to the essential request-response paradigm. Queuing on the path has a insignificant impact on the end-to-end latency for HAS. The \u201cspeed at which a protocol can detect queuing\u201d is not related to the relatively high latency issues of HAS. Overall, I see a mix of unrelated subjects here, which makes the paragraph overall meaningless. I would recommend starting the paragraph with a topic sentence (which may be the last one of the current paragraph).\r\n- Line 120. \u201c_Applying QUIC to HAS \u2026_\u201d (and the following sentences) is not necessary. The reasons for which QUIC does not bring advantages to HAS are still debatable on many points. This QUIC-on-HAS remark could raise unnecessary questions although the beginning of Section 1.1.2 is clear and sufficient to convey the message.\r\n- Line 125. \u201c_Universal_\u201d has a too broad sense. Do you mean \u201cUnicity of protocol in the whole pipeline\u201d (or something like this)?\r\n- Line 127. \u201c_Internet delivered media today has protocols optimized for ingest\u2026_\u201d I don\u2019t understand this sentence.\r\n- Line 127. Some examples of protocols could be good to support these claims. Note that WHIP is an attempt to unify the protocol.\r\n- Line 146. \u201c_to treat relays as first-class citizens of the protocol_\u201d is an excellent marketing message but it does not mean anything in a technical norm. Furthermore, see my two reserves above. I\u2019d claim that the current draft is not making relay first-class, on the contrary.\r\n- Line 179. \u201c_a join point_\u201d joint?\r\n- Line 231. \u201c_The application is solely responsible for the content of the object payload._\u201d What is the application? It is a bit confusing. It has not been defined.\r\n- Line 269 .\u201c_within a single MOQT scope, subscribing to the same full track name would result in the subscriber receiving the data for the same track._\u201d I am not sure to understand this sentence. Is a single MOQT scope a scope with only one server or do you mean \u201cwithin a MOQT scope\u201d? the two \u201csame\u201d adjectives are confusing too.\r\n- Line 273. It would be better to stick to \u201c_servers_\u201d or to \u201c_connection URIs_\u201d to refer to the elements of the scope.\r\n- Line 339. \u201cThe `authority` portion MUST NOT contain a non-empty `host` portion.\u201d Is it a double negation to say that the \u2018authority\u2019 MUST contain an empty \u2018host\u2019 portion? \r\n- Line 357. This sentence may require a MUST.\r\n- Line 359. \u201c_for exchanging \u2026_\u201d and following sentences are not related to session initialization. They are rather remarks that would be a fit with the draft Section 4.\r\n- +1 to the TODO remarks on line 381. This should be in Section 4.\r\n- Line 654. \u201c_it allows the peers\u2026_\u201d The term \u201c_peer_\u201d is used 7 times. It is supposed to be an \u201c_endpoint_\u201d (as defined Line 173), unless peer and endpoint have different meaning (in which case peer must be defined)\r\n- Line 693. \u201c_A relay that reads from a stream and writes to stream in order will introduce head-of-line blocking._\u201d I don\u2019t understand this claim.",
      "createdAt": "2023-06-20T06:51:10Z",
      "updatedAt": "2023-07-24T20:58:55Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the feedback.  I'm going to mark this as Editorial, but there are a number of points here.  If you believe any of them are not editorial (ie: \"Line 357. This sentence may require a MUST.\"), please split into a separate issue.",
          "createdAt": "2023-07-24T20:58:33Z",
          "updatedAt": "2023-07-24T20:58:33Z"
        }
      ]
    },
    {
      "number": 219,
      "id": "I_kwDOG2Ho4M5p8yx2",
      "title": "Encoding unknown parameters",
      "url": "https://github.com/moq-wg/moq-transport/issues/219",
      "state": "OPEN",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Needs Discussion",
        "Wire Format"
      ],
      "body": "The SETUP/ANNOUNCE/SUBSCRIBE messages are encoded like this:\r\n\r\n```\r\nmessage_type:   varint\r\nmessage_size:   varint\r\ntrack_id:       varint\r\nparam_1_id:     varint\r\n* param_1_size: varint\r\nparam_1_value:  bytes | varint\r\nparam_2_id:     varint\r\n* param_2_size: varint\r\nparam_2_value:  bytes | varint\r\n...\r\n\r\n* ANNOUNCE/SUBSCRIBE do not state if each value has a size\r\n```\r\n\r\nMessages and parameters need a size if we support unknowns, otherwise it's impossible to skip them. However:\r\n\r\n- **It's a waste**. This is particularly true for varints, as they have a variable length (1-8 bytes) and each of them must be prefixed with a varint size. This defeats the entire purpose of using the first two bits of a varint to encode the size.\r\n- **It's a pain to encode**. An encoder needs to precompute the size of each message/param or use copy between temporary buffers. Other encodings like TLS and MP4 can seek backwards to populate the size later, but that's only possible with fixed size integers (not varints*) and is quite annoying. \r\n- **It's a pain to decode**. A decoder needs to use nested readers limited based on the size, or provide each `decode` method with the remaining length. It's a protocol error if any reader is done without 0 bytes remaining to read.\r\n- **It prohibits streaming**. The required message length means you can't use stream encoders. We added a special case for 0 to mean undefined length, but that makes decoding more difficult and it prohibits future messages on the same stream.",
      "createdAt": "2023-06-27T18:41:53Z",
      "updatedAt": "2023-10-05T18:47:22Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "QUIC frames do not have sizes because it's illegal to use a frame/param not defined in the negotiated version. The only exception are transport parameters, as they are sent before a version is negotiated (similar to SETUP). It's efficient and a joy to encode and decode QUIC frames as a result. \r\n\r\nI propose that we copy this. We should explicitly _not_ support unknown messages and parameters after the CLIENT SETUP. The SERVER SETUP is prefixed with the chosen version so it doesn't need to support unknown parameters, but it could anyway for consistency.\r\n\r\nNote that we can still support optional parameters. If we follow QUIC's example, the message type can contain flags on which fields are present. Or the zero value means a field is not present, for example the auth field would have size 0 when not used.\r\n\r\nFor example, here's what I would propose for SUBSCRIBE:\r\n```\r\nmessage_type: varint | group_present | object_present\r\ntrack_id: varint\r\n(group_seq: varint)\r\n(object_seq: varint)\r\nauth_size: varint\r\nauth_value: bytes\r\n```\r\n\r\nIt's lighter and significantly easier to encode/decode. A new version of the draft can add or remove fields; an implementation that supports multiple versions would use conditionals based on the version.",
          "createdAt": "2023-06-27T18:52:28Z",
          "updatedAt": "2023-06-27T18:52:28Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One thought is to generalize this with a bitfield mask that indicated what options were in use. ",
          "createdAt": "2023-07-22T18:58:27Z",
          "updatedAt": "2023-07-22T18:58:27Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "> One thought is to generalize this with a bitfield mask that indicated what options were in use.\r\n\r\nThis is basically what Luke is proposing and what QUIC does, except that the \"flags\" field is effectively merged with the message type field.  So instead of \r\n\r\nmessage type = subscribe\r\nflags = group_present\r\n\r\nit's \r\n\r\nmessage type = subscribe-with-group-present\r\n\r\nAs an individual:\r\n\r\nHaving generic key/value parameters makes a very handy extension point (see HTTP headers).  I'm not sure we want to disallow unknown params and require a new version or extension negotiation to add or experiment with a new param.",
          "createdAt": "2023-07-26T14:52:00Z",
          "updatedAt": "2023-07-26T14:52:00Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "trvial nit but perhaps we should break out versioning it's own issue ",
          "createdAt": "2023-07-27T17:16:05Z",
          "updatedAt": "2023-07-27T17:16:05Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "I tend to agree that having Key/Value pair is pretty handy. I don't want us to start adding all options as bitmasks eventually. Mandatory fields go as the main fields, extensions/optionals go in key-value pairs. ",
          "createdAt": "2023-07-27T17:19:57Z",
          "updatedAt": "2023-07-27T17:19:57Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "#255 provides a fix to this issue, but there was a question about whether something more complex (ie: structured headers) might eventually be necessary.",
          "createdAt": "2023-10-05T18:47:22Z",
          "updatedAt": "2023-10-05T18:47:22Z"
        }
      ]
    },
    {
      "number": 221,
      "id": "I_kwDOG2Ho4M5rzmiy",
      "title": "Repo quality of life post migration",
      "url": "https://github.com/moq-wg/moq-transport/issues/221",
      "state": "OPEN",
      "author": "LPardue",
      "authorAssociation": "NONE",
      "assignees": [
        "ianswett"
      ],
      "labels": [],
      "body": "Now that this is a repo for, I think, a WG adopted doc, there's a number of improvements that could be made to improve it e.g. the description is stale, there's no link to the repo from the document, the markdown filename doesn't match the document name etc. These are all minor things but cumulatively make it harder for contributors. It would be great to get them fixed up.",
      "createdAt": "2023-07-17T21:58:26Z",
      "updatedAt": "2023-07-24T21:22:53Z",
      "closedAt": null,
      "comments": [
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 - I can't see any reason not to fix all of that. ",
          "createdAt": "2023-07-22T18:54:42Z",
          "updatedAt": "2023-07-22T18:54:42Z"
        }
      ]
    },
    {
      "number": 222,
      "id": "I_kwDOG2Ho4M5sKKpD",
      "title": "Clean subscribe termination",
      "url": "https://github.com/moq-wg/moq-transport/issues/222",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Subscribe"
      ],
      "body": "Currently, a subscriber will send SUBSCRIBE and the publisher will reply with SUBSCRIBE_OK/SUBSCRIBE_ERROR. It's undefined what a publisher should do when a broadcast/track is terminated after that.\r\n\r\nA clean termination is especially problematic. I was under the assumption that they would send a SUBSCRIBE_ERROR with code=0. However, not only is this unstated in the draft, but it's introduces a race condition. There needs to be some way for the subscriber to wait until it received all of the content, such as a final object/group sequence, before the subscription is removed. This might also be problematic because relay can choose to not transmit objects/groups...\r\n\r\n(my code errors pretty often because of this, since the catalog is a track with a single object that is closed immediately)",
      "createdAt": "2023-07-20T18:43:41Z",
      "updatedAt": "2023-10-04T20:40:39Z",
      "closedAt": "2023-10-04T20:40:39Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "This seems very similar to #203, but I may be missing a distinction?",
          "createdAt": "2023-07-24T13:19:17Z",
          "updatedAt": "2023-07-24T13:19:17Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In some cases, a single subscription might get data for multiple tracks, so I think the right way to think about this is 1) have a way for client to know what the last object is for a given track and 2) client can then unsubscribe normal way. I phased it as \"know what last object is\" vs \"steam ended\" as I think that makes more sense for broader set of uses cases such as the one Luke has with the catalog at start of this issue. ",
          "createdAt": "2023-07-24T14:41:42Z",
          "updatedAt": "2023-07-24T14:41:42Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "> a single subscription might get data for multiple tracks\r\n\r\nIs that right?  SUBSCRIBE_REQUEST takes a Full Track Name so it should refer to a single track.",
          "createdAt": "2023-07-24T15:17:46Z",
          "updatedAt": "2023-07-24T15:17:46Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> This seems very similar to #203, but I may be missing a distinction?\r\n\r\nYeah looks like a duplicate.",
          "createdAt": "2023-07-24T15:28:12Z",
          "updatedAt": "2023-07-24T15:28:12Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "There's a similar amount of discussion on both, so I'll close this as a dupe of #203 ",
          "createdAt": "2023-07-24T15:35:25Z",
          "updatedAt": "2023-07-24T15:35:25Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > a single subscription might get data for multiple tracks\r\n> \r\n> Is that right? SUBSCRIBE_REQUEST takes a Full Track Name so it should refer to a single track.\r\n\r\nJust want to point I don't think that is the case. An SFU in a conferencing case needs to subscribe to all the input media and you want that aggregated not a zillion subscribes. \r\n\r\nThat said, I do think this can all be discussed on the other bug ",
          "createdAt": "2023-07-27T17:04:24Z",
          "updatedAt": "2023-07-27T17:04:24Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "@fluffy I'd recommend a separate issue for aggregating subscribes.\r\n\r\n@suhasHere I see you reopened this issue, which was resolved as a duplicate.  Is there something unique to discuss here related to subscribe termination or can we keep the discussion in #203?",
          "createdAt": "2023-07-27T19:00:18Z",
          "updatedAt": "2023-07-27T19:00:18Z"
        }
      ]
    },
    {
      "number": 223,
      "id": "I_kwDOG2Ho4M5sZ4rK",
      "title": "Term QUIC is used in when it may not actually be QUIC",
      "url": "https://github.com/moq-wg/moq-transport/issues/223",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "ianswett"
      ],
      "labels": [
        "Editorial",
        "Needs PR"
      ],
      "body": "Though MOQT is optimized for QUIC, it technically can go over WebTransport over HTTP/1 or HTTP/2.\r\n\r\nThere are a number of cases when QUIC is used when it could be something else and in most cases, specifying QUIC is not critical to the design.  For example \"Consumer: A QUIC endpoint receiving media over the network.\"\r\n\r\nAlso, the definitions in 1.2 frequently reference terms defined later in the list.",
      "createdAt": "2023-07-24T16:08:40Z",
      "updatedAt": "2023-10-17T12:42:37Z",
      "closedAt": "2023-10-17T12:42:37Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Absolutely. Stream prioritization and congestion control is better with QUIC, and thus can support lower latencies, but MoQ over TCP should still work well enough.",
          "createdAt": "2023-07-24T17:58:12Z",
          "updatedAt": "2023-07-24T17:58:12Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For what its worth, we did did say during chartering that were were not going to focus on solving any of the problems that happen with fallback to TCP. Clearly we are not going to go and brak whatever fallback WebTransport does, but they key thing is this work when then WebTransport is over QUIC, not other cases ",
          "createdAt": "2023-07-27T17:09:57Z",
          "updatedAt": "2023-07-27T17:09:57Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I completely agree. This is an editorial point that there are times when 'QUIC' is used when it may not actually be QUIC.  In many cases, just removing that word makes the sentence both slightly more accurate and shorter.",
          "createdAt": "2023-07-27T23:40:44Z",
          "updatedAt": "2023-07-27T23:40:44Z"
        }
      ]
    },
    {
      "number": 224,
      "id": "I_kwDOG2Ho4M5saJ0W",
      "title": "Need object delimiters  in the OBJECT header ",
      "url": "https://github.com/moq-wg/moq-transport/issues/224",
      "state": "OPEN",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Object Model"
      ],
      "body": "While implementing stream carrying multiple objects, where the stream was carrying a GOP with multiple encoded frames in it,  the spec currently lacks object delimiters to implement caching at relays and consuming objects at the MOQ consumer library\r\n\r\nMy proposal is to extend OBJECT Header to have the following strucutre\r\n\r\n```\r\nOBJECT Message {\r\n  Track ID (i),\r\n  Group Sequence (i),\r\n  Object Sequence (i),\r\n  Object Send Order (i),\r\n  [Object Length (i)],\r\n  [Last Object Previous Group (i)],\r\n  Object Payload (b),\r\n}\r\n\r\n```\r\n\r\n* Object Length: Indicates the length of the object, if known\r\n* Last Object Previous Group : Indicates the last object sequence of the previous group and is sent as part of first object in a given group\r\n\r\n\r\n",
      "createdAt": "2023-07-24T16:57:53Z",
      "updatedAt": "2023-10-18T02:55:14Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "[Messages already have a length](https://www.ietf.org/archive/id/draft-ietf-moq-transport-00.html#name-messages). Wouldn't the object length be redundant?\r\n\r\nWhy does a relay need to know the final number of objects in a group? The relay just uses the group/object sequence number to identify active subscriptions (where to forward each object).\r\n\r\nWhy does a relay need to know the length of individual object anyway? A relay should cache/forward partial objects otherwise it can only introduce latency. Every major HTTP CDN does this already for HTTP chunked-transfer.\r\n\r\nIt is useful for a decoder to know when a group ends, although you still need some code to check for gaps based on timestamp. A stream per group handles this very cleanly as the stream FIN signals that the group has finished.",
          "createdAt": "2023-07-24T17:53:28Z",
          "updatedAt": "2023-07-24T17:53:28Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> Why does a relay need to know the final number of objects in a group?\r\n\r\nthis aids when a new group arrives for  the subscriber to know if it got all the objects from the previous group. \r\n\r\n> [Messages already have a length](https://www.ietf.org/archive/id/draft-ietf-moq-transport-00.html#name-messages). Wouldn't the object length be redundant?\r\n\r\nAgreed , I missed it completely.\r\n\r\n\r\n\r\n> A relay should cache/forward partial objects otherwise it can only introduce latency.\r\n\r\nRegardless of how the object is encoded or what it encodes, relays should forward objects as they arrive.",
          "createdAt": "2023-07-24T20:58:52Z",
          "updatedAt": "2023-07-24T20:58:52Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "As an individual:\r\n\r\n> Last Object Previous Group : Indicates the last object sequence of the previous group and is sent as part of first object in a given group\r\n\r\nIs there a use case where a publisher is publishing to multiple groups at the same time, so the \"last object of the previous group\" is not known when sending the first object in a new group?  The transport doesn't prohibit this currently - should it?\r\n\r\nWould a \"close group\" message (perhaps a zero length object?) on a group serve a similar function?",
          "createdAt": "2023-07-27T15:38:58Z",
          "updatedAt": "2023-07-27T15:38:58Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@afrind there are cases when i had tried stream per object. These were in parallel and i had relay peer mesh setup to test out the flows. This causes things to come out of order since some links were congested. \r\n\r\nHaving it part of first object of a new group will make it very clear on the group state . New message might work, but i still see the race happening though.",
          "createdAt": "2023-07-27T17:12:33Z",
          "updatedAt": "2023-07-27T17:40:35Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> > Why does a relay need to know the final number of objects in a group?\r\n> \r\n> this aids when a new group arrives for the subscriber to know if it got all the objects from the previous group.\r\n\r\nYou wouldn't be able to rely on this message though if multiple groups are lost/starving. For example, your audio decoder is working on group 65 and waiting for the group end signal from group 66. But what if group 67 is sent instead and group 66 is deprioritized or dropped?\r\n\r\nA GROUP_END message is a better option, but frankly I think you should just write a pessimistic decoder. Assume the worst case where QUIC streams may get starved for any reason (packet loss, deprioritization, reset, etc). Otherwise, the reliance on this optimistic group size message/parameter is just going to bite you when real issues occur.",
          "createdAt": "2023-07-27T19:05:45Z",
          "updatedAt": "2023-07-27T19:05:45Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Every group beginning is a sync point and having information there to identity is useful property\n\nNew message will have same race issues.\n\nYes if there are more than one group lost , you lost too many already. We can always extend it to include group number as well to help. This is anyways sent in the first object\n\nWhat I am proposing is a hint to apply \n- course correction at relays \n- apply application decision at the consumer\n\n",
          "createdAt": "2023-07-27T19:58:37Z",
          "updatedAt": "2023-07-27T19:58:37Z"
        }
      ]
    },
    {
      "number": 225,
      "id": "I_kwDOG2Ho4M5saYlP",
      "title": "Clarify conflicting announces across Producers",
      "url": "https://github.com/moq-wg/moq-transport/issues/225",
      "state": "OPEN",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Needs PR",
        "Announce"
      ],
      "body": "While implementing MOQT relay,  I stumbled upon #204. Thinking through authorization implementation a bit more , I think the current spec needs to clarify this behavior.\r\n\r\nProposal is to say, when a conflicting announce happens,  the Relay MUST reject with an appropriate error type in the ANNOUNCE_ERROR message when the authorization disallows\r\n\r\n```\r\nERROR_CONFLICT_TRACK\r\n```\r\n\r\nHowever, if the authorization policy allows such an allocation of namespaces, then clarify Relay interaction to indicate the most recent ANNOUNCE wins. \r\n",
      "createdAt": "2023-07-24T17:42:27Z",
      "updatedAt": "2024-02-07T22:55:36Z",
      "closedAt": null,
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm unclear how this issue is different from #227 - can we merge them or clarify how they are different?",
          "createdAt": "2023-07-27T15:34:38Z",
          "updatedAt": "2023-07-27T15:34:38Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "It can be treated same, if the solution applies to 2 different producers and same producers announcing more than once has the same behavior rules on the relay. \r\n\r\n@afrind do you think we would be fine with that ?",
          "createdAt": "2023-07-27T17:58:56Z",
          "updatedAt": "2023-07-27T17:58:56Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, I see.\r\n\r\nSo this issue is specific to two different producers announce the same namespace (eg: different auth fields in ANNOUNCE), and 227 is the generic case (two ANNOUNCE messages with the same namespace, regardless of auth)?\r\n\r\nI'll defer to you and @ianswett if it makes sense to keep separate or merge the discussion.\r\n\r\n",
          "createdAt": "2023-07-27T19:06:36Z",
          "updatedAt": "2023-07-27T19:06:36Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "After considering few more use-cases, for cases where we need to support make before break, it would be good to have multiple announces be allowed. \r\n\r\nSo here is the updated proposal\r\n\r\nProposal is to say, when a conflicting announce happens, the Relay MUST reject with an appropriate error type in the ANNOUNCE_ERROR message when the authorization disallows\r\n\r\n``` ERROR_CONFLICT_TRACK ```\r\n\r\nHowever, if the authorization policy allows such an allocation of namespaces, then clarify Relay interaction to indicate that multiple announces for the same namespace is allowed.",
          "createdAt": "2023-11-06T15:42:25Z",
          "updatedAt": "2023-11-06T15:42:25Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment:\r\n\r\nBikeshed: ERROR_CONFLICT_TRACK -> ERROR_CONFLICTING_TRACK_NAMESPACE\r\n\r\nMaybe simplify it to say, \r\n\r\nIf a server receives multiple Announce's for the same namespace, it MAY send an Announce Error = ERROR_CONFLICTING_TRACK_NAMESPACE depending on authorization policy.\r\n\r\nTo clarify: if a server sends this error it doesn't support make-before-break?",
          "createdAt": "2023-11-06T16:06:26Z",
          "updatedAt": "2023-11-06T16:06:26Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm borrowing HTTP status codes in my implementation, and yeah we need an equivalent of 409.",
          "createdAt": "2023-11-07T01:27:31Z",
          "updatedAt": "2023-11-07T01:27:31Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Conclusion of the discsusion was to allow identical ANNOUNCEs and provide a varint or token to allow deciding which to prefer.\r\n\r\nThe case when the the data is not byte identical is a different issue, and there didn't seem to be interest in solving that at the transport layer.\r\n\r\nConclusion applies to #227 as well",
          "createdAt": "2023-11-09T16:52:53Z",
          "updatedAt": "2023-11-09T16:53:24Z"
        }
      ]
    },
    {
      "number": 226,
      "id": "I_kwDOG2Ho4M5sbd1k",
      "title": "Converge on terminology ",
      "url": "https://github.com/moq-wg/moq-transport/issues/226",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "duplicate"
      ],
      "body": "Current terminology has caused lots of confusions on who does what in the MOQ end to end architecture.\r\n\r\nhttps://datatracker.ietf.org/doc/html/draft-nandakumar-moq-arch-00 has an attempt to address the terminology in terms of Roles and the scope a given role brings into a a component in the architecture.\r\n\r\n",
      "createdAt": "2023-07-24T21:02:13Z",
      "updatedAt": "2023-07-26T21:50:08Z",
      "closedAt": "2023-07-26T21:49:59Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "If there is specific terminology that is causing problems, and I agree that there is, can you please file an issue for each and what the issue is?\r\n\r\nFor the future, I've created a Naming tag, opposed to the Architectural tag, since Naming does not affect the bytes on the wire or its functionality.",
          "createdAt": "2023-07-24T21:15:49Z",
          "updatedAt": "2023-07-24T21:15:49Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Label is fine to be Naming. thanks\r\n\r\nMost common confusion points are\r\n\r\nPublisher, Consumer, Endpoint, Producer, Subscriber,\r\nRelay, Media Transformer, Special Relays\r\n\r\nAll of these are used to mean more than one thing in general",
          "createdAt": "2023-07-24T21:28:40Z",
          "updatedAt": "2023-07-24T21:28:40Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Dup of #157 ?",
          "createdAt": "2023-07-26T21:26:40Z",
          "updatedAt": "2023-07-26T21:26:40Z"
        }
      ]
    },
    {
      "number": 227,
      "id": "I_kwDOG2Ho4M5scDT6",
      "title": "Announces with same name in reconnect",
      "url": "https://github.com/moq-wg/moq-transport/issues/227",
      "state": "OPEN",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Needs PR",
        "Needs Discussion",
        "Announce"
      ],
      "body": "\r\nWhen the relays received an ANNOUNCE with exact same name as previous ANNOUNCE, what happens? \r\n\r\nOptions seem to be replace previous ANNOUNCE data or return an error. \r\n\r\nThis is related to https://github.com/moq-wg/moq-transport/issues/225 and https://github.com/moq-wg/moq-transport/issues/204\r\n\r\nDiscussion to follow in thread \r\n\r\n",
      "createdAt": "2023-07-24T23:31:00Z",
      "updatedAt": "2023-11-06T15:27:58Z",
      "closedAt": null,
      "comments": [
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One of use cases we should think about is a client that crashes and reconnects. ",
          "createdAt": "2023-07-24T23:31:46Z",
          "updatedAt": "2023-07-24T23:31:46Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "As an individual, \r\n\r\nThe crash (or disconnect) use case is compelling for \"the most recent one wins\".  Are there applications where that policy would break something?",
          "createdAt": "2023-07-27T15:33:26Z",
          "updatedAt": "2023-07-27T15:33:26Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with Alan that \"most recent\" overwrites any earlier ones is best path forward. ",
          "createdAt": "2023-07-27T16:55:31Z",
          "updatedAt": "2023-07-27T16:55:31Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 on most recent overwrites. this is what we do atleast today and it works fine to the amount we have tested.",
          "createdAt": "2023-07-27T17:14:51Z",
          "updatedAt": "2023-07-27T17:14:51Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Going with the most recent `ANNOUNCE` works for me, so long as the relay MUST send an `ANNOUNCE_ERROR` and `UNSUBSCRIBE` for any matching subscriptions to the original session. Otherwise we'll introduce zombie announcements and subscriptions.",
          "createdAt": "2023-07-27T19:28:21Z",
          "updatedAt": "2023-07-27T19:28:28Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "WFM",
          "createdAt": "2023-07-27T20:44:29Z",
          "updatedAt": "2023-07-27T20:44:29Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> Going with the most recent `ANNOUNCE` works for me, so long as the relay MUST send an `ANNOUNCE_ERROR` and `UNSUBSCRIBE` for any matching subscriptions to the original session. Otherwise we'll introduce zombie announcements and subscriptions.\n\nI Dont think existing subscriptions needs to be terminated. \n\nLet say the case where, A publisher disconnects due to getting into an elevator for a moment and sends announce on reconnect, sending out protocol messages to cancel the subscriptions on the second announce is too noisy. \n\n",
          "createdAt": "2023-07-27T23:38:18Z",
          "updatedAt": "2023-07-27T23:38:18Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "As an individual: \r\n\r\nI don't think we need to force unsubscribe everyone if the relay successfully resubscribes to the new ANNOUNCE.\r\n\r\nI think Luke is suggesting that the relay unsubscribe on the session that issued the old ANNOUNCE?",
          "createdAt": "2023-07-28T00:45:33Z",
          "updatedAt": "2023-07-28T00:48:27Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> As an individual:\r\n> \r\n> I don't think we need to force unsubscribe everyone if the relay successfully resubscribes to the new ANNOUNCE.\r\n> \r\n> I think Luke is suggesting that the relay unsubscribe on the session that issued the old ANNOUNCE?\r\n\r\nYeah exactly. The upstream subscription is reissued to the new connection, but any downstream subscriptions can be maintained by updating a lookup table. I can elaborate if this isn't clear; the glue between \"upstream\" and \"downstream\" subscriptions can be confusing.",
          "createdAt": "2023-07-28T01:02:26Z",
          "updatedAt": "2023-07-28T01:03:36Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Got it. Makes sense. Agree all the downstream subscriptions can stay intact for the announced namespace ",
          "createdAt": "2023-07-28T02:30:23Z",
          "updatedAt": "2023-07-28T02:30:23Z"
        }
      ]
    },
    {
      "number": 228,
      "id": "I_kwDOG2Ho4M5sq6Fc",
      "title": "How should a relay route ANNOUNCE messages?",
      "url": "https://github.com/moq-wg/moq-transport/issues/228",
      "state": "CLOSED",
      "author": "afrind",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Needs Discussion",
        "Announce"
      ],
      "body": "ANNOUNCE tells a relay where to route SUBSCRIBE messages for a given namespace.  Should there be a different message that serves the same purpose for ANNOUNCE?\r\n\r\nContext: \r\n\r\nIn my fledgling [moq-chat](https://afrind.github.io/draft-frindell-moq-chat/draft-frindell-moq-chat.html) protocol, there is a server entity that maintains a catalog of all the participants/tracks in the chat.  In order to perform auth, and keep the catalog up to date, I rely on the server seeing the ANNOUNCE message when a participant tries to join the chat.  However, if the clients and server are connected by a relay, it's unclear how the relay would know to forward the ANNOUNCE from a new client to the server.\r\n\r\nOption 1:\r\n\r\nThis is \"business logic\", which is out of scope.\r\n\r\nOption 2:\r\n\r\nAdd another message that an endpoint can send to indicate it would like to receive ANNOUNCE messages matching a given namespace.  This would be an optional message, and could co-exist with option 1.\r\n\r\nOption 3 (I don't like this, including for completeness): \r\n\r\nSend it to every endpoint connected to the relay, and see if anyone gives ANNOUNCE OK.",
      "createdAt": "2023-07-26T21:17:39Z",
      "updatedAt": "2023-11-03T21:28:20Z",
      "closedAt": "2023-11-03T21:28:20Z",
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "It seems like it would be \"Option 1\"",
          "createdAt": "2023-07-26T22:31:00Z",
          "updatedAt": "2023-07-26T22:31:00Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Victor offered the idea that the moq-chat server could authorize users to join the chat when they subscribe to the chat catalog, rather than requiring the relay to forward participant ANNOUCE's to the server.  It's a little strange, in that the client will ANNOUNCE it's track namespace to the relay, and also has to communicate it to the server in the SUBSCRIBE_REQEUST's auth field, but ultimately workable. \r\n\r\nI think that solves my immediate need, though I'm not sure that solution and \"business logic\" will cover all use cases.  ",
          "createdAt": "2023-07-27T15:26:14Z",
          "updatedAt": "2023-07-27T15:26:14Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "FWIW, in one of our deployment/implementations, the relay extracts the authz token and use it to validates the user server, outside moqT.\r\n In a slightly different scenario, the relay has all the needed info as part of the token for it to make the decision locally too. \r\n\r\nThat's the main reason I feel the transport cannot mandate how the business logic is setup other than provide recommendations, which we don't think should be in the core transport draft. May be arch draft can be updated to add some details in the next rev.",
          "createdAt": "2023-07-27T17:03:04Z",
          "updatedAt": "2023-07-27T17:24:40Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Like I [mentioned here](https://github.com/moq-wg/moq-transport/issues/204#issuecomment-1653999951), there's should actually two distinct ANNOUNCE messages. How they should be forwarded varies:\r\n\r\n- `PLS_SUBSCRIBE` depends on business logic. If you're a 1:1 proxy, then forward it downstream (basically push). If you're a 1:N relay, then you might not want to push it to all downstreams, so you terminate and wait for a `SUBSCRIBE`.\r\n- `PLS_ROUTE` on the other hand would be replicated to all downstreams (present and future). It's effectively a gossip protocol and a mechanism to indicate the origin for a broadcast.",
          "createdAt": "2023-07-27T19:14:15Z",
          "updatedAt": "2023-07-27T19:14:38Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "If a relay will replicate to other nodes or not is very much relay and deployment decision.\n\nOn the same lines, how relays plays role in the authorization is also very much deployment specific.\n\n\nI think what we have today meets the fine line to help subscribers meet the publishers without defining too much on how relays manage the internals.",
          "createdAt": "2023-07-27T20:04:24Z",
          "updatedAt": "2023-07-27T20:04:24Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think it should be out of scope of the MoQ spec on how the internals of the relays work. I view how relays route ANNOUNCE to other relays as part of those internal. The only thing we should spec about the behaviour of the relays is the black box behavior the clients needs to count on. \r\n",
          "createdAt": "2023-07-27T21:09:06Z",
          "updatedAt": "2023-07-27T21:09:06Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "As an individual: \r\n\r\nI agree with everything you said there @fluffy.  I'm just not sure if \"routing ANNOUNCE to a *client*\" (as opposed to another relay) is also out of scope.\r\n\r\nI like the way Suhas put it:\r\n\r\n> I think what we have today meets the fine line to help subscribers meet the publishers without defining too much on how relays manage the internals.\r\n\r\nI intended Option 2 in the issue description to be in-line with \"helping subscribers meet the publishers\" rather than being prescriptive about how a relay routes messages internally or performs auth.\r\n\r\n> PLS_ROUTE\r\n\r\nI haven't heard anyone state that they want something that looks like a gossip protocol.  If someone has a use case for it, maybe they can put it forward.  Otherwise, perhaps we can move forward with an assumption that is outside the design space for now.",
          "createdAt": "2023-08-01T21:52:36Z",
          "updatedAt": "2023-08-01T21:52:36Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": " > > PLS_ROUTE\r\n> \r\n> I haven't heard anyone state that they want something that looks like a gossip protocol. If someone has a use case for it, maybe they can put it forward. Otherwise, perhaps we can move forward with an assumption that is outside the design space for now.\r\n\r\nI might be jumping to conclusions, but advocating for prefix matching in #204 implies the `PLS_ROUTE` behavior is desired.\r\n\r\nAnyway, I agree with @fluffy. If an endpoint sends an ANNOUNCE, then all that means it that it will accept the corresponding SUBSCRIBE. There's no requirement that a relay forwards an ANNOUNCE provided it maintains this contract somehow (ex. inserts into a database).",
          "createdAt": "2023-08-01T23:44:33Z",
          "updatedAt": "2023-08-01T23:44:33Z"
        },
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "> I haven't heard anyone state that they want something that looks like a gossip protocol. If someone has a use case for it, maybe they can put it forward. Otherwise, perhaps we can move forward with an assumption that is outside the design space for now.\r\n\r\nI agree how the ANNOUNCE message is routed inside a relay service provider is internal. But if there are multiple relay service providers involved, ANNOUNCE routing would be useful for relay service provider chaining. In other words, IGP for ANNOUNCE does not need to be standardized, but BGP should. ",
          "createdAt": "2023-08-02T01:59:44Z",
          "updatedAt": "2023-08-02T01:59:44Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I made a different proposal for how to accomplish chat functionality in \"pure moq\" without relying on routing announce.  See https://github.com/afrind/draft-frindell-moq-chat/pull/1.\r\n\r\nIt involves creating a \"control track namespace\".  The participants in the chat join and leave by sending an empty subscribe to a random, unique track name in control track namespace, with commands encoded in Track Request Parameters.  Love it? \r\n Hate it?  \r\n\r\nHappy to take the discussion over moq-chat repo, but since no one else wants ANNOUNCE to go more than one hop in moqt, I'll close this.",
          "createdAt": "2023-11-03T21:28:20Z",
          "updatedAt": "2023-11-03T21:28:20Z"
        }
      ]
    },
    {
      "number": 229,
      "id": "I_kwDOG2Ho4M5s5f4a",
      "title": "Define Upstream and Downstream ",
      "url": "https://github.com/moq-wg/moq-transport/issues/229",
      "state": "CLOSED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "\r\nLuke took some confused text I sent and made it really clear by using upstream and downstream. I think we should add those to are defined terminology.  They would help many places. \r\n\r\n\r\n\r\n",
      "createdAt": "2023-07-28T19:49:57Z",
      "updatedAt": "2023-10-18T00:46:56Z",
      "closedAt": "2023-10-18T00:46:55Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Is there a PR for Luke's changes?",
          "createdAt": "2023-07-29T23:01:43Z",
          "updatedAt": "2023-07-29T23:01:43Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "There's no PR; it was just some terminology used in an issue. We used it within Twitch but I'm not sure how common it is across the industry.\r\n\r\nData is produced upstream and flows downstream, potentially branching out along the way. I think the branching is meant to symbolize a river but lul they work the other way around (multiple upstream tributaries join together).\r\n\r\nThe important part this is that \"upstream\" and \"downstream\" changes based on your perspective. Upstream is in the direction of a broadcaster (ex. OBS) and downstream is in the direction of a viewer (ex. VLC). A relay may have multiple downstream subscriptions (fanout), but deduplicates them into one upstream subscription.",
          "createdAt": "2023-08-07T22:27:59Z",
          "updatedAt": "2023-08-07T22:29:11Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "My experience with \"upstream\" and \"downstream\" is that it can be confusing, like \"backend\" and \"frontend\".  I tend to prefer \"sender\" and \"receiver\" or \"producer\" and \"consumer\" (or \"subscriber\"), but no term is perfect.",
          "createdAt": "2023-08-28T15:58:22Z",
          "updatedAt": "2023-08-28T15:58:22Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we wanted to use produce and consumer for the ends of the chain, but we need something for the next and prev in the chain. The sender and receiver is just too confusing because we send messages both direction even though media on flows one direction.  Not sure what names we need but I do think we should have a clear name for the prev and next hops for media as well as the first and last hop. \r\n",
          "createdAt": "2023-08-28T16:52:09Z",
          "updatedAt": "2023-08-28T16:52:09Z"
        },
        {
          "author": "acbegen",
          "authorAssociation": "NONE",
          "body": "> My experience with \"upstream\" and \"downstream\" is that it can be confusing\r\n\r\nLuke's definition is quite common. And I agree we need terms for next/previous, so I think we can use these.",
          "createdAt": "2023-09-06T15:45:55Z",
          "updatedAt": "2023-09-06T15:45:55Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "How about \nProducer and Consumer for the endpoints that represent media source and sink \n\nPublisher and subscriber for everything that participates in moqt transport pub/sub protocol",
          "createdAt": "2023-09-06T20:32:19Z",
          "updatedAt": "2023-09-06T20:32:19Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am tempted to support 'Publisher' and 'Subscriber'  to define the hop-endpoints, however it is quite possible that both end-points publish and subscribe simultaneously, in which case these semantics become murky. For a robust hop end-point description, how about 'client' (the endpoint that initiates the connection) and  'server' (the endpoint that accepts the connection). This is the same definition as offered by RFC9000. \r\n\r\nUpstream and downstream define directions along a distribution system.  Upstream is towards the source. Downstream is away from the source. \r\n\r\nSince distribution is a chain of clients and servers, we still need clear terms to define the original server and the terminal client. Some candidates:\r\n\r\n\"original server\"\r\n- Source publisher \r\n- Original publisher\r\n- Origin\r\n- Source\r\n- Media source\r\n\r\n\r\n\"terminal client\"\r\n- Client Subscriber\r\n- Final client\r\n- Media sink\r\n- End-user\r\n- Player\r\n\r\n",
          "createdAt": "2023-09-07T09:52:12Z",
          "updatedAt": "2023-09-07T10:40:24Z"
        },
        {
          "author": "englishm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(Reposting my edited comment because apparently edits don't generate e-mail and I know some people follow these discussions primarily through e-mail.)\r\n\r\n~~+1 to the Publisher and Subscriber being per-hop roles~~ Edit: I'm changing my mind on this slightly. Will is right that it can get confusing because an endpoint may assume both roles for the same connection. It's still good to have the Publisher and Subscriber roles to be able to describe the direction of a particular media flow within a single connection, however, it may often be more useful to focus on the Client and Server aspect of how the underlying QUIC connection is initiated.\r\n\r\nI agree it would be helpful to have clear terms referring the ultimate endpoints of (a possible chain of relayed) connections.\r\nPerhaps \"Origin Publisher\" and \"End Subscriber\" could work for those terms?\r\n\r\n+1 to using Upstream to refer to towards or closer to the \"Origin Publisher\" and Downstream to refer to away from or further from the \"Origin Publisher.\" These relative directional or proximity-describing terms are often useful in describing different scenarios and possible issues.\r\n\r\nEdit cont.: I'm realizing that we don't so much need to chose between all of these words as we need to clarify exactly what each pair of words means and in which contexts they apply.",
          "createdAt": "2023-09-07T13:01:50Z",
          "updatedAt": "2023-09-07T13:01:50Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "We don't currently use Upstream or Downstream in MOQT, so I'm closing this.",
          "createdAt": "2023-10-18T00:46:55Z",
          "updatedAt": "2023-10-18T00:46:55Z"
        }
      ]
    },
    {
      "number": 230,
      "id": "I_kwDOG2Ho4M5trpnM",
      "title": "Resetting control streams",
      "url": "https://github.com/moq-wg/moq-transport/issues/230",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "ianswett"
      ],
      "labels": [
        "Needs PR",
        "Control Streams"
      ],
      "body": "There's an assumption in the current draft that some messages are partially reliable (OBJECT messages) while some are fully reliable (everything else, aka control messages). The ability to drop a message depend on the ability to reset the QUIC stream.\r\n\r\nHowever, reseting a stream containing control messages wrecks havok on the subscription state machine. There's no way within QUIC determine if a messages was received or processed prior to a reset. For example, if I send a SUBSCRIBE on stream and then a receive a STOP_SENDING for that stream, then the subscription enters a limbo state:\r\n\r\n1. The SUBSCRIBE was processed and a SUBSCRIBE_OK or SUBSCRIBE_ERROR is forthcoming.\r\n2. The SUBSCRIBE was never processed and a SUBSCRIBE_OK or SUBSCRIBE_ERROR will never be received.\r\n\r\nThe only option currently is to set a timer after a reset is received. After a few RTTs or so, we assume the SUBSCRIBE was lost and issue a new SUBSCRIBE on a new stream, introducing latency in the process. Though things get extra weird if we receive a response after this timeout expires...\r\n\r\n---\r\n\r\nI think we either need to state:\r\n1. Control streams MUST NOT be reset (like HTTP/3)\r\n2. Reseting a control stream also resets all prior messages (ie. all prior SUBSCRIBEs).\r\n3. Reseting a control stream resets all unacknowledged messages (ie. SUBSCRIBEs without SUBSCRIBE_OK).\r\n\r\nOption 3 is problematic, since the subscriber knows that the OK was received prior to the reset but the publisher doesn't. Personally, I think option 1 is the best is there's a single control stream, while option 2 is the best if there's multiple (scoped) control streams. \r\n\r\n---\r\n\r\nRegardless of the approach, data messages and control messages should be split (#31) because they have different reliability. A receiver should know if it can issue STOP_SENDING for an OBJECT without impacting control messages, especially if we take approach 1.\r\n\r\nMy application uses a bidirectional stream for control messages and unidirectional streams for data messages. It makes it very easy for the application to know if a stream is resettable just based on the ID.",
      "createdAt": "2023-08-07T20:27:10Z",
      "updatedAt": "2023-10-16T17:19:04Z",
      "closedAt": "2023-10-16T17:19:04Z",
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "From #96 , (s/channels/streams)\r\n-- snip\r\nControl and Data Channels\r\nWhen a endpoint client or relay begins a transaction for media delivery, a new bilateral QUIC Stream is opened. This stream will act as the \"Control Channel\" for the exchange of data, carrying a series of control messages in both directions. There is one \"Control Channel\" setup per track. Control Channels are \"one way\" and are setup hop-by-hop between the participating MoQ entities. If a peer both sends and receive media, there will be different control channels for sending and receiving.\r\n\r\nFor exchanging media, OBJECT messages ({{message-object}}) belonging to a group are delivered over one or more unidirectional streams, called data channels, based on application's preferred mapping of the OBJECT and its group to underlying QUIC Stream(s).\r\n\r\nThe control channel will remain open as long as the peers are still sending or receiving the media. If either peer closes the control stream, the other peer will close its end of the stream and discard the state associated with the media transfer. The latter resulting in termination or clean up of stream states associated with the data channels.\r\n\r\n-- snip\r\n\r\n\r\nThe meta level thinking there was ,  OBJECT messages sent over data streams  doesn't impact control stream. However closing a control stream, say for a track namespace, will end up closing all the data streams corresponding to the media transfer for the associated track namespace\r\n\r\n\r\n\r\n",
          "createdAt": "2023-08-08T05:24:30Z",
          "updatedAt": "2023-08-08T05:24:30Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Resetting the control stream should be an error, given there is only a single control stream.",
          "createdAt": "2023-10-05T20:33:12Z",
          "updatedAt": "2023-10-05T20:33:12Z"
        }
      ]
    },
    {
      "number": 231,
      "id": "I_kwDOG2Ho4M5t55hs",
      "title": "ANNOUNCE and SUBSCRIBE relationship",
      "url": "https://github.com/moq-wg/moq-transport/issues/231",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I'm running into a bit of a conundrum with my implementation. ANNOUNCE and SUBSCRIBE contain a track namespace, but it's not clear how or if they are related.\r\n\r\nCurrently, ANNOUNCE is an optional message. It's meant to facilitate situations where publisher and consumer do not exchange the track namespace or authentication out-of-band. This was primarily for contribution, so a client could connect to a random edge and announce itself as an origin, but technically it also works for distribution. Let's assume one of those situations and ignore any pre-negotiation.\r\n\r\nBy receiving an ANNOUNCE, it implicitly becomes valid to issue a SUBSCRIBE to the given namespace. The message effectively carves out a space within the string namespace where a subscription might be served. Note that this is not a contract and the corresponding SUBSCRIBE could still fail, especially when the track name is invalid.\r\n\r\n---\r\n\r\nWhat happens after a subscriber receives a corresponding UNANNOUNCE (not specified)? Should the subscriber pretend like the original ANNOUNCE was never received? Does this mean:\r\n\r\n1. Terminate any active subscriptions? \r\n2. No longer issue any new subscriptions?\r\n3. Do nothing?\r\n4. Undefined?\r\n\r\n---\r\n\r\nLikewise what if the subscriber rejects an ANNOUNCE with ANNOUNCE_ERROR? Should the publisher continue to serve subscriptions from this namespace? Does this mean:\r\n\r\n1. Terminate any active subscriptions?\r\n2. Prevent any new subscriptions?\r\n3. Do nothing?\r\n4. Undefined?",
      "createdAt": "2023-08-09T19:40:34Z",
      "updatedAt": "2023-08-10T19:46:47Z",
      "closedAt": "2023-08-10T19:46:02Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "In my opinion, the answer is 1&2 for both, but that seems extremely counter-intuitive based on how the draft is currently written, as there is no explicit relationship between ANNOUNCE and SUBSCRIBE.\r\n\r\nHowever, when you step through how an application should behave in different roles, I think it becomes clear that some behavior needs to be standardized:\r\n\r\n---\r\n\r\nWhen a broadcaster receives ANNOUNCE_ERROR, it means the server rejected the broadcast. The client should terminate the broadcast and show an error message to the user.\r\n\r\nDoing nothing (option 3) or leaving it undefined (option 4) are the worst option as a result as the broadcast will hang. The broadcaster needs an explicit signal that the server WILL NOT subscribe.\r\n\r\nDoes the broadcaster clean up any existing subscriptions, or wait for them to drain? This can happen if an ANNOUNCE_OK was followed by a later ANNOUNCE_ERROR, indicating the broadcast is no longer valid.\r\n\r\nI think you sever, otherwise you're in this split-brain state where the ANNOUNCE is invalid but subscriptions are still valid for an arbitrary amount of time. This would block announcing a new broadcast until they have drained, and depending on the remote to cleanup just seems like a hang waiting to happen.\r\n\r\n---\r\n\r\nWhat happens when a relay receives an ANNOUNCE_ERROR or UNANNOUNCE? Well it probably occurred because the broadcaster disconnected and there's no longer route to the origin. Note that receiving an ANNOUNCE from the new origin would pre-empt this. \r\n\r\nAgain, doing nothing is probably the worst option as traffic will be routed to dead origin. Leaving it undefined seems like a terrible idea as relays will diverge in behavior during reconnections.\r\n\r\nBut does the relay sever any existing subscriptions, or just avoid issuing new ones? I think it should sever the subscriptions, explicitly telling downstream hosts that no more data is forthcoming. Otherwise, applications will starve with no visible signal and features like ABR will randomly break, as they rely on new subscriptions.\r\n\r\n---\r\n\r\nAnd what happens when a viewer sends an ANNOUNCE_ERROR, which means the client rejected the broadcast. This use-case needs to be fleshed out, but it could be because a participant is unauthenticated, an incompatible catalog was advertised, or some fatal error occurred. \r\n\r\nWhat if the server performs prefetching (subscribing in anticipation of the client), should it sever those subscriptions?\r\nAgain, doing nothing or leaving it undefined will cause resources to be wasted. The ANNOUNCE_ERROR should be an explicit signal that the client has no intention of subscribing.\r\n\r\n---\r\n\r\nI think this points to a very clear parent/child relationship between ANNOUNCE and SUBSCRIBE. If the ANNOUNCE is terminated, then so are the corresponding SUBSCRIBEs.\r\n\r\n* Is it valid to SUBSCRIBE after sending an ANNOUNCE_ERROR?\r\n* Is it valid to SUBSCRIBE after receiving an UNANNOUNCE?\r\n* Is it valid to SUBSCRIBE without receiving an ANNOUNCE?\r\n\r\nI think the answer to all of them is \"no\". There are race conditions involved, but I think the endpoint should assume that all subscriptions are rejected.\r\n\r\nHowever, we should still avoid introducing a round trip. You should be able to exchange the ANNOUNCE information out-of-band between coordinated endpoints, acting like an implicit (and irrevocable) ANNOUNCE message. Likewise we should also support implicit SUBSCRIBE messages.",
          "createdAt": "2023-08-09T20:55:59Z",
          "updatedAt": "2023-08-09T21:01:37Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual comment:\r\n\r\nI think we might first want to clarify the semantics of sending and receiving ANNOUNCE_ERROR and SUBSCRIBE_ERROR *after* receiving an ANNOUNCE_OK or SUBSCRIBE_OK for the same track namespace/full track name.  We may even want to disallow that and have separate messages to cancel or error an active announcement/subscription.  I read the problem differently if the initial ANNOUNCE fails versus someone cancelling it after it was valid for some time.\r\n\r\nI'm inclined to leave this decision up to the application, rather than being prescriptive. Is there an interop problem if, say, a sender leaves a subscription active after an ANNOUNCE_ERROR?  The receiver can always UNSUBSCRIBE.  Maybe there's a usecase for moving new subscriptions to another endpoint, but continuing existing ones?",
          "createdAt": "2023-08-09T21:09:48Z",
          "updatedAt": "2023-08-09T21:09:48Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think we might first want to clarify the semantics of sending and receiving ANNOUNCE_ERROR and SUBSCRIBE_ERROR _after_ receiving an ANNOUNCE_OK or SUBSCRIBE_OK for the same track namespace/full track name. We may even want to disallow that and have separate messages to cancel or error an active announcement/subscription. I read the problem differently if the initial ANNOUNCE fails versus someone cancelling it after it was valid for some time.\r\n\r\nThat's fair. I think @suhasHere called it ANNOUNCE_CEASE.\r\n\r\n**publisher sends:**\r\nANNOUNCE = \"You can subscribe\"\r\nANNOUNCE_RESET = \"You can no longer subscribe\"\r\n\r\n**subscriber sends:**\r\nANNOUNCE_OK = \"I might subscribe\"\r\nANNOUNCE_ERROR = \"I won't subscribe\"\r\nANNOUNCE_CEASE = \"I will no longer subscribe\"\r\n\r\nI think there's enough similarity between ANNOUNCE_ERROR and ANNOUNCE_CEASE that we don't need to separate them though.\r\n\r\n> I'm inclined to leave this decision up to the application, rather than being prescriptive. Is there an interop problem if, say, a sender leaves a subscription active after an ANNOUNCE_ERROR? The receiver can always UNSUBSCRIBE. Maybe there's a usecase for moving new subscriptions to another endpoint, but continuing existing ones?\r\n\r\nI think we should draw up a state machine. Leaving it up to the application is going to be an absolute mess because of the sheer number of permutations. This issue mostly centers around if the ANNOUNCE and SUBSCRIBE state machines are intertwined or separate. \r\n\r\nActually trying to draw up those state machines first would help, and will help inform if we need separate ANNOUNCE_ERROR and ANNOUNCE_CEASE messages.",
          "createdAt": "2023-08-09T21:41:49Z",
          "updatedAt": "2023-08-09T21:47:36Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual comment:\r\n\r\nThe QUIC decision to separate the send and receive stream state machines made them both simpler.  So I'm inclined to say the same here and keep the coupling very loose.  \r\n\r\nANNOUNCE hints to the subscriber where to route certain subscribes and that's it.  If the publisher wants to revoke that hint, and the subscriber already routed subscribes or wants to route new subscribes without an active announcement, fine.  The publisher can unsubscribe them and/or reject the new ones if it needs to.  It was never required in the first place, so even if there's no active announcement, a receiver may still try to send a subscribe.",
          "createdAt": "2023-08-09T23:52:12Z",
          "updatedAt": "2023-08-09T23:52:12Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm going to close this issue because there's not a concrete problem. I just kind of rambled on and it's frankly embarrassing to reread the \"issue\".\r\n\r\nBut I think the ambiguity of ANNOUNCE is going to keep being an issue, especially when trying to code generic endpoints. I would love to see a concrete state machine instead of an \"it's up to the application\" shoulder shrug.",
          "createdAt": "2023-08-10T19:46:02Z",
          "updatedAt": "2023-08-10T19:46:47Z"
        }
      ]
    },
    {
      "number": 233,
      "id": "I_kwDOG2Ho4M5uR49M",
      "title": "Decide how to achieve ALPN-style functionality in WebTransport",
      "url": "https://github.com/moq-wg/moq-transport/issues/233",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "vasilvv"
      ],
      "labels": [
        "Handshake"
      ],
      "body": "QUIC uses TLS that provides ALPN.  WebTransport does not currently have identical functionality.\r\n\r\n@vasilvv to bring this up with the W3C as to what the right way forward is.",
      "createdAt": "2023-08-14T17:01:53Z",
      "updatedAt": "2024-01-31T17:24:38Z",
      "closedAt": "2024-01-31T17:24:38Z",
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Filed w3c/webtransport#536",
          "createdAt": "2023-08-15T22:51:00Z",
          "updatedAt": "2023-08-15T22:51:08Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "@vasilvv : can this be closed now?",
          "createdAt": "2024-01-31T00:52:52Z",
          "updatedAt": "2024-01-31T00:52:52Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, this got solved in WebTransport.",
          "createdAt": "2024-01-31T17:24:38Z",
          "updatedAt": "2024-01-31T17:24:38Z"
        }
      ]
    },
    {
      "number": 237,
      "id": "I_kwDOG2Ho4M5usRJX",
      "title": "SUBSCRIBE state machine",
      "url": "https://github.com/moq-wg/moq-transport/issues/237",
      "state": "OPEN",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Subscribe"
      ],
      "body": "We should have a section that documents the subscription state machine, like QUIC does with stream states: https://www.rfc-editor.org/rfc/rfc9000.html#section-3\r\n\r\nIt makes it significantly easier to discuss about which messages are necessary and reason about what is available at each state. Implementations are certainly allowed to work outside of this framework, but personally it was a super valuable reference when I was implementing QUIC streams.\r\n\r\nThere's not much point documenting the current subscription states because they dead-end quickly. Here's my proposal that supports publisher and subscriber resets, via RESET and STOP respectively:\r\n\r\n### Publisher\r\n![publisher](https://github.com/moq-wg/moq-transport/assets/432854/9d0e8fbd-8434-4d4e-a56c-dd973945a473)\r\n\r\n### Subscriber\r\n![subscriber](https://github.com/moq-wg/moq-transport/assets/432854/cdd1c981-9887-45e1-90e3-a2c260651201)\r\n",
      "createdAt": "2023-08-18T18:06:49Z",
      "updatedAt": "2024-02-28T17:35:55Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "So just to elaborate the proposal a bit more.\r\n\r\n* **SUBSCRIBE**: \"I wish to receive this track\"\r\n* **SUBSCRIBE_OK**: \"I will start sending you this track\"\r\n* **SUBSCRIBE_STOP**: \"I no longer wish to receive this track\"\r\n* **SUBSCRIBE_RESET**: \"I will no longer send this track\"\r\n\r\nThere's an ID in each message that identifies the subscription state. It's up for debate if we allow reusing IDs (\"track_id\") or if each new subscription auto-increments the ID (\"subscription_id\").\r\n\r\nThe messages contain other information but they don't impact the subscription state. For example, SUBSCRIBE_OK can contain expires, but it will not automatically move the subscription into the closed state without an explicit SUBSCRIBE_RESET.",
          "createdAt": "2023-08-21T17:51:52Z",
          "updatedAt": "2023-08-21T17:54:02Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\nI would also like to see each message contain an (optional?) group/object sequence. This is useful for providing a range of valid OBJECTs and knowing what might be in transmit, although there is no guarantee.\r\n\r\n* **SUBSCRIBE**: request_start_group\r\n* **SUBSCRIBE_OK**: start_group\r\n* **SUBSCRIBE_STOP**: request_end_group\r\n* **SUBSCRIBE_RESET**: end_group\r\n\r\nThe only questionable one is SUBSCRIBE_STOP, since it could refer to a group that doesn't exist yet. It does seem kind of useful but it would mean queuing up unsubscriptions.",
          "createdAt": "2023-08-21T17:52:33Z",
          "updatedAt": "2023-08-21T17:52:33Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "By the same logic that suggests a SUBSCRIBE_OK response to the SUBSCRIBE command , should there also be a SUBSCRIBE_STOP_OK response to the SUBSCRIBE_STOP command? ",
          "createdAt": "2023-08-22T08:08:56Z",
          "updatedAt": "2023-08-22T08:08:56Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> By the same logic that suggests a SUBSCRIBE_OK response to the SUBSCRIBE command , should there also be a SUBSCRIBE_STOP_OK response to the SUBSCRIBE_STOP command?\r\n\r\nMy proposal is that the publisher sends `SUBSCRIBE_RESET` in response to `SUBSCRIBE_STOP` (subscriber close), unless a `SUBSCRIBE_RESET` has already been sent (publisher close).\r\n\r\nThe main race condition that needs to be addressed is when both the publisher and subscriber try to close the subscription at the same time.\r\n\r\n```\r\n     SUBSCRIBE -> |\r\n                  | <- SUBSCRIBE_OK\r\nSUBSCRIBE_STOP -> | <- SUBSCRIBE_RESET\r\n         (what happens now?)\r\n```\r\n\r\nMy proposal is pretty simple, the subscription is closed when a RESET is sent/received. It's the only way to advance to the terminal state and any further messages can be ignored.\r\n\r\nIf you explicitly acknowledge each message like Suhas is proposing, then you get into an ambiguous state. It's reasonable behavior for endpoints to reply with a corresponding OK, ERROR, or even nothing. \r\nThese are bugs just waiting to happen, especially because this is triggered by a rare and likely untested race condition.\r\n\r\nI suggest to try drawing up the state machine if explicit OK/ERROR messages seem like a good idea. You'll find that some of the messages are redundant (`SUBSCRIBE_RESET == SUBSCRIBE_STOP_OK`), some are useless (`SUBSCRIBE_RESET_OK, SUBSCRIBE_STOP_ERROR`), and that it's difficult to enter a terminal state when both endpoints close at the same time. I could try to draw it up too when I get home.\r\n\r\n",
          "createdAt": "2023-08-22T18:30:38Z",
          "updatedAt": "2023-08-22T18:33:35Z"
        },
        {
          "author": "hardie",
          "authorAssociation": "COLLABORATOR",
          "body": "Speaking as an individual, I agree that having the state machine laid out\r\nwill improve the discussion.\r\n\r\nAn additional point on the SUBSCRIBE_STOP semantics in-line.\r\n\r\nOn Tue, Aug 22, 2023 at 7:30\u202fPM kixelated ***@***.***> wrote:\r\n\r\n> By the same logic that suggests a SUBSCRIBE_OK response to the SUBSCRIBE\r\n> command , should there also be a SUBSCRIBE_STOP_OK response to the\r\n> SUBSCRIBE_STOP command?\r\n>\r\n> My proposal is that the publisher sends SUBSCRIBE_RESET in response to\r\n> SUBSCRIBE_STOP (subscriber close), unless a SUBSCRIBE_RESET has already\r\n> been sent (publisher close).\r\n>\r\n> The main race condition that needs to be addressed is when both the\r\n> publisher and subscriber try to close the subscription at the same time.\r\n>\r\n> SUBSCRIBE ->      |\r\n>                   | <- SUBSCRIBE_OK\r\n> SUBSCRIBE_STOP -> | <- SUBSCRIBE_RESET\r\n>          (what happens now?)\r\n>\r\n> My proposal is pretty simple, the subscription is closed when a RESET is\r\n> sent/received. It's the only way to\r\n>\r\nIf both are trying to close this at the same time, there is a condition\r\nwhere the group_id pair:\r\n\r\n*SUBSCRIBE_STOP*: request_end_group\r\nand the racing\r\n*SUBSCRIBE_RESET*: end_group\r\n\r\n\r\ndoesn't match.  If the client requested a later group than the end_group in\r\nthe racing SUBSCRIBE_REST this requires client side action to update its\r\nexpectations (as it may cause an error condition for the application using\r\nthe transport).  The state machine will also have to be clear on whether\r\nSUBSCRIBE_RESET used as a SUBSCRIBE_STOP_OKAY can ever alter the end_group\r\nproposed in SUBSCRIBE_STOP (e.g. to a group id that's already in flight).\r\n\r\n\r\n> advance to the terminal state and any further messages ignored.\r\n>\r\n> If you explicitly acknowledge each message like Suhas is proposing, then\r\n> you get into an ambiguous state. It's reasonable behavior for endpoints to\r\n> reply with a corresponding OK, ERROR, or even nothing.\r\n> These are bugs just waiting to happen, especially because this is\r\n> triggered by a rare and likely untested race condition.\r\n>\r\n> I suggest to try drawing up the state machine if explicit OK/ERROR\r\n> messages seem like a good idea. You'll find that some of the messages are\r\n> redundant (SUBSCRIBE_RESET == SUBSCRIBE_STOP_OK), some are useless (SUBSCRIBE_RESET_OK,\r\n> SUBSCRIBE_STOP_ERROR), and that it's difficult to enter a terminal state\r\n> when both endpoints close at the same time.\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/moq-wg/moq-transport/issues/237#issuecomment-1688709800>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AAKVXZFWSAHJVM237Q57653XWT3FXANCNFSM6AAAAAA3V3D6FA>\r\n> .\r\n> You are receiving this because you are subscribed to this thread.Message\r\n> ID: ***@***.***>\r\n>\r\n",
          "createdAt": "2023-08-23T08:25:33Z",
          "updatedAt": "2023-08-23T08:25:33Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> If both are trying to close this at the same time, there is a condition where the group_id pair: *SUBSCRIBE_STOP*: request_end_group and the racing *SUBSCRIBE_RESET*: end_group doesn't match. If the client requested a later group than the end_group in the racing SUBSCRIBE_REST this requires client side action to update its expectations (as it may cause an error condition for the application using the transport). The state machine will also have to be clear on whether SUBSCRIBE_RESET used as a SUBSCRIBE_STOP_OKAY can ever alter the end_group proposed in SUBSCRIBE_STOP (e.g. to a group id that's already in flight).\r\n\r\nExactly. That's why I added a separate \"stop\" state for the subscriber instead of jumping straight to \"closed\". \r\n\r\nUltimately, the publisher is the authority on the start/end group. It knows the minimum sequence in the cache and the maximum sequence that has been transmitted. The subscriber can hint a start/end but it has imperfect information until it gets an explicit reply.\r\n\r\nSuppose a subscriber sends a STOP with group X, an RTT passes, and then receives a RESET with group Y.\r\n- **X < Y** occurs when the publisher had already transmitted Y by the time the STOP arrived.\r\n- **X == Y** is possible but unlikely for any live source due to transmission delay.\r\n- **X > Y** occurs when the publisher never transmitted X, or the publisher reset first.\r\n\r\nA subscriber may choose to process objects while in the \"stop\" state (valid in QUIC), during which time it MAY receive objects >X. Once it receives the RESET and transitions to the \"closed\" state, then it MUST NOT receive objects >Y.",
          "createdAt": "2023-08-23T16:56:53Z",
          "updatedAt": "2023-08-23T16:59:12Z"
        }
      ]
    },
    {
      "number": 238,
      "id": "I_kwDOG2Ho4M5u2hzf",
      "title": "Ensure use of connection/session are clear and specify error codes when closing a session.",
      "url": "https://github.com/moq-wg/moq-transport/issues/238",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "ianswett"
      ],
      "labels": [
        "Needs PR"
      ],
      "body": "Part of PR #234 has text \"MUST close the connection if there are duplicates\"\r\n\r\nIt seems like we should be closing the session, and we should specify an error code.",
      "createdAt": "2023-08-21T17:03:27Z",
      "updatedAt": "2023-10-30T23:12:35Z",
      "closedAt": "2023-10-30T23:12:35Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is editorial, but unsure because of \"specify an error code\"",
          "createdAt": "2023-09-27T17:40:42Z",
          "updatedAt": "2023-09-27T17:40:42Z"
        }
      ]
    },
    {
      "number": 239,
      "id": "I_kwDOG2Ho4M5u2jlx",
      "title": "Change 'Key' to 'Type' to match other protocols (ie: TLS)",
      "url": "https://github.com/moq-wg/moq-transport/issues/239",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Editorial",
        "Parameters"
      ],
      "body": "TLV is the typical terminology.",
      "createdAt": "2023-08-21T17:08:38Z",
      "updatedAt": "2024-02-19T22:10:42Z",
      "closedAt": "2024-02-19T22:10:42Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I think `Type` is correct for messages but wrong for parameters (as they currently exist).\r\n\r\n`Type` distinguishes the encoding while `ID` distinguishes the meaning. Two parameters with the same encoding (ex. varint) would be the same `Type` but have different `ID`s.\r\n\r\nA quick glance at my favorite RFCs:\r\n* QUIC frames: `Type`\r\n* QUIC transport parameters: `ID`\r\n* HTTP/3 messages/streams: `Type`\r\n* HTTP/3 settings: `Identifier`\r\n* TLS messages: `Type`\r\n\r\nThat being said, I do prefer the TLS approach for extensions.",
          "createdAt": "2023-08-23T17:16:50Z",
          "updatedAt": "2023-08-23T17:21:47Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Does this mean we might want to rename \"Key\" to \"ID\" for parameters?  Given the large changes expected in parameters, I'll keep this open for now, but I'd also be ok with closing it.",
          "createdAt": "2023-10-17T01:17:52Z",
          "updatedAt": "2023-10-17T01:17:52Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd like to call parameters `Type` and give them proper types that depend on the value.\r\n\r\nFor example:\r\n\r\n```\r\ntype Auth {\r\n  scheme: int\r\n  payload: []byte\r\n} = 3\r\n\r\ntype SubscribeStart {\r\n  relative: bool\r\n  group: int\r\n  object: int\r\n} = 4\r\n```\r\n\r\nVersus how I interpret `ID`, where the `Type` can be `int, []byte, bool` in this example:\r\n\r\n```\r\nenum Params {\r\n  // ...\r\n  AuthScheme: int = 2\r\n  AuthPayload: []byte = 3\r\n  SubscribeStartRelative: bool = 4\r\n  SubscribeStartGroup: int = 5\r\n  SubscribeStartObject: int = 6\r\n  // ...\r\n}\r\n```",
          "createdAt": "2023-10-17T03:27:46Z",
          "updatedAt": "2023-10-17T03:29:55Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe the draft now uses these terms as intended, so closing.",
          "createdAt": "2024-02-19T22:10:42Z",
          "updatedAt": "2024-02-19T22:10:42Z"
        }
      ]
    },
    {
      "number": 240,
      "id": "I_kwDOG2Ho4M5wcz0U",
      "title": "ANNOUNCE_OK has no Namespace length",
      "url": "https://github.com/moq-wg/moq-transport/issues/240",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In principle, the receiver could do some sort of longest-match or something, but this will be really painful if, for example, one namespace is a substring of another.",
      "createdAt": "2023-09-07T21:47:02Z",
      "updatedAt": "2023-09-11T21:01:33Z",
      "closedAt": "2023-09-07T21:47:30Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oh, it's implied by the message length. D'oh.",
          "createdAt": "2023-09-07T21:47:30Z",
          "updatedAt": "2023-09-07T21:47:30Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't like how it's implied by the message length tho. It means an encoder/decoder needs two string types, one with an explicit prefix and one with an implicit length.",
          "createdAt": "2023-09-10T15:55:21Z",
          "updatedAt": "2023-09-10T15:55:21Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I can deal with that, but feel free to reopen this if you are dissatisfied.",
          "createdAt": "2023-09-11T21:01:33Z",
          "updatedAt": "2023-09-11T21:01:33Z"
        }
      ]
    },
    {
      "number": 241,
      "id": "I_kwDOG2Ho4M5wiPYE",
      "title": "Actions on unknown Message Type",
      "url": "https://github.com/moq-wg/moq-transport/issues/241",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Wire Format"
      ],
      "body": "Fail, or pass over?",
      "createdAt": "2023-09-08T16:53:26Z",
      "updatedAt": "2023-10-09T16:36:57Z",
      "closedAt": "2023-10-09T16:36:57Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "IMO fail. We have version negotiation and should add extension negotiation so it should never happen.\r\n\r\nThe problem with ignoring messages is that MoqTransport is designed for relays. If an intermediate relay doesn't support a message, it then gets silently dropped. At the very least we need enough information on where to forward unknown messages.",
          "createdAt": "2023-09-10T15:52:16Z",
          "updatedAt": "2023-09-10T15:53:26Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If it's going to Fail, then most Message types don't need a length field at all (OBJECT and ANNOUNCE_OK would be the exceptions)",
          "createdAt": "2023-09-14T17:07:40Z",
          "updatedAt": "2023-09-14T17:07:40Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment:\r\n\r\nIs there any reasonable action a relay can take on an unknown message, besides discarding it?  See how HTTP recently added a \"Capsule\" concept which is an envelop with a default relay action of \"forward\", which allows for end-to-end\u00a0extensions without upgrading all intermediaries.\r\n\r\nGiven that MoQ handles forwarding on a per-track level, I think there probably isn't any way to generically forward a message that isn't associated with an active subscription.\r\n\r\nThat said, it makes me wonder if we want to add a capsule-like extension message, or does the existing OBJECT definition give enough flexibility?",
          "createdAt": "2023-09-28T23:39:09Z",
          "updatedAt": "2023-09-28T23:39:09Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> Given that MoQ handles forwarding on a per-track level, I think there probably isn't any way to generically forward a message that isn't associated with an active subscription.\r\n\r\nYeah exactly. It's impossible to know the intended destination of an unknown message with the current ANNOUNCE/SUBSCRIBE mechanisms. \r\n\r\nI'm using the `PATH` (as the track namespace) and `ROLE` instead of `ANNOUNCE`. This actually does let you forward unknown messages from publisher -> subscribers and subscribers -> publisher since each session is associated with only a single track namespace. Session pooling is always the issue...",
          "createdAt": "2023-09-29T00:51:54Z",
          "updatedAt": "2023-09-29T00:52:51Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we need extensibility. We want the protocol to be extensible so a given server might support extension A and C and another server supports extension A and B.  It is very hard to do that using just a version number. ",
          "createdAt": "2023-10-03T14:25:43Z",
          "updatedAt": "2023-10-03T14:25:43Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Rereading all this - II think this whole issue just need to be uplevel to what is the extensibility strategy then this detailed part of it will be easy. ",
          "createdAt": "2023-10-03T14:30:52Z",
          "updatedAt": "2023-10-03T14:30:52Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "There was support for not requiring a length and failing on unknown message types at the Interim, so the intent is to land PR #255 after review.",
          "createdAt": "2023-10-04T14:50:17Z",
          "updatedAt": "2023-10-04T14:50:17Z"
        }
      ]
    },
    {
      "number": 242,
      "id": "I_kwDOG2Ho4M5wm0Uz",
      "title": "Client and/or server initiated handshake",
      "url": "https://github.com/moq-wg/moq-transport/issues/242",
      "state": "OPEN",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Handshake"
      ],
      "body": "Splitting discussion in #212 into a separate issue.\r\n\r\nThe current draft states that the client initiates the session via a CLIENT_SETUP message and then server replies with a SERVER_SETUP. The client sends a list of supported versions and its role, while the server chooses a version and reaffirms the role. This is done via a bidirectional stream opened by the client.\r\n\r\nHowever, depending on the underlying transport, the client won't always be the first endpoint allowed to send a flight, so this incurs a half-RTT of latency:\r\n\r\n* WebTransport: Client is allowed to send first (before CONNECT response), but most implementations will let the server send first (after 2xx CONNECT response)\r\n* QUIC: Client sends first with 0-RTT, while the server sends first with 1-RTT (most common).",
      "createdAt": "2023-09-10T16:38:18Z",
      "updatedAt": "2024-03-18T20:44:05Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we should emulate HTTP/3 SETTINGS. That means endpoints can send the SETUP in parallel.\r\n\r\n```\r\nSETUP\r\nsupported_versions: [ 1, 3, 4, ... ]\r\nsupported_roles: \"publisher\" | \"subscriber\" | \"both\" \r\n```\r\n\r\nAs far as I understand, this doesn't support from version negotiation attacks, since it's over an established QUIC connection.\r\n\r\nAlternatively, QUIC could use the ALPN to transmit this SETUP information. Unfortunately no such mechanism exists for WebTransport (yet).",
          "createdAt": "2023-09-10T16:46:18Z",
          "updatedAt": "2023-09-11T00:01:24Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "so I am working on the assumption the vast majority of connections, measured by numbers of connection, will be 0-RTT, not 1. I was assuming this because what the MoQ client sends in that would be \"SAFE\" in the HTTP replay sen. I realize other on this thread  have thought about this lots. Any particular reason 0-RTT would not be common in MoQ ?",
          "createdAt": "2024-02-05T00:03:58Z",
          "updatedAt": "2024-02-05T00:03:58Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> so I am working on the assumption the vast majority of connections, measured by numbers of connection, will be 0-RTT, not 1. I was assuming this because what the MoQ client sends in that would be \"SAFE\" in the HTTP replay sen. I realize other on this thread have thought about this lots. Any particular reason 0-RTT would not be common in MoQ ?\r\n\r\nWell, WebTransport does not support 0-RTT. Even if it did, MoQ would be subject to a replay attacks depending on how authentication is performed.",
          "createdAt": "2024-02-07T02:19:41Z",
          "updatedAt": "2024-02-07T02:19:41Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Note that in case of WebTransport, the question of 0-RTT is orthogonal to the question of which side speaks first (it just lets you skip a round trip that occurs before the WebTransport session is established).",
          "createdAt": "2024-02-07T16:52:44Z",
          "updatedAt": "2024-02-07T16:52:44Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "We now have a clearer definition of Role, so the 'server' from the perspective of a QUIC connection could initiate a MoQ session with a CLIENT_SETUP message I believe?\r\n\r\nI'm going to park this for now unless this is currently causing problems.  Currently the control stream is bidi and unidirectional streams are for Objects, so this would be a non-trivial change.",
          "createdAt": "2024-03-18T01:05:12Z",
          "updatedAt": "2024-03-18T01:05:12Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "> the 'server' from the perspective of a QUIC connection could initiate a MoQ session with a CLIENT_SETUP message\r\n\r\nDid we intend to allow this?",
          "createdAt": "2024-03-18T20:44:04Z",
          "updatedAt": "2024-03-18T20:44:04Z"
        }
      ]
    },
    {
      "number": 243,
      "id": "I_kwDOG2Ho4M5wneqn",
      "title": "Separate handshakes, or unified handshake?",
      "url": "https://github.com/moq-wg/moq-transport/issues/243",
      "state": "OPEN",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Handshake"
      ],
      "body": "A few issues have cropped up because we support QUIC and WebTransport with a unified SETUP handshake.\r\n\r\n- #232 was closed because there's a desire to use ALPN for native QUIC, however no such functionality exists in WebTransport.\r\n- #135 added a path to the SETUP message, mirroring WebTransport because no such functionality exists in QUIC.\r\n- #242 incurs an additional half RTT delay with native QUIC because the client sends the SETUP message first.\r\n\r\nDo we separate the QUIC and WebTransport handshakes, or continue to combine them into the same mechanism?",
      "createdAt": "2023-09-11T00:03:50Z",
      "updatedAt": "2023-10-03T23:39:38Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we have a separate handshakes for QUIC and WebTransport that better utilize the underlying transport.\r\n\r\n* QUIC could leverage ALPN.\r\n* WebTransport could leverage the CONNECT request.\r\n* WebTransport could leverage session pooling.\r\n\r\nHowever, I do want to avoid differences after the connection is established.",
          "createdAt": "2023-09-11T00:07:59Z",
          "updatedAt": "2023-09-11T00:08:34Z"
        }
      ]
    },
    {
      "number": 244,
      "id": "I_kwDOG2Ho4M5wo-aa",
      "title": "Object Model mapping to QUIC ",
      "url": "https://github.com/moq-wg/moq-transport/issues/244",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Object Model"
      ],
      "body": "Recent discussions around the points highlighted in https://datatracker.ietf.org/doc/html/draft-jennings-moq-usages-00 has made it clear that the core transport protocol needs to provide advices on how to moqt object model maps to the QUIC.\r\n\r\nGiven that different use-cases have slightly varying requirements, there is also need for applications to specify their preference on how to use QUIC streams to transport objects and groups within a track from the publisher to the subscriber. \r\n\r\n\r\nHere is the  proposal for  `Transport Delivery Mode` enumeration as part of `SUBSCRIBE OK` message as an **experimental** addition to the protocol for publishers to express their interest .\r\n\r\nFollowing delivery modes are proposed\r\n\r\n* StreamPerObject(0): \r\nIn this mode, the publisher intends to use one QUIC Stream per MOQT Object.\r\n\r\n* Stream Per Group(1):\r\nIn this mode, the publisher intends to use one QUIC Stream per MOQT Group. All the objects from a given Group share the same QUIC stream.\r\n\r\n* Stream Per Priority(2):\r\nIn this mode, the publisher intends to use one QUIC Stream per priority \r\nas determined by the MOQT object priority value. \r\n\r\n* Stream Per Track(3):\r\nIn this mode, the publisher intends to use one QUIC Stream for a given track.\r\n\r\n\r\n\r\nThe core idea behind such experimental extension is to help under the application, deployment and interoperability requirements before the final path is chosen for the core transport",
      "createdAt": "2023-09-11T06:48:00Z",
      "updatedAt": "2024-01-22T03:03:26Z",
      "closedAt": "2024-01-22T03:03:26Z",
      "comments": [
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In moq-transport, an intermediary knows how to extract objects from incoming Streams (there may be 1..N Objects in a Stream), read their metadata (such as Group and priority assignments), cache them and potentially drop them depending on prioritzation settings. They also need to know how to forward them, which I believe is the intent of this issue. Perhaps we should reframe these as `forwarding preferences`? They instruct intermediaries beyond the current hop in how to propagate the objects . The various forwarding types can be enumerated in the spec and should be a new field in the header of each Object.\r\n\r\nIf the intermediary is not making a new Stream for every Object it forwards, then it needs to bind a new Object to some existing Stream. I term this the \"binding ID\".  I have relisted the groups, adding in the binding ID that an intermediary would use.\r\n\r\n_Send each object in a new stream (default?)_\r\nBinding ID: None needed. \r\n\r\n_Send all objects with the same Group in the same stream_\r\nBinding ID: namespace + Group number\r\n\r\n_Send all objects with the same Priority in the same stream_\r\nBinding ID: namespace + priority value\r\n\r\n_Send all Objects in the same track in the same stream_\r\nBinding ID: namespace + track name\r\n\r\n",
          "createdAt": "2023-09-11T14:11:01Z",
          "updatedAt": "2023-09-11T14:11:01Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I want something simpler.\r\n\r\nIf a relay receives objects A, B on QUIC stream 1 and objects C, D on QUIC stream 2, then the relay continues that relationship. The relay MUST NOT reposition objects within a QUIC stream.\r\n\r\nObject per stream: A:1 B:2 C:3 D:4\r\nGroup per stream: AB:1 CD:2\r\nLayer per stream: AC:1 BD:2\r\nTrack per stream ABCD:1\r\n\r\nBonus points if objects on the same stream share a header. ex. prioritization is applied at a stream granularity, not object granularity.\r\n",
          "createdAt": "2023-09-11T16:20:58Z",
          "updatedAt": "2023-09-11T16:24:24Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> If a relay receives objects A, B on QUIC stream 1 and objects C, D on QUIC stream 2, then the relay continues that relationship.\r\n\r\nHow would caching work under this scheme? Caching introduces a temporal discontinuity to the transmission. Should the relay continue to cache by Object, or should it instead cache by Stream? ",
          "createdAt": "2023-09-11T16:30:29Z",
          "updatedAt": "2023-09-11T16:30:29Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> > If a relay receives objects A, B on QUIC stream 1 and objects C, D on QUIC stream 2, then the relay continues that relationship.\r\n> \r\n> How would caching work under this scheme? Caching introduces a temporal discontinuity to the transmission. Should the relay continue to cache by Object, or should it instead cache by Stream?\r\n\r\nYou would cache by stream and byte offset, like HTTP chunked-transfer. If you evict A from the cache, you would also evict B from the cache.\r\n\r\nIf the application chooses to put A+B on the same QUIC stream _in that order_, then it expects A+B to be delivered in that order. It the application wanted those objects to arrive in any order, then it would have put A and B on separate streams.\r\n\r\n---\r\n\r\nShould we support a situation where a client transmits A+B on the same stream, but expects the relay to split them into separate A and B streams to downstream clients? I don't think so, because of congestion on the first mile. Once you introduce head-of-line blocking, you can't remove it.\r\n\r\nTo oversimplify, it's like converting TCP -> UDP. If there's congestion on the TCP hop, then UDP packets will arrive in TCP order despite being split. This still has benefits for last-mile congestion versus TCP -> TCP, but to handle first-mile congestion what you really want is UDP -> UDP. \r\n\r\nVice versa, should a client transmit A and B on separate streams, but the relay combines them into A+B for downstream clients? Absolutely not, as you actually suffer from both first-mile congestion and last-mile congestion.\r\n\r\nThe analogy is UDP -> TCP. Any unreliable or out-of-order delivery at the first-mile needs to be fixed before it can be converted to reliable and ordered delivery. This is then exasperated by prioritization, as the relay wants object A to unblock B, but the sender may decide that C is higher priority.\r\n\r\nThese same principals apply for RTMP -> WebRTC and WebRTC -> HLS. I spent years working on the former at Twitch and we gave up because the user experience was terrible. We offered WebRTC -> HLS but ironically it introduces more latency and is a worse user experience than RTMP -> HLS.\r\n\r\n---\r\n\r\nI strongly believe that relays need to provide: X -> X\r\n\r\nIf an application introduces head-of-line blocking by putting content on the same stream, then the relay must maintain that head-of-line blocking. The relay doesn't try to introduce more, nor does it try to introduce less.\r\n\r\nThis is also amazingly simple for relay; they just proxy QUIC streams. The application still needs stream prioritization for inter-stream relationships, but now it can use stream ordering for intra-stream dependencies.\r\n\r\nFor example, the base catalog and deltas would be on the same QUIC stream. There's no need for parent sequence number as the relay would deliver the base and deltas in order. There's no reason for the relay to cache them separately, as evicting the base but not the deltas from the cache would be a mistake.",
          "createdAt": "2023-09-11T18:41:18Z",
          "updatedAt": "2023-09-11T18:44:32Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "@fluffy mentioned something at the start of the call that I wanted to address.\r\n\r\nIt sounded like the client was transmitting a single QUIC stream, and he wanted parts of that stream to be cached independently.\r\n\r\n- If this is a single GoP, then it can't be cached independently. If a new subscriber joins then it needs the entire GoP. You have to make multiple GoPs if you want independent join/cache points.\r\n- If there are multiple GoPs sent over the same QUIC stream, then yeah caching is a problem. You would have to cache based on group+stream tuple.\r\n\r\nHowever I doubt you actually want this behavior, because you just reinvented RTMP. The whole point of groups is that they're independent, but this property is lost when they share the same QUIC stream. They wouldn't actually be independent for the first-mile delivery, and just like I mentioned in the last post, any first-mile congestion will reek havoc on last-mile delivery.\r\n\r\nI think you want to split each group into a separate QUIC stream:\r\n**independent groups = independent delivery = independent streams**\r\n\r\n\r\nThis is why I want MoQ group == QUIC stream. However, I would be fine with MoQ object == QUIC stream, because like @hardie brought up at the start, I can use a single object per group to get the desired behavior. But something needs to be specified, because a relay MUST NOT be able to move my objects to other streams.",
          "createdAt": "2023-09-11T19:04:31Z",
          "updatedAt": "2023-09-11T19:06:59Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> * If this is a single GoP, then it can't be cached independently. If a new subscriber joins then it needs the entire GoP. You have to make multiple GoPs if you want independent join/cache points.\r\n\r\nWhen a new subscriber joins mid GOP, there are only 2 options to have any meaningful experience\r\n   - Start from the beginning of the current GOP to get the IDR \r\n   - Wait for the next GOP \r\n\r\nThis goes to issue #245",
          "createdAt": "2023-09-12T03:39:20Z",
          "updatedAt": "2023-09-12T03:39:20Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> This is why I want MoQ group == QUIC stream. However, I would be fine with MoQ object == QUIC stream, because like @hardie brought up at the start, I can use a single object per group to get the desired behavior. But something needs to be specified, because a relay MUST NOT be able to move my objects to other streams.\r\n\r\nI think we are mixing  2 different levels of mappings here.\r\n1. how an application maps its data to moqt object model\r\n  - One object as GOP or one object as encoded video frame of 33ms is entirely up to application.\r\n  \r\n2. how aspects of moqt object model is mapped to the QUIC\r\n - Once you have application data mapped to the moqt object model, then it comes down to question on how moqt objects/groups are transported via QUIC mechanisims.  This issue talks about this mapping in particular.\r\n \r\n\r\nYes application needs to know how to do 1 and 2, but the moqt transport only needs to specify 2.\r\n\r\nAlso caching needs to be done at object level since it allows retrieval from cache provided track, group and object information as keys.\r\n\r\nI don't think we should normatively specify that relay shouldn't map things differently  from ingest to egress. But yes a given relay implementation can choose to map it differently and it does indicate it via the transport delivery mode.",
          "createdAt": "2023-09-12T03:45:53Z",
          "updatedAt": "2023-09-12T03:45:53Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> This is why I want MoQ group == QUIC stream\r\n\r\nYou can achieve this via delivery mode of stream per group.  If a group has a single object (say GOP), it just caches one object for that GOP.",
          "createdAt": "2023-09-12T03:48:08Z",
          "updatedAt": "2023-09-12T03:48:24Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> > * If this is a single GoP, then it can't be cached independently. If a new subscriber joins then it needs the entire GoP. You have to make multiple GoPs if you want independent join/cache points.\r\n> \r\n> When a new subscriber joins mid GOP, there are only 2 options to have any meaningful experience\r\n> \r\n> * Start from the beginning of the current GOP to get the IDR\r\n> * Wait for the next GOP\r\n> \r\n> This goes to issue #245\r\n\r\nYeah, my point is that you shouldn't be sending multiple GoPs over the same QUIC stream, otherwise it's not possible to serve the latest GoP during congestion. Using a single stream for multiple GoPs is only optimal when there's zero congestion, in which case just use TCP lul.\r\n\r\n\r\n\r\n> > This is why I want MoQ group == QUIC stream. However, I would be fine with MoQ object == QUIC stream, because like @hardie brought up at the start, I can use a single object per group to get the desired behavior. But something needs to be specified, because a relay MUST NOT be able to move my objects to other streams.\r\n> \r\n> I think we are mixing 2 different levels of mappings here.\r\n> \r\n> 1. how an application maps its data to moqt object model\r\n> \r\n> * One object as GOP or one object as encoded video frame of 33ms is entirely up to application.\r\n> \r\n> 2. how aspects of moqt object model is mapped to the QUIC\r\n> \r\n> * Once you have application data mapped to the moqt object model, then it comes down to question on how moqt objects/groups are transported via QUIC mechanisims.  This issue talks about this mapping in particular.\r\n>\r\n> Yes application needs to know how to do 1 and 2, but the moqt transport only needs to specify 2.\r\n\r\nYeah, the problem is that without 2 the application can't decide 1. The transport needs to provide properties that the application can use. Right now MoqTransport OBJECTs are closer to jumbo-datagrams because they're semi-reliable and semi-ordered. It's a huge red flag when the application can't reliably deliver deltas in order because of the object/group abstraction.\r\n\r\nAt a minimum, the application needs the ability to deliver a stream of bytes over MoqTransport. We should absolutely use QUIC streams for that instead of reinventing them via an increasingly convoluted object model with flags.\r\n \r\n\r\n> Also caching needs to be done at object level since it allows retrieval from cache provided track, group and object information as keys.\r\n\r\nCaching should be performed at the stream level via byte ranges. Even with objects, you want to cache at the byte range level, as waiting to receive an entire object before caching/serving can only add latency. For example, an I-frame takes multiple round-trips to deliver (especially with packet loss), so don't want to wait to receive the entire frame before caching/serving it.\r\n\r\nHere's how a relay should work: Read chunk from upstream, (optional) write chunk to cache, forward chunk to downstream. A chunk is a stream offset+length, aka a QUIC stream frame.\r\n\r\n> I don't think we should normatively specify that relay shouldn't map things differently from ingest to egress. But yes a given relay implementation can choose to map it differently and it does indicate it via the transport delivery mode.\r\n\r\nI think the relay MUST maintain the stream mapping. Otherwise the application MUST assume the lowest common denominator, where some dumb relay decided to send every object over separate streams in an arbitrary order, or decided to drop arbitrary objects in the middle of a group.\r\n\r\nImagine if a HTTP relay was allowed to deliver a HTTP response body in an arbitrary order or unreliably. It would break so many assumptions and force the application to anticipate this substandard delivery, even if 99% of relays delivered the body correctly. Or it would become a defacto standard that relays MUST deliver the body reliably and in order, in which case we should have been made an official standard.",
          "createdAt": "2023-09-12T04:56:37Z",
          "updatedAt": "2023-09-12T04:57:08Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> Here's how a relay should work: Read chunk from upstream, (optional) write chunk to cache, forward chunk to downstream. A chunk is a stream offset+length, aka a QUIC stream frame.\r\n\r\nAdding to this tangent, caching based on byte offset instead of frame number is far more efficient. Let me explain why.\r\n\r\nLet's assume we send an entire 2s GoP via QUIC stream. A subscriber lost their connection half-way through a GoP and wants to request it again:\r\n\r\n- Ideal: `GET <track> <group> <byte-range>`\r\n- Poor: `GET <track> <group> <object-range>`\r\n\r\nIn the ideal scenario, that's one lookup into the cache table. We advance the data pointer X bytes to the start and read until the requested Y byte. This memory is mostly on the same page, and can be written to the QUIC stream in one operation.\r\n\r\nIn the poor scenario, the relay has to do N cache table lookups. These are likely all in separate memory pages and there's N writes to the QUIC stream. N depends on the frame rate if every frame is a separate object.",
          "createdAt": "2023-09-12T05:11:15Z",
          "updatedAt": "2023-09-12T05:11:15Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> Yeah, the problem is that without 2 the application can't decide 1. The transport needs to provide properties that the application can use\r\n\r\nThat's exactly the TransportDeliveryMode in this issue is addressing.",
          "createdAt": "2023-09-16T23:41:53Z",
          "updatedAt": "2023-09-16T23:41:53Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> Otherwise the application MUST assume the lowest common denominator, where some dumb relay decided to send every object over separate streams in an arbitrary order, or decided to drop arbitrary objects in the middle of a group.\r\n\r\nApplications themseleves has a choice to send every object in its own stream. Relays may choose \r\n\r\n> Even with objects, you want to cache at the byte range level, as waiting to receive an entire object before caching/serving can only add latency. For example, an I-frame takes multiple round-trips to deliver (especially with packet loss), so don't want to wait to receive the entire frame before caching/serving it.\r\n\r\nI am not sure how was the conclusion reached here that the entirety of the object has be to received before serving downstream though. \r\nIf an object is a I-Frame/GOP, the bytes/fragments come in and are sent to caching layer as fragments for building the cache for that object and also forwarded to all the subscribers in parallel as fragments.  This issue for delivery mode doesn't affect that behavior in any way.",
          "createdAt": "2023-09-16T23:49:35Z",
          "updatedAt": "2023-09-16T23:49:35Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> > Yeah, the problem is that without 2 the application can't decide 1. The transport needs to provide properties that the application can use\r\n> \r\n> That's exactly the TransportDeliveryMode in this issue is addressing.\r\n\r\nYeah, we both agree on that front and the disagreement is just over the implementation. Instead of N different modes toggling which messages constitute a QUIC stream, I literally just need a promise that the relay can't rearrange QUIC stream contents. Even if we do add `TransportDeliveryMode`, I still need a promise that the relay won't change it.\r\n\r\nie. if an application creates a QUIC stream with only object 1 and object 2 on it, then the relay MUST also transmit a QUIC stream with only object 1 and object 2 on it, and in that order. If a relay is allowed to split them into separate streams or insert object 3 in the middle, then it completely breaks many applications.\r\n\r\nWith that property in place, I do think the stream header could deduplicate some OBJECT properties, but that's an optimization and not actually required. It just seems like a bug to send two different objects with different priorities or groups over the same QUIC stream.\r\n\r\n> > Otherwise the application MUST assume the lowest common denominator, where some dumb relay decided to send every object over separate streams in an arbitrary order, or decided to drop arbitrary objects in the middle of a group.\r\n> \r\n> Applications themseleves has a choice to send every object in its own stream. Relays may choose\r\n\r\nRelays should absolutely not be able to choose; it can only create problems. The application made the decision to deliver objects over separate QUIC streams for a very explicit reason. The relay lacks any information about the application by design so if it changes the delivery mode, it's either making a completely uninformed and likely detrimental decision, or it's applying arbitrary business logic.\r\n\r\n> > Even with objects, you want to cache at the byte range level, as waiting to receive an entire object before caching/serving can only add latency. For example, an I-frame takes multiple round-trips to deliver (especially with packet loss), so don't want to wait to receive the entire frame before caching/serving it.\r\n> \r\n> I am not sure how was the conclusion reached here that the entirety of the object has be to received before serving downstream though. If an object is a I-Frame/GOP, the bytes/fragments come in and are sent to caching layer as fragments for building the cache for that object and also forwarded to all the subscribers in parallel as fragments. This issue for delivery mode doesn't affect that behavior in any way.\r\n\r\nThat was mostly from our old conversations around if objects are atomic. But I absolutely agree, relays should cache/forward streams.",
          "createdAt": "2023-09-17T03:50:16Z",
          "updatedAt": "2023-09-17T03:53:05Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "I just wanted to clarify though , caching is done for objects , however relay need not wait for the full object to arrive before forwarding to the subscribers ",
          "createdAt": "2023-09-17T14:38:20Z",
          "updatedAt": "2023-09-17T14:38:20Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> I just wanted to clarify though , caching is done for objects , however relay need not wait for the full object to arrive before forwarding to the subscribers\r\n\r\nThere's no distinction. If you can serve partial objects to existing subscribers (forwarding), then you can serve those partial objects to new subscribers too (caching). \r\n\r\nIn theory you could differentiate between existing and new subscribers, but that gets very complicated to implement and is detrimental when objects are not atomic (ex. GoP).\r\n\r\nYou might be talking about addressability, ie. you can't request a byte range within object. But the object cache itself is absolutely broken into a dynamic list of byte chunks.",
          "createdAt": "2023-09-17T16:28:40Z",
          "updatedAt": "2023-09-17T16:28:40Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "A object is the addressable entity from the moqt application perspective. How it gets delivered ( as chunks or fragments or few number of bytes) is lower layer transport level decision which is many times driven by MTu and other factors. Moqt applications ask for an object and they get it delivered. We should focus on whats the application model here ",
          "createdAt": "2023-09-18T02:44:08Z",
          "updatedAt": "2023-09-18T02:44:08Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "At IETF118 there was support to add explicit indicator for object model to transport mapping. \r\nPR #333 captures 2 proposals that were discussed during Boston interim.  \r\n\r\nplease review #333  and if there are suggestions o a totally different way to achieve the same results, please propose it here. ",
          "createdAt": "2023-11-08T15:12:36Z",
          "updatedAt": "2023-11-08T15:12:36Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "One thing missing from the discussion is ordering/reliability. The entire point of sending OBJECTs over specific streams is to utilize those properties so the application can decode in order. It's pointless to have stream mapping if OBJECTs can be reordered/dropped on those streams.\r\n\r\nAnyway, here's my proposals to round out the list:\r\n\r\n**Proposal 3 (implicit)**: Send objects in the same manner as they were received. \r\n**Proposal 4 (implicit==explicit):** Same as proposal 3 but add a `MoQ Stream ID` field to OBJECT.\r\n\r\nBut like I alluded to at the start, you need more than the Stream ID to be fully explicit. You also need signals to reproduce the ordering, gaps, and stream end. And all of a sudden you're reimplemented the QUIC STREAM frame.\r\n\r\nI'm a massive fan of implicit stream mapping. I don't think there's any other option.",
          "createdAt": "2023-11-08T16:16:31Z",
          "updatedAt": "2023-11-08T16:18:06Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@kixelated - I think it would be good to write down in the PR the details on implicit and cover how this works when a client switched from networks or there is an error and how it works with cached data. It may be all of this is easy but I want to get my head fully around it in trying to sort this out. ",
          "createdAt": "2023-11-08T16:30:11Z",
          "updatedAt": "2023-11-08T16:30:11Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> @kixelated - I think it would be good to write down in the PR the details on implicit and cover how this works when a client switched from networks or there is an error and how it works with cached data. It may be all of this is easy but I want to get my head fully around it in trying to sort this out.\r\n\r\nDo you want me to push directly to that PR?\r\n\r\nQUIC automatically handles network migration so you're talking about a hard disconnect. Something like going through a tunnel and triggering the idle timeout (ex. 10s).\r\n\r\nThe easy answer is that all streams are reset on connection loss. An application that uses long-lived streams will need to support multiple streams if they want to support reconnects. For example, if the catalog stream is reset due to connection loss, the new publisher can make a new stream with group += 1. You can still keep the ANNOUNCE/SUBSCRIBE alive, but any streams from the old publisher are reset.\r\n\r\nAttempting to resume a stream on a new connection is difficult to impossible, regardless of implicit versus explicit. The problem like I mentioned is gaps; if you're using a stream then the decoder expects objects to arrive in a specific order. \r\n\r\nThe old connection would have to use QUIC ACKs to guess which streams/objects were received just in case it crashes. However, ACKs doen't actually mean that the OBJECTs were actually flushed to the application. You could guess but we would likely have to add application ACKs (ex. OBJECT_OK) primarily for this feature. You would also need the relay to throw out duplicate objects because it may have already received an object but wasn't able to ACK it. Otherwise sending the same OBJECT twice over a stream is likely to break a decoder. It's a whole mess.",
          "createdAt": "2023-11-08T16:57:20Z",
          "updatedAt": "2023-11-08T17:44:31Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment:\r\n\r\nI have another proposal, which is is along the lines of @huitema 's idea from #270.  Combine the Proposal 2 Mode from the OBJECT wire format with the message type, and use a stream header to avoid repeating the same or potentially mismatched information.\r\n\r\neg:\r\n\r\nStreamPerObject:\r\nMessage = `OBJECT_STREAM` (same as OBJECT today -- eg no payload length)\r\n\r\nDatagram:\r\nThe same as `OBJECT_STREAM` but with no serialized type field (or add one if that's too \"implicit\")\r\n\r\nMulti Object Streams start with a stream header message and the fields that are constant across all objects on that stream.\r\n\r\nStreamPerGroup:\r\n~~~\r\nSTREAM_HEADER_GROUP {\r\n  TrackAlias\r\n  Group Sequence\r\n}\r\nSHORT_OBJECT_GROUP {\r\n  Object Sequence\r\n  Send Order\r\n  Payload Length\r\n  Payload\r\n}\r\n~~~\r\n\r\nWith similar constructs for StreamPerTrack and StreamPerPriority. The SHORT_OBJECT_* types are not serialized on the wire, it's inferred from the stream header. I will note this adds more flexibility than Proposal 2, eg a publisher could mix all 5 modes of object delivery in single track, though we could further restrict it if we wanted to.\r\n\r\nI wrote text for this proposal but wanted to pitch the idea here first.",
          "createdAt": "2023-11-08T22:51:32Z",
          "updatedAt": "2023-11-08T22:53:00Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Hmm, so there's some nuances to that proposal @afrind. Can `SHORT_OBJECT_GROUP` be reordered and/or dropped? Basically, what happens when sequence=3 has a higher sendOrder (lower priority) than sequence=4?",
          "createdAt": "2023-11-09T01:08:56Z",
          "updatedAt": "2023-11-09T01:08:56Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we need to take a step back and really ask ourselves what properties do we want from the transport. I'm worried that we're throwing solutions at the wall without analyzing the problem.\r\n\r\nAn application has live media that it needs to break into pieces. Mostly avoiding existing terminology for the moment, let's say we break a track into independent/streamable fragments which are then broken into chunks. Each fragment can have different modes:\r\n- **unreliable**: chunks MAY be dropped\r\n- **unordered**: chunks MAY arrive out of order\r\n- **framed**: chunks have boundaries\r\n\r\nAs a thought experiment, let's consider how an application would want to send a JSON catalog with (JSON) delta updates:\r\n- **independent**: New catalogs don't depend on old catalogs.\r\n- **reliable**: Delta updates can't be skipped.\r\n- **ordered**: Delta updates need to be applied in order.\r\n- **framed**: You can't concat two JSON objects together (without NDJSON).\r\n\r\nEach catalog would be a reliable/ordered/framed fragment in this scheme. The first chunk is the base JSON and each subsequent chunk is a JSON delta.\r\n\r\nHere's some possible use-cases for each type of fragment:\r\n| reliable | ordered | framed | example |\r\n|-|-|-|-|\r\n| yes | yes | yes | frames in decode order (without container) |\r\n| yes | yes | no | frames in decode order (with container) |\r\n| yes | no | yes | chat messages with best-effort ordering? |\r\n| yes | no | no | none |\r\n| no | yes | yes | lossy frames in decode order |\r\n| no | yes | no | self-repairing codec? |\r\n| no | no | yes | lossy frames in arbitrary order |\r\n| no | no | no | none |\r\n\r\nNote that sending a single chunk per fragment is the same for all modes. This is what RUSH currently does and it uses a  reassembly buffer to reorder. However, it would be neat if MoqTransport could perform that reordering via unreliable/ordered delivery, so the decoder could read in order by skip over any holes (ex. drop b-frames during congestion). ",
          "createdAt": "2023-11-09T03:51:00Z",
          "updatedAt": "2023-11-09T03:54:16Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Okay cool, but this concept is kind of useless unless we can actually implement it. Here's what is possible in draft-01:\r\n\r\n| reliable | ordered | framed | stream per | objects |\r\n|-|-|-|-|-|\r\n| yes | yes | no | fragment | one (unsized) |\r\n| no | no | yes | chunk  | one (unsized) |\r\n\r\nThe rest are not guaranteed due to the lack of a stream mapping. A relay can decide to reorder/drop/move OBJECTs on a whim. The only way to achieve guaranteed behavior is to use a single, unsized object per stream so the relay can't coalesce them. I think we all agree that this is a problem.\r\n\r\nLet's start with the easy proposal (3). Implicit mapping means the relay is not allowed to change the contents of a QUIC stream and all OBJECTs are delivered in the same position.\r\n\r\n| reliable | ordered | framed | stream per | objects |\r\n|-|-|-|-|-|\r\n| yes | yes | yes | fragment | per chunk |\r\n| yes | yes | no | fragment | one |\r\n| no | no | yes | chunk | one |\r\n\r\nYou can now send multiple OBJECTs on the same stream and have them reliably delivered (ex. catalog). But if you to do more complex stuff, like unreliable/ordered (ex. lossy frames in decode order) then you still need to perform reassembly in the application.\r\n\r\nThe problem with Alan's `StreamPerGroup` proposal is that it's unclear if chunks are reliable/ordered. If they are, then you don't need `sendOrder` or even `sequence` per `SHORT_OBJECT_GROUP`. If they're not, then it's ambiguous.\r\n\r\nBut what about taking that proposal a step further and explicitly include the reliable/ordered flags in the `STREAM_HEADER_GROUP`. There would always be a stream per fragment with at least one chunk. This would allow:\r\n\r\n| reliable | ordered | framed | relay can |\r\n|-|-|-|-|\r\n| yes | yes | yes | proxy only |\r\n| yes | yes | no | proxy only |\r\n| yes | no* | yes | reorder chunks |\r\n| no* | yes | yes | drop chunks |\r\n| no* | no* | yes | drop/reorder chunks |\r\n\r\nThe giant caveat here is that any dropping/reordering within a stream can only be performed at the MoqTransport layer. All chunks are reliable/ordered via QUIC streams, but the relay MAY drop chunks if there's sufficient back-pressure (like TCP low-watermark).\r\n\r\nHowever if latency is important, then you shouldn't perform reliable/ordered delivery in QUIC and then pretend like it unreliable/unordered in the MoQ layer. This is actually one of my complaints with SCTP; it gives the application the ability to specify unordered/unreliable delivery on a per-message basis but it's a facade.\r\n\r\nI don't think we should include reliable/unordered or unreliable/ordered messages on a QUIC stream because it's a foot gun. QUIC just doesn't work like that. Despite our object model, OBJECTs are not actually the unreliable/unordered unit, it's actually a QUIC stream and we have to remember that.",
          "createdAt": "2023-11-09T04:02:04Z",
          "updatedAt": "2023-11-09T04:07:35Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment:\r\n\r\nI think it's interesting to consider where reorderable and droppable properties fit in the object model, but I think we can tackle the problems separately and make incremental progress.  My proposal takes the draft-01 \"implicit\" signal and makes it explicit and more compact, without changing anything else.",
          "createdAt": "2023-11-09T07:06:17Z",
          "updatedAt": "2023-11-09T07:06:17Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "unfortunately draft-01 as-is implemented wasn't implicit or explicit  as shown cleary during interop. ",
          "createdAt": "2023-11-09T10:55:58Z",
          "updatedAt": "2023-11-09T10:55:58Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "> unfortunately draft-01 as-is implemented wasn't implicit or explicit as shown cleary during interop.\r\n\r\nSure, my point is that the implicit signal exists whether you read/use it or not, and this explicit scheme conveys equivalent information. ",
          "createdAt": "2023-11-09T12:59:13Z",
          "updatedAt": "2023-11-09T12:59:13Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> _OBJECT_* types are not serialized on the wire, it's inferred from the stream header. I will note this adds more flexibility than Proposal 2, eg a publisher could mix all 5 modes of object delivery in single track, though we could further restrict it if we wanted to.\r\n\r\nin this case, I wonder if flexibility will come bit us.  I need to think a bit more though ..",
          "createdAt": "2023-11-09T13:20:27Z",
          "updatedAt": "2023-11-09T13:20:27Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "I feel we are over complicating the issue at hand by mixing different things. Let me share my thinking and see if I messed it up\r\n\r\n- Every object carries an indicator for priority(sendOrder).  Relay application is the one that uses this field to make forward or drop decisions and not the transport mapping and hence not scoped to this issue IIUC\r\n\r\n- Proposal 2 (and even Proposal 1)  carries a 3 bit value in every object that indicates how a object needs to be transported. When the same object is replayed from cache the same rule applies since the object header has the necessary indicator.  This mapping is what this issue is all about. \r\n\r\nApplications know what treatment they need from the transport and they need a way to indicate their intention to the moq layer and this issue is about helping build that abstraction. For applications who don't know what to do , the draft needs to specify the reasonable default.\r\n\r\n",
          "createdAt": "2023-11-09T13:27:07Z",
          "updatedAt": "2023-11-09T13:27:43Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed offline with Suhas:\r\n\r\nIn Proposal 3, every Object has the forwarding preference, but in some modes it is \"compressed\" on the wire by including a stream header.  From an API perspective, publishers would publish objects with a mode and subscribers would receive objects with a mode, like Proposal 2.",
          "createdAt": "2023-11-09T14:18:02Z",
          "updatedAt": "2023-11-09T14:18:02Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I've thought about this for a bit, and I think I'm also a fan of \"explicit-implicit\" design. What I mean by this is that we formally define a way to describe the object placement (that is used in the APIs and can be serialized into the cache), but we don't actually send most of it on the wire since it's redundant (a \"compression\" of sorts).",
          "createdAt": "2023-11-09T16:23:40Z",
          "updatedAt": "2023-11-09T16:23:40Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh, and to be clear, I think Christian and Alan's stream header is absolutely the correct direction. My rambling is only because the presence of `sendOrder` implies that objects on a stream are not reliable/ordered.\r\n\r\n**Controversial take:** For all of these stream mapping proposals, OBJECTs on a stream MUST be delivered in reliably and in order. \r\n\r\nWhy? Well the entire point of mapping objects to streams is to get these properties. If a relay is allowed to arbitrarily reoreder or drop OBJECTs within a stream, then we're right back to where we started without stream mapping.\r\n\r\nFor example, we want to produce a catalog with an OBJECT for each delta. These objects are placed on the same stream so the decoder doesn't need to implement a reassembly buffer or detect gaps.\r\n\r\n```\r\nstream: base delta1 delta2 delta3 delta4\r\n```\r\n\r\nIf we allow a relay to drop or reorder objects on the same stream for whatever reason, then this is possible:\r\n```\r\nstream: delta1 base delta4 delta2\r\n```\r\n\r\nFor anybody who implemented moq-clock this week, I'm sure this looks familiar. It's what you get with a stream per OBJECT, stream mapping actually served no purpose.\r\n\r\nI can live with flag indicating that objects on a stream are potentially unreliable/unordered, but I do caution that QUIC streams are reliable/ordered by nature. If an application wants unreliable or unordered OBJECTs within a stream, it's possible but head-of-line blocking will limit the upside. These objects really should be sent over a dedicated stream or datagram instead.",
          "createdAt": "2023-11-10T02:40:54Z",
          "updatedAt": "2023-11-10T03:08:06Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@kixelated if multiple objects are sent on a single stream, they are by definition delivered reliably and in order. Why do you think that they would not be?",
          "createdAt": "2023-11-10T03:34:17Z",
          "updatedAt": "2023-11-10T03:34:17Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> @kixelated if multiple objects are sent on a single stream, they are by definition delivered reliably and in order. Why do you think that they would not be?\r\n\r\nOBJECTs on a stream are reliable/ordered over QUIC, but do we agree that they're reliable/ordered at rest too? Basically a relay MUST transmit OBJECTs in the same manner as they arrived.",
          "createdAt": "2023-11-10T04:13:23Z",
          "updatedAt": "2023-11-10T06:08:21Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment: \r\n\r\nThe different send order on the same stream is covered in issue #105, and I don't think we need to resolve that before we  address the basic transport mapping.",
          "createdAt": "2023-11-10T12:38:10Z",
          "updatedAt": "2023-11-10T12:38:10Z"
        }
      ]
    },
    {
      "number": 245,
      "id": "I_kwDOG2Ho4M5wpB3k",
      "title": "Subscription Hints ",
      "url": "https://github.com/moq-wg/moq-transport/issues/245",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "suhasHere"
      ],
      "labels": [
        "Needs PR",
        "Subscribe"
      ],
      "body": "Subscribers needs a way to hint the publishers on when do they have the want the objects to delivered to them within the requested track. This is needed in case due to the fact that different media types can be handled differently by the application ( audio can be delivered to the application immediately,  video needs some form of key-frame to have the best experience or something more specific that the application wants )\r\n\r\nIn that effect , i want to propose an **experimental** extension to the Track Request Parameters called \"SubscriptionHint\" with the following variants.\r\n\r\n* latest (0):\r\nThe \"latest\" subscription hint identifies delivery of the objects for the\r\nrequested track to begin from the most recent group and object sequence.\r\n\r\n* catchup (1):\r\nThe \"catchup\" subscription hint identifies delivery of the objects for the\r\nrequested track from the beginning of the group provided in the GroupSequence track request param. \r\n\r\n* waitup(2): \r\nThe \"waitup\" subscription hint identifies delivery of the objects for the\r\nrequested track  from the beginning of the new group.\r\n\r\n\r\n",
      "createdAt": "2023-09-11T06:57:41Z",
      "updatedAt": "2023-10-23T18:19:16Z",
      "closedAt": "2023-10-23T18:19:16Z",
      "comments": [
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One of the reason this is key, is often a client is doing a subscribe to a track with a different bandwidth because there is not enough bandwidth for the current track. ( the case where a client is receiving a high bandwidth track, and wants to move a low bandwidth track of the same stuff ). In this case, there is already congestion happening and the client wants to move to the new track quickly without making the congestion worse. Hints along the lines of this really help in this critical case. ",
          "createdAt": "2023-09-22T21:40:56Z",
          "updatedAt": "2023-09-22T21:40:56Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Oof yeah this is a difficult problem that we need to solve.\r\n\r\n### Goal:\r\n* A new player can start X seconds behind the live playhead, where X is the target size of the jitter buffer.\r\n    * Real-time will set this to 0.\r\n* An existing player  can switch between tracks at timestamp Y. (@fluffy's example)\r\n\r\n### Problem:\r\n* Neither the player nor the relay knows the mapping from group <-> timestamp.\r\n* Tracks might not have aligned groups; different offsets, frequencies, boundaries, etc.",
          "createdAt": "2023-09-22T22:39:37Z",
          "updatedAt": "2023-09-22T22:39:37Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "My issue with this proposal is that (0) latest and (2) waitup are based on the relay's cache and are extremely racey. The assumption is that the relay always has the latest group/object in cache. The reality is that it often won't, nor does it even know what the \"latest\" group is supposed to be.\r\n\r\nFor example: A player is subscribed to 720p and encounters congestion after `group=7`. It wants to subscribe to 360p and it has three choices:\r\n\r\n### (0) SUBSCRIBE 360p latest \r\n* **If the latest object in cache is `group=7 object=49`**, then we receive some undecodable objects until `group=8` starts. It's wasteful and exacerbate congestions, but hopefully for not too long.\r\n* **If the latest object in cache is `group=8 object=5`**, then `group=8` is undecodable and and playback stalls until `group=9` is generated in a few seconds (oof).\r\n* **If there's no cache**, we could forward the SUBSCRIBE upstream with the `latest` and run into either of the two above scenarios. Note: the upstream may have it's own cache; it won't necessarily be the origin.\r\n* **If there's a partial cache**, the \"latest\" object might actually be in the past. For example, another subscriber issued a SUBSCRIBE for `group=6` 100ms ago, so our latest in cache might be `group=6 object=30`. We incorrectly start delivering at `group=6 object=30` and exacerbate congestion. (oof)\r\n\r\nNote that there's no way for a relay to know when it's transitioned from a partial cache (not caught up to live playhead) to a full cache (caught up to live playhead). Issuing two separate subscriptions, one for each mode, would be the only option, but that would temporarily double bandwidth usage (bad for first hop in particular).\r\n\r\n### (1) SUBSCRIBE 360p catchup 8\r\nThis works the best because it doesn't depend on what is in the relay's cache. It knows to always start at `group=8`.\r\n\r\nHowever this requires groups to be aligned across different tracks (ex. HLS). If 720p `group=8` does not correspond to 360p `group=8`, then this isn't an option. It's also not an option for startup since the player doesn't know the latest group number.\r\n\r\nThe player needs to somehow know which timestamps correspond to which group for each track.\r\n\r\n### (2) SUBSCRIBE 360p waitup\r\n* **If the latest object in cache is `group=7 object=49`**, then we correctly wait until `group=8` starts.\r\n* **If the latest object in cache is `group=8 object=5`**, then playback stalls until  `group=9` is generated in a few seconds (oof).\r\n* **If there's no cache**, we could forward the SUBSCRIBE to the upstream and run into either of the two above scenarios. Note: the upstream may have it's own cache; it won't necessarily be the origin.\r\n* **If there's a partial cache**, the \"latest\" object might actually be in the past. For example, another subscriber issued a SUBSCRIBE for `group=6` 100ms ago, so our latest in cache might be `group=6 object=30`. We incorrectly start delivering at `group=7` and exacerbate congestion. (oof)\r\n\r\nBasically the same problems as (0), but on the other side of the coin flip.",
          "createdAt": "2023-09-22T23:10:58Z",
          "updatedAt": "2023-09-22T23:30:49Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "That was a wall of text; hopefully I explained it well enough.\r\n\r\nLike I said initially, the fundamental issue is that neither the player nor the relay know the mapping from group <=> timestamp. What if we resolved that?\r\n\r\n# Proposal: Relay knows timestamp <=> group mapping\r\n* `OBJECT` contains a timestamp field\r\n* `SUBSCRIBE` contains a relative/absolute timestamp.\r\n* `UNSUBSCRIBE` contains an optional timestamp for graceful termination.\r\n\r\n\r\nThis suffers from some rounding/alignment issues but it's fine. Relative timestamp requests are also problematic with partial caches.\r\n\r\n# Proposal: Player knows timestamp <=> group mapping\r\n* `/timeline` track contains group/timestamp pairs.\r\n* `SUBSCRIBE` contains start group and optional end group.\r\n* `UNSUBSCRIBE` contains optional end group for graceful termination.\r\n\r\nThis is absolutely the best option for relays. It knows what groups are missing in the cache and can fill them on request. It also means the relay can have multiple SUBSCRIBE requests upstream for the same track without fear of duplication.\r\n\r\nThe problem is that the media protocol needs to produce a live group listing kinda like HLS. This incurs an extra RTT on startup, although it's super useful for seeking backwards and DVR.",
          "createdAt": "2023-09-22T23:23:39Z",
          "updatedAt": "2023-09-22T23:23:39Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think there are scalability and flexibility benefits to keeping relays agnostic to time and in fact to any internal characteristics of the objects they are serving. Keeping them decoupled allows the content to change (and the complete timing mechanism if so desired), without having to change the relay networks.\r\n\r\nThe introduction of relay\u2019s requiring timestamp knowledge stems from the original assertion that `Neither the player nor the relay knows the mapping from group <-> timestamp.` I think this need not be true. We can teach players the relationship between group and timestamp without too much difficulty. We do this all the time with HLS and DASH. In both cases the HTTP servers delivering these formats know nothing about the relationship between segments and time, yet we are able to build players which seek to precise points in a stream.\r\n\r\nWe can do something similar with our streaming formats and the ideas already presented in this thread by Suhas and Luke. One difference is that I would make would be to allow the group offset described by Suhas to be either an absolute or relative one. As a proposal, what if the WARP catalog listed two things:\r\n1.\tThe GROUP duration in milliseconds. \r\n2.\tThe name of a track which described GROUP number/timestamp pairs (exactly the track suggested by Luke above). We assume that this timeline track allows delta updates, perhaps describing the complete DVR window every minute at a group boundary, with incremental updates in between. \r\n\r\nUse cases:\r\n1.\t**Start as close to the live edge as possible**\r\na.\tSince the last group represents the last independently accessible point in the stream, the player would issue a plain SUBSCRIBE \r\nb.\tThe relay would serve content starting with the last group it has cached (its default behavior).\r\nc. If the relay does not have this content cached, and there is no pending subscription, then it would issue its own SUBSCRIBE upstream. \r\n2.\t**Start with a 5s buffer**\r\na.\tThe player would calculate how many group\u2019s it would need to guarantee a 5s buffer. Assuming the advertised group duration was 2000, then it would need 3 groups. Using zeroth based relative group addressing, it would issue SUBSCRIBE (-2). \r\nb.\tThe relay would serve from the 3rd last group that it had cached. \r\nc. If the relay does not have the content cached, it would send its own SUSBCRIBE(-2) upstream. If it has an open subscription, but has only received 2 groups, then it should wait for the 3rd before responding. \r\n4.\t**Seek to a wall clock time of T seconds**\r\na.\tThe player would subscribe to the /timelines track, using SUBSCRIBE so that it receives the last full DVR description.\r\nb.\tBased on the data in the timeline track, the player calculates that it needs a group number of 5321. It issues a SUBSCRIBE(5321).\r\nc.\tThe relay recognizes that this is an absolute reference to a GROUP (as all relative ones are negative) and returns content starting at GROUP #5321.\r\n5. **Player encounters congestion at group 53 on 720p and wants to switch to 360p track**\r\na. WARP places the packaging restriction that group numbers across tracks must carry the same media time offset (it actually has this requirement already)\r\nb. The player knows it was playing group 53 when it encountered slowness. Its next chance for a switch will be at a group boundary. Since it knows the group duration from the catalog, it can decide whether it is better off waiting for the next group, or reloading from the same group. In this case it is near the end of the group, so it decides to fetch the next group.\r\nc. It issues a SUBSCRIBE (54) for the 360p track and a UNSUBSCRIBE(53) for the 720p. \r\n\r\nCheers\r\nWill\r\n",
          "createdAt": "2023-09-23T11:15:30Z",
          "updatedAt": "2023-09-23T11:15:30Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Absolutely @wilaw \r\n\r\nThe main difficulty with relative requests is deduplication: a relay has trouble merging subscriptions that use absolute and relative groups when the cache is empty.\r\n\r\nex.\r\nSUBSCRIBE 480p -3\r\n(50ms delay)\r\nSUBSCRIBE 480p 351\r\n\r\nThe relay doesn't know if the existing upstream subscription (-3) will fulfill both. In fact the relay doesn't know if 351 is even remotely close; it could be a group from minutes/hours ago. We don't want to download the same objects twice, but maybe that's okay when the cache is empty?\r\n\r\nI think we either:\r\n1. only use only absolute groups or\r\n2. add a way to OR an existing SUBSCRIBE ",
          "createdAt": "2023-09-23T16:03:07Z",
          "updatedAt": "2023-09-23T16:03:07Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Thinking about it some more.\r\n\r\nIf the player only knows the duration of each group (fixed), then it could use relative timestamps, but it's still a massive headache for the relay.\r\n\r\nSuppose two SUBSCRIBES from separate viewers:\r\n\r\n```\r\nSUBSCRIBE 0 6328\r\nSUBSCRIBE 0 -3\r\n```\r\n\r\nA relay with an empty cache issues the `SUBSCRIBE 6328` upstream. It starts getting some OBJECTs: `6328 6329 6330`. And then it gets a `SUBSCRIBE -3` from a viewer.\r\n\r\nIt would be an error to serve those three objects from cache. Why? Who knows if they were the latest three or from an hour ago.\r\n\r\nThe relay could hypothetically augment the existing upstream subscription: `SUBSCRIBE 0 6328 OR -3`. However, it still doesn't know which groups correspond to -3. No additional objects would be sent if 6330 actually was the live playhead, and the relay wouldn't know where to start the -3 subscribe.\r\n\r\nIMO the relay needs a way of converting relative groups to absolute groups for this to work. Maybe SUBSCRIBE_OK contains that translation? ex. `-3 is 6345`. It's still complicated though.",
          "createdAt": "2023-09-23T16:29:07Z",
          "updatedAt": "2023-09-23T16:29:40Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Who knows if they were the latest three or from an hour ago.\r\n\r\nYou're indeed right. This the fatal weakness of the relative request approach. If the relay has the latest group cached and an active subscription, it works fine, but the player can never be sure of that and the relay can never disambiguate fresh from stale content. \r\n\r\n> IMO the relay needs a way of converting relative groups to absolute groups for this to work.\r\n\r\nIf the relay can do that translation, then why couldn't the player do the same and just request an absolute group to begin with?\r\n\r\nWhat are some solutions to this problem?\r\n\r\n1. Players always make absolute requests. Here are two ways to do this:\r\na. The catalog instructs the player in how to calculate the group number for any given time, for example, via a start time and then modulus the group duration. To avoid players having to have an accurate clock, the SETUP response from the server could echo back the current time. This is essentially a DASH approach to timing. \r\nb. The player subscribes to the /timeline track which describes the wallclock time and media time associated with the start of each group. This is similar to an HLS approach and has the downside of requiring 1xRTT before starting to discover the latest group. It has an advantage that it can describe groups of varying duration and \r\n\r\n2. Each group carries a timestamp in its header indicating the UTC time at which it was produced. This is not violating any decoupling of relays and payload because the time of production is core characteristic of any payload and is independent of the internal media time. With these timestamps in place, the relay can judge freshness. A player can issue SUBSCRIBE (-5) which means gives me this track starting with any group whose timestamp T > (now -5). We could also consider SUBSCRIBE (from: 1695571105212), which would require the player to have an accurate clock (although SETUP could be used to address that). Note that this scheme also works for DVR seeking if the player knows how to translate group number to UTC time. \r\n\r\n4. Same as [2] except that we add both a media timestamp and a UTC timestamp to each group. This gives the flexibility to ask relays to begin subscriptions at both media time offset and absolute and relative UTC offsets. The downsides are that it binds moq-transport to internal properties of payloads. One way round this is in core moq-transport we can specify two \"index fields\" in the header of each group. These fields must be numeric and monotonically increasing. Relays don't know that these fields represent, however they can service subscription requests that reference them. The streaming format would then bind index A to UTC time and index B to media time. Other formats may bind different attributes, but all could still work with generic relays.\r\n\r\nAfter writing these out , I'm in favor of [3] with generic indexes. \r\n\r\n\r\n\r\n",
          "createdAt": "2023-09-24T16:34:05Z",
          "updatedAt": "2023-09-24T16:34:05Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> > IMO the relay needs a way of converting relative groups to absolute groups for this to work.\r\n> \r\n> If the relay can do that translation, then why couldn't the player do the same and just request an absolute group to begin with?\r\n\r\nYeah exactly.\r\n\r\nUTC timestamps get annoying because of clock synchronization. It's also annoying because the player has to know the latency to the origin; requesting media that was generated 200ms ago results in a very different experience if the origin is 10 miles away versus 10k miles away.\r\n\r\nI like the idea of delegating the group <=> timestamp mapping to the application. The catalog could contain a formula (like DASH) or it could maintain a /timeline track. That being said, we still run into the same issue; how are you supposed to request the latest group in the /timeline track? Do you always request `group=0`? And is `object=32` the latest, or do you need to wait until you receive the full /timeline?\r\n\r\nI think there's a missing piece. If I were to implement this in HTTP, I would make a GET request with an ETAG to get the latest group/object sequence. There's no equivalent in MoQ which is problematic. I think we still need relative group requests, but the relays need an authoritative source somehow; it can't decide what is \"latest\" from cache.",
          "createdAt": "2023-09-24T21:24:54Z",
          "updatedAt": "2023-09-24T21:25:36Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> The assumption is that the relay always has the latest group/object in cache. The reality is that it often won't, nor does it even know what the \"latest\" group is supposed to be.\r\n\r\nI think that's not what it meant. By \"latest\", relays starts delivering whatever it has in the cache as the most recent group/object  and it doesn't need to remember anything about it other than they happen to be in cache. \"waitup\" is saying given everything once you get objects from current group +1.",
          "createdAt": "2023-09-25T03:13:09Z",
          "updatedAt": "2023-09-25T03:13:09Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think there are scalability and flexibility benefits to keeping relays agnostic to time and in fact to any internal characteristics of the objects they are serving. Keeping them decoupled allows the content to change (and the complete timing mechanism if so desired), without having to change the relay networks.\r\n> \r\n> The introduction of relay\u2019s requiring timestamp knowledge stems from the original assertion that `Neither the player nor the relay knows the mapping from group <-> timestamp.` I think this need not be true. We can teach players the relationship between group and timestamp without too much difficulty. We do this all the time with HLS and DASH. In both cases the HTTP servers delivering these formats know nothing about the relationship between segments and time, yet we are able to build players which seek to precise points in a stream.\r\n> \r\n> We can do something similar with our streaming formats and the ideas already presented in this thread by Suhas and Luke. One difference is that I would make would be to allow the group offset described by Suhas to be either an absolute or relative one. As a proposal, what if the WARP catalog listed two things:\r\n> \r\n> 1. The GROUP duration in milliseconds.\r\n> 2. The name of a track which described GROUP number/timestamp pairs (exactly the track suggested by Luke above). We assume that this timeline track allows delta updates, perhaps describing the complete DVR window every minute at a group boundary, with incremental updates in between.\r\n> \r\n> Use cases:\r\n> \r\n> 1. **Start as close to the live edge as possible**\r\n>    a.\tSince the last group represents the last independently accessible point in the stream, the player would issue a plain SUBSCRIBE\r\n>    b.\tThe relay would serve content starting with the last group it has cached (its default behavior).\r\n>    c. If the relay does not have this content cached, and there is no pending subscription, then it would issue its own SUBSCRIBE upstream.\r\n> 2. **Start with a 5s buffer**\r\n>    a.\tThe player would calculate how many group\u2019s it would need to guarantee a 5s buffer. Assuming the advertised group duration was 2000, then it would need 3 groups. Using zeroth based relative group addressing, it would issue SUBSCRIBE (-2).\r\n>    b.\tThe relay would serve from the 3rd last group that it had cached.\r\n>    c. If the relay does not have the content cached, it would send its own SUSBCRIBE(-2) upstream. If it has an open subscription, but has only received 2 groups, then it should wait for the 3rd before responding.\r\n> 3. **Seek to a wall clock time of T seconds**\r\n>    a.\tThe player would subscribe to the /timelines track, using SUBSCRIBE so that it receives the last full DVR description.\r\n>    b.\tBased on the data in the timeline track, the player calculates that it needs a group number of 5321. It issues a SUBSCRIBE(5321).\r\n>    c.\tThe relay recognizes that this is an absolute reference to a GROUP (as all relative ones are negative) and returns content starting at GROUP #5321.\r\n> 4. **Player encounters congestion at group 53 on 720p and wants to switch to 360p track**\r\n>    a. WARP places the packaging restriction that group numbers across tracks must carry the same media time offset (it actually has this requirement already)\r\n>    b. The player knows it was playing group 53 when it encountered slowness. Its next chance for a switch will be at a group boundary. Since it knows the group duration from the catalog, it can decide whether it is better off waiting for the next group, or reloading from the same group. In this case it is near the end of the group, so it decides to fetch the next group.\r\n>    c. It issues a SUBSCRIBE (54) for the 360p track and a UNSUBSCRIBE(53) for the 720p.\r\n> \r\n> Cheers Will\r\n\r\n+1 on keeping the relays not aware of media characteristics. Since its complex and may not apply the same way to all the types of media getting transported (live vs dvr vs chat vs catalog vs something new).\r\n\r\n+1 to keep players aware of mapping from media time to group number. I would be interested in knowing where this will not work though.  I agree with Will that the warp catalog can specify the needed relationship here\r\n\r\nAlso the susbcribe message today has \"Group/Object Id\" in its track request parameters. I would proposes merging Will's usecases (2) and (3) into \r\n    - given a Time T, find the group number you want to start fetching the media \r\n    - Issue a subscribe with that group number\r\n    - Relay can decide if the requsted group number is behind or ahead of the current group and if it is in cache serve them accordingly\r\n    Basically i think we don't need offset. But would love to hear from @wilaw  where we can't do away with absolute groups",
          "createdAt": "2023-09-25T03:21:06Z",
          "updatedAt": "2023-09-25T03:21:06Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> how are you supposed to request the latest group in the /timeline track? Do you always request `group=0`? And is `object=32` the latest, or do you need to wait until you receive the full /timeline?\r\n\r\nWe need to be clear on the term latest. In my proposal of Subscription Hints \"Latest\" is in terms of latest in the cache. So if the cache is current running group-45, object-32, then that's the latest.  And waitup is , wait until you see group number change before giving me objects.\r\n\r\nI think with the hints listed, group_id & object_id being in the track request parameters and player providing the mapping function from timeline to group, we can address most of the use-cases being raised here.  I would interested to learn what use-cases cannot be addressed with the proposed scheme",
          "createdAt": "2023-09-25T03:26:19Z",
          "updatedAt": "2023-09-25T03:26:19Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> > how are you supposed to request the latest group in the /timeline track? Do you always request `group=0`? And is `object=32` the latest, or do you need to wait until you receive the full /timeline?\r\n> \r\n> We need to be clear on the term latest. In my proposal of Subscription Hints \"Latest\" is in terms of latest in the cache. So if the cache is current running group-45, object-32, then that's the latest. And waitup is , wait until you see group number change before giving me objects.\r\n\r\nCan you give an example using the \"latest\" mode? Would you use it for playback start or switching between tracks or both?\r\n\r\nAs I understand, groups are independent but objects are not. `group=45 object=32` would be a P-frame or catalog delta. I don't understand why you would ever want to start your subscription at an undecodable object. Starting at `group=45 object=0` or `group=46 object=0` would work, but never `group=45 object=32`.",
          "createdAt": "2023-09-25T04:04:35Z",
          "updatedAt": "2023-09-25T04:18:54Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> Starting at `group=45 object=0` or `group=46 object=0` would work, but never `group=45 object=32`.\r\n\r\nFor the video delivery case, I would use \"waitup\" if i have no idea what the current group is. Since it will start delivery the objects from the beginning of the next group. I would use latest for audio use-case where the `group=45 object=32` is fine for me to either render or conceal. \r\n\r\nAgain we can enumerate the use-cases we want to address and I am happy to share my thinking around how the hints help. As part of exercise , we may come out deciding if we need more granular things than what is being proposed here.\r\n\r\n@kixelated could you please share one liner for the use-cases you have been considering from a subscribe perspective ?",
          "createdAt": "2023-09-25T05:25:01Z",
          "updatedAt": "2023-09-25T05:25:01Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I think that's not what it meant. By \"latest\", relays starts delivering whatever it has in the cache as the most recent group/object and it doesn't need to remember anything about it other than they happen to be in cache.\r\n\r\nThe key point we're forgetting in the freshness quandary (or perhaps it is implicit) is that the _relay knows whether it has an open subscription for a given track_. This is a key bit of information. If it does have an open subscription, then the objects it has in cache are by definition the latest, and hence any 'relative' or 'latest' queries can be satisfied. If it does not have an open subscription, then it cannot make any determination about the freshness of any objects, even if it has some in cache and it must renew its subscription before responding. \r\n\r\nTo illustrate this, consider a relay which has groups 637,638,639 in cache.  Five minutes later another client joins issues a SUBSCRIBE (latest). The response of the relay should be different in the two cases below:\r\n\r\n* It has an open subscription for that track - in this case it knows that those are still the latest objects available for that track and so it would return 639\r\n* It does not have an open subscription for that track (because the prior client that subscribed went away) - in this case the relay must make a SUBSCRIBE(latest) request upstream and return the first group it receives (perhaps 763) to the client.\r\n\r\n> But would love to hear from @wilaw where we can't do away with absolute groups\r\n\r\nThe advantage of relative requests is that the player does not need any understanding of the relationship between group number and time. This makes for simple players, as long as they don't need to seek behind live with any accuracy. The relative datum, in this case the \"live edge\", is constantly changing, and for players that need to seek back accurately this can be a problem. Depending on when you make your request and how long it is queued by intermediaries, you may get two different answers. Absolute groups make precise group selection for more deterministic and are robust. For live-only players (such as the web meeting use case), we probably could get by with relative addressing alone. However since our charter includes intermediate and higher levels of latency, we should design moq-transport such that it is flexible enough to handle both relative and absolute group addressing. \r\n",
          "createdAt": "2023-09-25T10:57:26Z",
          "updatedAt": "2023-09-25T11:06:51Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> * It does not have an open subscription for that track (because the prior client that subscribed went away) - in this case the relay must make a SUBSCRIBE(latest) request upstream and return the first group it receives (perhaps 763) to the client.\r\n\r\nif there are no upstream subscriptions active and hence no published data is being received , then there are couple of things to note\r\n1. What's in the cache is the current source of truth and it needs to be served \r\n2. yes Relay may forward the subscription upstream and feed the data that arrives towards the subscriber ( and also add it to the cache)\r\n\r\nThis will keep \"latest\" property preserved. Players need to handle gaps that might be caused for several reasons including relay cache purges, publisher going away/reconnecting, subscribers loosing state, relay reboots. I see these as player level details and not specific to moqt. Isn't it ?",
          "createdAt": "2023-09-25T16:29:32Z",
          "updatedAt": "2023-09-25T16:33:49Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> What's in the cache is the current source of truth and it needs to be served\r\n\r\nIt's not a source of truth at all. It may be 5 minutes old or 50 minutes old. Without the active subscription, there is no guarantee about its status at all other than it was previously served to some client and hasn't yet fallen out of cache. Why would a client wanting \"latest\" want that and if it was sent, how would the client know that it wasn't the latest. It would start rendering and then jump ahead when the true latest content arrived . If you need a subscription-hint for give-me-anything-in-your-cache-not-matter-how-old-it-is, we can create that, but thats different from \"latest\" and I'm not clear on its utility. ",
          "createdAt": "2023-09-25T16:46:34Z",
          "updatedAt": "2023-09-25T16:46:34Z"
        },
        {
          "author": "englishm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > I think that's not what it meant. By \"latest\", relays starts delivering whatever it has in the cache as the most recent group/object and it doesn't need to remember anything about it other than they happen to be in cache.\r\n> \r\n> The key point we're forgetting in the freshness quandary (or perhaps it is implicit) is that the _relay knows whether it has an open subscription for a given track_. This is a key bit of information. If it does have an open subscription, then the objects it has in cache are by definition the latest, and hence any 'relative' or 'latest' queries can be satisfied. If it does not have an open subscription, then it cannot make any determination about the freshness of any objects, even if it has some in cache and it must renew its subscription before responding.\r\n> \r\n> To illustrate this, consider a relay which has groups 637,638,639 in cache. Five minutes later another client joins issues a SUBSCRIBE (latest). The response of the relay should be different in the two cases below:\r\n> \r\n> * It has an open subscription for that track - in this case it knows that those are still the latest objects available for that track and so it would return 639\r\n> * It does not have an open subscription for that track (because the prior client that subscribed went away) - in this case the relay must make a SUBSCRIBE(latest) request upstream and return the first group it receives (perhaps 763) to the client.\r\n> \r\n\r\nThis is good insight and I think the proposed behavior makes good sense.\r\n\r\n> > But would love to hear from @wilaw where we can't do away with absolute groups\r\n> \r\n> The advantage of relative requests is that the player does not need any understanding of the relationship between group number and time. This makes for simple players, as long as they don't need to seek behind live with any accuracy. The relative datum, in this case the \"live edge\", is constantly changing, and for players that need to seek back accurately this can be a problem. Depending on when you make your request and how long it is queued by intermediaries, you may get two different answers. Absolute groups make precise group selection for more deterministic and are robust. For live-only players (such as the web meeting use case), we probably could get by with relative addressing alone. However since our charter includes intermediate and higher levels of latency, we should design moq-transport such that it is flexible enough to handle both relative and absolute group addressing.\r\n\r\nIn particular, I would like to see MoQ also support some improvements for DVR or even VoD playback, for example: faster frame-accurate seeking. We don't necessarily need the protocol to provide a complete implementation, but having the ability to absolutely address groups would be especially useful in that context. One concern I have about adding timestamps into the mix is in how they would apply to content being played back at arbitrary points in time relative to the original recording time.",
          "createdAt": "2023-09-26T13:24:35Z",
          "updatedAt": "2023-09-26T13:24:35Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Here's my current thought.\r\n\r\n* SUBSCRIBE can contain a relative or absolute start group.\r\n   * A bit flag is used to specify if it's an absolute or relative request.   \r\n   * N means serve group N and onwards\r\n   * +1 means serve the next latest group (waitup) \r\n   * -0 means serve the latest group (catchup)\r\n   * -N means serve N groups prior to latest \r\n* SUBSCRIBE_OK contains the latest `group=N` and `object=K`.\r\n    * Useful for players: it knows it should start rendering after decoding object=K\r\n    * Useful for relays: enough information to serve relative requests from cache.\r\n* Relays can compute \"latest\" if it has an active subscription:\r\n    * if SUBSCRIBE active: `latest = max(cache.latest, subscribe_ok.latest)`\r\n    * if SUBSCRIBE inactive: `latest = new_subscribe_ok.latest`\r\n\r\nYou can serve relative subscriptions from cache only once you have an active SUBSCRIBE and the corresponding SUBSCRIBE_OK. If you don't have an active subscription, then you need to SUBSCRIBE again. The SUBSCRIBE_OK will tell the relay how stale the cache is and what can still be served.",
          "createdAt": "2023-09-27T03:50:20Z",
          "updatedAt": "2023-09-27T03:50:20Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "`if SUBSCRIBE active: latest = max(cache.latest, subscribe_ok.latest)`\r\n\r\nSince cache.latest can only be equal to but never greater than subscribe_ok.latest, this simplifies to \r\n\r\n`if SUBSCRIBE active: latest = subscribe_ok.latest`\r\n\r\nAnother another topic, we should also allow the use case of subscribing to a stream before any groups have been produced. In this case we need some convention to convey that no groups are yet available, for example group=null and object=null",
          "createdAt": "2023-09-27T09:51:11Z",
          "updatedAt": "2023-09-27T09:51:11Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> `if SUBSCRIBE active: latest = max(cache.latest, subscribe_ok.latest)`\r\n> \r\n> Since cache.latest can only be equal to but never greater than subscribe_ok.latest, this simplifies to\r\n> \r\n> `if SUBSCRIBE active: latest = subscribe_ok.latest`\r\n\r\nNah, `cache.latest` is updated on receipt of a new object. It's used for any new relative subscriptions.\r\n\r\nHere's a full example from the relay <- relay POV. The edge receives a SUBSCRIBE -3 from a viewer or downstream and has an empty cache:\r\n\r\n```\r\n-> SUBSCRIBE min_group=-3\r\n<- SUBSCRIBE_OK latest_group=6745\r\n<- OBJECT group=6743\r\n```\r\n\r\nThe subscription hasn't caught up to the live edge yet, but now the relay has a snapshot of how to map relative requests to absolute requests. If the relay receives a relative SUBSCRIBE during this state, it will know what can be served from cache.\r\n\r\n```\r\n6743=-2\r\n6744=-1\r\n6745=+0\r\n6746=+1\r\n```\r\n\r\nFor example, a new SUBSCRIBE asking for 0 will *not* receive 6743 thanks to this hint. It's the only object in cache at the moment, so it would have been served with `catchup` or `latest` but not with this approach. The SUBSCRIBE_OK says that 6745 is the latest so we just have to wait for the data to finish transfering. \r\n\r\nThis snapshot of latest will go stale, but the active subscribe will catch up soon. The snapshot exists mainly to support the first ~100ms where the subscribe is backfilling. In the meantime, the relay keeps receiving groups, possibly out of order:\r\n\r\n```\r\n<- OBJECT group=6742\r\n<- OBJECT group=6745\r\n<- OBJECT group=6744\r\n<- OBJECT group=6746\r\n```\r\n\r\nUpon receiving 6746, the relay updates the `latest` value since it's now larger than the snapshot from SUBSCRIBE_OK. \r\n\r\n```\r\n6743=-3\r\n6744=-2\r\n6745=-1\r\n6746=+0\r\n6747=+1\r\n```\r\n\r\nA new downstream SUBSCRIBE asking for -1 now will get 6745 and 6746 from cache. Note that there's no new upstream SUBSCRIBE; we can continue to serve relative requests indefinitely from cache unless they are too far in the past.\r\n\r\nJust to complete the example, let's suppose the relay UNSUBSCRIBEs right now for whatever reason. 6742-6746 are still in cache but we've wiped our \"latest\" value since the subscription is no longer active. The relay could get either a new absolute or relative downstream subscriber:\r\n\r\n* `SUBSCRIBE 6745`: the relay serves 6745-6746 from cache while SUBSCRIBE 6747 is sent upstream.\r\n* `SUBSCRIBE -1`: the relay doesn't know if it can serve from cache since the active subscription has ended.\r\n\r\nThe `SUBSCRIBE -1` is sent upstream and the relay behavior depends on the resulting `SUBSCRIBE_OK`:\r\n\r\n* `latest=6746`: both 6745 and 6746 are served from cache\r\n* `latest=6747`: only 6746 can be served from cache\r\n* `latest=*`: the cache is stale and can't be used\r\n\r\n In the first two cases, the relay would receive a duplicate copy of the objects it already has cached. That's probably fine, but a way to avoid this would be to subscribe based on both absolute and relative groups: `SUBSCRIBE max(6747, -1)`",
          "createdAt": "2023-09-27T13:20:29Z",
          "updatedAt": "2023-09-27T18:06:46Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Please do not use these tricks of encoding meaning as the sign of an integer. It looks like a premature optimization, and in fact it is not: there is no syntax defined to encode negative integer, you will end up with a complement to 2 64 bit integer encoded on 8 bytes. It will be much cleaner and also more efficient to encode the hint as a tuple:\r\n\r\n- meaning: an enum value describing what the subscriber wants, such as start at the current group, the next group, the first group, a specific group, or a specific location.\r\n- additional parameters if needed, such as actual group ID if not \"current\", \"next\" or \"first\", and actual object ID if needs to be specified.",
          "createdAt": "2023-10-05T14:45:45Z",
          "updatedAt": "2023-10-05T14:45:45Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Consensus at the interim is that we definitely want this and we both want to relative (n groups back) and range requests (ie: group n to group m), which could be open-ended.\r\n\r\nJoining from the currently ongoing group (start_point=-1 in slides), and the next group (start_point=1) had strong interest.\r\n\r\nstart_point=0 starts from the current object within a group and there is contention about whether it's necessary given groups are intended as start points, but there was enough interest in the room that it was felt the correct way forward was to support it and then we can revisit the issue in the future if needed.\r\n\r\nAdditionally, there is interest in object granularity, particularly for the range requests.\r\n\r\nA solution should fix #111 and #260.",
          "createdAt": "2023-10-05T14:52:06Z",
          "updatedAt": "2023-10-05T14:52:06Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 to christian and happy to help with the PR . thanks",
          "createdAt": "2023-10-05T15:04:10Z",
          "updatedAt": "2023-10-05T15:04:10Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Here's what I was thinking:\r\n\r\n```\r\nBOUNDARY {\r\n  // absolute: indexed relative to 0, increasing\r\n  // relative: indexed relative to latest, decreasing\r\n  // future: indexed relative to latest+1, increasing\r\n  // We can save a byte by combining these two; ex. lower 2 bits are mode.\r\n  Mode = none/absolute/past/future\r\n  Sequence = varint\r\n}\r\n\r\nSUBSCRIBE {\r\n  // DISCUSS Required, but it could be optional with default: relative/0\r\n  Start Group:  BOUNDARY\r\n  // DISCUSS Required, but it could be optional with default: absolute/0\r\n  Start Object: BOUNDARY\r\n\r\n  // Optional, default: none\r\n  End Group:  BOUNDARY\r\n  // Optional, default: none\r\n  End Object: BOUNDARY\r\n}\r\n```\r\n\r\nThese fields could be optional via a parameter, message type flag, or a `mode=none`. My preference would be the mode because it's easier to decode and encode. It would take 4 bytes to specify all of the start/end boundaries versus up to 12 bytes if they're all parameters.\r\n\r\nHere's how the modes from #289 would map:\r\n|suhas|luke|\r\n|-|-|\r\n| type=StartPoint mode=PREVIOUS group=N | start_group=relative/N start_object=absolute/0 | \r\n| type=StartPoint mode=NEXT group=N | start_group=future/N start_object=absolute/0 |\r\n| type=StartPoint mode=CURRENT | start_group=relative/1 start_object=absolute/0 |\r\n| type=StartPoint mode=NOW | start_group=relative/1 start_object=relative/0 |\r\n| type=Interval start_group=A start_object=B end_group=C end_object=D | start_group=absolute/A start_object=absolute/B end_object=absolute/C end_object=absolute/D |\r\n\r\nI think this is simpler and more powerful. A publisher just needs to write a `resolve` function to convert a relative boundary into an absolute one based on the latest value in the cache*. This might be an asynchronous process for a relay if the cache is empty or new.\r\n\r\nHere's some things you can't do with the proposed encoding in #289:\r\n\r\n- Start 4 groups in the past and end 2 in the future: `start=relative/4 end=future/1`\r\n- Start at group 69 and end at latest: `start=absolute/69 end=relative/0`\r\n- Start at 69 and end 4 groups in the past (might be a noop): `start=absolute/69 end=relative/4`\r\n- Keep refreshing a relative subscription while it's needed: `start=relative/4 end=future/3`",
          "createdAt": "2023-10-18T02:03:47Z",
          "updatedAt": "2023-10-18T04:13:37Z"
        }
      ]
    },
    {
      "number": 247,
      "id": "I_kwDOG2Ho4M5wuC3s",
      "title": "MUST close connection on duplicate parameters",
      "url": "https://github.com/moq-wg/moq-transport/issues/247",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Wire Format",
        "Parameters"
      ],
      "body": "Does this apply for duplicate unknown parameters?\r\n\r\nIf so, it makes for annoying bookkeeping. One has to keep an unbounded data structure of received parameter types,  instead of a handful of bools for the known parameter types.",
      "createdAt": "2023-09-11T19:18:43Z",
      "updatedAt": "2023-10-20T16:57:15Z",
      "closedAt": "2023-10-20T16:57:15Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 this was annoying to implement. For each parameter, you have to check if you're already parsed it, including unknown parameters. Then at the end you have to check that all required parameters have been set.\r\n\r\nI much prefer how QUIC frames have fixed fields, instead of this optional/unknown parameter scheme. We should use versioning to determine the field presence/order. The handshake still needs to support unknown parameters (pre-version negotiation), but the format of SUBSCRIBE/ANNOUNCE should be known after that.",
          "createdAt": "2023-09-11T22:02:40Z",
          "updatedAt": "2023-09-11T22:07:40Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I will also note that SETUP parameters currently use a SHOULD here, while Track Request parameters use a MUST.",
          "createdAt": "2023-09-28T19:46:06Z",
          "updatedAt": "2023-09-28T19:46:06Z"
        }
      ]
    },
    {
      "number": 248,
      "id": "I_kwDOG2Ho4M5wuk5c",
      "title": "Zero-length messages are foot guns",
      "url": "https://github.com/moq-wg/moq-transport/issues/248",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Wire Format"
      ],
      "body": "A zero-length message length indicates that the message runs to the end of the stream. It is also possible to have actual zero length messages (in the spec, currently just GOAWAY).\r\n\r\nZero-length messages can only exist at the end of the stream; otherwise, their encoding is ambiguous. (This is fine for GOAWAY, but not in general).\r\n\r\nThere are several ways to design out of this, which are pretty obvious. We ought to pick one.\r\n",
      "createdAt": "2023-09-11T20:59:45Z",
      "updatedAt": "2023-10-09T22:40:46Z",
      "closedAt": "2023-10-09T22:40:46Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Absolutely, I agree.\r\n\r\nMy goal is to send each GoP over a QUIC stream. The problem is that the group/object abstraction doesn't let you do that (#244). The closest you can get is to send the entire GoP as an unbounded object, because then a relay is unable to coalesce multiple (unbounded) objects into the same stream.\r\n\r\nI think we choose:\r\n- A stream per OBJECT with an unspecified length. QUIC will report the final size via FIN.\r\n- A stream per OBJECT, broken into sized DATA frames like HTTP/3. This allows intermixing messages between the data but is transparent to the application.\r\n- A stream per GROUP, broken into sized OBJECT frames. Object boundaries are exposed to the application.\r\n\r\nI'm not a fan of the third option. I want to take my 2s media segment and send it over MoQ without parsing/fragmenting at frame boundaries.",
          "createdAt": "2023-09-11T21:56:49Z",
          "updatedAt": "2023-09-11T21:58:31Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My parser would be MUCH simpler if the \"end of stream\" magic number was UINT62_MAX instead of zero. Of course, this is all inter-related with both @kixelated's concerns and the question as to if we need message length at all except for OBJECT frames.",
          "createdAt": "2023-09-15T20:31:13Z",
          "updatedAt": "2023-09-15T20:31:13Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "UINT62_MAX is also a footgun, because you really should throw UnexpectedEOF if a stream FIN truncates a message. Anyway just to summarize:\r\n\r\nControl messages:\r\n- Don't need a length if we depend on versioning/extensions. ex. QUIC frames.\r\n- Need a length if you want to ignore unknown messages. ex. HTTP/3 frames\r\n\r\nData messages:\r\n- Don't need a length if they run until the end of the stream. ex. one OBJECT per QUIC stream\r\n- Need a length if there's multiple messages per stream. ex. HTTP/3 DATA frames\r\n\r\nI'm fine with an explicit length for all messages, but only if group/object abstraction has a tighter coupling with QUIC streams. The only way to transmit a byte stream right now using MoQ is to make a single OBJECT with size=0.",
          "createdAt": "2023-09-15T21:45:37Z",
          "updatedAt": "2023-09-15T21:46:01Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Although I would still want to avoid implicit sizes like #240. If the last field in a message is a variable size (ex. string), then it still needs to encode its size instead of running until the end of the message. It wastes bytes but that's how most protocols  work (especially TLS), and it means you don't need separate encoders/decoders for implicit sizes.",
          "createdAt": "2023-09-15T21:48:48Z",
          "updatedAt": "2023-09-15T21:49:25Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this subject is misleading. This is not about messages that have no payload which have lots of uses, it seems to be about messages with and indefinte size. \r\n\r\nI can't see any argument for supporting infinite length messages. \r\n\r\nI would argue against them because it will difficult to map into some of the existing ways people want to move data between relays. ",
          "createdAt": "2023-10-03T14:33:47Z",
          "updatedAt": "2023-10-03T14:33:47Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we could take the format of QUIC \"stream data\" frames as guidance. There is a bit to say \"has length\" or not. If ahs length, then encode it. If has not, runs through end of QUIC stream.",
          "createdAt": "2023-10-04T14:48:34Z",
          "updatedAt": "2023-10-04T14:48:34Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I thought the intent was because 0 is not a valid length, and it's short (1 byte on the wire), it's a good way to indicate there is not a length?",
          "createdAt": "2023-10-05T18:43:57Z",
          "updatedAt": "2023-10-05T18:43:57Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is fixed in #255 because zero-length is just a thing for OBJECT. If people want zero payload length for some reason, then we have to use something other than zero",
          "createdAt": "2023-10-05T18:58:52Z",
          "updatedAt": "2023-10-05T18:58:52Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closed by #255",
          "createdAt": "2023-10-09T22:40:46Z",
          "updatedAt": "2023-10-09T22:40:46Z"
        }
      ]
    },
    {
      "number": 249,
      "id": "I_kwDOG2Ho4M5w0qSM",
      "title": "Object/group TTL",
      "url": "https://github.com/moq-wg/moq-transport/issues/249",
      "state": "OPEN",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Object Model"
      ],
      "body": "I'm (properly) implementing caching in my relay and need to know how long to cache an object.\r\n\r\nFor example, a catalog object should be cached until the session terminates. Meanwhile a media segment should only be cached for X seconds. The relay could evict the cache earlier than that, and possibly refetch the object if it's still within the advertised expires window.\r\n\r\nIt doesn't seem valid to have objects with different cache expirations in a group. For example, there's never a reason why you would expire the I-frame, but not the P-frames that depend on it. Expiration should ideally be a group property but there's no message to express that currently.",
      "createdAt": "2023-09-12T16:19:24Z",
      "updatedAt": "2024-03-01T15:30:26Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "My pitch: QUIC streams are the unit of caching. Each stream contains a header with expiration semantics, based on HTTP Cache-Control. \r\n\r\nApplications that rely on ordering use a QUIC stream, ex. video GoPs and catalog updates. This means you don't deliver/expire objects before their dependencies. It also means that you could address the cache by byte offset.\r\n\r\nUnlike HTTP, we should totally add an (inline?) message to update the TTL. We might say that a GoP has a 10s TTL initially, but maybe the encoder has decided to produce an increasingly long GoP, and keep bumping up the TTL as it grows.\r\n\r\n```\r\nquic stream:\r\n\r\nGROUP  track=4 sequence=69 expires=10s\r\nOBJECT size=x\r\nOBJECT size=x\r\nUPDATE expires=15s\r\nOBJECT size=x\r\nOBJECT size=x\r\nUPDATE expires=20s\r\n...\r\nEOF\r\n```",
          "createdAt": "2023-09-12T16:32:41Z",
          "updatedAt": "2023-09-12T16:41:53Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> a catalog object should be cached until the session terminates.\r\n\r\nWith LIVE streams, true, but for VOD (not your use-case but still valid moq-transport ) we might want to cache a catalog for months. \r\n\r\nFor the record, I think streams as the atomic cache unit is interesting. One challenge is if you do a long running stream with the equivalent of a DVR window. Now you have to have partial object caching at arbitrary boundaries. This is messy.  I'd rather have a scheme where we cache by Group. I don't mind serving byte-ranges out a group, but at least I would cache all of a group, or none of a group. If we put header info in groups then they can easily be served out in the same stream pattern as they arrived. (stream per Object, or stream per group etc). The header info would preserve the stream relationship while in cache. ",
          "createdAt": "2023-09-12T21:52:29Z",
          "updatedAt": "2023-09-12T21:52:29Z"
        },
        {
          "author": "simonkorl",
          "authorAssociation": "NONE",
          "body": "> I'd rather have a scheme where we cache by Group.\r\n\r\nIf I've got it right, Luke was transferring a single group over a single QUIC stream. The header info of groups arrives at the beginning of the stream and the whole stream may expire by canceling the current stream. This method looks good except for the possibly messy stream bytes. \r\n\r\nI have a question: If the object is cached in the QUIC stream, then will the UPDATE message create discontinuous byte intervals in the stream?\r\n\r\n> If we put header info in groups then they can easily be served out in the same stream pattern as they arrived. (stream per Object, or stream per group etc).\r\n\r\nI agree with this idea. It is a good idea to adapt to different stream patterns to transport a Group, such as stream per Object or stream per Group. Even if we send Objects of a Group in separate streams, we can also cache them in the stream and drop arbitrary Objects or Groups as wish. ",
          "createdAt": "2023-09-15T02:17:58Z",
          "updatedAt": "2023-09-15T02:17:58Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> If I've got it right, Luke was transferring a single group over a single QUIC stream. The header info of groups arrives at the beginning of the stream and the whole stream may expire by canceling the current stream. This method looks good except for the possibly messy stream bytes.\r\n\r\nYeah exactly.\r\n\r\n> I have a question: If the object is cached in the QUIC stream, then will the UPDATE message create discontinuous byte intervals in the stream?\r\n\r\nGood observation. The same thing happens today with HTTP since the body is broken into an arbitrary number of [DATA frames](https://www.rfc-editor.org/rfc/rfc9114.html#section-7.2.1) or [chunks](https://en.wikipedia.org/wiki/Chunked_transfer_encoding). A HTTP range request ignores this framing when determining what bytes to serve.\r\n\r\nThere's generally two options:\r\n\r\n1. You only cache the content inside the DATA frames, which makes range requests easy to serve. You reframe the data on the way out at arbitrary boundaries based on what's currently available in the cache, sliiiighly reducing the overhead for slow receivers.\r\n2. You cache the raw stream contents. You can then just copy the stream to all downstreams, preserving the same original framing. However range requests are now more difficult to serve, as you either need to reparse these headers on demand, or keep a list of offset/size pairs for each DATA chunk.\r\n\r\nThere's nothing like UPDATE in HTTP as far as I know. Based on the two approaches above, you would:\r\n\r\n1. Separately cache a list of UPDATE frames by offset, reinserting them into the stream.\r\n2. No action needed.\r\n\r\nI think we did option 2 at Twitch because we were using HTTP/1.1 and could copy the bytes directly to/from TCP sockets. With HTTP/2 and HTTP/3 it probably doesn't make a difference, with a sliiight edge to option 1 because UPDATEs would be rare.\r\n\r\nEither way, it's going significantly faster than iterating through hundreds of separate OBJECT caches. ",
          "createdAt": "2023-09-15T03:18:06Z",
          "updatedAt": "2023-09-15T03:18:06Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> > If we put header info in groups then they can easily be served out in the same stream pattern as they arrived. (stream per Object, or stream per group etc).\r\n> \r\n> I agree with this idea. It is a good idea to adapt to different stream patterns to transport a Group, such as stream per Object or stream per Group. Even if we send Objects of a Group in separate streams, we can also cache them in the stream and drop arbitrary Objects or Groups as wish.\r\n\r\n\\<rant incoming; not directed at you don't worry>\r\n\r\nThe application decides how to fragment data into objects and groups depends on the properties they provide. As the draft is currently written, putting objects into groups doesn't accomplish much. They don't get delivered in order nor are they reliable. Groups only exists as a subtle hint to a relay that they should start subscriptions at group boundaries... but that isn't even enough information for higher latency targets.\r\n\r\nThe authors argued a lot about the properties of groups and the main issue was B-frames. OBJECT sequence=6 does not necessarily depend on OBJECT sequence=5 even within the same group, which is why you can't make any assumptions about reliability (ex. B-frame was dropped). The result is that OBJECTs are are more like jumbo-datagrams, able to be dropped at arbitrary points for arbitrary reasons (aka a future of gross business logic in relays), and group membership means nearly nothing.\r\n\r\nI use QUIC streams instead of groups because they actually have useful properties. The idea is similar; objects mostly depend on earlier objects in the same group, however there's actually a strong ordering and delivery guarantee. The application doesn't need to support arbitrary gaps, reorder objects, and it can use byte offsets. A relay receives a QUIC stream and MUST deliver/cache it in the same order, or not at all.",
          "createdAt": "2023-09-15T03:31:27Z",
          "updatedAt": "2023-09-15T03:41:40Z"
        },
        {
          "author": "simonkorl",
          "authorAssociation": "NONE",
          "body": "> Either way, it's going significantly faster than iterating through hundreds of separate OBJECT caches.\r\n> I use QUIC streams instead of groups because they actually have useful properties. The idea is similar; objects mostly depend on earlier objects in the same group, however there's actually a strong ordering and delivery guarantee.\r\n\r\nI understand the reason why you don't send Objects through separate streams is that it introduces extra time costs to match Objects to corresponding Groups. Even though we can use data structures like the Link List to handle the Object caches, it is in fact not necessary because the stream has already kept the order of different Objects by itself. It is definitely a good implementation, but it would be better to be able to support different stream patterns for extensibility.\r\n\r\n> There's nothing like UPDATE in HTTP as far as I know. Based on the two approaches above, you would:\r\n> Separately cache a list of UPDATE frames by offset, reinserting them into the stream.\r\n\r\nI didn't quite get why we need to cache the UPDATE frames. Shouldn't the UPDATE frames be consumed once they arrive and only change the parameter `expires` rather than making other influences on the system? Or is the UPDATE frame updating the expiration time of different Objects so we need to cache it?",
          "createdAt": "2023-09-15T03:44:23Z",
          "updatedAt": "2023-09-15T03:44:23Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> I didn't quite get why we need to cache the UPDATE frames. Shouldn't the UPDATE frames be consumed once they arrive and only change the parameter `expires` rather than making other influences on the system? Or is the UPDATE frame updating the expiration time of different Objects so we need to cache it?\r\n\r\nYeah, the edge could drop the UPDATE frames if they only contained cache information, as the viewer likely won't use it. However with a chain of relays you would need to reemit them or risk expiring a downstream cache early. It's also more complicated because you don't know if a downstream is an end user or actually another relay.\r\n\r\nBut I imagine we would want to use UPDATE for more than just caching expirations. Forwarding it always seems useful.",
          "createdAt": "2023-09-15T04:01:46Z",
          "updatedAt": "2023-09-15T04:01:46Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "I am not too sure of the updates, but  setting the transport delivery mode of one group per stream and just sending one object in that stream (which is the entire GOP) should get the configuration needed. \r\n\r\nAlso agree with @simonkorl on allowing different grouping objects.\r\n\r\nI like the simple properties we have for object defined today\r\n1.  \"An object is an addressable unit whose payload is a sequence of bytes\" . \r\n2.  A relay MUST NOT combine, split, or otherwise modify object payloads.\r\n\r\nObjects are the units of caching and can be retrieved and it avoids the complications of splitting them,  and also ending up delivering them into pieces across streams/connections.\r\n\r\n",
          "createdAt": "2023-09-16T17:19:51Z",
          "updatedAt": "2023-09-17T02:48:00Z"
        },
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "+1 to @suhasHere . The caching should happen in the MoQT layer not in the underlying \"real\" transport(WebTransport or Raw QUIC). QUIC stream is only one way of transport the unit in MoQT layer(Object/Group). ",
          "createdAt": "2023-09-18T02:39:18Z",
          "updatedAt": "2023-09-18T02:39:18Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Walk me through how this works for an audio call where you only want to cache the most recent 15 seconds. ",
          "createdAt": "2023-09-18T16:13:09Z",
          "updatedAt": "2023-09-18T16:13:09Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To answer the top level questions at top of this issue. I think each object should have a Time To Live or Expiry Date. The main reason is to allow CDNs to bill for the time data is stored and for the applications to have a way to indicate to the CDN what the desired behavior is. This is a significant limitation of existing HTTP CDNs. ",
          "createdAt": "2023-09-18T16:16:01Z",
          "updatedAt": "2023-09-18T16:16:01Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I think each object should have a Time To Live or Expiry Date.\r\n\r\n+1\r\n\r\n> This is a significant limitation of existing HTTP CDNs.\r\n\r\nHTTP CDNs do have pretty extensive cache control - see [here ](https://techdocs.akamai.com/property-mgr/docs/know-caching#what-is-ttl)for some details. We could for moq-transport think of simplifying this and reducing the applicaiton defined options (e.g s-maxage, max-age,no-store,no-cache) down to a single value which is the desired TTL in milliseconds. ",
          "createdAt": "2023-09-18T16:23:37Z",
          "updatedAt": "2023-09-18T16:23:37Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> Walk me through how this works for an audio call where you only want to cache the most recent 15 seconds.\r\n\r\nSure. The simple answer is that you deliver independent chunks, over independent streams, which are cached independently. I'm going to call these \"groups\" because that's the spirit behind the abstraction in the draft. ex. There's no point caching/delivering a B frame if you already invalidated/dropped the I frame.\r\n\r\nThe audio group size is up to the application (and codec). It could be as small as 1 frame or as large as the entire video GoP. It's a trade-off between overhead (number of streams) and granularity (not latency). For example, if you make a group every 100ms, then you can only start/skip at 100ms boundaries. MAX_STREAMs is really the only reason why you wouldn't make 1 frame audio groups though.",
          "createdAt": "2023-09-19T20:48:26Z",
          "updatedAt": "2023-09-19T21:01:31Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "The long answer bleeds into QUIC stream mapping.\r\n\r\nThe key property is independence. You want media to be split into chunks which can then be cached/served independently. \r\n\r\nMy claim is that you want network dependency == cache dependency == application dependency. You want to each group to be it's own independent pipeline: encode -> transmit -> cache -> receive -> decode. That way when there's congestion or queuing, you can cancel or deprioritize less important groups without impacting more important groups.\r\n\r\nNow, let's suppose you send two OBJECTs with two different groups over the same QUIC stream. You could cache these independently however the premise is flawed. The intent is to cache them independently so you can deliver them independently downstream, however they were delivered **_dependently_** from the upstream. Any congestion from upstream propagates downstream; you can't put the genie back in the bottle.\r\n\r\nSo that's not to say that caching objects independently is inherently wrong. The core issue is delivering independent objects on the same QUIC stream, which introduces dependencies, and then expecting to cache them independently.\r\n\r\nAlso just to clarify, a CDN does not need to use QUIC streams internally. It only matters when there's congestion, much like a CDN would use HTTP/3 externally but HTTP/1/2 internally. The streams/groups would still be logically separate, much like HTTP/2 requests are logically separate and are cached separately, even when are serialized over a single TCP stream.",
          "createdAt": "2023-09-19T21:00:38Z",
          "updatedAt": "2023-09-19T21:09:20Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I can imagine three possible uses of a TTL:\r\n\r\n1. How long can one cache this before revalidating the content - MoQT objects are immutable, so this is not an issue.\r\n2. How long can one cache this before it should be purged from the cache for policy reasons.\r\n3. How long would we expect the content to be cached in order to satisfy the typical user/usecase.\r\n\r\nIt seems like this issue is mostly focused on the 3rd concept, which is essentially a performance optimization/hint?",
          "createdAt": "2024-02-20T02:55:13Z",
          "updatedAt": "2024-02-20T02:55:13Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment:\r\n\r\nTTLs are relative to something, for example Cache-Control: max-age is relative to the Date header in an HTTP response.  There are no absolute dates in moqt right now, so are we talking about TTLs relative to when an entity receives an object?  Or are we actually talking about an absolute 'expiration' field.\r\n\r\nI agree with Ian that revalidation is not a use case.  \r\n\r\nI had thought that part of the use case for TTL was something mentioned in #396 -  a point at which Objects should no longer be transmitted.  Hinting to the cache when things can be purged may be orthogonal to that, so maybe moq requires  multiple properties conveying different types of object lifetime information?",
          "createdAt": "2024-02-20T17:17:08Z",
          "updatedAt": "2024-02-20T17:17:08Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think there are two different object time properties we need to consider - content expiration and cache expiration. The two are not the same. here is how I see them defined:\r\n\r\n**Expiration** - an absolute timestamp after which the content is invalid. It MUST NOT be delivered after this time and may be purged from cache or dropped if it is in a send queue. \r\n**Cache TTL** - a relative time that the content should be cached after receipt at any relay. This is a hint to the relays as to the period of time that storing this object would be useful. \r\n\r\nExamples (as set by publisher) \r\n\r\n- Real-time video conference stream: Expiration: now + 2000ms, Cache TTL 2000ms\r\n- Sports broadcast with 1hr DVR window; Expiration: now  + 3600000, cache TTL 3600000\r\n- VOD movie valid all year but cached for 30min: Expiration: now + 1314000000, cache TTL:1800000\r\n\r\nIf cacheTTL is not set, then relay MAY cache until expiration date.\r\nIf cacheTTL is set without any expiration date, and the cacheTTL has been exceeded, relay should renew the subscription before serving the content downstream. \r\n\r\nCaching at all times is a scaling and efficiency mechanism for avoiding trips upstream. It is decoupled from the core pub/sub behavior of moqt. Therefore any cacheTTL properties are suggestions to the relays and should not be relied upon. \r\n",
          "createdAt": "2024-02-20T17:49:25Z",
          "updatedAt": "2024-02-20T17:49:25Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just want to flag that I think a bunch of this is really going the wrong direction but I don't want to discuss in an issue. I think we need a better way to make progress on this. ",
          "createdAt": "2024-03-01T15:30:25Z",
          "updatedAt": "2024-03-01T15:30:25Z"
        }
      ]
    },
    {
      "number": 250,
      "id": "I_kwDOG2Ho4M5w1MnX",
      "title": "server-sent ROLE parameters",
      "url": "https://github.com/moq-wg/moq-transport/issues/250",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Handshake"
      ],
      "body": "Sec 6.1.1.1 specifies client sending or ROLE, and says nothing of server-sent.\r\n\r\nI guess server-sent ROLE is not needed, but maybe we should fail if it is sent?",
      "createdAt": "2023-09-12T17:47:11Z",
      "updatedAt": "2024-02-23T18:00:55Z",
      "closedAt": "2024-02-23T18:00:55Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I filed #151 about the role parameter. The client doesn't actually know what the server intends to do. The server should be able to reply with its functionality, which might be a subset of what the client can support.",
          "createdAt": "2023-09-12T17:54:39Z",
          "updatedAt": "2023-09-12T17:54:39Z"
        }
      ]
    },
    {
      "number": 251,
      "id": "I_kwDOG2Ho4M5yErft",
      "title": "What's the point of mandatory SETUP parameters?",
      "url": "https://github.com/moq-wg/moq-transport/issues/251",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Needs PR",
        "Handshake",
        "Parameters"
      ],
      "body": "Parameters are a useful tool for optional fields in a message.\r\n\r\nBut AFAICT, none of the SETUP parameters are actually optional. Clients MUST send ROLE.  #151 and #250 discuss the server ROLE situation, but ISTM the server ROLE will be either required or forbidden.\r\n\r\nMeanwhile, PATH will be required for raw QUIC clients and forbidden for all other cases.\r\n\r\nSo why not make these part of the SETUP message and save ourselves all the parameter encoding overhead? It's true that it would require different formats for Webtrans client, Raw QUIC client, and server, but we've already split SETUP into client and server variants.\r\n\r\nI would not be opposed to leaving parameters in SETUP with an empty registry, as it would be a good extension point for capability negotiation.",
      "createdAt": "2023-09-26T15:55:56Z",
      "updatedAt": "2023-11-09T09:20:36Z",
      "closedAt": "2023-11-09T09:20:35Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, it's quite frustrating right now. Especially the server SETUP, because it supports generic parameters but receipt of any known parameters is an error.\r\n\r\nHowever the messages do need to be generic so they can be used to perform version negotiation. I wish we could punt version negotiation to another layer like ALPN but no equivalent exists in WebTransport.\r\n",
          "createdAt": "2023-09-26T21:24:29Z",
          "updatedAt": "2023-09-26T21:24:49Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hmm, interesting point about VN. I did a PR, so the group can decide.",
          "createdAt": "2023-09-28T19:54:46Z",
          "updatedAt": "2023-09-28T19:54:46Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "> So why not make these part of the SETUP message and save ourselves all the parameter encoding overhead?\r\n\r\nTLS used to do that, and as a result, like half of TLS client hello in 1.3 are unused legacy fields with fixed values.  Though I guess if we defer version negotiation to ALPN, this is less of an issue.",
          "createdAt": "2023-09-29T16:28:02Z",
          "updatedAt": "2023-09-29T16:28:02Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It might be worthwhile to sketch out exactly what VN looks like. Is the idea here that the client will include parameters for every version for which it advertises support? Adn then the server responds with the subset of parameters for the chosen version?",
          "createdAt": "2023-09-29T16:37:05Z",
          "updatedAt": "2023-09-29T16:37:05Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "People who know me from QUIC will know that I am not a fan of negotiation via ALPN.",
          "createdAt": "2023-09-29T16:39:19Z",
          "updatedAt": "2023-09-29T16:39:19Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "We now have some text on negotiation.  I think if we saw a PR for this, it could be landed, especially now that SETUP has been split into two in #297 ",
          "createdAt": "2023-10-24T00:46:15Z",
          "updatedAt": "2023-10-24T00:46:15Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The VN text answers the question of what SETUP parameters are for. Closing.",
          "createdAt": "2023-11-09T09:20:35Z",
          "updatedAt": "2023-11-09T09:20:35Z"
        }
      ]
    },
    {
      "number": 252,
      "id": "I_kwDOG2Ho4M5yNOsN",
      "title": "Does relay matching behavior need to be negotiated in-band?",
      "url": "https://github.com/moq-wg/moq-transport/issues/252",
      "state": "CLOSED",
      "author": "afrind",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Announce"
      ],
      "body": "This came out of discussion on #204\r\n\r\nWhen a relay receives an SUBSCRIBE it may need to issue its own SUBSCRIBE to a publisher that has previously ANNOUNCE'd a namespace matching that track.  The current draft doesn't specify how this match is done.  A relay could implement an exact match on Track Namespace (requires a tweak to SUBSCRIBE), or could do a longest prefix match on track name vs all ANNOUNCE'd namespaces, or possibly something else.  Is it ok to leave this up to implementations or should the draft specify this behavior more exactly?  If more than one matching type is allowed, does it need to be negotiated, and by whom (publisher, subscriber, or both)? ",
      "createdAt": "2023-09-27T18:02:09Z",
      "updatedAt": "2024-02-23T18:01:26Z",
      "closedAt": "2024-02-23T18:01:26Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "An issue that came up in interop that is somewhat related - @kixelated's relay was implemented to take the namespace from the connect URL, because in his use-case, ANNOUNCE can be made redundant with the connect URL (eg it contains a namespace and enough auth).  However, this caused an interop problem because my chat application assumes a certain functionality from relays, and that includes supporting ANNOUNCE messages to determine routing to publishers.  Do we need to be more prescriptive about relay behavior?",
          "createdAt": "2023-10-04T00:31:25Z",
          "updatedAt": "2023-10-04T00:31:25Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "ANNOUNCE is what my implementation expects as well. A producer can announce track namespaces at any point (after being connected).  Overloading connect URL  with track info is limiting ",
          "createdAt": "2023-10-04T02:22:02Z",
          "updatedAt": "2023-10-04T02:22:02Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is going to be a slightly long comment but this is how I think this should work. \r\n\r\nThe catalog has two fields for the track namespace , and track name. We also specify in the catalog a way to form a URL from these two fields. See Teds proposal and that is catalog specific.  The things we put in these track namespaces and track name fields are already canonicalized  in a way defined by the catalog and URL. \r\n\r\nWhen the application using the moq transport puts these two fields into message, they are treated as just a bunch of bits and any comparison of them is done with bitwise compare. A relay that needs to check if a namespace matches another does not need to worry about string prep or escape encoding of the bits, the will all have been done when the catalog was formed. \r\n\r\nThis allows the relays to work faster by just doing bitwise compare yet at the same time allows us to use URI at the application level. The transport draft just needs to deal with a bag of bits. The catalog draft pushes the work to the URL definition, and the URL definition does the heavy lifting but that is where this type of stuff should be\r\n\r\n",
          "createdAt": "2023-11-04T15:42:57Z",
          "updatedAt": "2023-11-04T15:42:57Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "@fluffy Just to clarify that when you say \"bitwise compare\" you also mean exact matching the entire namespace field from announce to the one in subscribe?",
          "createdAt": "2023-11-05T13:12:59Z",
          "updatedAt": "2023-11-05T13:12:59Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> The catalog has two fields for the track namespace , and track name.\r\n\r\nI would like to decouple the media layer from the transport layer. A tool like ffmpeg should be able to generate a MoQ catalog without knowing the namespace it will be served from, much like a tool like zip should be able to generate a file without knowing the path it will be stored.\r\n\r\nHLS/DASH provides this functionality with absolute or relative paths. If the playlist contains relative paths, then it can be served from any HTTP host/path provided the segments are served from the same host/path. If you want to decouple the two (ex. application serves playlist, CDN serves segments), then you use absolute URLs.\r\n\r\nTo accomplish the same thing, the namespace should be optional in a MoQ catalog. This would mean media tracks are served from the same namespace as the catalog: whatever that might be.\r\n",
          "createdAt": "2023-11-06T01:08:25Z",
          "updatedAt": "2023-11-06T01:08:25Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "To expand further, I think that MoQ broadcasts should be namespace agnostic: a broadcast ingested with namespace XXX is NOT required to be delivered as XXX.\r\n\r\nI understand where Cullen is coming from: an application like WebEx can use the same namespace for contribution/distribution because it controls the full pipeline. The application has all of the information required for all future routing/identification so it can set it on the first hop and expect any relays to blindly proxy.\r\n\r\nHowever, for a more generic or distributed system, this is not true. A client like OBS knows nothing about how the broadcast will eventually be distributed, fanned out, or the requirements of potentially multiple CDNs that might be used, nor will those requirements be the same between vendors (present or future).\r\n\r\nSo I don't think we should require that input namespace == output namespace. In the HTTP world, this would be like requiring that all HTTP paths match the origin. It's quite restrictive and just means a CDN needs find another way to perform routing via a custom header/parameter.\r\n\r\nI propose we emulate the HTTP model where there's non in-band notification that a path/namespace was modified. An origin might serve `/foo.html` and a CDN might decide to serve it as `/customer/asdgsa13/foo.html`. Any namespace remapping from XXX -> YYY is business logic and not signaled over the wire. If you don't want any remapping, then that's a business agreement between you and the CDN, wherein you may need to encode namespaces in a vendor-specific way.",
          "createdAt": "2023-11-06T01:39:07Z",
          "updatedAt": "2023-11-06T01:40:52Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think that MoQ broadcasts should be namespace agnostic: a broadcast ingested with namespace XXX is NOT required to be delivered as XXX.\r\n\r\nI think we have agreement on that from past discussions.  \r\n\r\nCan the catalog draft have a mechanism to inherit the namespace for tracks from somewhere else, like a relative URL in an HTML page?\r\n\r\nI'm not sure this is relevant for how relays perform matching between SUBSCRIBE and ANNOUNCE though.  The only available information in announce *is the namespace*.",
          "createdAt": "2023-11-06T08:58:36Z",
          "updatedAt": "2023-11-06T08:58:36Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'm not sure this is relevant for how relays perform matching between SUBSCRIBE and ANNOUNCE though. The only available information in announce _is the namespace_.\r\n\r\nYeah I'm probably rambling about something unrelated. But in order to support namespace remapping, the downstream ANNOUCE/SUBSCRIBE won't necessarily match the upstream ANNOUCE/SUBSCRIBE.",
          "createdAt": "2023-11-06T09:09:49Z",
          "updatedAt": "2023-11-06T09:15:43Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> To accomplish the same thing, the namespace should be optional in a MoQ catalog. This would mean media tracks are served from the same namespace as the catalog: \r\n\r\n> Can the catalog draft have a mechanism to inherit the namespace for tracks from somewhere else, like a relative URL in an HTML page?\r\n\r\nThis is a useful property. I opened [#33](https://github.com/moq-wg/catalog-format/issues/33) to address this issue and PR https://github.com/moq-wg/catalog-format/pull/34 to fix it. ",
          "createdAt": "2023-11-06T10:03:42Z",
          "updatedAt": "2023-11-06T10:03:42Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So if the input full track name does not equal output full track name ( for some version of matching the two ), what is it that tells the relays there is mapping between the two. I'm not objecting to some other way to do this, I just don't understand what it is that tells the relays to do that.  Keep in mind relays do not need to read the catalog. \r\n\r\n",
          "createdAt": "2023-11-06T10:21:05Z",
          "updatedAt": "2023-11-06T10:21:05Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To clarify the  \"bitwise compare\" ... yes I mean exact matching the entire namespace field from announce to the one in subscribe? If the namespace was utf-8 or even a url restricted utf-8, that would match. I am just aruging that a relay should not have to verify every string is a valid utf-8 string, it should just match the bits. ",
          "createdAt": "2023-11-06T10:22:47Z",
          "updatedAt": "2023-11-06T10:22:47Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> So if the input full track name does not equal output full track name ( for some version of matching the two ), what is it that tells the relays there is mapping between the two. I'm not objecting to some other way to do this, I just don't understand what it is that tells the relays to do that. Keep in mind relays do not need to read the catalog.\r\n\r\nHTTP proxies will not modify the path by default. A downstream request for `/foo` arrives, there's some rules to match it to a backend, and then an upstream request for `/foo` is sent. A simple MoQ relay would work the same way.\r\n\r\nHowever, you can configure a HTTP proxy to perform special behavior, including rewriting the path. Note that a the HTTP server does rewrite the HLS/DASH playlist provided they are using relative URLs since both the playlist and segment would match the same prefix rules.\r\n\r\nFor example, here's a simple nginx configuration:\r\n\r\n```nginx\r\nserver {\r\n    # match any requests for `akamai.com`\r\n    server_name akamai.com;\r\n\r\n    # match any requests that start with /webex\r\n    location /webex {\r\n        # perform custom auth based on prefix\r\n        auth_webex \"$WEBEX_KEY\"\r\n\r\n        # Route to the webex origin and remove /webex from the path\r\n        # ex. /webex/foobar => https://origin.webex.com/foobar\r\n        proxy_pass \"https://origin.webex.com\";\r\n    }\r\n\r\n    # match any requests that start with /twitch\r\n    location /twitch {\r\n        # ex. /twitch/foobar => https://video-edge-cdn.hls.twitch.tv/foobar\r\n        proxy_pass \"https://video-edge-cdn.hls.twitch.tv\";\r\n    }\r\n}\r\n\r\n# alternatively, match based on SNI\r\nserver {\r\n    # route any requests for webex.akamai.com straight to the origin\r\n     server_name webex.akamai.com;\r\n\r\n     location / {\r\n       # note the path is not written\r\n       proxy_pass \"https://origin.webex.com\";\r\n    }\r\n}\r\n```\r\n\r\nI would allow the same exact thing for MoQ, but of course use our terminology instead. I think a key improvement with MoQ over HTTP is actually the namespace/name tuple. I propose:\r\n\r\n- A relay SHOULD NOT change the track name. That means a producer can make a track called \"video_480p\" and reference it in a catalog, inheriting the current namespace. \r\n- A relay MAY change the track namespace when negotiated out-of-band. It's RECOMMENDED that an application support being served from arbitrary namespaces, including using relative namespaces when tracks reference each other.\r\n\r\nBasically, the track name is controlled by the application (encoder/decoder) while the track namespace is controlled by the relay (hop-by-hop). This makes a ton of sense if the namespace is primarily meant for routing (critical for relays), and it allows relays to do stuff like encode the route or a unique ID into the namespace itself.",
          "createdAt": "2023-11-07T03:28:09Z",
          "updatedAt": "2023-11-07T03:28:09Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Going back to the original issue Alan posted (if I understand it correctly), I think we need to support out-of-band negotiation given the nature of fanout. Maybe we can provide something in-band but it won't always be possible.\r\n\r\nFor example, an OBS client sends:\r\n```\r\nCONNECT https://ingest.twitch.tv\r\nANNOUNCE twitch/kixelated\r\n```\r\n\r\nIn theory, the server could reply with the information required to watch the broadcast (final hop), including any remapping along the way:\r\n\r\n```\r\nANNOUNCE_OK connect=https://twitch.akamai.com namespace=kixelated_123\r\n```\r\n\r\nBut this gets really messy when you factor in auth, multiple CDNs, multiple edge hosts, and just the nature of ingest being on the other side of the pipe from distribution. In this example, I think the application has to negotiate with Akamai on how they need to ingest and how they need to egress.\r\n\r\nI'm not opposed to using extensions to make this mapping explicit though. It would be cool to have a scheme that defines routing/authentication using globally unique namespace, kind of like a decentralized CDN. But it shouldn't be required as part of the base protocol and there's a LOT of sharp edges to figure out.",
          "createdAt": "2023-11-07T03:29:11Z",
          "updatedAt": "2023-11-07T03:35:49Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment: \r\n\r\n> So if the input full track name does not equal output full track name ( for some version of matching the two ), what is it that tells the relays there is mapping between the two\r\n\r\nMy opinion is that anything that does this kind of rewriting is out-of-band, at least for now?  For a completely generic relay input=output.",
          "createdAt": "2023-11-07T06:20:54Z",
          "updatedAt": "2023-11-07T06:20:54Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Can the catalog draft have a mechanism to inherit the namespace for tracks from somewhere else, like a relative URL in an HTML page?\r\n\r\nYes. I opened issue https://github.com/moq-wg/catalog-format/issues/33 to address this and PR https://github.com/moq-wg/catalog-format/pull/34 to fix it. I really like the flexibility that relative names bring. We know this works at scale for current web and media delivery across disparate systems. I'd hope that relative track names are the normal mode of operation. We should allow absolute namespaces in catalogs to allow mixing between sources, however I think this will be an edge case. \r\n\r\nBy default, a relay SHOULD NOT modify the track namespace or track name. However, what a distribution network does within the bounds of its own network is up to it. As it restores the original namespace and name at its boundaries (to match the catalog), then external systems cannot tell and distribution intent is preserved. Additionally, there will be business logic and distribution agreements between CDNs, coordinated by the content distributor, to rewrite namespaces between networks. Such namespace rewriting is common between networks and should not be prohibited. \r\n\r\nHere's how I envisage a scalable solution working. When a twitch user wants to use OBS to publish, they would log in to Twitch.com and authenticate against the Twitch CMS. It would vend them two URLS:\r\n\r\na connect  and publish URL `https://ingest.akamai.twitch.tv/twitch/kixelated`\r\na playback URL to share with their followers `https://playback.fastly.twitch.tv/premiergaming/gamer34/catalog. `\r\n\r\nThe OBS client would use this to \r\n\r\n```\r\nCONNECT https://ingest.akamai.twitch.tv/\r\nANNOUNCE twitch/kixelated\r\n\r\n```\r\nThe client then publishes twitch/kixelated/catalog, a track which describes two relative tracks - audio and video. \r\n\r\n```\r\nvideo\r\naudio\r\n```\r\n\r\nThe playback client connects to https://playback.fastly.twitch.tv and subscribes to premiergaming/gamer34/catalog. After parsing the catalog it subscribes  to\r\n\r\n```\r\npremiergaming/gamer34/video\r\npremiergaming/gamer34/video\r\n```\r\n\r\nThe Fastly relays have been configured by Twitch, out-of--band, so that when they go forward to origin (which is Akamai), they do a namespace rewrite to\r\n\r\n```\r\npremiergaming/gamer34/video -> twitch/kixelated/video\r\npremiergaming/gamer34/audio -> twitch/kixelated/audio\r\n```\r\n\r\nThe subscriptions  make their way back to the OBS instance. The encoder prepare Moqt Objects with `twitch/kixelated/video ` in their headers. As these are received by Fastly, business logic rewrites them to `premiergaming/gamer34/video`, caches them as such and they are delivered to the client. \r\n",
          "createdAt": "2023-11-07T11:27:41Z",
          "updatedAt": "2023-11-07T11:27:41Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "As per the discussions in person,  it is more nuanced than renaming few bits in the header.  It might break e2e encryption /auth for example or reencryption in some cases. As this is very application specific,  one needs to be take into consideration the costs as it may not be just rewrite few bits in and out of network edges.  The more appropriate or clearer framing may be -  whenever the name changes, it is ,in a way, republishing the content with a new name .. \r\n\r\n",
          "createdAt": "2023-11-07T16:05:41Z",
          "updatedAt": "2023-11-07T16:05:41Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> As it restores the original namespace and name at its boundaries (to match the catalog)\r\n\r\njust to note, the network wouldn't have access to the catalog ",
          "createdAt": "2023-11-07T16:07:39Z",
          "updatedAt": "2023-11-07T16:07:39Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Conclusion is that we'll use exact matching like specified in #329 ",
          "createdAt": "2023-11-09T16:44:14Z",
          "updatedAt": "2023-11-09T16:44:14Z"
        }
      ]
    },
    {
      "number": 253,
      "id": "I_kwDOG2Ho4M5yNPNK",
      "title": "Wildcard SUBSCRIBE",
      "url": "https://github.com/moq-wg/moq-transport/issues/253",
      "state": "OPEN",
      "author": "afrind",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Subscribe"
      ],
      "body": "SUBSCRIBE today requires a full track name, and specifies exactly one track.  Do we need a subscription mechanism that matches more than one track, including tracks that may not exist currently, but may come into existence in the future?",
      "createdAt": "2023-09-27T18:03:48Z",
      "updatedAt": "2024-02-07T16:37:55Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "The only use-case for wildcard subscriptions is what I'm dubbing **catalog-less**. A subscriber could subscribe to tracks without knowing about their existence.\r\n\r\n1. A subscriber would know the `base` path of a conference call.\r\n2. Each participant would `ANNOUNCE base/participant`.\r\n3. Each participant would `SUBSCRIBE base/*`.\r\n\r\nThis is cool at first glance, but I don't see it actually working in practice. The problem is that there's no selection mechanism; a subscriber will receive ALL possible tracks. That means stuff like simulcast or multiple codec support is basically impossible. You would absolutely need a catalog for each participant at a minimum.\r\n\r\n3a. Each participant would `SUBSCRIBE base/*/catalog`\r\n\r\nNow you could choose tracks for each participant. The benefit of **catalog-less** is that you don't have a central server; each participant would talk directly to the CDN only.\r\n\r\n...except you still would still want a central server; I don't think you can get away with it. Stuff like authentication, notifications, logging, billing, validation, versioning etc is really difficult if participants are allowed to connect to a CDN and publish arbitrary namespaces. It's possible, but you're just going to end up exposing an API (ex. `api.webex.com/join`). The central server can then just publish a catalog of all participants; there's no need for catalog-less.",
          "createdAt": "2023-09-29T01:18:11Z",
          "updatedAt": "2023-09-29T01:18:49Z"
        },
        {
          "author": "hardie",
          "authorAssociation": "COLLABORATOR",
          "body": "As a personal comment, I think you are taking the semantics of * a little\r\ntoo literally in your modeling of the problem.   You have:\r\n\r\n\r\n   1. A subscriber would know the base path of a conference call.\r\n   2. Each participant would ANNOUNCE base/participant.\r\n   3. Each participant would SUBSCRIBE base/*.\r\n\r\nbut you could have this as\r\n\r\nbase/audio/*\r\nbase/video/*\r\n\r\nthus ignoring text or haptics or whatever else the client couldn't handle,\r\nbut getting audio and video from all participants.   You could also have a\r\nsemantic like base/participant/default/* where the subscription has the\r\nother side choose what tracks to send based on their defaults.  Or even\r\nbase/*/audio-codec1 base/*/video-codec1 to get all the participants, known\r\nand unknown, to send that audio and video (note that this works best if the\r\napplication has a mandatory to implement codec set, because then you can be\r\ncertain this works).\r\n\r\nThis might add some complexity, but I think we will need it for conference\r\ncall case; otherwise the join latency will depend on a catalog update.\r\n\r\nregards,\r\n\r\nTed\r\n\r\nOn Fri, Sep 29, 2023 at 2:18\u202fAM kixelated ***@***.***> wrote:\r\n\r\n> The only use-case for wildcard subscriptions is what I'm dubbing\r\n> *catalog-less*. A subscriber could subscribe to tracks without knowing\r\n> about their existence.\r\n>\r\n>    1. A subscriber would know the base path of a conference call.\r\n>    2. Each participant would ANNOUNCE base/participant.\r\n>    3. Each participant would SUBSCRIBE base/*.\r\n>\r\n> This is cool at first glance, but I don't see it actually working in\r\n> practice. The problem is that there's no selection mechanism; a subscriber\r\n> will receive ALL possible tracks. That means stuff like simulcast or\r\n> multiple codec support is basically impossible. You would absolutely need a\r\n> catalog for each participant at a minimum.\r\n>\r\n> 3a. Each participant would SUBSCRIBE base/*/catalog\r\n>\r\n> Now you could choose tracks for each participant. The benefit of\r\n> *catalog-less* is that you don't have a central server; each participant\r\n> would talk directly to the CDN only.\r\n>\r\n> ...except you still would still want a central server; I don't think you\r\n> can get away with it. Stuff like authentication, notifications, logging,\r\n> billing, validation, versioning etc is really difficult if participants are\r\n> allowed to connect to a CDN and publish arbitrary namespaces. It's\r\n> possible, but you're just going to end up exposing an API (ex.\r\n> api.webex.com/join). The central server can then just publish a catalog\r\n> of all participants.\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/moq-wg/moq-transport/issues/253#issuecomment-1740183903>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AAKVXZCMJ2P7E5LYW4NB3VLX4YOWBANCNFSM6AAAAAA5JYAHCE>\r\n> .\r\n> You are receiving this because you are subscribed to this thread.Message\r\n> ID: ***@***.***>\r\n>\r\n",
          "createdAt": "2023-09-29T08:10:47Z",
          "updatedAt": "2023-09-29T08:10:47Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The wildcard approach is alluring in its simplicity.  However it opens up a strong vector for unintentional (or perhaps malicious) DOS'ing of a distribution relay. For example, a reasonable wildcard'ed subscription like this\r\n\r\n`webex.com/session/gh34gh43j4/carol/*`\r\n\r\nwould get you Carol's slides when she publishes them. However this subscription\r\n\r\n`webex.com/*`\r\n\r\nwould likely DOS your relay and all the nodes upstream of it. In the HTTP world, it would be the equivalent to being able to ask any CDN edge node for all 22PB of assets owned by a customer, without even knowing any of their URLs. \r\n\r\nWe can counter this risk by using tokens to enforce access control. The token would presumably define some base path below which a user is allowed to wildcard. In moq-transport so far, token protection is at the discretion of the application. Since we have no standard tokenization scheme, this is difficult to enforce, brittle when we get to scale and IMO is overreaching in terms of design. \r\n\r\nThere are two alternate solutions  (beyond wildcard subscriptions) to the oft cited use case of getting the slides quickly in a conferencing use-case. \r\n1. The catalog for Carol (or for the web conference if the catalog is generated by a central server) can advertise a track for Carol's slides and all the other participants can subscribe to it. It doesn't mean she actually has to send out any content on that track and in fact she many never do. However, the moment Carol shares her slides, the network is setup to instantly distribute the content to the correct recipients.\r\n2. Simply use a delta catalog update to describe the new slide track.  It is a very small payload and would be distributed very quickly. A web conferencing application already has a roundtrip delay in sharing slides, because only one person can share at a time, and so the orchestrator needs to coordinate who has the right to share. The delta catalog update would happen in parallel to any such orchestration. By using the catalog update, you inherit the content selection, initialization, track relationship and access control built in to that solution. I think this solution is a clean one and I'd like to see evidence from some of the early conferencing poc's that it is insufficiently performant. ",
          "createdAt": "2023-09-29T10:10:15Z",
          "updatedAt": "2023-09-29T10:10:15Z"
        },
        {
          "author": "hardie",
          "authorAssociation": "COLLABORATOR",
          "body": "On Fri, Sep 29, 2023 at 11:10\u202fAM Will Law ***@***.***> wrote:\r\n\r\n> The wildcard approach is alluring in its simplicity. However it opens up a\r\n> strong vector for unintentional (or perhaps malicious) DOS'ing of a\r\n> distribution relay. For example, a reasonable wildcard'ed subscription like\r\n> this\r\n>\r\n> webex.com/session/gh34gh43j4/carol/*\r\n>\r\n> would get you Carol's slides when she publishes them. However this\r\n> subscription\r\n>\r\n> webex.com/*\r\n>\r\n> would likely DOS your relay and all the nodes upstream of it.\r\n>\r\nIt seems far more likely to simply be refused.  The ability to use\r\nwildcards does not imply that they can be used everywhere; */* (any host,\r\nany session) is clearly ridiculous and would be refused.  example.com/*\r\nshould be out of bounds as well.\r\n\r\nIn the HTTP world, it would be the equivalent to being able to ask any CDN\r\n> edge node for all 22PB of assets owned by a customer, without even knowing\r\n> any of their URLs.\r\n>\r\n> We can counter this risk by using tokens to enforce access control. The\r\n> token would presumably define some base path below which a user is allowed\r\n> to wildcard. In moq-transport so far, token protection is at the discretion\r\n> of the application. Since we have no standard tokenization scheme, this is\r\n> difficult to enforce, brittle when we get to scale and IMO is overreaching\r\n> in terms of design.\r\n>\r\n> There are two alternate solutions (beyond wildcard subscriptions) to the\r\n> oft cited use case of getting the slides quickly in a conferencing use-case.\r\n>\r\nThis isn't the main problem I was referencing.  Let's take the authors'\r\ncall as an example.  When I connect, I want the audio and video sent by the\r\nparticipants.  But the participant list isn't consistent from week to week\r\nand it is very common for a participant to join later than the main set.\r\nWaiting for a catalog track and re-request will mean someone joining will\r\ntake longer to be visible/audible to other participants and may \"arrive\" at\r\ndifferent time scales for different participants.  A subscription like:\r\n\r\nexample.com/sesssionID/$ALL_Participants/video\r\nexample.com/sesssionID/$ALL_Participants/audio\r\nexample.com/sesssionID/$ALL_Participants/chat_text\r\n\r\nWould mean that the other participants would automatically be subscribed to\r\nchat text, audio, and video of anyone as they join.  You could also design\r\nthis so that the latecomer (Carol) can distribute a catalog track as well,\r\nso that any other tracks offered (including alternate video or audio\r\ncodecs) would be available shortly.\r\n\r\n\r\n>\r\n>    1. The catalog for Carol (or for the web conference if the catalog is\r\n>    generated by a central server) can advertise a track for Carol's slides and\r\n>    all the other participants can subscribe to it. It doesn't mean she\r\n>    actually has to send out any content on that track and in fact she many\r\n>    never do. However, the moment Carol shares her slides, the network is setup\r\n>    to instantly distribute the content to the correct recipients.\r\n>    2. Simply use a delta catalog update to describe the new slide track.\r\n>    It is a very small payload and would be distributed very quickly. A web\r\n>    conferencing application already has a roundtrip delay in sharing slides,\r\n>    because only one person can share at a time, and so the orchestrator needs\r\n>    to coordinate who has the right to share. The delta catalog update would\r\n>    happen in parallel to any such orchestration. By using the catalog update,\r\n>    you inherit the content selection, initialization, track relationship and\r\n>    access control built in to that solution. I think this solution is a clean\r\n>    one and I'd like to see evidence from some of the early conferencing poc's\r\n>    that it is insufficiently performant.\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/moq-wg/moq-transport/issues/253#issuecomment-1740644258>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AAKVXZBUMKFSWIRI74UAY7DX42NBHANCNFSM6AAAAAA5JYAHCE>\r\n> .\r\n> You are receiving this because you commented.Message ID:\r\n> ***@***.***>\r\n>\r\n",
          "createdAt": "2023-09-29T10:39:06Z",
          "updatedAt": "2023-09-29T10:39:06Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> This might add some complexity, but I think we will need it for conference call case; otherwise the join latency will depend on a catalog update.\r\n\r\nI'm proposing that the meeting host (participant or service) maintains a meeting catalog track of all participants. All participants are subscribed to this track, so when a new participant is added, the catalog update is effectively pushed. \r\n\r\n```\r\n-> SUBSCRIBE meeting/catalog\r\n<- SUBSCRIBE_OK meeting/catalog\r\n<- OBJECT meeting/catalog 0\r\n<- OBJECT meeting/catalog 1\r\n...\r\n(alice joins)\r\n<- OBJECT meeting/catalog 2\r\n```\r\n\r\nHow Alice joins the meeting is up to the application; somehow the meeting host needs to get the catalog from Alice. It could be part of a `api.webex.com/join` API call that you'll need anyway for 3rd party CDN support, or it could be via an ANNOUNCE from Alice. Either way, the meeting host updated the meeting catalog and each participant can fetch Alice's media.\r\n\r\n```\r\n-> SUBSCRIBE meeting/alice/audio\r\n-> SUBSCRIBE meeting/alice/video\r\n<- SUBSCRIBE_OK meeting/alice/audio\r\n<- SUBSCRIBE_OK meeting/alice/video\r\n<- OBJECT meeting/alice/audio 0\r\n<- OBJECT meeting/alice/video 0\r\n```\r\n\r\nThis adds another RTT so the viewer can choose which tracks it wants. You're right that this RTT could be avoided if every participant produced required tracks using required codecs. However, you will eventually need to support optional codecs, optional renditions, and/or optional tracks. It's possible with catalog-less, but it would be gross as it would require unsubscribing to individual wildcard matches. \r\n\r\nAnother issue with catalog-less is the lack of a central authority. I don't see how you could remove a participant from a meeting, or approve a participant to screen share, or force mute a participant, or really perform any sort of access control. With a catalog, the meeting host (possibly `api.webex.com`) can push a delta update to add/remove/modify tracks based on UI interaction. With a wildcard subscribe instead... I'm not sure what you would do actually.",
          "createdAt": "2023-09-29T11:33:46Z",
          "updatedAt": "2023-09-29T12:34:47Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "(Will and Ted replied while I was drafting my latest wall of text)\r\n\r\n\r\n> The wildcard approach is alluring in its simplicity. However it opens up a strong vector for unintentional (or perhaps malicious) DOS'ing of a distribution relay.\r\n\r\nThe auth token would definitely need to scope wildcard SUBSCRIBEs, much like it would already scope individual SUBSCRIBEs. I don't think this is a problem.\r\n\r\n> Waiting for a catalog track and re-request will mean someone joining will take longer to be visible/audible to other participants and may \"arrive\" at different time scales for different participants. \r\n\r\nI agree that a periodic catalog refresh ala HLS would be a poor experience.\r\n\r\nWill and I want a live catalog track so there's no \"re-request\". Each update gets \"pushed\" to all participants since they will be subscribed to the meeting catalog track. There's no arrival variance other than the latency to origin.\r\n\r\n> You could also design this so that the latecomer (Carol) can distribute a catalog track as well, so that any other tracks offered (including alternate video or audio codecs) would be available shortly.\r\n\r\nIt's just a lot of complexity to save an RTT or two on join. You could save those RTTs in other ways, like pushing the catalog update while the webcam/encoder is initializing, so subscriptions are active before any OBJECTs are generated. I think it's premature to optimize for RTTs, especially when it's not clear how you would implement standard conferencing functionality without a catalog.",
          "createdAt": "2023-09-29T12:26:12Z",
          "updatedAt": "2023-09-29T12:38:14Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Wildcard subscribe doesn't imply catalog-less :-) . \r\n\r\nuse-cases that needs supporting group semanitcs (not the moqt group, but group of users in a chat room, group of members for whom there will be policy (security) updates  published frequently and so on)  will be benefited with something like wildcard. All these cases require  the subscriber to not know  full track names before hand or will end up being too noisy with several catalog updates or can incur latencies. ",
          "createdAt": "2023-10-04T11:54:49Z",
          "updatedAt": "2023-10-04T11:57:25Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment: \r\n\r\nIt seems to me that this is an optimization to save some RTTs, but that is meaningful and worth investigating.\r\n\r\nDoes anyone have a sketch of how this might work with the constructs we have in the current draft?\r\n\r\nI keep running back into the Track Alias problem, which is that objects can suddenly arrive at a receiver who does not have any reference of what they are if the OBJECT races the OK.  Maybe something like this:\r\n\r\n```\r\nWILDCARD_SUBSCRIBE {\r\n  # matching criteria, TBD\r\n  Num Reserved Subscription IDs (i)\r\n  [Reserved Subscription ID (i)] +\r\n}\r\n```\r\n\r\nWhen a track is available the matches the criteria, all objects get a preface with the track name / subscription ID mapping\r\n\r\n```\r\nWILDCARD_SUBSCRIBE_OK {\r\n  Full Track Name\r\n  Subscription ID (i)\r\n  # other useful info\r\n}\r\nOBJECT_STREAM | STREAM_HEADER_TRACK | STREAM_HEADER_GROUP\r\n```\r\n\r\nMaybe the subscriber could issue a regular subscribe after seeing the mapping header or a catalog update and that would get rid of the extra overhead within a few RTTs.  Another option is send the WILDCARD_SUBSCRIBE_OK on the control stream, and the receiver may have to buffer unknown objects, but only if it's using wildcards.\r\n\r\nThe publisher/relay can also send messages to indicate it needs more subscribe IDs.",
          "createdAt": "2024-02-07T04:04:15Z",
          "updatedAt": "2024-02-07T04:04:15Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "One option is as follows: if you subscribe to `foo/*` in SUBSCRIBE identified by number 123, and you receive an object for `foo/bar`, you can abbreviate it as `(123, bar)`.",
          "createdAt": "2024-02-07T16:37:54Z",
          "updatedAt": "2024-02-07T16:37:54Z"
        }
      ]
    },
    {
      "number": 254,
      "id": "I_kwDOG2Ho4M5yVCDx",
      "title": "Draft Numbering",
      "url": "https://github.com/moq-wg/moq-transport/issues/254",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Editorial"
      ],
      "body": "Can we PLEASE number editor's drafts as draft-ietf-moq-transport-latest?\r\n\r\nCurrently, it says draft-00, which can result is significant confustion with respect to the last published draft and creates an unstable interop target.",
      "createdAt": "2023-09-28T19:12:56Z",
      "updatedAt": "2023-10-09T17:40:01Z",
      "closedAt": "2023-10-09T17:40:01Z",
      "comments": []
    },
    {
      "number": 259,
      "id": "I_kwDOG2Ho4M5yZ3ER",
      "title": "Sender-side ABR",
      "url": "https://github.com/moq-wg/moq-transport/issues/259",
      "state": "OPEN",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Parked"
      ],
      "body": "The basic problem is: the publisher provides two versions of the same track, let's say, `video/360p` and `video/720p`; the subscriber wants to receive only one of those, and it best quality it can receive in a timely manner.  It makes more sense to make this switch at the sender, since the sender's congestion controller ultimately decides how much data the sender is going to send short-term.\r\n\r\n@kixelated proposed before to allow the sender to subscribe to a list of tracks in order of preference, so something like `SUBSCRIBE_REQUEST video/720p video/360p` would result in 720p video being sent preferentially when available.  I like this approach, though we do need to specify more details first.  For instance, what are the conditions under which the sender is allowed to switch?  I think those should be group boundaries (and we should also require alignment between tracks if you want to subscribe to those as an alternative).",
      "createdAt": "2023-09-29T14:32:31Z",
      "updatedAt": "2024-02-07T16:45:03Z",
      "closedAt": null,
      "comments": [
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "At June interim I presented this slide on a proposal for server-side ABR. Still like this approach. Requiring the server to have an estimate of the throughput is reasonable. We'd also need to figure out some convention to remove a track from a previously declared ABR group. Perhaps as simple as unsubscribe it and then resubscribe without a group number. \r\n\r\n![Screenshot 2023-09-29 at 5 02 53 PM](https://github.com/moq-wg/moq-transport/assets/2762250/9ad57aba-e3fc-4321-ab92-5a6d2fb82316)\r\n\r\nThe catalog draft proposes the [altGroup identifier](https://www.ietf.org/archive/id/draft-wilaw-moq-catalogformat-01.html#name-alternate-group), which would map conveniently to the group descriptor in the above image. ",
          "createdAt": "2023-09-29T15:09:26Z",
          "updatedAt": "2023-09-29T15:15:11Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we should be able to atomically subscribe to the entire switching set at once, otherwise one of the subscriptions may have an error, leaving the subscriber in a half-subscribed state.",
          "createdAt": "2023-09-29T15:16:14Z",
          "updatedAt": "2023-09-29T15:16:14Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's certainly feasible with some type of subscribe object carrying name and an optional throughput threshold\r\n\r\n`SUBSCRIBE ({\"n\":\"4k\", \"throughput\":16000},{\"n\":\"hd\",\"throughput\":8000},{\"n\":\"sd\"})`\r\n\r\nWe already have other subscribe hints we want to hang off the subscription, so they could all be properties of a subscribe object\r\n\r\nAlthough I would argue that even it you atomically subscribe, one of the subscriptions can still fail. Do you then fail the whole atomic group? I would think most players would want a notification of the failed track but then still continue with the tracks that are available. I like the flexibility for players to subscribe individually, convey ABR group as part of that subscription and get notified of failure individually.",
          "createdAt": "2023-09-29T15:29:41Z",
          "updatedAt": "2023-09-29T15:29:41Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I implemented ranked delivery and it worked very well. The server would select a track based on the estimated bitrate.\r\n\r\n```\r\nSUBSCRIBE 0:1080p or 1:720p or 2:480p or 3:240p\r\n```\r\n\r\nHowever, the relay had access to the HLS playlist so it both knew the rendition bitrate and the switch points. I don't know the best way to support this within a generic MoQ relay and need to think more about it.\r\n\r\nOne of the problems with this approach is that it doesn't work between relays. If there's congestion between relays, then it should switch down for all downstream subscriptions too. This would be useful for more remote edges (ex. CDN edge on a cruise ship).",
          "createdAt": "2023-09-29T21:02:03Z",
          "updatedAt": "2023-09-29T21:02:03Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">  I don't know the best way to support this within a generic MoQ relay \r\n\r\nOne solution is that relays never make 'ranked delivery' subscriptions upstream. They should always decouple them to individual subscriptions that are not gated on throughput. This also addresses the second concern of \r\n\r\n> If there's congestion between relays, then it should switch down for all downstream subscriptions too.\r\n\r\n\r\n",
          "createdAt": "2023-09-30T08:40:22Z",
          "updatedAt": "2023-09-30T08:40:22Z"
        },
        {
          "author": "acbegen",
          "authorAssociation": "NONE",
          "body": "> It makes more sense to make this switch at the sender, since the sender's congestion controller ultimately decides how much data the sender is going to send short-term.\r\n\r\nThis does not make more sense to me. It is a better move to let the client know what the server thinks how fast it can send but still let the client decide to pick one of the options. The ABR selection is not just a function of the sender's sending rate, it is a function of client's receiving rate plus so many other things that only the client knows about.",
          "createdAt": "2023-09-30T11:23:25Z",
          "updatedAt": "2023-09-30T11:23:25Z"
        },
        {
          "author": "hardie",
          "authorAssociation": "COLLABORATOR",
          "body": "On Sat, Sep 30, 2023 at 12:23\u202fPM Ali C. Begen ***@***.***>\r\nwrote:\r\n\r\n> It makes more sense to make this switch at the sender, since the sender's\r\n> congestion controller ultimately decides how much data the sender is going\r\n> to send short-term.\r\n>\r\n> This does not make more sense to me. It is a better move to let the client\r\n> know what the server thinks how fast it can send but still let the client\r\n> decide to pick one of the options. The ABR selection is not just a function\r\n> of the sender's sending rate, it is a function of client's receiving rate\r\n> plus so many other things that only the client knows about.\r\n>\r\nI agree that the sender's information is incomplete; both sides have\r\nincomplete information.  I tend to prefer letting the client decide both\r\nbecause the congestion/long bandwidth delay tends to be worse client side\r\nand because the client knows what its playout buffer size is.  If it is\r\ncaching a significant amount before starting playout (playing stored ads to\r\nget the buffer size up, for example), it may be willing to take a higher\r\nbitrate than a short-term measurement would indicate.\r\n\r\n(Just a personal opinion, of course).\r\n\r\nTed\r\n\r\n\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/moq-wg/moq-transport/issues/259#issuecomment-1741744367>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AAKVXZF5X66OQ4XWUXFN353X476LTANCNFSM6AAAAAA5MSB77E>\r\n> .\r\n> You are receiving this because you are subscribed to this thread.Message\r\n> ID: ***@***.***>\r\n>\r\n",
          "createdAt": "2023-09-30T13:53:30Z",
          "updatedAt": "2023-09-30T13:53:30Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 to Ted and Ali's points.  Clients assess the recv rate and considering factors like (buffer depth, quality expectations and so on), can make a suitable choice on requesting the right quality stream from the sender. This is done in a loop and constantly updated to meet the application needs. \r\n\r\nSuch a design will also keep relays agnostic to  rate control and media adaptation logic for media which is application and media type specific. \r\n\r\n\r\n",
          "createdAt": "2023-09-30T22:57:15Z",
          "updatedAt": "2023-09-30T22:57:26Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, the fundamental problem is that the sender and receiver have an incomplete view of the world. Whatever the approach, we can't rely on QUIC's congestion control alone for real-time media.\r\n\r\nIf we look at WebRTC for inspiration, sender-side congestion control (GCC) is superior to receiver-side congestion control (REMB). I think you could implement something similar on the receiver with the right feedback, but that's a whole academic pursuit in itself. \r\n\r\nMeanwhile, HLS/DASH uses a combination of TCP (sender-side) and ABR (receiver-side) for congestion control. From my experience, this is inadequate for real-time latency for a multitude of reasons and I can elaborate. This is roughly equivalent to what has been proposed by a few folks, having the receiver detect congestion and resubscribe, but it won't be good enough.\r\n\r\nBut I want to clarify that a goal is **server-side** ABR, which is not necessarily the same as **sender-side** ABR. The problem is dumb 3rd party clients out of your control. At Twitch this was especially a problem with the iOS HLS player, but it's also a problem with clients that are difficult to update, such as smart TVs and consoles. The ability to offload ABR onto the server gives a service more control and the ability to experiment. \r\n\r\nNote that this also applies to broadcasting; the server doesn't want to rely on the stock client behavior. An analogy is RTMP, where the default OBS behavior was to increase the bitrate by 5% every **minute** after each congestion event, which is exceptionally slow. Fortunately OBS is a responsive open-source project, but we didn't have that luxury for other clients like the PlayStation broadcaster.\r\n \r\nI think we need cooperative ABR. Both the sender and receiver need to share their view of the world somehow.",
          "createdAt": "2023-10-01T04:23:46Z",
          "updatedAt": "2023-10-01T04:28:55Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Here's an situation I want to address:\r\n\r\nA broadcast client is transmitting 3 renditions via simulcast: 240p 480p 1080p. A relay server is subscribed to all of them. Viewers use ABR to subscribe to one of the renditions from the relay.\r\n\r\nIf the broadcaster encounters congestion, then the relay will unsubscribe from 1080p or somehow deprioritize it. The problem is that downstream viewers will continue to fetch 1080p, despite it being starved, because the viewer's ABR algorithm did not detect last-mile congestion (via estimated network bitrate). \r\n\r\nOkay so let's say the viewer looks at media timestamps instead of estimated bitrate. It could correctly detect that 1080p is starving due to first-mile congestion, so it switches down.\r\n\r\nHowever this doesn't work if the broadcast client is not using simulcast, but is instead transmitting 1 rendition which is then transcoded into 3 renditions on the server. First mile congestion will equally affect all renditions, so switching down from 1080p to 240p will just make the picture quality worse for no reason. This was very common on Twitch and was one of the reasons why mobile broadcasting was poor.",
          "createdAt": "2023-10-01T05:05:25Z",
          "updatedAt": "2023-10-01T05:15:59Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I think you need some form of chainable sender-side ABR to solve this. Here's a rough idea of what I'm thinking.\r\n\r\n---\r\n\r\nEach viewer only wants to subscribe to a single rendition, so it provides a list of acceptable tracks with OR.\r\n\r\n**viewer**: Provides a list of all acceptable renditions in order of preference\r\n`-> SUBSCRIBE: 480p OR 240p`\r\n\r\n**relay**: Responds with the initial rendition\r\n`<- SUBSCRIBE_OK: 240p`\r\n\r\n**relay**: Responds when the sender-selected rendition changes\r\n`<- SUBSCRIBE_OK: 480p`\r\n\r\n**viewer**: Can change the list at any point. For example: based on the playback buffer, the window size, the estimated bitrate, etc.  \r\n`-> SUBSCRIBE: 1080p OR 480p OR 240p`\r\n\r\n**relay**: Can switch up now if it wants. It may also delay the switch until the cache is populated.\r\n`<- SUBSCRIBE_OK: 1080p`\r\n\r\n---\r\n\r\nThe relay needs to serve multiple viewers, so it requests all acceptable tracks from the origin with AND.\r\n\r\n**relay**: Subscribes to the origin in order of preference\r\n`-> SUBSCRIBE 240p AND 480p AND 1080p`\r\n\r\n**origin**: Replies with the list of tracks\r\n`<- SUBSCRIBE_OK 240p AND 480p AND 1080p`\r\n\r\n**origin**: indicates there's congestion and it's temporarily no longer sending all tracks\r\n`<- SUBSCRIBE_OK 240p AND 480p`\r\n\r\n---\r\n\r\nThe relay can then use this information to modify the viewer's ABR rendition.\r\n\r\n**relay**: Switches the viewer down to 480p\r\n`<- SUBSCRIBE_OK: 480p`\r\n\r\n---\r\n\r\nThis is chainable through an arbitrary number of relays. There could be a lossy hop in the middle, for example GCP -> AWS, or Akamai -> CloudFlare, or satellite -> cruise ship. The ability to propagate ABR decisions seems very powerful.",
          "createdAt": "2023-10-01T05:10:44Z",
          "updatedAt": "2023-10-01T05:16:09Z"
        },
        {
          "author": "acbegen",
          "authorAssociation": "NONE",
          "body": "> Yeah, the fundamental problem is that the sender and receiver have an incomplete view of the world. Whatever the approach, we can't rely on QUIC's congestion control alone for real-time media.\r\n\r\nAgain, QUIC's congestion control is only one of the signals - not just for real-time media but also for streaming.\r\n \r\n> If we look at WebRTC for inspiration, sender-side congestion control (GCC) is superior to receiver-side congestion control (REMB). I think you could implement something similar on the receiver with the right feedback, but that's a whole academic pursuit in itself.\r\n\r\nThere is tons of work in this domain. GCC is so old now, nobody cares about it anymore. There are many client-side algorithms out there, see for example: https://ieeexplore.ieee.org/document/9926128 (pdf is open access). Check Figure 2.\r\n\r\nMicrosoft will run a grand challenge on this for ACM MMSys'24.\r\n\r\n> Meanwhile, HLS/DASH uses a combination of TCP (sender-side) and ABR (receiver-side) for congestion control. From my experience, this is inadequate for real-time latency for a multitude of reasons and I can elaborate. \r\n\r\nI respectfully disagree (see above).\r\n\r\n> This is roughly equivalent to what has been proposed by a few folks, having the receiver detect congestion and resubscribe, but it won't be good enough.\r\n\r\nAgain, HLS/DASH does that because they work over HTTP and till recently, it meant TCP. Since TCP does not expose anything, the entire responsibility for rate adaptation (which you call congestion control) has been carried out by the client. With H3 in the picture, if QUIC exposes some information about its perceived congestion, DASH/HLS clients can be modified to use that info and they will surely do a better job than the sender side.\r\n\r\n> But I want to clarify that a goal is **server-side** ABR, which is not necessarily the same as **sender-side** ABR. The problem is dumb 3rd party clients out of your control. At Twitch this was especially a problem with the iOS HLS player, but it's also a problem with clients that are difficult to update, such as smart TVs and consoles. The ability to offload ABR onto the server gives a service more control and the ability to experiment.\r\n\r\nThis, I agree with. But it is only a good option when the client cannot rate-adapt properly. It is expensive, increases server complexity and messes up a lot of things in the caches. \r\n\r\nIf you are curious enough, see our INFOCOM paper earlier this year. \r\nhttps://ieeexplore.ieee.org/document/10228951\r\npdf is attached.\r\n[IEEE_INFOCOM23.pdf](https://github.com/moq-wg/moq-transport/files/12777672/IEEE_INFOCOM23.pdf)\r\n\r\n> Note that this also applies to broadcasting; the server doesn't want to rely on the stock client behavior. An analogy is RTMP, where the default OBS behavior was to increase the bitrate by 5% every **minute** after each congestion event, which is exceptionally slow. Fortunately OBS is a responsive open-source project, but we didn't have that luxury for other clients like the PlayStation broadcaster.\r\n> \r\n> I think we need cooperative ABR. Both the sender and receiver need to share their view of the world somehow.\r\n\r\nThis is a cost-quality-performance trade-off. As usual, unless we are overdoing it, cooperation will always perform better.\r\n\r\n",
          "createdAt": "2023-10-01T16:54:36Z",
          "updatedAt": "2023-10-01T16:54:36Z"
        },
        {
          "author": "acbegen",
          "authorAssociation": "NONE",
          "body": "> Here's an situation I want to address:\r\n> \r\n> A broadcast client is transmitting 3 renditions via simulcast: 240p 480p 1080p. A relay server is subscribed to all of them. Viewers use ABR to subscribe to one of the renditions from the relay.\r\n> \r\n> If the broadcaster encounters congestion, then the relay will unsubscribe from 1080p or somehow deprioritize it. \r\n\r\nIf the broadcaster is struggling to transmit (simulcast) 3 renditions, it should adjust itself first w/o any relay unsubscribing. Frankly, until I read this post, I did not realize you were referring to the simulcast broadcaster. In this case, the source itself needs to rate-adapt the 3 renditions, or drop one of them.\r\n\r\n> The problem is that downstream viewers will continue to fetch 1080p, despite it being starved, because the viewer's ABR algorithm did not detect last-mile congestion (via estimated network bitrate).\r\n\r\nThey should not if the broadcaster decides to drop 1080p. If it decides to drop the other two, viewers will do just fine.\r\n\r\n> Okay so let's say the viewer looks at media timestamps instead of estimated bitrate. It could correctly detect that 1080p is starving due to first-mile congestion, so it switches down.\r\n> \r\n> However this doesn't work if the broadcast client is not using simulcast, but is instead transmitting 1 rendition which is then transcoded into 3 renditions on the server. First mile congestion will equally affect all renditions, so switching down from 1080p to 240p will just make the picture quality worse for no reason. This was very common on Twitch and was one of the reasons why mobile broadcasting was poor.\r\n\r\nIf the input to the transcoder deteriorates, it should be smart enough to adjust the output streams accordingly. E.g., if the input is now barely 720p, it should output 720p and lower resolutions, not anything higher. \r\n\r\n",
          "createdAt": "2023-10-01T17:06:07Z",
          "updatedAt": "2023-10-01T17:06:07Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> > Yeah, the fundamental problem is that the sender and receiver have an incomplete view of the world. Whatever the approach, we can't rely on QUIC's congestion control alone for real-time media.\r\n> \r\n> Again, QUIC's congestion control is only one of the signals - not just for real-time media but also for streaming.\r\n\r\nI think this is mostly a philosophical disagreement.\r\n\r\nThe shared goal of QUIC/TCP congestion congestion, VBR, ABR is to prevent queuing. They all adjust the send rate in response to signals to keep buffer growth/bloat to a minimum. The difference is the granularity; QUIC/TCP congestion works at packet boundaries, VBR works at encoder frame boundaries, and ABR works at rendition boundaries.\r\n\r\nThe problem with treating these congestion control mechanisms as separate, independent entities is split brain. If QUIC thinks there's congestion but the ABR algorithm doesn't, the buffer grows. If the ABR algorithm thinks there's congestion but the QUIC algorithm doesn't, the network is underutilized. If neither algorithm thinks there's congestion, the buffer grows (bufferbloat).\r\n\r\nMy goal with sender-side ABR is tighter integration with the sender-side congestion control algorithms used by QUIC. The downside with receiver-side ABR is that there's an chasm; cooperation between the sender/receiver is more difficult over a congested (ie. delayed/lossy) network link. This chasm historically hasn't mattered much for ABR given the lack of granularity, but it becomes more and more important as latency is lowered.\r\n\r\n> > If we look at WebRTC for inspiration, sender-side congestion control (GCC) is superior to receiver-side congestion control (REMB). I think you could implement something similar on the receiver with the right feedback, but that's a whole academic pursuit in itself.\r\n> \r\n> There is tons of work in this domain. GCC is so old now, nobody cares about it anymore. There are many client-side algorithms out there, see for example: https://ieeexplore.ieee.org/document/9926128 (pdf is open access). Check Figure 2.\r\n> \r\n> Microsoft will run a grand challenge on this for ACM MMSys'24.\r\n\r\nYeah, Twitch struggled mightily with LHLS ABR and ran an ACM grand challenge too. The signals available to the receiver were just insufficient, especially in a browser environment. The sender-side bandwidth estimate is extremely important and it needs to be in MoQ at a minimum.\r\n\r\nI'm quite out of date on the latest algorithms in WebRTC land, but I will add that it's impossible to evaluate congestion control algorithms outside of production. It would be a huge mistake to rule out sender-side ABR in the design phase without proper experimentation.\r\n\r\n> Again, HLS/DASH does that because they work over HTTP and till recently, it meant TCP. Since TCP does not expose anything, the entire responsibility for rate adaptation (which you call congestion control) has been carried out by the client. With H3 in the picture, if QUIC exposes some information about its perceived congestion, DASH/HLS clients can be modified to use that info and they will surely do a better job than the sender side.\r\n\r\nTCP exposes the same congestion control stats as QUIC. It has slightly worse RTT estimation but you can get the stats via a syscall (which is how CMSD works). The problem is that those stats are not exposed via HTTP or the browser, and that doesn't change with QUIC or HTTP/3.\r\n\r\nWe need absolutely something like CMSD in MoQ for receiver-side ABR, although it needs to be more frequent because per-segment granularity won't be good enough for real-time latency. ",
          "createdAt": "2023-10-02T02:28:51Z",
          "updatedAt": "2023-10-02T02:28:51Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> If the broadcaster is struggling to transmit (simulcast) 3 renditions, it should adjust itself first w/o any relay unsubscribing. Frankly, until I read this post, I did not realize you were referring to the simulcast broadcaster. In this case, the source itself needs to rate-adapt the 3 renditions, or drop one of them.\r\n\r\nYeah that's kind of my point; simulcast very similar to sender-side ABR. The sender is in charge of which tracks get sent, the only difference being that it can choose up to N tracks instead of up to 1 track.\r\n\r\n> If the input to the transcoder deteriorates, it should be smart enough to adjust the output streams accordingly. E.g., if the input is now barely 720p, it should output 720p and lower resolutions, not anything higher.\r\n\r\nAll renditions will equally deteriorate if there's congestion first-mile when transcoding, but not when using simulcast. The viewer needs some sort of signal to know when to temporarily unsubscribe from 1080p/720p in the simulcast scenario, and when to resubscribe after recovery. \r\n\r\nIf this signal is in the catalog, it will only work first-mile. If this signal is in MoqTransport, it can work for any hop. My proposal is basically to have the receiver and sender choose a subset of tracks and the intersection is the active subscription.",
          "createdAt": "2023-10-02T02:48:17Z",
          "updatedAt": "2023-10-02T02:48:17Z"
        }
      ]
    },
    {
      "number": 260,
      "id": "I_kwDOG2Ho4M5yftqt",
      "title": "Subscription requests and buffers",
      "url": "https://github.com/moq-wg/moq-transport/issues/260",
      "state": "CLOSED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "suhasHere"
      ],
      "labels": [
        "Needs PR",
        "Subscribe"
      ],
      "body": "Currently, we have GROUP SEQUENCE and OBJECT SEQUENCE parameters that allow subscribing to a track at a specific offset.  As far as I can tell, we do not actually describe what happens when those are not present.  I imagine what most subscribers would want is to receive most recent N groups when they subscribe (for some subscriber-specified N that is determined by how large they want their buffer to be), and we should add a parameter for the said N.",
      "createdAt": "2023-10-01T18:54:40Z",
      "updatedAt": "2023-10-23T18:19:16Z",
      "closedAt": "2023-10-23T18:19:16Z",
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "This is a special case of Subscription hint issue IIUC (#245)\n\nWondering if we should discuss together",
          "createdAt": "2023-10-01T20:51:15Z",
          "updatedAt": "2023-10-01T20:51:15Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": ">  As far as I can tell, we do not actually describe what happens when those are not present\r\n\r\nI hit this in moq-chat when traversing a non-caching relay - a client's subscription to a catalog track came after the most recent group/object was published, so the client didn't get a catalog.  Do *all* relays need to implement caching of some kind in order to satisfy late-comer requests?  Or something else?",
          "createdAt": "2023-10-03T23:27:43Z",
          "updatedAt": "2023-10-03T23:27:43Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the default behavior should be to cache/serve the latest group. It's basically required for any sort of catalog. \r\n\r\nBut I do think we should support cache-less senders. They can basically only support `waitup` from #245 and will ignore requests to start subscriptions further back.",
          "createdAt": "2023-10-04T13:30:20Z",
          "updatedAt": "2023-10-04T13:30:20Z"
        }
      ]
    },
    {
      "number": 261,
      "id": "I_kwDOG2Ho4M5y2v4C",
      "title": "Can you have subscribe error after OK ",
      "url": "https://github.com/moq-wg/moq-transport/issues/261",
      "state": "CLOSED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "fluffy"
      ],
      "labels": [
        "Needs PR",
        "Subscribe"
      ],
      "body": "",
      "createdAt": "2023-10-04T20:47:09Z",
      "updatedAt": "2023-10-17T04:24:32Z",
      "closedAt": "2023-10-16T17:28:58Z",
      "comments": [
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "one question is if they come on different streams can they get out order ",
          "createdAt": "2023-10-04T20:48:31Z",
          "updatedAt": "2023-10-04T20:48:31Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "My inclination is to send a SubscriptionEnd {} message with appropriate Reason Code set. This will help to support the case that we discussed on publisher wanting to indicate wanting to stop publishing",
          "createdAt": "2023-10-05T04:51:08Z",
          "updatedAt": "2023-10-05T04:51:08Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "SUBSCRIPTION_END and SUBSCRIPTION_END_ERROR could be split for the graceful vs non-graceful cases.",
          "createdAt": "2023-10-05T20:31:25Z",
          "updatedAt": "2023-10-05T20:31:25Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussion in room  seems to be rather not have an error after OK but instead use new messages or in subscribe_end message",
          "createdAt": "2023-10-05T20:31:30Z",
          "updatedAt": "2023-10-05T20:31:30Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd like to consolidate messages at some point, but we can revisit later.",
          "createdAt": "2023-10-17T04:24:32Z",
          "updatedAt": "2023-10-17T04:24:32Z"
        }
      ]
    },
    {
      "number": 263,
      "id": "I_kwDOG2Ho4M5zAQ-D",
      "title": ".editorconfig",
      "url": "https://github.com/moq-wg/moq-transport/issues/263",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Editorial"
      ],
      "body": "Could we include an [.editorconfig](https://editorconfig.org/) file? It wouldn't be required, but it would reduce the amount of reformatting required.\r\n\r\n[The QUIC configuration is good.](https://github.com/quicwg/base-drafts/blob/main/.editorconfig)\r\n\r\n```ini\r\nroot = true\r\n\r\n[*.md]\r\ncharset = utf-8\r\nend_of_line = lf\r\nindent_size = 2\r\nindent_style = space\r\ninsert_final_newline = true\r\nmax_line_length = 80\r\ntrim_trailing_whitespace = true\r\n```\r\n\r\n```\r\n% editorconfig-checker draft-ietf-moq-transport.md\r\ndraft-ietf-moq-transport.md:\r\n\t6: Trailing whitespace\r\n\t11: Trailing whitespace\r\n\t175: Trailing whitespace\r\n\t693: Line too long (129 instead of 80)\r\n\t704: Line too long (149 instead of 80)\r\n\t705: Line too long (174 instead of 80)\r\n\t872: Line too long (140 instead of 80)\r\n\t953: Trailing whitespace\r\n\t954: Trailing whitespace\r\n\t955: Trailing whitespace\r\n\t1040: Trailing whitespace\r\n\r\n11 errors found\r\n```\r\n\r\nMost of those long lines were added by me, since my IDE is configured to use 120 lines and tabs by default. If we check in the `.editorconfig` file then my IDE ([VSCode](https://marketplace.visualstudio.com/items?itemName=EditorConfig.EditorConfig)) will use those settings instead.",
      "createdAt": "2023-10-06T05:13:14Z",
      "updatedAt": "2023-10-19T02:20:43Z",
      "closedAt": "2023-10-19T02:20:43Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "A markdown linter in general might be nice. I don't know what is typical for IETF documents.",
          "createdAt": "2023-10-06T05:58:41Z",
          "updatedAt": "2023-10-06T05:58:41Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Does the repo use the I-D template repo?  I find it has a lot of useful lint checks - you can't push commits that fail the lint",
          "createdAt": "2023-10-06T16:25:02Z",
          "updatedAt": "2023-10-06T16:25:02Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> Does the repo use the I-D template repo? I find it has a lot of useful lint checks - you can't push commits that fail the lint\r\n\r\nWe should use the I-D template. This repo was my first IETF draft, so I didn't know about the template and made something custom.",
          "createdAt": "2023-10-08T07:11:08Z",
          "updatedAt": "2023-10-08T07:11:08Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 on common formatting. Don't care what it is as long as widely used tools support it. FWIW ... I dislike the id-template. It is full of black magic and when it breaks, very few people can fix it. I greatly prefer simplicity over black magic. That said, I don't really care if we use it or not. ",
          "createdAt": "2023-10-09T16:10:15Z",
          "updatedAt": "2023-10-09T16:10:15Z"
        }
      ]
    },
    {
      "number": 265,
      "id": "I_kwDOG2Ho4M5zF3uI",
      "title": "Write up Version Negotiation/Extension Negotiation",
      "url": "https://github.com/moq-wg/moq-transport/issues/265",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Needs Discussion"
      ],
      "body": "I suggested a mechanism in Cambridge and there was broad agreement. We should write it down.",
      "createdAt": "2023-10-06T20:51:56Z",
      "updatedAt": "2023-10-20T18:13:18Z",
      "closedAt": "2023-10-20T18:13:18Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "It might help to put the high level summary here in the issue?",
          "createdAt": "2023-10-06T22:38:35Z",
          "updatedAt": "2023-10-06T22:38:35Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "- The client sends a list of supported versions and the union of all parameters required for SETUP messages in any of the supported versions.\r\n\r\n- These parameters can include ones that communicate support for an extension.\r\n\r\n- The server replies with the selected version, any parameters required for SETUP messages of that version, including any supported extensions as parameters.",
          "createdAt": "2023-10-09T19:35:45Z",
          "updatedAt": "2023-10-09T19:35:45Z"
        }
      ]
    },
    {
      "number": 266,
      "id": "I_kwDOG2Ho4M5zI0ck",
      "title": "Editorial: Error codes",
      "url": "https://github.com/moq-wg/moq-transport/issues/266",
      "state": "OPEN",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Editorial"
      ],
      "body": "I'd like to structure/format the error codes like the QUIC draft. That means all error codes named with `ALL_CAPS` and the error codes inlined with the definition. See: [QUIC](https://datatracker.ietf.org/doc/html/rfc9000#section-20.1) vs [MoqT](https://moq-wg.github.io/moq-transport/draft-ietf-moq-transport.html#name-termination)\r\n\r\nI can make the PR if it sounds gud.",
      "createdAt": "2023-10-08T07:45:43Z",
      "updatedAt": "2023-10-08T07:45:43Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 267,
      "id": "I_kwDOG2Ho4M5zI03r",
      "title": "Graceful session migration",
      "url": "https://github.com/moq-wg/moq-transport/issues/267",
      "state": "OPEN",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "kixelated"
      ],
      "labels": [
        "Needs PR"
      ],
      "body": "I initially added a recommended session migration algorithm in #264. However it's too prescriptive and non-normative and I removed it. However I do think we should talk about what it takes to gracefully migrate a MoqTransport session, if it's non-obvious and should be in the draft (maybe an appendix), and if we need more mechanisms in the protocol.\r\n\r\nThis recommended algorithm requires servers to not error on a duplicate ANNOUNCE. It also results in an RTT where duplicate OBJECTs will arrive on both sessions, which is not necessarily ideal. Here's the original text before I removed it:\r\n\r\n> ### Graceful {#session-migration-graceful}\r\n> A graceful session migration involves migrating all subscriptions between\r\n> sessions without impeding data flow. The application should be unaware that\r\n> a session migration even occured.\r\n> \r\n> The client SHOULD establish the new MoqTransport session in the background\r\n> since it may take a few round trips to resolve the address and perform any\r\n> handshakes. Once the the new session is established, any active subscriptions\r\n> and announcements are removed from the old session and issued on the new\r\n> session.\r\n> \r\n> An endpoint MAY choose to abruptly transition between sessions. However it is\r\n> RECOMMENDED that both sessions are simultaneously active for a brief window\r\n> while subscriptions are individually migrated. The client and server migrate any\r\n> active announcements and subscriptions depending on their role(s) as covered\r\n> below.\r\n> \r\n> The client terminates the old session once there are no more active\r\n> subscriptions or announcements. The client MAY choose to delay if OBJECTs are\r\n> still being sent/received as queues are drained, but should be prepared to\r\n> receive a GOAWAY Failure from the server if it waits too long.\r\n> \r\n> #### Publisher\r\n> A publisher needs to migrate all active announcements to the new session. For\r\n> each active announcement:\r\n> \r\n> 1. The publisher sends an ANNOUNCE on the new session.\r\n> 2. The publisher receives an ANNOUNCE\\_OK on the new session.\r\n> 3. The publisher sends an UNANNOUNCE on the old session.\r\n> 4. The publisher receives an ANNOUNCE\\_ERROR on the old session, acknowledging\r\n>    the UNANNOUNCE.\r\n> \r\n> Once these steps are complete, new subscriptions will arrive on the new session\r\n> instead of the old session. The publisher may receive new subscriptions in the\r\n> meantime which should be served normally.\r\n> \r\n> #### Subscriber\r\n> A subscriber needs to move all active subscriptions to the new session. For each\r\n> active subscription:\r\n> \r\n> 1. The client sends a SUBSCRIBE message on the new session, starting one past\r\n>    the maximum received object sequence.\r\n> 2. The client sends an UNSUBSCRIBE message on the old session.\r\n> 3. The client receives a SUBSCRIBE\\_OK on the new session.\r\n> 4. The client receives a SUBSCRIBE\\_ERROR on the old session, acknowledging the\r\n>    UNSUBSCRIBE.\r\n> \r\n> The SUBSCRIBE and UNSUBSCRIBE are sent in parallel to avoid underutilizing the\r\n> network, however this results in overutilizing the network for at least an RTT.\r\n> The endpoint may receive duplicate OBJECT messages across both sessions which\r\n> MUST be discarded.",
      "createdAt": "2023-10-08T07:51:27Z",
      "updatedAt": "2023-10-24T00:58:57Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it'd be useful to have a PR to look at if you're willing to write one up?",
          "createdAt": "2023-10-24T00:58:57Z",
          "updatedAt": "2023-10-24T00:58:57Z"
        }
      ]
    },
    {
      "number": 268,
      "id": "I_kwDOG2Ho4M5zPvYc",
      "title": "Define and register the moqt:// URL ",
      "url": "https://github.com/moq-wg/moq-transport/issues/268",
      "state": "OPEN",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-09T17:29:23Z",
      "updatedAt": "2023-10-16T18:38:10Z",
      "closedAt": null,
      "comments": [
        {
          "author": "hardie",
          "authorAssociation": "COLLABORATOR",
          "body": "Do we want moq or moqt ?\r\n\r\nOn Mon, Oct 9, 2023 at 6:29\u202fPM Cullen Jennings ***@***.***>\r\nwrote:\r\n\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/moq-wg/moq-transport/issues/268>, or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AAKVXZHISDN3DRZOMC3BZATX6QX77AVCNFSM6AAAAAA5ZEA6CKVHI2DSMVQWIX3LMV43ASLTON2WKOZRHEZTGNJQGYYDONQ>\r\n> .\r\n> You are receiving this because you are subscribed to this thread.Message\r\n> ID: ***@***.***>\r\n>\r\n",
          "createdAt": "2023-10-10T15:21:35Z",
          "updatedAt": "2023-10-10T15:21:35Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Shorter is better when it comes to names. So I'd suggest moq://",
          "createdAt": "2023-10-10T16:10:43Z",
          "updatedAt": "2023-10-10T16:10:43Z"
        },
        {
          "author": "hardie",
          "authorAssociation": "COLLABORATOR",
          "body": "On Tue, Oct 10, 2023 at 5:10\u202fPM Will Law ***@***.***> wrote:\r\n\r\n> Shorter is better when it comes to names. So I'd suggest moq://\r\n>\r\n> BCP 35 (RFC 7595), section 3.8 has the guidance for selecting a scheme\r\nname.  The reason we might prefer moqt is this:\r\n\r\n   A scheme name is not a \"protocol.\"  However, like a service name as\r\n   defined in Section 5 of [RFC6335], it often identifies a particular\r\n   protocol or application.  If a scheme name has a one-to-one\r\n   correspondence with a service name, then the names SHOULD be the\r\n   same.\r\n\r\nThe part of the system we're defining at this point is the transport, and\r\nwe expect there to be other parts of the overall MoQ ecosystem (the\r\nmappings, the catalog formats, and so on).  Specifying that this refers to\r\nthe transport itself may be useful if any other part of the system would\r\nalso like to use URIs  as identifiers.\r\n\r\nNeither of them seems likely to collide with other uses any time soon, so I\r\ndon't think we need to make the decision urgently, so it may be useful to\r\nconsider whether any other bits will want their own schemes before we\r\ncommit to this scheme name.\r\n\r\n\r\n\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/moq-wg/moq-transport/issues/268#issuecomment-1755769073>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AAKVXZAYBUDBZFY6SCOCHXDX6VXQ7AVCNFSM6AAAAAA5ZEA6CKVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMYTONJVG43DSMBXGM>\r\n> .\r\n> You are receiving this because you commented.Message ID:\r\n> ***@***.***>\r\n>\r\n",
          "createdAt": "2023-10-11T07:58:17Z",
          "updatedAt": "2023-10-11T07:58:17Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 to Ted. Let's use `moqt://` for the transport and save `moq://`, probably for the media layer.",
          "createdAt": "2023-10-11T08:53:31Z",
          "updatedAt": "2023-10-11T08:53:31Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm perfectly happy with either.",
          "createdAt": "2023-10-16T18:37:39Z",
          "updatedAt": "2023-10-16T18:37:39Z"
        }
      ]
    },
    {
      "number": 269,
      "id": "I_kwDOG2Ho4M5zP0Mj",
      "title": "Multiple subscriptions and updating a subscription",
      "url": "https://github.com/moq-wg/moq-transport/issues/269",
      "state": "OPEN",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Needs Discussion",
        "Subscribe"
      ],
      "body": "It would be useful to clarify whether multiple subscriptions are valid, and whether there are any constraints on them (ie: non-overlapping).\r\n\r\n@kixelated brought up the fact that a relay may have to issue overlapping subscribes because it doesn't know whether a relative or absolute subscription is earlier.\r\n\r\nA related question is how one updates a subscription, for example if you wanted to seek closer to realtime, and whether that is just UNSUBSCRIBE/SUBSCRIBE or a new SUBSCRIBE_UPDATE message.  There may be cases where SUBSCRIBE_UPDATE is more efficient and better at avoiding sending duplicate objects.",
      "createdAt": "2023-10-09T17:44:45Z",
      "updatedAt": "2024-03-04T03:10:59Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DanielFay22",
          "authorAssociation": "NONE",
          "body": "If multiple subscribes are allowed, would that result in multiple transmission of the same data, or a single stream that the endpoint is expected to process/fanout? If the former then I think that there could be some potential for exploit there if a user could effectively make unbounded requests for a single track.\r\n\r\nAs for the SUBSCRIBE_UPDATE, I think that if updating subscriptions is a supported action then having an explicit message for it is generally better. A side effect of this would be that with a SUBSCRIBE_UPDATE message a failure to update can just continue the current subscription unchanged. With an UNSUBSCRIBE/SUBSCRIBE method, if the SUBSCRIBE request fails the subscriber is left without an active subscription, which is potentially more disruptive.",
          "createdAt": "2023-10-09T19:15:55Z",
          "updatedAt": "2023-10-09T19:15:55Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "When discussed, there was general interest in a SUBSCRIBE_UPDATE, but given we haven't landed a change to add subscription hints, I think it makes sense to land that first.\r\n\r\nA related issue is that a server could select the same Track ID for multiple subscriptions, which creates ambiguity about what subscription an object is for, but the object metadata could be used to distinguish in some cases.  This is where the dedupe question becomes interesting on a number of levels.\r\n\r\nThe most problematic issue I can see with multiple subscriptions is that UNSUBSCRIBE and SUBSCRIBE_ERROR use the full track name, but if there are multiple subscriptions to the same track, there's no way to disambiguate between them.\r\n\r\n",
          "createdAt": "2023-10-10T18:36:58Z",
          "updatedAt": "2023-10-10T18:36:58Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One point to consider with the multiple subscriptions is relays aggregating subscription requests upstream. Consider the case of a relay which has 5 clients connected (in reality it could have thousands). Those 5 clients make different subscription requests to (), (-1),(-5),(345-375) to the same track and they arrive in that order.\r\n\r\nThe relay sends the first SUBSCRIBE() upstream. What should it do for the 2nd and subsequent? Using SUBSCRIBE_UPDATE(-1) is not appropriate, since the prior request is still valid. The reality is that an aggregating relay needs to be able to make multiple SUBSCRIBES in parallel to different points within a given track.\r\n\r\nAssuming we allow parallel subscribes to happen, then a second problem is how does the relay tell the responses apart? Assume it gets group 345 as the first group back. Is that the first group of the live track, or -1 back, or -5, or just the start of the DVR section?\r\n\r\nOne solution is that the upstream relay assign a different trackID to each type of SUBSCRIBE request even if its for the same track. It must assign trackIDs based on similar SUBSCRIBE arguments, not just the track name.  This does mean that duplicate objects will be sent over the wire. For example group 345 might be sent 4 times, each time with a different trackID. This duplicity exists as long as we allow relative subscriptions. If we restrict ourselves to absolute only , then there will be no duplicity. \r\n",
          "createdAt": "2023-10-10T20:47:58Z",
          "updatedAt": "2023-10-10T20:47:58Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "A side benefit for a separate SUBSCRIBE_UPDATE message is that you don't need to retransmit the full track name again.\r\n\r\nBut yeah I can see situations where you don't want duplicates (relative subscriptions) and others where you want duplicates (seeking with no cache).\r\n\r\nI think SUBSCRIBE should take multiple start-end ranges. Deduplication would occur per subscribe ID, and you would use SUBSCRIBE_UPDATE if you want to expand or shrink the ranges.\r\n\r\nI don't think we can use multiple SUBSCRIBE messages with the same ID because like Ian pointed out, it's difficult to disambiguate them. What if you want to cancel the relative subscription but not the absolute one? How do you signal that two subscribes should be deduplicated while another two subscribes should be duplicated?\r\n\r\nWe could have multiple SUBSCRIBE messages with different subscription IDs but the same track ID. Deduplication would be performed per track ID. That opens some edge cases, like if the SUBSCRIBEs are for different track names, which can be avoided by using multiple ranges instead. But I kinda like it.\r\n\r\nAlthough if deduplicate occurs per track ID, this limits the sender's ability to choose an ID.",
          "createdAt": "2023-10-11T00:18:19Z",
          "updatedAt": "2023-10-11T00:19:33Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Having the subscription ID different from the Track ID seems to add another layer of complexity.  I really hope that is not necessary.\r\n\r\nI'm not sure what our goals are, but if we want to avoid duplicates then I'd suggest the Producer reject duplicate subscriptions and respond to overlapping subscriptions with the range they are intending to deliver.  Combined with unique track IDs, this makes it easy for the consumer to know what to expect.",
          "createdAt": "2023-10-11T00:46:47Z",
          "updatedAt": "2023-10-11T00:46:47Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "> subscription ID different from the Track ID \r\n\r\nIt's been brought up before that 'Track ID' could be renamed 'Subscription ID', but there wasn't clear consensus before.  Perhaps resolving whether multiple simultaneous subscriptions are allowed to the same track will illuminate the right naming - does it identify a track, or a track + subscribe parameters?",
          "createdAt": "2023-10-11T18:32:47Z",
          "updatedAt": "2023-10-11T18:32:47Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Conclusions from IETF118 : \r\n- Support subscribe update when track name alias and subscribe id matches. \r\n- Track Name Alias is compression scheme for Full Track name and copied in every object\r\n- Subscribe ID is transaction identifier and will not be carried in the object header",
          "createdAt": "2023-11-06T14:25:20Z",
          "updatedAt": "2023-11-06T14:25:20Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment:\r\n\r\nIf the OBJECT does not contain the subscribe ID, then we need to update Subscribe OK to resolve any relative groups or objects.  Otherwise, a receiver won't know if a particular object belongs to a particular subscription.  \r\n\r\nThere's also no point in sending duplicate objects, since they would all be identical.  This is why I inferred that \"MUST NOT deduplicate\" implies OBJECt includes subscribe ID.  Am I misreading this?",
          "createdAt": "2023-11-06T15:12:44Z",
          "updatedAt": "2023-11-06T15:12:44Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> If the OBJECT does not contain the subscribe ID, then we need to update Subscribe OK to resolve any relative groups or objects. Otherwise, a receiver won't know if a particular object belongs to a particular subscription.\r\n\r\nYeah, we need SUBSCRIBE_OK to map from relative -> absolute anyway.\r\n\r\nFor example, a player wants to start rendering the broadcast 3 groups from latest. If it receives group N, can it render it? Without the mapping, no it cannot.\r\n\r\n> There's also no point in sending duplicate objects, since they would all be identical. This is why I inferred that \"MUST NOT deduplicate\" implies OBJECt includes subscribe ID. Am I misreading this?\r\n\r\nYeah... it wasn't clear if OBJECT contains subscribe ID. If the OBJECTs are byte-for-byte identical, why on earth MUST a publisher send duplicate objects?",
          "createdAt": "2023-11-06T15:22:54Z",
          "updatedAt": "2023-11-06T15:22:54Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Conclusion from the session was to add a frame to explicitly change/update an active subscription instead of relying upon UNSUBSCRIBE and SUBSCRIBE, because there are easy optimizations that can be made and it makes it easy to ensure there aren't gaps in subscriptions.",
          "createdAt": "2023-11-09T17:26:32Z",
          "updatedAt": "2023-11-09T17:26:32Z"
        }
      ]
    },
    {
      "number": 270,
      "id": "I_kwDOG2Ho4M5zQRoZ",
      "title": "Rethinking the track-id issue",
      "url": "https://github.com/moq-wg/moq-transport/issues/270",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Subscribe"
      ],
      "body": "TL-DR: if we move the Track-ID out of the object field and into a stream or datagram header, we can copy object messages directly to the stream without having to reformat them.\r\n\r\nWe have been debating solutions to the track-ID problem, with two opposite goals:\r\n\r\n- have the server choose the track-id, so the \"object\" values can be copied as is to the output streams\r\n- have the client choose the track-id, and avoid the race condition between subscribe OK and first object messages.\r\n\r\nSee Issue #145, PR #258 and #262, and minutes from the October 2023 interim.\r\n\r\nThe debate is leading to a muddled compromise, in which a default behavior is \"client chooses\" with some TBD escape condition if the publisher really wants to choose -- which would have to be something better than an error return on every subscribe. I wonder if there is a simple solution.\r\n\r\nBig relays with large fan-out do not like having to reformat messages \"on the fly\". They would prefer being able to simply copy messages from their cache. This is difficult because of the current definition of the OBJECT message:\r\n~~~\r\nOBJECT Message {\r\n  Track ID (i),\r\n  Group Sequence (i),\r\n  Object Sequence (i),\r\n  Object Send Order (i),\r\n  Object Payload Length (i),\r\n  Object Payload (b),\r\n}\r\n~~~\r\nThe bits on the wire look like:\r\n\r\n| fields | Object Message ID | Track ID | Group, sequence, send order, payload length, object payload |\r\n|------|-----|-----|-----------------|\r\n| On receive | constant | variable length integer | value specific to the object |\r\n| On send | constant | different variable length integer | value specific to the object |\r\n\r\nIf the track-id is not the same for all receivers, the relays will need for every object to:\r\n\r\n- Find out what Track ID to use on the publishing connection, which requires decompressing the Track ID into a Full Track Name on receive, then mapping that Full Track Name to the receiver selected Track ID when publishing,\r\n- Reformat the Object message to incorporate the receiver chosen track ID.\r\n- Send the modified copy to the receiver\r\n\r\nYes, it is possible to use a scatter gather copy, so as to write three segments in place: the constant value message type, the track-id selected by the receiver, and the object specific part of the object message. Implementation would be reasonably simple if the cached value of the track ID was fixed length, e.g. an internal 64 bit identifier of the track. But this scatter-gather would have to be done for each object and each receiver, which is going to cost several instructions per message.\r\n\r\nWe can observe that in several of the proposed transport encoding, several messages will be sent on the single QUIC stream, and also that a single QUIC stream will typically carry only messages from a single track. Suppose that the stream data start with a \"Track-ID\" message:\r\n~~~\r\nTRACK-ID Message {\r\n  Track ID (i)\r\n}\r\n~~~\r\nFollowed by set of object messages:\r\n~~~\r\nOBJECT Message {\r\n  Group Sequence (i),\r\n  Object Sequence (i),\r\n  Object Send Order (i),\r\n  Object Payload Length (i),\r\n  Object Payload (b),\r\n}\r\n~~~\r\nIf the stream only includes objects of the same track, the Track-ID needs to be sent just once. The OBJECT Message would have no variable part, which is useful for caching. The cache itself will have to maintain a relation between cached objects and corresponding track, but it already does, so not a big change. We will save some byte per object message (the track-id varint), at the cost of the TRACK-ID message (one byte message ID plus track-id varint), which means one extra byte if a stream has just one Object, several fewer bytes if the stream has multiple objects. We will also save a couple instructions when pushing messages to streams.\r\n\r\nComments? Was this just the bad-idea fairy putting words in my mouth?",
      "createdAt": "2023-10-09T19:12:23Z",
      "updatedAt": "2024-01-31T00:49:14Z",
      "closedAt": "2024-01-31T00:49:14Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual comment:\r\n\r\nI very much like the separation of hop-by-hop compression information from end-to-end object information - it makes caching a lot clearer.  I also think it's reasonable to restrict one QUIC stream or datagram to at most one track.\r\n\r\nIs your proposal to also move to \"subscriber picks the ID\" along with this proposal? \r\n\r\n> means one extra byte if a stream has just one Object\r\n\r\nSince I think we are headed towards a stream identifier at the beginning of every stream to indicate if it is an object stream or the control stream, I think this can be collapsed and not cost a net extra byte.\r\n\r\nI'll note that when the publisher is sending stream-per-object, the id rewriting cost is the same as other subscriber chooses proposals.",
          "createdAt": "2023-10-09T22:58:04Z",
          "updatedAt": "2023-10-09T22:58:04Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I would love to see a `STREAM` header for other reasons. I think it's a foot-gun to allow multiple OBJECTs on the same stream that do not share the same track, priority*, and even group (but I know that last one is controversial).\r\n\r\nAnd even if we do allow objects on the same stream with the same value, perhaps you could send another STREAM message. This would avoid encoding redundant values over and over again, or maybe it could even be used as a signal for when the relay should create a new stream (re: stream mapping).\r\n\r\n```\r\nSTREAM track=0 group=4 priority=3\r\nOBJECT sequence=0\r\nOBJECT sequence=1\r\n...\r\nOBJECT sequence=58\r\nOBJECT sequence=59\r\nSTREAM track=0 group=5 priority=3\r\nOBJECT sequence = 0\r\nOBJECT sequence = 1\r\n...\r\n```\r\n\r\nBut yeah when there's a single OBJECT per stream, this proposal doesn't really change anything on the wire. But the `scatter gather copy` approach like you described would be built into the protocol which is definitely a little cleaner. I'm all for it.\r\n\r\n\\* some QUIC implementations support decreasing priorities, but increasing priorities is incompatible with QUIC's flow control.",
          "createdAt": "2023-10-11T00:45:33Z",
          "updatedAt": "2023-10-11T00:45:59Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The OBJECT Message would have no variable part, which is useful for caching.\r\n\r\nIs it useful for caching? I think the opposite might be true.   At a bare minimum, a cached object needs a unique name.   When the trackID is carried in a QUIC stream header, then the interpretation of an OBEJCT, and its position in the cache, is bound to the stream on which it arrived. This has a few drawbacks:\r\n  - its a bit of a layer violation , using the transport protocol to transmit a key attribute of the pub/sub protocol. \r\n  - it removes the flexibility of mapping OBJECTS to streams. Once you've started a stream, you are constrained as to which objects can be placed inside it. \r\n -  consider the case of advanced relays in which the components receiving steams are decoupled from those sending them, or the case where the QUIC transmission is handled via hardware (in the near future) and the stream payload received via API. In these cases the stream header would have to be extracted and routed via some metadata for each object, at which point it might just as well have been in each object. \r\n\r\nWith the track ID carried in the OBJECT header, the Object is atomic. This is a useful feature. The atomic OBJECT becomes the common currency between the receive and send sides of a relay. So I think its better to stick with our original concept of a trackID in the OBJECT header and head back to #145 to figure out an efficient way to do that. \r\n",
          "createdAt": "2023-10-17T19:24:54Z",
          "updatedAt": "2023-10-17T19:24:54Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual comment:\r\n\r\n> With the track ID carried in the OBJECT header, the Object is atomic.\r\n\r\nThat's not entirely true, since the track ID today is scoped to a session.  I can't cache an object as {TrackID, GroupNum, ObjNum}, I have to cache it as {Full Track Name, GroupNum, ObjNum}.  So no matter how we pick or transmit the compression identifier for the full track name, the wire representation of the object is not cacheable as is - you have to decompress it first.\r\n\r\n> then the interpretation of an OBEJCT, and its position in the cache, is bound to the stream on which it arrived\r\n\r\nFWIW this is true for HTTP responses too.  A response doesn't contain the URL.  You use the stream ID to join it with the request to know the name of the thing.",
          "createdAt": "2023-10-17T19:45:48Z",
          "updatedAt": "2023-10-17T19:45:48Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> > then the interpretation of an OBEJCT, and its position in the cache, is bound to the stream on which it arrived\r\n> \r\n> FWIW this is true for HTTP responses too. A response doesn't contain the URL. You use the stream ID to join it with the request to know the name of the thing.\r\n\r\nYeah, I do want to emphasize that HTTP caches do NOT cache the raw response bytes.\r\n\r\nWith HTTP/1.1 it's possible to cache the upstream bytes and forward them downstream unmodified. However, this means the relay cannot modify any headers, so it's extremely situational. Even adding a header like `X-Forwarded-For` means you cannot serve the exact same bytes as received. With HTTP/2 and HTTP/3 it's just impossible to cache the raw response.\r\n\r\nInstead, a relay will parse the headers into a struct/map and marshal it on a per-connection basis. There's certainly some optimizations you can do, like maybe serializing some of the QPACK headers as literals and sharing them across responses, but it's not advisable since it will hurt compression.\r\n\r\n---\r\n\r\nI'm proposing something similar for OBJECT. The relay MUST decode the OBJECT headers to function: track ID, group, object, priority, etc. This entire debate revolves around if a relay needs to re-encode the headers, or if it can copy them blindly. The thing is, re-encoding the OBJECT headers is so extremely trivial (they're VarInts) that even the branch miss caused by the slow path (publisher choosing ID) might be more expensive.\r\n\r\nThe important thing is that the relay does NOT decode the payload; that can be fanned out to multiple streams verbatim. This is what you would store in your cache:\r\n\r\n```rust\r\nstruct Track {\r\n  name: string,\r\n  objects: Stream<Object>, // a subscribable stream of objects\r\n}\r\n\r\nstruct Object {\r\n  group: int,\r\n  object: int,\r\n  priority: int,\r\n  payload: Stream<Bytes>, // a subscribable stream of bytes\r\n}\r\n```\r\n\r\nHere's the relevant code in [moq-relay](https://github.com/kixelated/moq-rs/blob/a30f31343924118a545bd0a7cad3710d21a05dae/moq-transport/src/session/publisher.rs#L174). The track ID is replaced in the object header and it's encoded straight to the stream buffer. The object payload is received in chunks, which are zero-copy written to the stream. I can profile my server if it would be insightful, because this entire debate centers around the assumption that line 174 (linked) is expensive.",
          "createdAt": "2023-10-17T23:58:47Z",
          "updatedAt": "2023-10-18T00:00:59Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Note that with @huitema's proposal, you would split `message::Object` into two separate messages, and the second message _could_ be copied as bytes from the upstream. Although it's probably slightly slower when there's an OBJECT per stream; calling `stream.write()` twice will be more more expensive than re-encoding 3 VarInts, but it's so insignificant.",
          "createdAt": "2023-10-18T00:06:30Z",
          "updatedAt": "2023-10-18T00:08:38Z"
        },
        {
          "author": "jordicenzano",
          "authorAssociation": "NONE",
          "body": "I implemented draft-01 and I have it working now, but I also faced this issue, I realized trackName <-> TrackId relation and how this is specified in the draft-01 created a lot of problems (at least in my implementation)\r\n- If we accept subscribe before announce then we need to rewrite objects (that seems bad)\r\n- Forcing announce first (seems a big constraint)\r\n\r\nSo, this raised the following question to me: why do we need TrackName? Can we just use trackId everywhere and let catalog have the friendly names?\r\n\r\nThis is the only variation I have made from draft-01 in my implementation:\r\n- Remove trackName and replace it with trackId\r\n    - Announce has trackId (obviously set in the encoder)\r\n    - Subscribe has trackId (it subscribe to a specific trackId)",
          "createdAt": "2023-10-31T06:09:12Z",
          "updatedAt": "2023-10-31T06:09:12Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> So, this raised the following question to me: why do we need TrackName? Can we just use trackId everywhere and let catalog have the friendly names?\r\n\r\nThe main reason is wildcard subscriptions. I agree though, I think the track ID within a broadcast should just be an integer referenced in the catalog.\r\n\r\nHowever, you still need a way to distinguish between two different broadcasts (ex. two ANNOUNCE messages). My implementation gets around this by associating a single WebTransport session with a single broadcast, basically using the session layer to tell them apart. There's limitations to this approach, namely that it requires WebTransport pooling for efficiency, but I would very much like to use some form of QUIC session layer to isolate broadcasts anyway.\r\n\r\nIn MoQ terminology, I'm proposing a session and control stream per track namespace. SUBSCRIBE and OBJECT would use the `track_id` as referenced in the catalog so OBJECTs will NEVER rewritten across hops. The session layer would be provided by QUIC or WebTransport; basically each QUIC stream would start with a `session_id` to identify the track namespace.\r\n\r\nThis also eliminates head-of-line blocking between broadcasts, such as within a relay.",
          "createdAt": "2023-11-03T06:38:42Z",
          "updatedAt": "2023-11-03T06:45:18Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">  the track ID within a broadcast should just be an integer referenced in the catalog.\r\n\r\nBut since relays can't read catalogs, we still need a object naming scheme that disambiguates concurrent broadcasts, hence the concept of namespace|name tuple. \r\n\r\n> There's limitations to this approach, namely that it requires WebTransport pooling for efficiency,\r\n\r\nConsider the case of an edge relay which must forward thousands of parallel broadcasts to a parent. Requiring each broadcast to be in a unique WebTransport session is more constraining than allowing the relay to shard those broadcasts across streams over as many WebTransport sessions as it needs to optimize performance. \r\n",
          "createdAt": "2023-11-03T09:26:54Z",
          "updatedAt": "2023-11-03T09:26:54Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Conclusion IETF 118\r\n- Track Alias defines compressed Full track name and carried in the object message\r\n- Subscribe ID defines transaction identifier for a given track and there can be more than one Subscribe ID for a given TrackId",
          "createdAt": "2023-11-06T14:30:49Z",
          "updatedAt": "2023-11-06T14:30:49Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> > the track ID within a broadcast should just be an integer referenced in the catalog.\r\n> \r\n> But since relays can't read catalogs, we still need a object naming scheme that disambiguates concurrent broadcasts, hence the concept of namespace|name tuple.\r\n \r\nA session ID at the start of each stream identifies the track namespace. Maybe a full writeup would help:\r\n\r\nWe still have our `ANNOUNCE` message but it contains a `Announce ID: VarInt` and a `Track Namespace: String`. We still have our `ANNOUNCE_OK` or `ANNOUNCE_ERROR` message to accept or reject an announce for the given namespace, and our `UNANNOUNCE` and `ANNOUNCE_RESET` message that immediately closes the announce and any associated subscriptions.\r\n\r\nEach QUIC stream would be prefixed with the `Announce ID`, which would be used with a lookup table to get the `Track Namespace` for all messages (control and data) on that stream. The `Track Name` is small since it only needs to be unique per namespace, perhaps even just a VarInt (0=video, 1=audio). You wouldn't need the `Track ID` lookup table any more and you would never rewrite OBJECTs per session as a result (no need for publisher chooses).\r\n\r\nThere would be one control stream per track namespace. It's kind of annoying to have the server `ANNOUNCE` for distribution, so instead we could have the client create the control channel and send `NAMESPACE role=publisher|subscriber` or something.\r\n\r\nI think this is a better design that what we currently have. And it's literally how WebTransport works and what it provides:\r\n\r\n- `ANNOUNCE` == `CONNECT` request. \r\n- `ANNOUNCE_OK` == `CONNECT` response status=200\r\n- `ANNOUNCE_ERROR` == `CONNECT` response status=[345]\\d\\d\r\n- `UNANNOUNCE` == `RESET_STREAM` on the CONNECT request.\r\n- `ANNOUNCE_RESET` == `STOP_SENDING` on the CONNECT request\r\n- `Announce ID` ==  `Session ID`\r\n- `Track Namespace` == `CONNECT` request path.\r\n\r\n> > There's limitations to this approach, namely that it requires WebTransport pooling for efficiency,\r\n> \r\n> Consider the case of an edge relay which must forward thousands of parallel broadcasts to a parent. Requiring each broadcast to be in a unique WebTransport session is more constraining than allowing the relay to shard those broadcasts across streams over as many WebTransport sessions as it needs to optimize performance.\r\n\r\nWithout pooling, yeah a QUIC connection per session is expensive to establish. But with pooling, a WebTransport \"session\" is a VarInt in front of each QUIC stream. There is an additional QUIC stream per session but it's mostly just there to close the session.\r\n\r\nWhy would WebTransport session's layer be any slower than the custom session layer with ANNOUNCE I outlined above?",
          "createdAt": "2023-11-07T11:54:41Z",
          "updatedAt": "2023-11-07T11:56:49Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Draft-02 has a mechanism for the publisher to request a different track id, and a object-model mapping to QUIC that borrows ideas from this issue.",
          "createdAt": "2024-01-31T00:49:14Z",
          "updatedAt": "2024-01-31T00:49:14Z"
        }
      ]
    },
    {
      "number": 272,
      "id": "I_kwDOG2Ho4M5zZE6r",
      "title": "Multiple subscriptions could cause resource exhaustion",
      "url": "https://github.com/moq-wg/moq-transport/issues/272",
      "state": "OPEN",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Needs PR",
        "Subscribe"
      ],
      "body": "Currently, there's no way to limit the number of simultaneous subscriptions.  QUIC stream limits cannot effectively be used to limit the number of subscriptions, so I'd suggest MoQ have a limit.\r\n\r\nThe simplest idea would be to have a limit specified as a parameter in the server's SETUP message.\r\n\r\nAs a related question, even with limits, what happens if a client subscribes to a number of streams that it doesn't have the bandwidth to support?  ie: 10 4k video streams and they're on a slow link?  Possibly the subscriptions could fail with an error code indicating that the server didn't have enough bandwidth to request them and/or serve them to the client?",
      "createdAt": "2023-10-10T18:23:44Z",
      "updatedAt": "2023-11-09T16:57:45Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "rofl I just came here to post the same issue. See: https://cloud.google.com/blog/products/identity-security/how-it-works-the-novel-http2-rapid-reset-ddos-attack\r\n\r\nI think we follow QUIC and have a MAX_SUBSCRIBES frame. The initial value can be set in the SETUP message. The subscribe is considered active until the publisher sends `SUBSCRIBE_ERROR` or `SUBSCRIBE_RESET` (TODO).\r\n\r\nI think we're okay with the subscriber/publisher using arbitrary subscription IDs if there's a single control channel. It would be easier if we required incremental subscribe IDs and you couldn't reuse them though.",
          "createdAt": "2023-10-10T23:38:58Z",
          "updatedAt": "2023-10-10T23:38:58Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Also do we need `MAX_ANNOUNCES`? That seems like a potential attack vector too, since it involves inserting into a potentially CDN-wide routing table.",
          "createdAt": "2023-10-10T23:39:23Z",
          "updatedAt": "2023-10-10T23:39:47Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "A few months ago, I would have said we should go with the HTTP/2 style design of just having a limit on number of streams, but given the recent issues, I'd be inclined towards the QUIC style of specifying the max number.  But I think that works better if we also have a subscription ID that's monotonically increasing for subscriptions, ie: #282 \r\n\r\nAnnounces also likely need some limits, but I'm less clear on how that might work.",
          "createdAt": "2023-10-16T23:38:28Z",
          "updatedAt": "2023-10-16T23:38:28Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I propose a monotonically increasing `Subscribe ID` in the `SUBSCRIBE` message. You can't reuse Subscribe IDs. We add a `MAX_SUBSCRIBES` message containing the maximum allowed ID and possibly a SETUP parameter to set the initial value. \r\n\r\nThe corresponding `SUBSCRIBE_OK, SUBSCRIBE_ERROR, SUBSCRIBE_RESET, SUBSCRIBE_FIN, UNSUBSCRIBE` messages use that ID instead of echoing the full track name. This removes ambiguity and overhead.\r\n\r\nWe would still have Track ID for compressing the full track name (maybe renamed?). You could have multiple SUBSCRIBE reference the same Track ID but contain different Subscribe IDs. For example:\r\n\r\n```\r\n<-- MAX_SUBSCRIBES max=2\r\n--> SUBSCRIBE id=0 track_id=2314 track_name=foobar start_group=-1\r\n--> SUBSCRIBE id=1 track_id=2314 track_name=foobar start_group=653\r\n<-- SUBSCRIBE_OK id=0\r\n<-- SUBSCRIBE_ERROR id=1 code=404\r\n<-- OBJECT track_id=2314 group=673\r\n<-- MAX_SUBSCRIBES max=3\r\n--> SUBSCRIBE id=2 track_id=2314 track_name=foobar start=670\r\n...\r\n```\r\n\r\nSame for `s/SUBSCRIBE/ANNOUNCE`. ",
          "createdAt": "2023-10-17T03:50:46Z",
          "updatedAt": "2023-10-17T03:50:46Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Adding a Subscribe ID used as you're describing SGTM and as you said remove any ambiguity about what subscription is being referenced.  Unless we are absolutely never going to have multiple subscriptions, I believe we'll need a Subscribe ID.",
          "createdAt": "2023-10-17T12:59:31Z",
          "updatedAt": "2023-10-17T12:59:31Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "This is related to #282 ",
          "createdAt": "2023-10-17T17:42:41Z",
          "updatedAt": "2023-10-17T17:42:41Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "may be better to name it as transaction_id . since it is id tied to a given subscribe transaction .. ",
          "createdAt": "2023-10-17T20:43:06Z",
          "updatedAt": "2023-10-17T20:43:06Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "As a follow-up to adding a Subscribe ID, we'll add a SETUP field or param to indicate the initial value and a MAX_SUBSCRIBE_ID frame to increase the limit, similar to QUIC flow control.",
          "createdAt": "2023-11-09T16:57:44Z",
          "updatedAt": "2023-11-09T16:57:44Z"
        }
      ]
    },
    {
      "number": 273,
      "id": "I_kwDOG2Ho4M5z7aLO",
      "title": "Nothing good comes out of a reason phrase",
      "url": "https://github.com/moq-wg/moq-transport/issues/273",
      "state": "OPEN",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Wire Format",
        "Parked"
      ],
      "body": "Reasons phrases either have useful information in them, in which case it should not be in a reason phrase, it should be in a well defined field in the protocol. Or they do not have useful information in which case they should not be there. \r\n\r\nI think we should get rid of reason phrases - if we need to describe more information about why an error happened, we should put that data in well defined fields. ",
      "createdAt": "2023-10-16T11:04:11Z",
      "updatedAt": "2024-02-07T17:21:44Z",
      "closedAt": null,
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment: \r\n\r\nI find value in reason phrases.  I agree that it's better to have specific error information in the error code, but often implementations have multiple reasons to send the same code, and adding the phrase enhances debugabiltity.  This is especially true once the error codes have frozen.  One implementation may find an error condition where none of the existing reason codes fit, so they are left with sending \"UNKNOWN\" or \"PROTOCOL ERROR\".  \r\n\r\nHTTP removed per message reason phrases in H2.  This was good since they were always the same and redundant with the codes they had, or enough implementations assumed they were they wouldn't get proxied.  Note though that the \"Proxy-Status\" header has brought back an extensible mechanism for communicating additional context when something goes wrong.  I still miss the debug data in an H2 GOAWAY which was removed in H3. We log these strings and can group by them to find interesting interop bugs.\r\n\r\nIf nothing else, I think we should keep reason phrases around in moq for a while, because it's going to help interop testing. If we feel like we've nailed the error codes later on, we can yank them closer to the end.",
          "createdAt": "2023-10-16T15:41:07Z",
          "updatedAt": "2023-10-16T15:41:07Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To be clear, I don't care deeply about this ... but it seems the reason you give for having it are nearly the same as why I think we should not. If we find a need for a new type of error, we should be able to extent to add that - for example a new parameter in the return message with better semantics than this is a string with no meaning. My argument is if our extensibility model is good, one will never need a random string with undefined content called reason. \r\n\r\nAll that said, I ca live with a reason code. ",
          "createdAt": "2023-10-16T18:35:39Z",
          "updatedAt": "2023-10-16T18:35:39Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "> If we find a need for a new type of error, we should be able to extent to add that \r\n\r\nI totally agree with this - adding new error codes is good.  The problem is that I don't want to negotiate a new protocol version with an intermediary to use a new error code.  So as a relay operator I'll just see an error code I don't understand yet, which would be more helpful with some human readable context.  There's also been push back in other working groups about creating too many error codes, when the receiver won't do anything differently if it receives code A vs code B. ",
          "createdAt": "2023-10-16T18:50:06Z",
          "updatedAt": "2023-10-16T18:50:06Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that at least for now, these are useful.  When developing a new extension/optimization/etc, sometimes these can really help debugging the change.",
          "createdAt": "2023-10-17T00:34:54Z",
          "updatedAt": "2023-10-17T00:34:54Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the reasons are useful for early interop, but we should absolutely remove them when the draft is more mature. Nobody will instrument each error, nor do we have defined error codes for all permutations, so likely you'll have a big try/catch statement followed with `code=500 reason=error.messsage`.",
          "createdAt": "2023-10-17T03:13:01Z",
          "updatedAt": "2023-10-17T03:19:27Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "In QUIC, `CONNECTION_CLOSE` has a code/reason while `STOP_SENDING/RESET_STREAM` only has a code.\r\n\r\nI like it and we should copy; remove `reason` from `ANNOUNCE_*` and `SUBSCRIBE_*`.",
          "createdAt": "2023-10-17T03:55:31Z",
          "updatedAt": "2023-10-17T03:56:00Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 for keeping these at least until interop has matured.",
          "createdAt": "2023-10-19T23:25:24Z",
          "updatedAt": "2023-10-19T23:25:24Z"
        },
        {
          "author": "alvestrand",
          "authorAssociation": "NONE",
          "body": "Seems like a rehash of the debate we have every time we design an error field.\r\nMy usual distillation is:\r\n- If the application that gets the error can do something sensible based on it, it needs to be a structured field.\r\n- If it's useful for debugging the problem, it's an unstructured text field (and that's OK).\r\n\r\nThe most common use I have for text messages is grepping the source to figure out which line produced the error. And that's essential both in product development and product maintenance. (Second most common use is to log the value of some parameter that made the error happen, which is incredibly important for reproducing the error, but where the application cannot and should not need to care.)\r\n",
          "createdAt": "2023-10-20T05:20:27Z",
          "updatedAt": "2023-10-20T05:20:27Z"
        }
      ]
    },
    {
      "number": 275,
      "id": "I_kwDOG2Ho4M5z9QH_",
      "title": "\"SUBSCRIBE OK\" and \"SUBSCRIBE ERROR\" or SUBSCRIBE_OK and SUBSCRIBE_ERROR",
      "url": "https://github.com/moq-wg/moq-transport/issues/275",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "ianswett"
      ],
      "labels": [
        "Editorial",
        "Needs PR"
      ],
      "body": "I'd make this change in a single PR, but I prefer frame names have underscores to having to quote them when referring to them when they are two words.\r\n\r\nObserved when reviewing #274 ",
      "createdAt": "2023-10-16T14:59:59Z",
      "updatedAt": "2023-10-17T12:48:34Z",
      "closedAt": "2023-10-17T12:48:34Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Preference: always underscore",
          "createdAt": "2023-10-16T15:32:10Z",
          "updatedAt": "2023-10-16T15:32:10Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 Always underscore ",
          "createdAt": "2023-10-16T17:19:15Z",
          "updatedAt": "2023-10-16T17:19:15Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 let's use underscore . Makes readability and editing so much better",
          "createdAt": "2023-10-16T18:14:12Z",
          "updatedAt": "2023-10-16T18:14:12Z"
        }
      ]
    },
    {
      "number": 276,
      "id": "I_kwDOG2Ho4M5z9X_C",
      "title": "Is GOAWAY bidirectional?",
      "url": "https://github.com/moq-wg/moq-transport/issues/276",
      "state": "OPEN",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "afrind"
      ],
      "labels": [
        "Needs Discussion"
      ],
      "body": "PR #264 has GOAWAY as only sent from server to client, but there may be use cases for the reverse as pointed out by @afrind ",
      "createdAt": "2023-10-16T15:11:46Z",
      "updatedAt": "2024-02-19T21:19:49Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DanielFay22",
          "authorAssociation": "NONE",
          "body": "I'm not really clear, what would be the use case for client -> server GOAWAY? If the only use case is a client indicating end of subscription, then I think that would be better encoded in the SUBSCRIPTION_END that Alan mentioned, but if there's other use cases then I could see GOAWAY making more sense.",
          "createdAt": "2023-10-20T18:27:10Z",
          "updatedAt": "2023-10-20T18:27:10Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "What if the client is not the original source, but rather a relay.  In that case, the relay may need to restart/etc.  One option is the relay sends a GOAWAY and the client starts publishing to a new relay.  But does it need to do something about it's upstream subscriptions?",
          "createdAt": "2023-10-20T18:37:50Z",
          "updatedAt": "2023-10-20T18:37:50Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW ... relay to relay is out of scope - we are only doing client to relay - we would need a lot more to have a full relay to relay protocol ",
          "createdAt": "2024-02-04T23:45:33Z",
          "updatedAt": "2024-02-04T23:45:33Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "A client-initiated GOAWAY is weird but kind of makes sense.\r\n\r\nI'm thinking of the dual ingest case when there are two connections from broadcaster to relay(s). If the client sends a GOAWAY message, it's an explicit signal to the relay that it needs to UNSUBSCRIBE to everything and find another route to the content. The party isn't over, you just can't stay here.\r\n\r\nBut there's some overlap with UNANNOUNCE. I'm not sure if we actually need it.",
          "createdAt": "2024-02-04T23:57:24Z",
          "updatedAt": "2024-02-04T23:58:04Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That use case makes sense.   \"The party isn't over, you just can't stay here.\"  is awesome tag line for use case. \r\n\r\nFor a graceful shutdown of a publisher,  I think the way to do that would be the client publishing sends un-annouce and the relay then ends all the subscriptions, once all the subscriptions are gone, the client closes the connection. \r\n",
          "createdAt": "2024-02-05T00:08:35Z",
          "updatedAt": "2024-02-05T00:08:35Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "With UNANNOUNCE and ANNOUNCE_CANCEL (#392), I'm inclined to think we don't need this.",
          "createdAt": "2024-02-19T21:19:48Z",
          "updatedAt": "2024-02-19T21:19:48Z"
        }
      ]
    },
    {
      "number": 282,
      "id": "I_kwDOG2Ho4M5z-u_A",
      "title": "Disambiguating control messages for the same track",
      "url": "https://github.com/moq-wg/moq-transport/issues/282",
      "state": "CLOSED",
      "author": "afrind",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Needs Discussion",
        "Subscribe"
      ],
      "body": "If we allow more than one SUBSCRIBE for the same Full Track Name, then SUBSCRIBE_OK/SUBSCRIBE_ERROR become ambiguous.  \r\n\r\neg:\r\n\r\nC->S: SUBSCRIBE /foo, group sequence=1\r\nC->S: SUBSCRIBE /foo, group sequence=100\r\nS->C: SUBSCRIBE_OK /foo\r\nS->C: SUBSCRIBE_ERROR /foo",
      "createdAt": "2023-10-16T18:16:40Z",
      "updatedAt": "2024-01-31T00:49:55Z",
      "closedAt": "2024-01-31T00:49:54Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "This has overlap with #209",
          "createdAt": "2023-10-17T17:41:47Z",
          "updatedAt": "2023-10-17T17:41:47Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Specific proposal by @kixelated in #272: https://github.com/moq-wg/moq-transport/issues/272#issuecomment-1765619883",
          "createdAt": "2023-10-24T22:22:35Z",
          "updatedAt": "2023-10-24T22:22:35Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Conclusions from IETF118 : \r\n- Subscribe ID is used to differentiate different subscriptions within and across tracks\r\n",
          "createdAt": "2023-11-06T14:26:50Z",
          "updatedAt": "2023-11-06T14:26:50Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by adding subscribe ID to control messages.",
          "createdAt": "2024-01-31T00:49:54Z",
          "updatedAt": "2024-01-31T00:49:54Z"
        }
      ]
    },
    {
      "number": 284,
      "id": "I_kwDOG2Ho4M5z_xnf",
      "title": "Are there restrictions on track names and namespaces?",
      "url": "https://github.com/moq-wg/moq-transport/issues/284",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Needs Discussion",
        "Subscribe"
      ],
      "body": "In HTTP, there are a number of restrictions on what characters are allowed in a path, headers, etc.\r\n\r\nI don't see any text restricting track names and track namespaces, but the examples are all ASCII, implying the namespace and name are not intended to be completely opaque and are instead intended to be human readable.\r\n\r\nThere's nothing in the spec that prohibits them being treated as opaque identifiers, but I'm unclear if that's the intent and I think it'd be good to explicitly say what we intend.",
      "createdAt": "2023-10-16T21:07:47Z",
      "updatedAt": "2023-11-08T13:54:11Z",
      "closedAt": "2023-11-08T13:54:11Z",
      "comments": [
        {
          "author": "hardie",
          "authorAssociation": "COLLABORATOR",
          "body": "Most of the restrictions in the HTTP world are derivative of the\r\nrestrictions in URIs: see RFC 3986, sections 2 and 3.  I'd suggest we adopt\r\nthose limitations and the percent encoding method from HTTP.  That allows\r\nfolks to use a well-known set of methods and aligns with the idea that we\r\nmight have one or more URI schemes in the MoQ protocol space.\r\n\r\n\r\nOn Mon, Oct 16, 2023 at 10:07\u202fPM ianswett ***@***.***> wrote:\r\n\r\n> In HTTP, there are a number of restrictions on what characters are allowed\r\n> in a path, headers, etc.\r\n>\r\n> I don't see any text restricting track names and track namespaces, but the\r\n> examples are all ASCII, implying the namespace and name are not intended to\r\n> be completely opaque and are instead intended to be human readable.\r\n>\r\n> There's nothing in the spec that prohibits them being treated as opaque\r\n> identifiers, but I'm unclear if that's the intent and I think it'd be good\r\n> to explicitly say what we intend.\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/moq-wg/moq-transport/issues/284>, or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AAKVXZH45J7RV6GH3DDCQWLX7WO27AVCNFSM6AAAAAA6CZU6NWVHI2DSMVQWIX3LMV43ASLTON2WKOZRHE2DMMBZHAYTIMY>\r\n> .\r\n> You are receiving this because you are subscribed to this thread.Message\r\n> ID: ***@***.***>\r\n>\r\n",
          "createdAt": "2023-10-17T08:24:18Z",
          "updatedAt": "2023-10-17T08:24:18Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe we currently don't have a way to put a track name or a track namespace into a URL, so I don't think those restrictions apply.",
          "createdAt": "2023-10-17T09:37:54Z",
          "updatedAt": "2023-10-17T09:37:54Z"
        },
        {
          "author": "hardie",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that they don't apply now, but if we adopt them it will simplify\r\nthe set we have to deal with (since we will have the same set as other\r\nparts of the protocol).  I suspect people will want the namespaces to be\r\neasy to generate from FQDNs (which are also the authority part of HTTP\r\nURIs), as an example.\r\n\r\nOn Tue, Oct 17, 2023 at 10:38\u202fAM Victor Vasiliev ***@***.***>\r\nwrote:\r\n\r\n> I believe we currently don't have a way to put a track name or a track\r\n> namespace into a URL, so I don't think those restrictions apply.\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/moq-wg/moq-transport/issues/284#issuecomment-1766045926>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AAKVXZA4FAXAQF6SIYDGQB3X7ZGXZAVCNFSM6AAAAAA6CZU6NWVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMYTONRWGA2DKOJSGY>\r\n> .\r\n> You are receiving this because you commented.Message ID:\r\n> ***@***.***>\r\n>\r\n",
          "createdAt": "2023-10-17T10:00:43Z",
          "updatedAt": "2023-10-17T10:00:43Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "IMO a track name should be human readable. Otherwise we should use numeric IDs instead, like most containers.\r\n\r\nI also think the track namespace should be human readable since it will likely be exposed to the user. Currently you need a URL and track namespace to configure a player/broadcaster. It will be quite common to combine both into a single URL (ex. like my relay) so it would be nice if track namespaces could be encoded into URLs.",
          "createdAt": "2023-10-17T10:10:03Z",
          "updatedAt": "2023-10-17T10:10:55Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Maybe we should ask the flip side: is there a use-case that won't work if track names are utf-8?",
          "createdAt": "2023-10-17T10:12:35Z",
          "updatedAt": "2023-10-17T10:12:35Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Moq transport must not define the interpretation. At the moqt transport layer track name and track namespace are set of octets and relay perform fast match where needed. \r\n\r\nHow things from application domain gets mapped and gets setup with Relay is out of scope of MoQ Transport. Also how an application sets up namespaces with CDN/Relays is out of scope of moq.\r\n\r\n",
          "createdAt": "2023-10-20T03:18:13Z",
          "updatedAt": "2023-10-20T03:18:13Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> I don't see any text restricting track names and track namespaces, but the examples are all ASCII, implying the namespace and name are not intended to be completely opaque and are instead intended to be human readable.\r\n\r\nWe should clarify in the spec to say these are opaque and examples are intended for human readability purposes only.",
          "createdAt": "2023-10-20T03:20:49Z",
          "updatedAt": "2023-10-20T03:20:49Z"
        },
        {
          "author": "hardie",
          "authorAssociation": "COLLABORATOR",
          "body": "On Fri, Oct 20, 2023 at 4:18\u202fAM Suhas Nandakumar ***@***.***>\r\nwrote:\r\n\r\n> Moq transport must not define the interpretation. At the moqt transport\r\n> layer track name and track namespace are set of octets and relay perform\r\n> fast match where needed.\r\n>\r\n> How things from application domain gets mapped and gets setup with Relay\r\n> is out of scope of MoQ Transport. Also how an application sets up\r\n> namespaces with CDN/Relays is out of scope of moq.\r\n>\r\nI don't have any particular heartburn about where this gets defined, but I\r\ndon't believe that the overall system will function well if the namespaces\r\nand track names are defined solely as \"octets\".  We are talking about these\r\nas a tuple of namespace and name to create a globally unique identifier.\r\nIf there isn't a common agreement on how those are composed and of what\r\nthey are constructed, different systems doing different things will hinder\r\ninteroperability and/or generate collisions.\r\n\r\nI would personally prefer the HTTP syntax, but UTF-8 would likely be okay\r\nif we specify how to handle things like byte-order marks, joiners, bidi,\r\narabic letter marks and so on.  That's a lot of work, but if someone wants\r\nto do it, okay.  I don't think accepting a bunch of different encodings is\r\nhelpful and I don't think using non-human readable identifiers is going to\r\nfly without a mapping to them (which only shoves the problem up a layer of\r\nindirection and adds in something new to fail).\r\n\r\nIf not moqt, where do you want all this defined?\r\n\r\n\r\n\r\n\r\n\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/moq-wg/moq-transport/issues/284#issuecomment-1772012186>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AAKVXZB2KC242TU6NC2WCBTYAHUQBAVCNFSM6AAAAAA6CZU6NWVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMYTONZSGAYTEMJYGY>\r\n> .\r\n> You are receiving this because you commented.Message ID:\r\n> ***@***.***>\r\n>\r\n",
          "createdAt": "2023-10-20T07:50:41Z",
          "updatedAt": "2023-10-20T07:50:41Z"
        },
        {
          "author": "hardie",
          "authorAssociation": "COLLABORATOR",
          "body": "On Fri, Oct 20, 2023 at 4:21\u202fAM Suhas Nandakumar ***@***.***>\r\nwrote:\r\n\r\n> I don't see any text restricting track names and track namespaces, but the\r\n> examples are all ASCII, implying the namespace and name are not intended to\r\n> be completely opaque and are instead intended to be human readable.\r\n>\r\n> We should clarify in the spec to say these are opaque and examples are\r\n> intended for human readability purposes only.\r\n>\r\n\r\nI disagree.  We have to recognize that we are distributing the process of\r\nminting these identifiers very widely.  Allowing people to re-use existing\r\nsystems to create these is going to get us better scale and present fewer\r\nproblems.  You should expect folks to re-use DNS names to mint namespaces,\r\nto take an obvious example.\r\n\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/moq-wg/moq-transport/issues/284#issuecomment-1772014474>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AAKVXZDZ7RLCAZMGJ6P54N3YAHUZZAVCNFSM6AAAAAA6CZU6NWVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMYTONZSGAYTINBXGQ>\r\n> .\r\n> You are receiving this because you commented.Message ID:\r\n> ***@***.***>\r\n>\r\n",
          "createdAt": "2023-10-20T07:53:42Z",
          "updatedAt": "2023-10-20T07:53:42Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> I disagree. We have to recognize that we are distributing the process of minting these identifiers very widely. Allowing people to re-use existing systems to create these is going to get us better scale and present fewer problems. You should expect folks to re-use DNS names to mint namespaces, to take an obvious example.\n\nI don't think I am forbidding any of these. I am just saying it is not something moqt should enforce or we should support all forms of these not just one class of things ",
          "createdAt": "2023-10-20T13:53:08Z",
          "updatedAt": "2023-10-20T13:53:08Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am also strongly in favor of a utf-8 restriction. I'd like to inherit the usability achieved from a globally deployed and understood resource identifiers and to leverage the existing DNS and certificate system for authentication and routing. If we define names in terms of octets then we need to reinvent these conventions, or else have an unnecessarily  bi-furcated system in which some addressing occurs via binary octets and others occurs via utf-8 resource locators. ",
          "createdAt": "2023-10-20T15:34:42Z",
          "updatedAt": "2023-10-20T15:34:42Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "The AUTH parameter is currently defined as an ASCII string. Whatever we use for track names, can the auth token share the same encoding?",
          "createdAt": "2023-10-30T05:32:20Z",
          "updatedAt": "2023-10-30T05:32:20Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Summary of IETF 118 meeting is there are no restrictions on at the moq transport layer but there may be a layers above this. This is to say the compare function for track namespace and track name are the equivalent of posix memcmp. ",
          "createdAt": "2023-11-06T14:25:30Z",
          "updatedAt": "2023-11-06T14:25:30Z"
        }
      ]
    },
    {
      "number": 288,
      "id": "I_kwDOG2Ho4M50BJkZ",
      "title": "Expand Error Codes",
      "url": "https://github.com/moq-wg/moq-transport/issues/288",
      "state": "OPEN",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Wire Format"
      ],
      "body": "I think it would be a good idea to flesh out the error code space a little bit. Here's the list of errors that I catch in my implementation: [cache errors](https://github.com/kixelated/moq-rs/blob/d0fca054854bdccc036eaebc8a5d8504f1ce3670/moq-transport/src/cache/error.rs#L6), [session errors](https://github.com/kixelated/moq-rs/blob/d0fca054854bdccc036eaebc8a5d8504f1ce3670/moq-transport/src/session/error.rs#L4).\r\n\r\nNote: the only difference between the two is which abstraction throws the error; they shouldn't be separate in the draft. If you scroll down, I tried to assign them a relevant-ish HTTP status code but there wasn't always a clean fit.",
      "createdAt": "2023-10-17T03:18:53Z",
      "updatedAt": "2023-11-03T20:18:52Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 296,
      "id": "I_kwDOG2Ho4M50m5yS",
      "title": "Empty subscriptions",
      "url": "https://github.com/moq-wg/moq-transport/issues/296",
      "state": "OPEN",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Subscribe"
      ],
      "body": "As mentioned in the sprawling #289, I think we should allow empty subscriptions, aka subscriptions that match no objects.\r\n\r\n- It would be nice to have a way to check if a track exists without receiving any OBJECTs. The MoQ equivalent of a HTTP HEAD request.\r\n- It could be useful to pre-warm the cache. An empty subscription could be the equivalent of \"I'm interested, but don't have the bandwidth to receive objects yet\". Again, similar to HTTP HEAD requests.\r\n\r\nFor example, a client could issue a `SUBSCRIBE /audio/japanese start=none` to accomplish two separate things:\r\n1. The `/audio/japanese` track exists if it gets a SUBSCRIBE_OK.\r\n2. The encoder/CDN starts producing the `/audio/japanese` track.\r\n3. The client could resubscribe at any point to immediately start receiving the track.",
      "createdAt": "2023-10-23T04:59:36Z",
      "updatedAt": "2023-10-25T00:40:21Z",
      "closedAt": null,
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Can the same be accomplished with:\r\n\r\n```\r\nStartGroup=Absolute/0\r\nStartObject=Absolute/0\r\nEndGroup=Absolute/0\r\nEndObject=Absolute/0\r\n```\r\n\r\nor any other range request where start==end?\r\n\r\nIs it ok for the publisher sends SUBSCRIBE_OK and SUBSCRIBE_FIN, or does your use case require the publisher to hold the subscription open?\r\n\r\nAdding a new message is also an option.",
          "createdAt": "2023-10-24T22:15:17Z",
          "updatedAt": "2023-10-24T22:15:17Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I think there's a few potential use-cases:\r\n\r\n1. Check if the track exists.\r\n2. Check if the track is active.\r\n3. Check if the track is active, and get notified when the track is closed.\r\n4. Check if the track exists and group/object N exists.\r\n\r\n\"exists\" vs \"active\" is tricky. If you request absolute/0, then it's totally valid for the relay to return OK so long as the objects haven't expired yet, even if the publisher sent a FIN a long time ago.\r\n\r\nBut what should the relay do if absolute/0 has expired? Should it return an error, even if the track is still actively producing objects? Requesting relative/0 is better, although what if that object has expired too? For example, a muted audio track.\r\n\r\nIMO\r\n\r\n1. ?\r\n2. SUBSCRIBE start/end=none ... UNSUBSCRIBE \r\n3. SUBSCRIBE start/end=none ... SUBSCRIBE_FIN\r\n4. SUBSCRIBE start/end=absolute/N ... SUBSCRIBE_FIN",
          "createdAt": "2023-10-24T22:56:15Z",
          "updatedAt": "2023-10-24T22:56:15Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "And a more concrete use-case that @acbegen and @wilaw might like.\r\n\r\nLet's say I have 3 renditions: `480p 720p 1080p`. The client starts watching a broadcast:\r\n\r\n```\r\n--> SUBSCRIBE 480p start=relative/1 end=none\r\n--> SUBSCRIBE 720p start=none       end=none\r\n```\r\n\r\nThis is a hint to the relay that the 720p track exists and it should start warming the cache. The relay is free to ignore the hint, but at the very least it will perform authentication. \r\n\r\n```\r\n<-- SUBSCRIBE_OK 480p start=absolute/69 end=none\r\n<-- SUBSCRIBE_OK 720p start=none        end=none\r\n```\r\n\r\nWhen the client decides that it has enough bandwidth for 720p, it will switch up at an aligned group:\r\n\r\n```\r\n--> RESUBSCRIBE 480p  start=absolute/69 end=absolute/72\r\n--> RESUBSCRIBE 720p  start=absolute/72 end=none\r\n--> SUBSCRIBE   1080p start=none        end=none\r\n```\r\n\r\n- If the relay warmed the cache, then this switch is instantaneous.\r\n- If the relay ignored the hint, then it takes at least an RTT to origin to fetch the 720p track.\r\n\r\nThe time it takes to switch renditions matters more when switching down in response to congestion. The buffer will deplete while the CDN fetches the rendition from origin, which pre-warming subscriptions will avoid.\r\n\r\nAnd just to complete the example, you have to pre-warm the 480p SUBSCRIBE again. This could either be done with multiple subscriptions, or waiting until the SUBSCRIBE_FIN arrives and then subscribing again. I'm not quite sure which approach is better.",
          "createdAt": "2023-10-24T23:21:39Z",
          "updatedAt": "2023-10-24T23:22:07Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm a little concerned about this use case, for the reasons below:\r\n\r\n> It would be nice to have a way to check if a track exists without receiving any OBJECTs. \r\n\r\nIs the assumption that the catalog, which declares the existence of the track, is not trustable? \r\n\r\n> It could be useful to pre-warm the cache. \r\n\r\nHow? If the relay went forward to the origin with the same start=none request then the origin should not actually send anything and therefore the cache would not fill. The only way this works is if the relay  goes forward with a different request with some !none start value. This non-deterministic behavior (ask one component for one thing and it asks for somehting else) can lead to scaling and debugging problems.\r\n\r\nI appreciate the benefits of cache warming, for fast start especially when the the edge relay is far from the origin. There are other ways to achieve this. One way can be by having a \"warming client\" make a conventional subscription request. This client may be an agent hosted on the edge relay for this purpose and its APi would be offered by the CDN and is outside the scope of moqt. \r\n\r\nAs a third point, empty subscriptions are also a DDOS attack vector. As a client, if  can make a hundred requests for streams that all then flow to a relay, but no content actually comes to me, it is a highly asymmetric (and therefore dangerous) DDOS tool. \r\n\r\n\r\n\r\n",
          "createdAt": "2023-10-24T23:22:53Z",
          "updatedAt": "2023-10-24T23:22:53Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'm a little concerned about this use case, for the reasons below:\r\n> \r\n> > It would be nice to have a way to check if a track exists without receiving any OBJECTs.\r\n> \r\n> Is the assumption that the catalog, which declares the existence of the track, is not trustable?\r\n\r\nI think it's useful for applications that don't use a catalog. ex. Alan's chat protocol could check if a chat room or participant exists by performing an empty subscribe. \r\n\r\n> > It could be useful to pre-warm the cache.\r\n> \r\n> How? If the relay went forward to the origin with the same start=none request then the origin should not actually send anything and therefore the cache would not fill. The only way this works is if the relay goes forward with a different request with some !none start value. This non-deterministic behavior (ask one component for one thing and it asks for somehting else) can lead to scaling and debugging problems.\r\n\r\nThe relay doesn't have to forward ranges verbatim. Just like if a CDN receives a HEAD request, the relay MAY issue a GET request to the origin instead. I think this is actually pretty common?\r\n\r\nIn the MoQ case, the relay could request `start=relative/0` instead of `start=none` from the origin. It's completely up to the relay; it would only do this if there's sufficient bandwidth/cache available. It's a little bit of business logic though; maybe the customer can choose to enable it.\r\n\r\n>  I appreciate the benefits of cache warming, for fast start especially when the the edge relay is far from the origin. There are other ways to achieve this. One way can be by having a \"warming client\" make a conventional subscription request. This client may be an agent hosted on the edge relay for this purpose and its APi would be offered by the CDN and is outside the scope of moqt.\r\n\r\nJust keep in mind that we don't want the relay to have access to the catalog.\r\n\r\nSo you're asking applications to provide this functionality, requiring a custom service worker, a custom player, and hooks to notify the service worker on player start/stop. And the service worker itself doesn't actually want to receive these objects, so yeah there would need to be a non-standard API to actually warm a track.\r\n\r\nPlus it gets more complicated when you through in alternative renditions. Maybe the client has no intention of downloading AV1 tracks, or maybe it has no intention of downloading Japanese subtitles. This sort of selection criteria should be signaled to the service worker; pre-warming all tracks is a waste.\r\n\r\nI think this is the type of thing we build into the protocol instead of asking every application make a unique implementation. Warming would be completely optional for both the publisher and subscriber.\r\n\r\n> As a third point, empty subscriptions are also a DDOS attack vector. As a client, if can make a hundred requests for streams that all then flow to a relay, but no content actually comes to me, it is a highly asymmetric (and therefore dangerous) DDOS tool.\r\n\r\nI don't quite understand. \r\n\r\nThe CDN would deduplicate subscriptions so only one would ever reach the origin for a given track. If the relay already has an active subscription for the 480p track, then it wouldn't need to issue another subscribe upstream to serve empty subscriptions.\r\n\r\nBut if you're talking about using random track names, a client can already SUBSCRIBE to random track names (just like random HTTP paths) to DoS the origin.\r\n\r\nOr maybe you're talking about a client potentially pre-warming a bunch of valid tracks. Like somebody wrote a bot to scrape all Twitch broadcasts with zero viewers and issued an empty subscribe to them all. The CDN is completely in charge of determining if it pre-warms empty subscribes, which it should not do if it's near capacity or detects abuse.\r\n\r\nBut I don't think this is unique to empty subscribes. A client could perform a normal subscribe and then either immediately unsubscribe, close the connection, or set MAX_STREAMS_UNI=0 avoid receiving any objects. These empty subscribes follow the normal authentication logic, so the mitigation is going to be the same for both.",
          "createdAt": "2023-10-24T23:51:24Z",
          "updatedAt": "2023-10-24T23:54:48Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment:\r\n\r\nLet's retitle this issue to be more specific about what the ask is.  \r\n\r\nEmpty subscriptions are possible with draft-01.  Their semantics are a bit undefined - eg: a relay or publisher has multiple options - SUBSCRIBE_ERROR, SUBSCRIBE_OK + SUBSCRIBE_FIN, SUBSCRIBE_OK and no FIN, in case the subscriber wants to do something else?  Do we need to mandate a particular behavior for better interoperability?\r\n\r\nThen there's a separate issue about supporting these use cases:\r\n\r\n> 1. Check if the track exists.\r\n> 2. Check if the track is active.\r\n> 3. Check if the track is active, and get notified when the track is closed.\r\n> 4. Check if the track exists and group/object N exists.\r\n\r\nIf these are required, then there's other ways to spell that without changing Subscribe - and none of these cases have anything to do with subscribing except maybe 3? A QUERY_TRACK (eg: HEAD) message that doesn't alter the subscribe state seems like a more apt vehicle.\r\n\r\nHow to pre-warm a cache seems out of scope.\r\n\r\n> set MAX_STREAMS_UNI=0 avoid receiving any objects\r\n\r\nI think we should open a separate issue about this case, and what the relay requirements are (if any) around backpressure.    The same thing can happen if a client runs out of streams and doesn't grant new credit in a timely way.  Are there obligations to keep the subscription open and/or cache at the relay for some period of time, or can a relay aggressively drop objects or reset subscriptions? A naive relay is going to get itself in big trouble very quickly.",
          "createdAt": "2023-10-25T00:40:20Z",
          "updatedAt": "2023-10-25T00:40:20Z"
        }
      ]
    },
    {
      "number": 300,
      "id": "I_kwDOG2Ho4M50096L",
      "title": "GROUP_SEQUENCE and OBJECT_SEQUENCE are overcome by events",
      "url": "https://github.com/moq-wg/moq-transport/issues/300",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Editorial"
      ],
      "body": "These parameters have been replaced with explicit fields in the SUBSCRIBE message.\r\n\r\nAll that's left (outside of SETUP) is AUTHORIZATION_INFO in SUBSCRIBE and ANNOUNCE.\r\n\r\nI would just as soon get rid of non-setup parameters entirely and have an \"auth_info_length\" field in the messages which can be zero.\r\n\r\nAt a minimum, we need to eliminate GROUP_ and OBJECT_SEQUENCE.",
      "createdAt": "2023-10-24T20:42:11Z",
      "updatedAt": "2023-10-26T18:42:29Z",
      "closedAt": "2023-10-26T18:42:29Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> I would just as soon get rid of non-setup parameters entirely and have an \"auth_info_length\" field in the messages which can be zero.\r\n\r\n+1\r\n\r\nI would go even further and make a dedicated AUTH message.",
          "createdAt": "2023-10-24T21:01:41Z",
          "updatedAt": "2023-10-24T21:01:41Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Whoops, those were deleted but must have been re-added in a merge conflict.  ",
          "createdAt": "2023-10-24T21:07:47Z",
          "updatedAt": "2023-10-24T21:07:47Z"
        }
      ]
    },
    {
      "number": 301,
      "id": "I_kwDOG2Ho4M500-3Z",
      "title": "Reason Phrase in SUBSCRIBE_ERROR is of type (b)",
      "url": "https://github.com/moq-wg/moq-transport/issues/301",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Editorial"
      ],
      "body": "When we added (b) we didn't update this.",
      "createdAt": "2023-10-24T20:45:11Z",
      "updatedAt": "2023-10-27T01:33:44Z",
      "closedAt": "2023-10-27T01:33:44Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "SUBSCRIBE_RST as well",
          "createdAt": "2023-10-24T20:46:39Z",
          "updatedAt": "2023-10-24T20:46:39Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "and ANNOUNCE_ERROR",
          "createdAt": "2023-10-24T20:48:16Z",
          "updatedAt": "2023-10-24T20:48:16Z"
        }
      ]
    },
    {
      "number": 304,
      "id": "I_kwDOG2Ho4M51LKDV",
      "title": "Does MoQ over QUIC require support for multiple sessions?",
      "url": "https://github.com/moq-wg/moq-transport/issues/304",
      "state": "OPEN",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Parked"
      ],
      "body": "As it stands today, QUIC does not have a 'session' layer allowing multiple instances of the same application or different applications to share a single connection.\r\n\r\nAt the last interim, I believe a few people thought that both the WebTransport and raw QUIC deployments of MoQ should support multiple sessions over a single connection.\r\n\r\nThere are proposals to add a session layer, but they're early on.  I feel like this isn't a blocker, and more of a nice to have, and MoQ can use whatever is available when it's done, but wanted the WGs opinion.",
      "createdAt": "2023-10-27T16:42:13Z",
      "updatedAt": "2024-02-07T16:44:31Z",
      "closedAt": null,
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "my initial reaction is , we may don't need it ..  atleast for conferencing like use-cases, different meetings will use different connections (may also land on different middles boxes) .. \r\n\r\nI would love to explore the idea though and see if it can be simplified (esp not have pooling, if possible) .. @ianswett  can you please share the pointers to the proposals in this space ?\r\n\r\n",
          "createdAt": "2023-10-28T03:37:11Z",
          "updatedAt": "2023-10-28T03:37:11Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "An example of a way to accomplish this: https://datatracker.ietf.org/doc/draft-seemann-quic-stream-groups/",
          "createdAt": "2023-10-28T17:26:29Z",
          "updatedAt": "2023-10-28T17:26:29Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I think a session layer is inevitable. The only question is do we do it within QUIC, WebTransport, or MoqTransport.\r\n\r\nThere's been a desire to work at the track granularity. However, tracks are not independent, in fact they usually share some form of naming, grouping, prioritization, authentication, termination, etc. \r\n\r\nI think tracks should be bundled into a session and share:\r\n* a control stream\r\n* a prioritization domain\r\n* authentication\r\n* a namespace\r\n* a termination code?\r\n\r\nFor example, a conference call would be a single session.\r\n\r\nPersonally, I think a WebTransport session per MoqTransport session makes the most sense, so we don't have to implement our own pooling or session identification.",
          "createdAt": "2023-10-30T04:47:43Z",
          "updatedAt": "2023-10-30T04:48:42Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment:\r\n\r\nHaving been part of WebTransport inventing a session layer, I prefer we wait for QUIC to define something and rely on that.",
          "createdAt": "2023-10-30T15:40:48Z",
          "updatedAt": "2023-10-30T15:40:48Z"
        }
      ]
    },
    {
      "number": 309,
      "id": "I_kwDOG2Ho4M51RAwJ",
      "title": "Classify messages by ROLE",
      "url": "https://github.com/moq-wg/moq-transport/issues/309",
      "state": "OPEN",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Editorial"
      ],
      "body": "Here is the SUBSCRIBE family of messages:\r\n\r\n```rust\r\nSUBSCRIBE = 0x3,\r\nSUBSCRIBE_OK = 0x4,\r\nSUBSCRIBE_ERROR = 0x5,\r\nUNSUBSCRIBE = 0xa,\r\nSUBSCRIBE_FIN = 0xb,\r\nSUBSCRIBE_RESET = 0xc,\r\n```\r\n\r\nI have two separate modules for publishing and subscribing as they are fully* independent in MoqTransport. Additionally, some applications will only publish or subscribe, so it's not necessary to implement/expose the full API surface.\r\n\r\nHowever, at a glance, it's not clear which messages are sent by each role. I think it would help a lot if we classified which role sends which messages:\r\n\r\n```rust\r\n// Sent by a subscriber\r\nSUBSCRIBE = 0x3,\r\nUNSUBSCRIBE = 0xa,\r\n\r\n// Sent by a publisher\r\nSUBSCRIBE_OK = 0x4,\r\nSUBSCRIBE_ERROR = 0x5,\r\nSUBSCRIBE_FIN = 0xb,\r\nSUBSCRIBE_RESET = 0xc,\r\n```\r\n\r\nFor example, I think it makes it a lot clearer that a subscriber needs to accept 3(!) possible error messages.",
      "createdAt": "2023-10-30T03:18:02Z",
      "updatedAt": "2023-10-30T04:20:12Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Here's from my documentation:\r\n\r\n```\r\nMessages sent by the publisher:\r\n- [Announce]\r\n- [Unannounce]\r\n- [SubscribeOk]\r\n- [SubscribeError]\r\n- [SubscribeReset]\r\n- [SubscribeFin]\r\n- [Object]\r\n\r\nMessages sent by the subscriber:\r\n- [Subscribe]\r\n- [Unsubscribe]\r\n- [AnnounceOk]\r\n- [AnnounceError]\r\n```",
          "createdAt": "2023-10-30T04:20:12Z",
          "updatedAt": "2023-10-30T04:20:12Z"
        }
      ]
    },
    {
      "number": 310,
      "id": "I_kwDOG2Ho4M51RQVy",
      "title": "Consolidating SUBSCRIBE errors",
      "url": "https://github.com/moq-wg/moq-transport/issues/310",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Subscribe"
      ],
      "body": "As mentioned in #309, there are 3 different ways for a publisher to close a subscriber, each with minor differences.\r\n\r\n- `SUBSCRIBE_ERROR`: I never sent you an object.\r\n- `SUBSCRIBE_FIN`: There are no more objects to send after group/object X/Y.\r\n- `SUBSCRIBE_RESET`: There are more objects after group/object X/Y... but I won't send them.\r\n\r\nA few things:\r\n\r\n### 1. `SUBSCRIBE_ERROR` naming\r\nI think it should be renamed since it's not the only ERROR message. Maybe `SUBSCRIBE_REJECT`?\r\n\r\n### 2. `SUBSCRIBE_FIN` and `SUBSCRIBE_RESET` are virtually identical\r\nThe only difference is that one has an error code. Otherwise they both include a final group/object and it's up to the application/library to decide if they wait for the final object(s). I'd like to only implement this once but right now I have to copy/paste any code to handle these almost identical messages.\r\n\r\nWhat if we merged them and use error code 0 to signal a FIN. The reason phrase should be removed as part of #273.\r\n\r\n### 3. It's difficult to determine which messages are protocol violations\r\n\r\nThere really needs to be a state machine like #237 with this many ways to terminate a subscription.\r\n\r\nI think these are all protocol violations:\r\n- `SUBSCRIBE_OK` then `SUBSCRIBE_ERROR`\r\n- `SUBSCRIBE_ERROR` then `SUBSCRIBE_*` \r\n- `SUBSCRIBE_RESET/FIN` then `SUBSCRIBE_*`\r\n\r\nMy interpretation of the draft is that a `SUBSCRIBE_FIN` followed by a `SUBSCRIBE_RESET` is invalid, which is not obvious and unlike QUIC.\r\n> A subscription remains active until it expires, until the publisher of the track terminates the track with a SUBSCRIBE_FIN (see [Section 6.8](https://moq-wg.github.io/moq-transport/draft-ietf-moq-transport.html#message-subscribe-fin)) or a SUBSCRIBE_RST (see [Section 6.9](https://moq-wg.github.io/moq-transport/draft-ietf-moq-transport.html#message-subscribe-rst)).\r\n\r\n### 4. Do these error distinctions actually matter to the transport?\r\n\r\nI don't think so. The library/relay behavior doesn't change based on `SUBSCRIBE_RESET/FIN`. The only thing that miiiight differentiate between the two is the application, which can use errors codes for this purpose. At the very least I would merge these two messages.\r\n\r\nBut I would also like to explore a single way for the publisher to close a subscription. The application can signal the nuanced differences between errors (ex. error code 404 vs 410). The library/relay doesn't care, it just forwards the error code.",
      "createdAt": "2023-10-30T04:11:24Z",
      "updatedAt": "2024-03-04T02:51:03Z",
      "closedAt": "2024-03-04T02:51:02Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment:\r\n\r\n> The library/relay behavior doesn't change based on SUBSCRIBE_RESET/FIN.\r\n\r\nThe inspiration for FIN vs RST in moq came from HTTP caching.  If a resource has no content-length, and the caching proxy has received N bytes, does it have the entire resource, or does it need to refetch the tail?  If that response was terminated with a FIN (H2 or H3), then it has the whole resource.  If it was terminated by a RST, it can't assume that it does.\r\n\r\nSo the value I see in these two messages is for a moq relay is similar.  A client connected to the relay and subscribed to a track, which fowarded the subscribe to a publisher.  The track was published to the relay and ended with a FIN.  Another client subscribes to this track from the beginning (Absolute/0,0) and no end.  Does the relay need to resubscribe upstream?\r\n\r\nNow suppose that the connection from the publisher to the relay closed abruptly, or the track was terminated with SUBSCRIBE_RST.  This is a signal to the relay that it's worth another subscribe to find out where the end of the track is.\r\n\r\nI can live if we consolidate the framing to a single message, and define a special error code to mean FIN, but I do think the transport needs to see the difference.",
          "createdAt": "2023-11-03T21:55:34Z",
          "updatedAt": "2023-11-03T21:55:34Z"
        }
      ]
    },
    {
      "number": 312,
      "id": "I_kwDOG2Ho4M51Rg53",
      "title": "Clarify how to end a SUBSCRIBE at group N",
      "url": "https://github.com/moq-wg/moq-transport/issues/312",
      "state": "OPEN",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Subscribe"
      ],
      "body": "If I wanted to receive all objects in group N, I would issue:\r\n\r\n```\r\nSUBSCRIBE\r\nend_group=absolute/N\r\nend_object=none\r\n```\r\n\r\nHowever the draft sneaks this restriction in, and it would actually be a protocol violation:\r\n\r\n> EndObject's Mode MUST NOT be None if EndGroup's Mode is not None.\r\n\r\nIt wasn't clear to me until chatting with Alan how you're supposed to do it:\r\n\r\n```\r\nSUBSCRIBE\r\nend_group=absolute/N+1\r\nend_object=absolute/0\r\n```\r\n\r\nIt's clarified in example 5, but I don't think this is obvious and it feels like an off-by-one. For example, if N was the last group in the broadcast, I can imagine some implementations incorrectly throwing an error or somehow mishandling it.",
      "createdAt": "2023-10-30T05:11:53Z",
      "updatedAt": "2023-10-30T15:51:26Z",
      "closedAt": null,
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment:\r\n\r\n> the draft sneaks this restriction in\r\n\r\nThis was discussed on the PR here: https://github.com/moq-wg/moq-transport/pull/289#discussion_r1368916351.\r\n\r\nGiven how subscribe locations work (end is exclusive), end=N+1/0 means \"including through the end of group N\".  The question is whether we should have more than one way to do things, and defaults when values are not present.",
          "createdAt": "2023-10-30T15:48:50Z",
          "updatedAt": "2023-10-30T15:48:50Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> Individual Comment:\r\n> \r\n> > the draft sneaks this restriction in\r\n> \r\n> This was discussed on the PR here: [#289 (comment)](https://github.com/moq-wg/moq-transport/pull/289#discussion_r1368916351).\r\n\r\nSorry, bad choice of word there. I meant that it's not immediately obvious why the restriction exists, and what it impacts.",
          "createdAt": "2023-10-30T15:51:25Z",
          "updatedAt": "2023-10-30T15:51:25Z"
        }
      ]
    },
    {
      "number": 313,
      "id": "I_kwDOG2Ho4M51Ri1H",
      "title": "SUBSCRIBE_RST/FIN with null final Group/Object",
      "url": "https://github.com/moq-wg/moq-transport/issues/313",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Implementation Blocker",
        "Subscribe"
      ],
      "body": "`SUBSCRIBE_RST` and `SUBSCRIBE_FIN` define:\r\n\r\n> Final Group: The largest Group Sequence sent by the publisher in an OBJECT message in this track.\r\n> Final Object: The largest Object Sequence sent by the publisher in an OBJECT message in the Final Group for this track.\r\n\r\nHowever, what happens if no objects were ever produced/sent?",
      "createdAt": "2023-10-30T05:20:32Z",
      "updatedAt": "2024-02-21T17:15:32Z",
      "closedAt": "2024-02-21T17:15:32Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment:\r\n\r\nOops.  Two possible ways to handle this:\r\n\r\n1) Flag indicating presence of these fields (Use Location now that is defined elsewhere?)\r\n2) Change the semantics of the fields to be exclusive (eg: it is the first object NOT sent), so 0/0 means none.\r\n\r\n",
          "createdAt": "2023-10-30T15:51:10Z",
          "updatedAt": "2023-10-30T15:51:10Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm inclined towards 0/0, because optional fields are more complex to parse and I would expect the existing logic to work correctly with 0/0.",
          "createdAt": "2023-11-06T12:45:00Z",
          "updatedAt": "2023-11-06T12:45:00Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's say the last object delivered by the relay is `group=5 object=29`. Does the relay send RESET `group=5 object=30` or `RESET group=6 object=0`? Is the subscriber able to infer the presence of future objects? What if either of those objects actually exist in the cache?\r\n",
          "createdAt": "2023-11-06T14:12:29Z",
          "updatedAt": "2023-11-06T14:12:29Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment:\r\n\r\nIf we use exclusive encoding then I'd say that the receiver shouldn't infer the existence of non-existence of the named object, and either 5/30 or 6/0 works, but 5/30 is preferable?",
          "createdAt": "2023-11-06T15:04:49Z",
          "updatedAt": "2023-11-06T15:04:49Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\r\nIf you define there will be no objects greater than or equal to these, then 0/0 makes total sense.  So 0/0 for null case and say the last group ID of the last object publish was 10 then the value in SUB_FIN would be 11. ",
          "createdAt": "2024-02-04T22:08:27Z",
          "updatedAt": "2024-02-04T22:08:27Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "In #343 we went with an explicit flag, so I'm inclined to do the same here for consistency.",
          "createdAt": "2024-02-19T20:17:22Z",
          "updatedAt": "2024-02-19T20:17:22Z"
        }
      ]
    },
    {
      "number": 314,
      "id": "I_kwDOG2Ho4M51RpRP",
      "title": "VarInt parameters length mismatch",
      "url": "https://github.com/moq-wg/moq-transport/issues/314",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "martinduke"
      ],
      "labels": [
        "Needs PR",
        "Parameters"
      ],
      "body": "Currently, VarInts have two lengths:\r\n\r\n1. In the parameter length.\r\n2. In the first two bits of the parameter value.\r\n\r\nThe decision in #294 was that the two MUST match, which is a good solution without a full #256 reform.\r\n\r\nHowever:\r\n\r\n> If the parameter value is a varint, but the self-encoded length of that varint does not match the Parameter Length field, the receiver MUST ignore the parameter using the value in the Parameter Length field.\r\n\r\nIgnoring seems like the wrong play. For example, we know the role parameter (0x0) is a VarInt in the current draft. However this text says I MUST ignore any errors when parsing this varint and pretend like the parameter was never sent, which is both unenforceable and a major foot-gun (silently ignoring parameters).\r\n\r\nI think we close the connection with an error if there's an error parsing a known parameter.",
      "createdAt": "2023-10-30T05:47:46Z",
      "updatedAt": "2024-01-10T17:36:41Z",
      "closedAt": "2024-01-10T17:36:41Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If a parameter is unknown, then the parser doesn't know if the value is a varint and therefore can't check the length match.\r\n\r\nI thought it was better to have consistent behavior than not, because it's easier to write and easier to reason about. But if this has actual downstream consequences, I could be convinced otherwise.",
          "createdAt": "2023-11-09T09:23:41Z",
          "updatedAt": "2023-11-09T09:23:41Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't know what I was smoking when I came up with this title. My concern is that when a **known** parameter has the wrong length, the text says the decoder MUST ignore it. But it likely has the wrong length due to a bug, so this will cause unintended (non-fatal) behavior.",
          "createdAt": "2023-11-09T09:48:40Z",
          "updatedAt": "2023-11-09T09:49:27Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I understand what you mean. My point was that an unknown parameter has an inevitable result, and trying to make the processing for known parameters the same had some advantages.\r\n\r\nWe'll discuss today.",
          "createdAt": "2023-11-09T10:12:40Z",
          "updatedAt": "2023-11-09T10:12:40Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Conclusion was to make it an error instead of skipping over the field if there's a length mismatch.",
          "createdAt": "2023-11-09T17:29:41Z",
          "updatedAt": "2023-11-09T17:29:41Z"
        }
      ]
    },
    {
      "number": 315,
      "id": "I_kwDOG2Ho4M51R1bM",
      "title": "Group size",
      "url": "https://github.com/moq-wg/moq-transport/issues/315",
      "state": "OPEN",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Object Model"
      ],
      "body": "How big can a group be? I know we (probably) won't be able to set a fixed limit, but I feel like we need to answer this in order to know what kind of design assumptions to make.\r\n\r\nIs a single group expected to be small enough to fit in the cache?  Will the protocol work if a media track is just a single group that is being appended to for hours if not days?  I was thinking about stream mapping and the resource-use-at-relays problem earlier today, and realized we might not currently have a conclusive answer for those.",
      "createdAt": "2023-10-30T06:33:27Z",
      "updatedAt": "2023-11-05T10:25:16Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "As it stands today, the group ID is merely an annotation used by SUBSCRIBE hints. It's a sync point only by convention; in actuality the relay has no idea if objects within a group depend on each other. The relay is expected to cache/serve/evict objects independently so the group size is irrelevant.\r\n\r\nFor example, a valid use-case is a single audio group with an object per frame. Each OBJECT would have an expires field of 30s, effectively dropping the head of the group as time progresses. The total number of objects per group is unbounded but the cache size is bounded.\r\n\r\nI strongly disagree with this. I want groups to actually be sync points, in which a relay knows that it should not evict OBJECT N without also evicting OBJECT N+1. Then the maximum size of the group actually matters.",
          "createdAt": "2023-10-30T07:27:12Z",
          "updatedAt": "2023-10-30T07:27:12Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "IMO the size of a group (in bytes, or object count, or wallclock duration) should not be defined by the moq-transport spec. Limits such as these are driven by the physical characteristics of the caches and therefore should be provided by the relay (cache) provider. A streaming format (such as WARP) may choose to define a minimum object size to be supported for interop reasons between relays, but this should probably stay outside of moq-transport. ",
          "createdAt": "2023-10-30T15:12:44Z",
          "updatedAt": "2023-10-30T15:12:44Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 to will's point.  Group Size vary depending on the application - video, audio, chat, something new \r\n\r\nIf any application needs to be aware of this, we can do the following\r\n1. Have catalog  specify the group size per track\r\n2. Have a MOQT message updated where the Publisher can specify  it per track in Subscribe OK. This might help as hint to caches if need be.",
          "createdAt": "2023-10-30T21:15:48Z",
          "updatedAt": "2023-10-30T21:16:19Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment:\r\n\r\nThere may be something interesting for moqt here in expressing more information that's useful to a cache.  Maybe an explicit expiry time would be more useful than a TTL, or a TTL at the group rather than the object level?  \r\n\r\nCaches will evict stuff and can go fetch it if someone asks for it later.  Maybe what needs to be specified is what happens when a cache receives Objects 0-10, evicts 0-3, then gets a SUBSCRIBE for Absolute/0-10?",
          "createdAt": "2023-10-30T22:14:13Z",
          "updatedAt": "2023-10-30T22:14:13Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> Individual Comment:\r\n> \r\n> There may be something interesting for moqt here in expressing more information that's useful to a cache. Maybe an explicit expiry time would be more useful than a TTL, or a TTL at the group rather than the object level?\r\n> \r\n> Caches will evict stuff and can go fetch it if someone asks for it later. Maybe what needs to be specified is what happens when a cache receives Objects 0-10, evicts 0-3, then gets a SUBSCRIBE for Absolute/0-10?\r\n\r\nYeah, the cache needs some dependency information if it has any hope of evicting objects before the maximum TTL. That should be the purpose of group in my opinion.",
          "createdAt": "2023-10-31T04:10:26Z",
          "updatedAt": "2023-10-31T04:11:10Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we should allow it to be pretty much any size and as we use a VarInt for the object id so it does not matter.   I guese I am not seeing a problem here from what we have today with pretty much no limit on number of of objects or number of groups.  \r\n\r\nSo I guess I am saying whatever max of VarInt is which I assume will be at least 2^60. ",
          "createdAt": "2023-11-05T10:23:34Z",
          "updatedAt": "2023-11-05T10:25:16Z"
        }
      ]
    },
    {
      "number": 317,
      "id": "I_kwDOG2Ho4M51gYBb",
      "title": "Reapply PR 277 after mismerge",
      "url": "https://github.com/moq-wg/moq-transport/issues/317",
      "state": "CLOSED",
      "author": "afrind",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Editorial"
      ],
      "body": "",
      "createdAt": "2023-10-31T23:07:00Z",
      "updatedAt": "2023-11-07T12:45:57Z",
      "closedAt": "2023-11-07T12:45:57Z",
      "comments": []
    },
    {
      "number": 318,
      "id": "I_kwDOG2Ho4M51hLL0",
      "title": "Impossible to know group FIN",
      "url": "https://github.com/moq-wg/moq-transport/issues/318",
      "state": "OPEN",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Object Model"
      ],
      "body": "The current approach of allowing any OBJECTs to arrive on any stream makes it impossible for the receiver to know when a group ends.\r\n\r\nThere's a few conditions when you need to know the end of a group:\r\n\r\n1. A relay being told to terminate the subscription after group N (subscription hints).\r\n2. A relay knowing when to close a QUIC stream (if it writes a group per stream).\r\n3. A decoder deciding when to start decoding/rendering the next group (ex. GoP).\r\n\r\nLikewise there's a similar problem of knowing when there's an gap within a group. There's no way to signal that OBJECT X will never arrive, so the receiver should not wait for it.",
      "createdAt": "2023-11-01T03:30:02Z",
      "updatedAt": "2024-02-08T23:32:06Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I strongly advocate for a 1:1 mapping of group to stream. Objects within a group are in order, but there may be gaps.\r\n\r\nThe stream FIN signals the end of a group. The sequence number (or FIN) can be used to determine gaps. An application that doesn't support gaps or skips a group can send STOP_SENDING; something that is not possible with an arbitrary stream mapping.",
          "createdAt": "2023-11-01T03:36:03Z",
          "updatedAt": "2023-11-01T03:40:26Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Alternatively, we could have `OBJECT_DROP`, `GROUP_DROP` and `GROUP_FIN` control messages. I think this is a mess, and the receiver would need a corresponding `STOP_GROUP` in response to an unrecoverable gap caused by `OBJECT_DROP`. \r\n\r\nI don't think we can annotate OBJECTs like @suhasHere once proposed with a GROUP_FIN flag because they're lossy. You need some reliable mechanism to signal the end. For example, sending the OBJECT with a GROUP_FIN flag over a datagram would be illegal, as would sending a reset_stream/stop_sending for any stream containing a GROUP_FIN object.",
          "createdAt": "2023-11-01T03:44:07Z",
          "updatedAt": "2023-11-01T03:46:53Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Maybe this a duplicate of #315 ?",
          "createdAt": "2023-11-01T05:19:45Z",
          "updatedAt": "2023-11-01T05:19:45Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "The issue mentioning Last Object Previous Group is in #224",
          "createdAt": "2023-11-03T20:55:17Z",
          "updatedAt": "2023-11-03T20:55:17Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the best solutions to this is a header on the last object in the group that indicates it is the last object in the group. ",
          "createdAt": "2023-11-05T11:35:24Z",
          "updatedAt": "2023-11-05T11:35:24Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment:\r\n\r\n> I think the best solutions to this is a header on the last object in the group that indicates it is the last object in the group.\r\n\r\nI share Luke's concern above about OBJECT being somewhat unreliable.  I think a GROUP_FIN message with stronger reliability guarantees would look similar on the wire but work better.\r\n\r\neg:\r\n\r\nInstead of \r\n\r\n```\r\nOBJECT(G1,O1)  OBJECT(G1,O2)  OBJECT(G1,O3,last)\r\n```\r\n\r\nHave\r\n\r\n\r\n```\r\nOBJECT(G1,O1)  OBJECT(G1,O2)  OBJECT(G1,O3), GROUP_FIN(G1, O3)\r\n```\r\n\r\nThis works better than implicit mapping from groups to streams.  A relay might need to close a connection with an open stream, but wouldn't want to reset it and wouldn't want the stream FIN to be interpreted as a group FIN.  I don't want to put GROUP_FIN on the control stream, but that would be the safest.\r\n\r\nI think the other messages Luke mentioned related to DROP are probably an orthogonal issue.",
          "createdAt": "2023-11-05T13:07:06Z",
          "updatedAt": "2023-11-05T13:07:06Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": " > I think the other messages Luke mentioned related to DROP are probably an orthogonal issue.\r\n\r\nAgreed, I'm just bringing it up early because stream mapping has massive ramifications on what control messages we'll need in the future. If we can't utilize QUIC's STREAM_FIN, STREAM_RESET, STOP_SENDING, MAX_STREAMS... then we'll need our own, analogous control messages.",
          "createdAt": "2023-11-06T01:43:32Z",
          "updatedAt": "2023-11-06T01:44:52Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "you guys have convinced me \r\n",
          "createdAt": "2023-11-06T09:42:21Z",
          "updatedAt": "2023-11-06T09:42:21Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As I mentioned during the interim meeting, it makes sense to put that information in the header of the next group. Something like:\r\n~~~\r\nSTREAM_HEADER_GROUP Message {\r\n  Subscribe ID (i),\r\n  Track Alias (i),\r\n  Group ID (i),\r\n  Previous Group ID(i),\r\n  Last Object ID of Previous Group(i),\r\n  Object Send Order (i)\r\n}\r\n~~~\r\nThat information can be used by the receiver to decide when to start playing the new group, and when to wait for more information instead. It is useful:\r\n\r\n* when using \"stream per object\", to understand how many individual objects are expected for the previous group,\r\n* when using \"stream per group\", if group numbers are skipped.\r\n\r\nThe downside is that the relay needs to know the value of previous group and last object before sending the first object of the next group. This may or may not be a problem in practice -- relays may be receiving the information from the origin. If the relay sets an overoptimistic value of previous object, it will have to send some kind of replacement for the skipped objects, such as\r\n~~~\r\nSTREAM_HEADER_RESET_GROUP\r\n{\r\n  Group ID (i),\r\n  Reset At Object ID (i)\r\n}\r\n~~~\r\nWhich will inform the receiver that the specified object ID and the following ones will not be sent for this group.\r\n",
          "createdAt": "2024-02-08T23:32:05Z",
          "updatedAt": "2024-02-08T23:32:05Z"
        }
      ]
    },
    {
      "number": 319,
      "id": "I_kwDOG2Ho4M51oMPk",
      "title": "Subscriber rejecting ANNOUNCE",
      "url": "https://github.com/moq-wg/moq-transport/issues/319",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Announce"
      ],
      "body": "> Relays respond with an ANNOUNCE_OK or ANNOUNCE_ERROR control message providing the result of announcement. The entity receiving the ANNOUNCE MUST send only a single response to a given ANNOUNCE of either ANNOUNCE_OK or ANNOUNCE_ERROR.\r\n\r\nThe problem is not possible for the subscriber to reject an ANNOUNCE afterwards. This would be very useful, for example to inform a publisher that no more subscriptions will be routed to them for whatever reason. Examples:\r\n\r\n1. The auth parameter in ANNOUNCE has expired.\r\n2. Another publisher has sent an overriding ANNOUNCE (reconnect?)\r\n3. The broadcast has been closed remotely, ex. some moderation tool.\r\n\r\nWithout this message, the only recourse for the subscriber is to close the connection. This won't work if multiple ANNOUNCE messages are pooled over the same connection, nor is it clean.",
      "createdAt": "2023-11-02T04:12:19Z",
      "updatedAt": "2024-02-21T22:39:42Z",
      "closedAt": "2024-02-21T22:39:42Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I propose two options:\r\n\r\n1. `ANNOUNCE_RESET` can be sent after `ANNOUNCE_OK`.\r\n2.  We add `ANNOUNCE_RST` and `ANNOUNCE_FIN` to mirror `SUBSCRIBE`.\r\n\r\nI personally hate 3 separate messages for a subscriber to close an announce, or a publisher to close a subscription. See #310 ",
          "createdAt": "2023-11-02T04:13:55Z",
          "updatedAt": "2023-11-02T04:13:55Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "very trivial bikeshed comment ...  I would prefer to call it something other RESET ( and also other places we use RESET ). I get the TCP analogy but I think that is the wrong way to think about this. I would prefer something like REVOKE. ",
          "createdAt": "2023-11-06T09:36:02Z",
          "updatedAt": "2023-11-06T09:36:02Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "how about ANNOUNCE_CANCEL  to cancel an open announce ?",
          "createdAt": "2023-11-06T15:25:27Z",
          "updatedAt": "2023-11-06T15:25:27Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Conclusion is that we do need to add a new frame to end an ANNOUNCE.\r\n\r\nAdditionally, there was a principle stated that we should not rely on closing the session as the typical or optimal way to close state and close either an ANNOUNCE or SUBSCRIBE.",
          "createdAt": "2023-11-09T16:45:38Z",
          "updatedAt": "2023-11-09T16:45:38Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "On the call today, people tend to prefer ANNOUNCE_CLOSE over ANNOUNCE_CANCEL as a name.  They also prefer merging SUBSCRIBE_RESET and SUBSCRIBE_FIN into a single message, possibly SUBSCRIBE_CLOSE.",
          "createdAt": "2024-02-21T17:36:46Z",
          "updatedAt": "2024-02-21T17:36:46Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "On an editorial note, it'd be nice to have subsections for publisher/subscriber to make it clearer to the reader.",
          "createdAt": "2024-02-21T17:41:04Z",
          "updatedAt": "2024-02-21T17:41:04Z"
        }
      ]
    },
    {
      "number": 320,
      "id": "I_kwDOG2Ho4M51s0Il",
      "title": "Support datagrams for FEC data?",
      "url": "https://github.com/moq-wg/moq-transport/issues/320",
      "state": "OPEN",
      "author": "rom1v",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "NotTransport"
      ],
      "body": "To get the lowest possible latency (and avoid retransmission), we may want to add FEC (like [RaptorQ](https://www.rfc-editor.org/rfc/rfc6330.html)) to send redundant packets, so that even if some packets are lost (but enough are received), we can still reconstruct the source data, without retransmission.\r\n\r\nThis is mentioned in the draft [Use Cases and Requirements for Media Transport Protocol Design](https://datatracker.ietf.org/doc/html/draft-ietf-moq-requirements-02#name-interactive-media):\r\n\r\n> It may make sense to use FEC [RFC6363] and codec-level packet loss concealment [RFC6716], rather than selectively retransmitting only lost packets. These mechanisms use more bytes, but do not require multiple round trips in order to recover from packet loss.\r\n\r\nIt makes sense to never retransmit such FEC packets if they are lost (that's the purpose), so we would like to send them in datagrams (over [QUIC](https://datatracker.ietf.org/doc/html/rfc9221) or [WebTransport](https://developer.mozilla.org/en-US/docs/Web/API/WebTransport/datagrams)).\r\n\r\nBut in [MOQT](https://datatracker.ietf.org/doc/html/draft-ietf-moq-transport-01#name-session-initialization), it seems that objects must always be sent over QUIC/WebTransport streams:\r\n\r\n> Objects are sent on unidirectional streams.\r\n\r\nTherefore, some Objects containing FEC payloads might be retransmitted by the transport layer (QUIC/WebTransport), which is undesirable.\r\n\r\nAre they any plan to support this FEC use case over datagrams?",
      "createdAt": "2023-11-02T17:04:44Z",
      "updatedAt": "2024-02-19T23:51:11Z",
      "closedAt": null,
      "comments": [
        {
          "author": "rom1v",
          "authorAssociation": "NONE",
          "body": "Oh, I just found #316.\r\n\r\nHowever, it says:\r\n\r\n> OBJECT messages are transmitted over unidirectional streams and can\r\n> also be transmitted over datagrams if the object or objects fit into\r\n> single datagram. **For larger objects, a stream needs to be used.**\r\n\r\nTypically, I think I would like to use 1 Object for a single video frame.\r\n\r\nBut if I use FEC and datagrams, each packet containing a single video frame will need to be split into _n_ FEC packets (most of them of 1280 bytes for example). In that case, I will need to define 1 `Object` = 1 FEC packet and combine several `Object`s at the application level to reconstruct frames, is it correct?\r\n",
          "createdAt": "2023-11-02T17:12:53Z",
          "updatedAt": "2023-11-02T17:21:46Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "So we're going to have trouble implementing FEC as it stands.\r\n\r\nA QUIC library can coalesce multiple QUIC datagrams per UDP packet. A FEC scheme that assumes QUIC datagrams are individual packets (not fate bound) won't work over generic implementations. This is especially a problem with MTU discovery, as even if you're sending 1.2kB datagrams, they might get bundled together into large packets. At the very least MoQ would have to require that QUIC datagrams MUST NOT be coalesced for this to work over generic relays. You kinda run into this same problem with FEC in general, as what looks like an individual packet at one layer might be coalesced into a jumbo packet at a lower layer.\r\n\r\n#316 just lets you can send individual OBJECTs as datagrams. It wouldn't be useful unless the application builds a FEC layer on MoQTransport, splitting each OBJECT into 1.2Kb OBJECTs. But you would have no way of preventing spurious retransmissions like you mentioned. It's also a burden for relays, as they're forced to proxy these numerous FEC OBJECTs even over pristine links.\r\n\r\nFrankly, I want FEC at the QUIC layer. Any FEC encoding should be applied over the entire connection, not individual frames/objects. I think we could combine this with priorities/hints in MoqTransport to designate important media, without building full-blown FEC into MoqTransport. One possibility: https://datatracker.ietf.org/doc/draft-michel-quic-fec/",
          "createdAt": "2023-11-02T19:24:54Z",
          "updatedAt": "2023-11-02T19:39:26Z"
        },
        {
          "author": "englishm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Seconding @kixelated's suggestion that we probably want to have FEC at the underlying QUIC layer. Part of the value of MoQ is being able to benefit from these types of enhancements to QUIC itself as it continues to grow and mature.",
          "createdAt": "2023-11-02T19:37:12Z",
          "updatedAt": "2023-11-02T19:37:12Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, and just one more point. Disclaimer, I haven't used FEC so I could be talking out of my ass.\r\n\r\nFEC is meant to conceal random loss which occurs on a link-by-link basis. The frequency and distribution of random loss is very different if you're on cellular, versus wifi, versus ethernet. All of these protocols have some form of FEC built but it can be inadequate, which is why the application wants to augment.\r\n\r\nI think performing FEC hop-by-hop within QUIC makes the most sense. This would support:\r\n- the FEC scheme could be dynamic, based on measured hop-by-hop properties.\r\n- viewer A could use a separate FEC scheme from viewer B. \r\n- QUIC paths could use different FEC schemes, ex. a path over a satellite link would be different from path over ethernet. \r\n- QUIC paths could work in tandem, for example the satellite path could be used to provide parity only.\r\n- a relay wouldn't be forced to use FEC within the backbone\r\n\r\nFEC end-to-end is an option for 1:1 but I just don't think it scales to multiple paths.",
          "createdAt": "2023-11-02T20:07:28Z",
          "updatedAt": "2023-11-02T20:07:28Z"
        },
        {
          "author": "rom1v",
          "authorAssociation": "NONE",
          "body": "Thank you for your answers, very instructive!\r\n\r\n> Frankly, I want FEC at the QUIC layer. Any FEC encoding should be applied over the entire connection, not individual frames/objects. I think we could combine this with priorities/hints in MoqTransport to designate important media, without building full-blown FEC into MoqTransport. One possibility: https://datatracker.ietf.org/doc/draft-michel-quic-fec/\r\n\r\nThat would be awesome! I was not aware of such work, thank you for the link. :+1:\r\n\r\n> as what looks like an individual packet at one layer might be coalesced into a jumbo packet at a lower layer.\r\n\r\nI [faced a similar problem](https://github.com/quinn-rs/quinn/issues/1572) when I tried to simulate packet loss using `iptables`, due to UDP segmentation offload (several UDP packets were coalesced into one big UDP packet). However, it was just a local issue, UDP packets were still sent individually \"on the wire\".\r\n\r\nIndeed, if UDP packets are coalesced at a lower layer, FEC becomes useless. If this \"lower level\" is lower than UDP, it would also impact FEC at the QUIC layer though.\r\n\r\nTo give some more context, we are developing a prototype for remote gaming, experimenting with several custom protocols over QUIC and WebTransport.\r\n\r\nIn practice, if we use QUIC/WebTransport streams, it works pretty well, but we may experience stuttering due to packet loss: sometimes the game (mirrorring) freezes for few hundreds milliseconds (presumably on packet loss), then catches up.\r\n\r\nIf instead, we split each frame packet into [RaptorQ](https://www.rfc-editor.org/rfc/rfc6330.html) packets having a size computed from [`max_datagram_size()`](https://docs.rs/quinn/latest/quinn/struct.Connection.html#method.max_datagram_size), send them over QUIC/WebTransport datagrams, and reconstruct the source packets on the other side, then this avoids the problem in practice.\r\n\r\n> It's also a burden for relays\r\n\r\n> FEC end-to-end is an option for 1:1 but I just don't think it scales to multiple paths\r\n\r\nYes, I totally agree. It's not clear to me how it should work with relays.\r\n\r\nIn addition, if a burst of packet loss is too severe, data may be completely lost without retransmission: this is not good for a relay, which might want to record (without being impacted by packet loss).\r\n\r\nBut for the 1:1 remote gaming use case, I think FEC packets over datagrams may still be useful.",
          "createdAt": "2023-11-03T10:43:37Z",
          "updatedAt": "2023-11-03T10:43:37Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> Indeed, if UDP packets are coalesced at a lower layer, FEC becomes useless. If this \"lower level\" is lower than UDP, it would also impact FEC at the QUIC layer though.\r\n\r\nYeah absolutely. UDP packets aren't necessarily independent nor are the loss events. It's a difficult problem to solve and it's understandable why FEC algorithms can get quite complicated.\r\n\r\n> To give some more context, we are developing a prototype for remote gaming, experimenting with several custom protocols over QUIC and WebTransport.\r\n\r\nI spent a while talking to JB at the last year about WebTransport and QUIC. I'm glad you're making great progress!\r\n\r\n> In practice, if we use QUIC/WebTransport streams, it works pretty well, but we may experience stuttering due to packet loss: sometimes the game (mirrorring) freezes for few hundreds milliseconds (presumably on packet loss), then catches up.\r\n\r\nYeah, it's quite difficult to tell random loss apart from queue loss. FEC will help with random loss, but it might actually exacerbate queue loss; depends on how the router decides to shed load.\r\n\r\nWhat congestion control algorithm are you using with QUIC? There's probably some improvements you can make there to avoid these freezes. Ah you linked the Quinn docs below, so that means New Reno (by default) or BBRv1 (experimental). \r\n\r\nNew Reno will absolutely cause random freezes like that, either due to bufferbloat or a sudden cwnd reduction. BBRv1 is much better in my experience but can also cause random freezes due to the PROBE_RTT phase. It's also not clear if it's even implemented correctly in Quinn given the experimental flag, and upgrading to BBRv2 or BBRv3 will definitely help live video.\r\n\r\nOh and check out [my recent blog post](https://quic.video/blog/replacing-webrtc/#detecting-queuing) if you haven't already. We'll need a QUIC extension if you want to use something like GCC to match WebRTC performance.\r\n\r\n> If instead, we split each frame packet into [RaptorQ](https://www.rfc-editor.org/rfc/rfc6330.html) packets having a size computed from [`max_datagram_size()`](https://docs.rs/quinn/latest/quinn/struct.Connection.html#method.max_datagram_size), send them over QUIC/WebTransport datagrams, and reconstruct the source packets on the other side, then this avoids the problem in practice.\r\n\r\nFEC can definitely help if you have a high RTTs, for example if you have a limited edge deployment. But if that's not the case then I'm not quite sure why it would help when using Reno or BBR.\r\n\r\nOh and with your QUIC streams, make sure you're prioritizing them otherwise they'll fight for limited bandwidth. It makes a huge difference and is comparable to manually dropping packets via datagrams.\r\n\r\n> But for the 1:1 remote gaming use case, I think FEC packets over datagrams may still be useful.\r\n\r\nYeah, FEC does make sense when latency is critical and RTTs are high.",
          "createdAt": "2023-11-03T13:13:55Z",
          "updatedAt": "2023-11-03T13:13:55Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm big fan of FEC but I think it is complicated at a level that I was waiting until the basic of MoQ were more stable before jumping into it. \r\n\r\nSome cases you might only want FEC on one link in which case doing it at the QUIC layer might make sense. In other cases only the application really knows what type of FEC would work best for the current application and network environment. There are also cases where you want the applications to be able to do end to end FEC without waiting for the relay network to support that form of FEC. And clearly what type of FEC is optimal is highly application dependent. \r\n\r\nRight now, I feel like the best experiments could be done with just putting the FEC on separate tracks and having it be application defined. This does have the issue with  some video frames  not fitting in a single MTU but, for now, an applications could deal with splitting up the frame. \r\n\r\n",
          "createdAt": "2023-11-04T16:51:28Z",
          "updatedAt": "2023-11-04T16:51:28Z"
        },
        {
          "author": "francoismichel",
          "authorAssociation": "NONE",
          "body": "Hey, I am the author of  https://datatracker.ietf.org/doc/draft-michel-quic-fec/ .\r\nI am jumping in to let you know that I am in Prague this week, including at the Hackathon if you want to discuss. \r\n\r\nI have performed a few FEC experiments with different applications, including low latency video streaming ones such as GStreamer/FFMpeg, obtaining good results. Everything is in my thesis and in our coming papers.",
          "createdAt": "2023-11-04T20:31:37Z",
          "updatedAt": "2023-11-04T21:15:46Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "draft-02 added some mechanisms for datagrams. Is that sufficient to close this issue for now and, as fluffy suggested, experiment with FEC at the application layer?",
          "createdAt": "2024-01-31T00:26:25Z",
          "updatedAt": "2024-01-31T00:26:25Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I feel like this is outside the scope of MOQ Transport, so marking it as such.",
          "createdAt": "2024-02-19T23:51:04Z",
          "updatedAt": "2024-02-19T23:51:04Z"
        }
      ]
    },
    {
      "number": 321,
      "id": "I_kwDOG2Ho4M51s74I",
      "title": "SUBSCRIBE REQUEST parameters",
      "url": "https://github.com/moq-wg/moq-transport/issues/321",
      "state": "CLOSED",
      "author": "rom1v",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hi,\r\n\r\nI have just read the RFC, and I have a question about the `SUBSCRIBE REQUEST` description:\r\n\r\n```\r\nSUBSCRIBE REQUEST Message {\r\n  Full Track Name Length (i),\r\n  Full Track Name (...),\r\n  StartGroup (Location),\r\n  StartObject (Location),\r\n  EndGroup (Location),\r\n  EndObject (Location),\r\n  Track Request Parameters (..) ...\r\n}\r\n```\r\n\r\n> Track Request Parameters: The parameters are defined in [Section 6.1.1](https://datatracker.ietf.org/doc/html/draft-ietf-moq-transport-01#version-specific-params)\r\n\r\nIf I'm not mistaken, these Track Request Parameters are:\r\n - GROUP SEQUENCE Parameter\r\n - OBJECT SEQUENCE Parameter\r\n - AUTHORIZATION INFO Parameter\r\n\r\nIt seems to me that `StartGroup`/`EndGroup` and `StartObject`/`EndObject` overlap (i.e. are partially redundant) with `GROUP SEQUENCE` and `OBJECT SEQUENCE`, don't they?\r\n\r\nWhat if `StartGroup` and `GROUP SEQUENCE` refer to different groups?\r\n\r\n(I probably misunderstood something or miss context.)\r\n\r\nAnother small question:\r\n\r\n> EndObject's Mode MUST NOT be None if EndGroup's Mode is not None.\r\n\r\nIIUC, this means that it is not possible to subscribe for Groups 42 to 47 without specifying the last object number in group 47? (just a theoretical question)\r\n\r\nThank you for your time :slightly_smiling_face: ",
      "createdAt": "2023-11-02T17:17:01Z",
      "updatedAt": "2023-11-03T17:49:36Z",
      "closedAt": "2023-11-03T17:49:36Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Group Sequence and Object Sequence should have been deleted",
          "createdAt": "2023-11-02T18:18:00Z",
          "updatedAt": "2023-11-02T18:18:00Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah we forgot to delete them before releasing draft-01. See: #302 \r\n\r\nAs for `EndGroup`, I agree and filed #312. You're apparently supposed to EndGroup+1 and EndObject=0 but I don't think that's obvious.",
          "createdAt": "2023-11-02T19:02:32Z",
          "updatedAt": "2023-11-02T19:02:52Z"
        },
        {
          "author": "rom1v",
          "authorAssociation": "NONE",
          "body": "> Group Sequence and Object Sequence should have been deleted\r\n\r\nOh, ok, that makes more sense now :+1:\r\n\r\nThank you.",
          "createdAt": "2023-11-03T10:46:04Z",
          "updatedAt": "2023-11-03T10:46:04Z"
        }
      ]
    },
    {
      "number": 322,
      "id": "I_kwDOG2Ho4M51tU1T",
      "title": "SUBSCRIBE_REQUEST encoding",
      "url": "https://github.com/moq-wg/moq-transport/issues/322",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "duplicate"
      ],
      "body": "The section wire diagram says there is a \"Full Track Name,\" but the text suggests there is a namespace and name.",
      "createdAt": "2023-11-02T18:18:57Z",
      "updatedAt": "2023-11-03T19:59:40Z",
      "closedAt": "2023-11-03T19:59:40Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "See: #317 \r\n\r\n#277 was accidentally reverted",
          "createdAt": "2023-11-02T18:59:58Z",
          "updatedAt": "2023-11-02T18:59:58Z"
        }
      ]
    },
    {
      "number": 326,
      "id": "I_kwDOG2Ho4M519fr0",
      "title": "Hints & sendOrder how can they work together",
      "url": "https://github.com/moq-wg/moq-transport/issues/326",
      "state": "OPEN",
      "author": "jordicenzano",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "Needs Discussion",
        "Transmission"
      ],
      "body": "If we use hints on SUBSCRIBE (StartGroup, StartObject) I assume is to request objects from the past. Thinking about the live rewind or VOD (archived after live):\r\n- The objects have a sendOrder burnt-in, and since those were part of a live stream that sendOrder is probably increasing (meaning more recent, higher priority)\r\n- If player requests objects from 1h in the past, and relay respects the sendOrder the player will start receiving objects from the end of the live stream to the start. Also those will be sent at wire speed\r\n\r\nIt seems for VOD-like use cases we need a different type of delivery than live edge. Perhaps we should do sliding window and/or sendOrder updates?\r\n\r\nFinals questions:\r\n- Can we use current current hints to deliver VOD?\r\n- Do we need to add signals?",
      "createdAt": "2023-11-06T12:40:25Z",
      "updatedAt": "2024-03-18T03:30:47Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Absolutely.\r\n\r\n`sendOrder` is meant to avoid head-of-line blocking when subscribed to the live playhead. Everything is delivered on a best-effort basis according to `sendOrder` with the expectation that there's a limited amount of time to deliver each new frame (jitter buffer size).\r\n\r\nBut when \"subscribed\" to old content like VOD, you actually want head-of-line blocking. The player can build up a massive buffer so there's no need to panic; reliable delivery is just fine. In fact when a viewer seeks back to the 12:34 mark of the VOD, they want 12:34 to be the first frame rendered, so that needs to be the first frame delivered. That's not possible with `sendOrder` unless you subscribe to a single group... assuming `sendOrder` is incremented per group.\r\n\r\n---\r\n\r\nFirst off, doing an unbounded SUBSCRIBE for VOD is always a mistake. If you want to watch content starting at 12:34, then `SUBSCRIBE start=12:34 end=none` will absolutely inundate you with media; there's no back-pressure. You might receive hours of media at line-speed overflowing any local buffer, and of course `sendOrder` will incorrectly send you the newest media first.\r\n\r\nAt a minimum each SUBSCRIBE needs to be scoped. ex. `SUBSCRIBE start=12:34 end=12:45`. The player can periodically request chunks to fill the buffer based on the current playback position. `sendOrder` will still incorrectly send you the newest media first.\r\n\r\nOne option is to SUBSCRIBE on a per-group basis. ex. `SUBSCRIBE start=12:34 end=12:36`, wait for `SUBSCRIBE_FIN`, `SUBSCRIBE start=12:36 end=12:38`. This is analogous to performing a single HTTP GET at a time like how HLS/DASH perform VOD. There's a small window between each SUBSCRIBE_FIN and SUBSCRIBE where you're not fully utilizing the connection, so it could be slightly better.\r\n\r\nAnother option to add a command to `GET start=12:34 end=12:45`, which would tell the relay to disable any congestion control avoidance mechanisms like `sendOrder` and dropping OBJECTs. This would be reliable hop-to-hop, but not necessarily end-to-end (we should support holes in the VOD).\r\n\r\nHowever it's not clear what a relay is supposed to do when there's simultaneous SUBSCRIBEs and GETs active, since prioritization is performed at a session/connection level. Sometimes you want `GET` to be higher priority than any live content (DVR), sometimes you want `GET` to be performed in the background (filling holes in the cache).  Maybe `GET` can provide a `sendOrder` override or something. \r\n\r\nI do think a way of reliably fetching media is necessary, so I would be inclined to add something like `GET`.",
          "createdAt": "2023-11-07T01:58:49Z",
          "updatedAt": "2023-11-07T02:14:12Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "@wilaw you probably have some opinions here.",
          "createdAt": "2023-11-07T02:08:44Z",
          "updatedAt": "2023-11-07T02:08:44Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I was thinking of it working much like you propose above - the player making a series of bounded requests, so that it can control its forward buffer growth. As the user plays forward, it could just update that subscribe (I think we just approved that control message yesterday) to push out the end range until it reaches EOF.\r\n\r\nSUBSCRIBE start=0:0 end=20:0\r\nSUBSCRIBE-UPDATE [1] start=0:0 end=40:0\r\nSUBSCRIBE-UPDATE [1] start=0:0 end=60:0\r\n...\r\nSUBSCRIBE-UPDATE [1] start=0:0 end=343:16\r\n\r\nI wouldn't subscribe on a group-by-group basis (even though it would work), as that is just mirroring the unnecessarily verbose HLS behavior. We can take advantage of the sequential delivery that subscription affords to minimize the amount of control requests that must cross the wire and that the relay must process.\r\n\r\nAs for GET, that is very interesting. We do need a mode where a client can reliably request a range of content and have the relay ignore any priority instructions in the header and also fill in any gaps . I think this should be a new hint on the SUBSCRIBE request rather than a new request .\r\n\r\n`Imagine SUBSCRIBE start=0:0 end:32:10 reliable=true`\r\n\r\nThis would instruct the relay to do two things:\r\n1. Never drop an object. When faced with congestion, it should queue the data and always send it reliably. \r\n2. If it has gaps in the range, it should fill them by making explicit reliable requests back to the origin to fill them. ",
          "createdAt": "2023-11-07T14:50:40Z",
          "updatedAt": "2023-11-08T08:45:11Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment:\r\n\r\n> SUBSCRIBE start=0:0 end:32:10 reliable=true\r\n\r\nI think something like a subscribe hint regarding delay vs. drop is useful.\r\n\r\n> the player making a series of bounded requests\r\n\r\nIt makes me cringe slightly that we built this beautiful pub/sub and we would not take full advantage of it.  \r\n\r\n> there's no back-pressure\r\n\r\nI wonder if another way to spell this is with object flow control (expressed in bytes, object count or both).  You could then issue one subscribe for everything you want and then strategically grant more flow control credits to control the receive rate.    Maybe there's a way to cleverly use QUIC's flow control instead of a moq one, but we'd need to think through that carefully.",
          "createdAt": "2023-11-07T22:02:26Z",
          "updatedAt": "2023-11-07T22:02:26Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is starting to sound very complicated for relays . What is it that the relay does differently for  reliable=true vs false?\r\n",
          "createdAt": "2024-02-04T23:51:56Z",
          "updatedAt": "2024-02-04T23:51:56Z"
        }
      ]
    },
    {
      "number": 328,
      "id": "I_kwDOG2Ho4M52FstZ",
      "title": "Space in names are resulting in definitions that make no sense.  ",
      "url": "https://github.com/moq-wg/moq-transport/issues/328",
      "state": "CLOSED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Editorial"
      ],
      "body": "Take the line from your drafts that says \r\n\r\n```\r\nFull Track Name = Track Namespace Track Name\r\n```\r\n\r\nThere is no valid way to parse the right hand of this. We have things like \"Full Track Name Length\" and \"Full Track Name\". \r\n\r\nI do not think we should have ambiguous syntax for things that require precision.  I think it would also be good to have things that can be directly mapped to common programming languages.  This moves beyound simply editorial, or specification is underspecified and ambiguous until we fix this. ",
      "createdAt": "2023-11-07T12:09:58Z",
      "updatedAt": "2023-12-11T00:28:42Z",
      "closedAt": "2023-12-11T00:28:42Z",
      "comments": [
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One possible solution would be use underscore or CamelCase",
          "createdAt": "2023-11-07T12:10:05Z",
          "updatedAt": "2023-11-07T12:10:05Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oh, and the longer we leave this dumpster fire, the more painful it will be to fix.",
          "createdAt": "2023-11-07T12:10:46Z",
          "updatedAt": "2023-11-07T12:10:46Z"
        }
      ]
    },
    {
      "number": 332,
      "id": "I_kwDOG2Ho4M52PXC_",
      "title": "Proposal for a TRACK_STATUS and TRACK_STATUS_OK messages",
      "url": "https://github.com/moq-wg/moq-transport/issues/332",
      "state": "CLOSED",
      "author": "wilaw",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "It is useful for a client to be able to discover attributes of track at a relay (publisher)\r\n\r\n- is the subscription active, which ensures that the relay has a updated view of the live edge?\r\n- latest group number that the relay has available to deliver\r\n- latest object number that the relay has available to deliver\r\n\r\nTRACK_STATUS Message {\r\n  Track Namespace (b),\r\n  Track Name (b),\r\n}\r\n\r\nTRACK_STATUS_OK\r\n{\r\n  Track Namespace (b),\r\n  Track Name (b),\r\n  hasActiveSubscription(i),\r\n  lastGroup(i),\r\n  lastObject(i)\r\n}\r\n\r\nlastGroup and lastObject should be nullable, for the case in which hasActiveSubscription is false AND the relay has no objects from that track in cache. \r\n\r\nOpen for debate is whether we should extend the response to also include the firstGroup and firstObject that the relay has in cache. To consider here is that the range may have holes and whether these need to be reported or not. Also to consider is whether returning range boundaries is expensive for the relay. \r\n",
      "createdAt": "2023-11-08T14:27:27Z",
      "updatedAt": "2023-11-10T21:54:40Z",
      "closedAt": "2023-11-10T21:54:40Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment:\r\n\r\nDoes `hasActiveSubscription` distinguish between the cases of \"relay is subscribed to a live track\" and \"relay is in the middle of cache-filling something old\"?",
          "createdAt": "2023-11-09T06:54:55Z",
          "updatedAt": "2023-11-09T06:54:55Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "We should augment SUBSCRIBE_OK with this information too because it's necessary to map relative groups to absolute.\r\n\r\nWhat about auth? Could we reuse messages instead of making a new one, perhaps: `SUBSCRIBE end_object=0`?",
          "createdAt": "2023-11-09T08:19:37Z",
          "updatedAt": "2023-11-09T08:22:42Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Does hasActiveSubscription distinguish between the cases of \"relay is subscribed to a live track\" and \"relay is in the middle of cache-filling something old\"?\r\n\r\nYes. hasActiveSubscription has two requirements to be true:\r\n1. The relay has an open subscription upstream that includes the head of the track\r\n2. The relay has received at least one Object in response to that subscription\r\n\r\nA relay that was cache-filling a hole in its archive should return false (because it doesn't know the true state of the live edge), as should a relay which has made a live subscription but has yet to receive any content. \r\n\r\n> We should augment SUBSCRIBE_OK with this information, because it's necessary to map relative groups to absolute.\r\n\r\nAgree. This would enrich the SUBSCRIBE_OK response. It's still useful to have a separate ability to check STATUS without having to execute a SUBSCRIBE. The former gives you information about the live state. The latter commits you to receiving the track. ",
          "createdAt": "2023-11-09T08:23:51Z",
          "updatedAt": "2023-11-09T08:23:51Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "`hasActiveSubscription` feels wrong to me. Is this meant to inform the client that the data is stale? Shouldn't the relay fetch the correct status instead of returning stale data? It's going to be false a LOT of the time given how distributed relays work.",
          "createdAt": "2023-11-09T08:24:01Z",
          "updatedAt": "2023-11-09T08:24:47Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Shouldn't the relay fetch the correct status instead of returning stale data?\r\n\r\nI originally imagined this as a quick lookup that is completely local to the edge. You are just asking it to report the status of its cache, not to go back to the origin to validate. \r\n\r\nHowever we can expand it to be a lookup that validates with the origin. Currently the only way for a client to find out the live edge is for the edge relay to make a real subscription and for each intermediate relay to do the same. Having this message allows much lighter weight inspection. Think of it like a HEAD request against the track, versus a GET. \r\n\r\nIf it goes back to origin, then the body should be modified to remove the `hasActiveSubscription`.\r\n\r\n```\r\nTRACK_STATUS_OK\r\n{\r\nTrack Namespace (b),\r\nTrack Name (b),\r\nlastGroup(i),\r\nlastObject(i)\r\n}\r\n```",
          "createdAt": "2023-11-09T08:35:42Z",
          "updatedAt": "2023-11-09T08:35:42Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "It wouldn't need to go all the way to origin; just upstream until the first relay with an active subscription.",
          "createdAt": "2023-11-09T08:38:00Z",
          "updatedAt": "2023-11-09T08:38:00Z"
        },
        {
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "body": "what is the usecase for a client to do it without subscribing? Is that for clients to figure out \"range\" to subscribe for?",
          "createdAt": "2023-11-09T11:34:57Z",
          "updatedAt": "2023-11-09T11:34:57Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "After speaking this over with Kiril, the primary use case is an edge relay resolving relative subscription requests. For that there is a better solution which is described in https://github.com/moq-wg/moq-transport/issues/337. Closing this issue.",
          "createdAt": "2023-11-10T21:54:40Z",
          "updatedAt": "2023-11-10T21:54:40Z"
        }
      ]
    },
    {
      "number": 335,
      "id": "I_kwDOG2Ho4M52YQnK",
      "title": "Unique track token",
      "url": "https://github.com/moq-wg/moq-transport/issues/335",
      "state": "OPEN",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Object Model"
      ],
      "body": "(I thought I have proposed this before, but I can't find the corresponding issue)\r\n\r\nThe proposal is to have the publisher (the original one) generate a random token blob whenever it starts publishing a track. This allows us to deal with situations where the publisher for the track changes.  One such common situation is a publisher restart (related issues: #225, #204, #79): this allows us to tell apart the same binary reconnecting (meaning it's a continuation of the same stream) from the binary crashing and restarting (meaning it's a new stream that's a semantic continuation of the previous stream with the same name).\r\n\r\n(this is in some sense similar to how HTTP uses ETag)",
      "createdAt": "2023-11-09T17:13:44Z",
      "updatedAt": "2024-02-07T22:55:29Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 This token would inform a relay if two ANNOUNCEs are cooperative and share a cache.",
          "createdAt": "2023-11-09T17:57:22Z",
          "updatedAt": "2023-11-09T17:57:22Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "I am but worried that we are solving a problem that isn't actually a problem or I am not seeing it clearly.\r\n\r\nA publisher crashes/restarts and comes back - in either of these cases,  from a relay perspective there is objects for a given track with a small interruption in between. Yes the streams on which arrives changes in both the cases, but from a track and object state, the relays need to forward to matching subscribers and store the objects in the cache.\r\n\r\nI am not sure if having this token, a relay would act differently in terms of how it caches or forwards things.\r\n\r\nwhat am i missing here?",
          "createdAt": "2023-11-09T19:29:35Z",
          "updatedAt": "2023-11-09T19:29:35Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "@suhasHere it depends on what you mean by \"a publisher crashes\". Do you mean:\r\n\r\n- MoQ crashed?\r\n- QUIC crashed?\r\n- Encoder crashed?\r\n- Process crashed?\r\n- Host crashed?\r\n\r\nThe difference between them is the amount of state retained. You can resume existing subscriptions ONLY if the full MoQ and encoder state was retained, otherwise you'll wreck downstream subscribers.\r\n\r\n```\r\n# old process\r\nANNOUNCE webex.com/kixelated\r\nOBJECT track=video group=68 payload=h264\r\nOBJECT track=video group=69 payload=h264\r\n\r\n# segfault\r\n\r\n# new process\r\nANNOUNCE webex.com/kixelated\r\nOBJECT track=video group=0 payload=av1\r\nOBJECT track=video group=1 payload=av1\r\n```\r\n\r\nAny existing subscribers for `webex.com/kixelated/video` will either crash or ignore the new data. It is a fatal error if the relay considers both connections as bitwise identical in this instance.\r\n\r\n\r\nWhat Victor is proposing is that by default, ANNOUNCE is mutually exclusive unless you can provide an identical token. Something like:\r\n\r\n```\r\n# old process\r\nANNOUNCE webex.com/kixelated token=abc123\r\nOBJECT track=video group=68 payload=h264\r\nOBJECT track=video group=69 payload=h264\r\n\r\n# segfault\r\n\r\n# new process\r\nANNOUNCE webex.com/kixelated token=abc123\r\nOBJECT track=video group=70 payload=h264\r\nOBJECT track=video group=71 payload=h264\r\n```\r\n\r\nThe resumption token \"proves\" that you're a cooperative entity and not another instance launched by mistake. An application can hard-code the token if it wants to opt into shooting itself in the foot. If you want to do redundant ingest, both instances ANNOUNCE simultaneously with the same token and the relay knows both are potential sources.",
          "createdAt": "2023-11-10T02:22:59Z",
          "updatedAt": "2023-11-10T02:24:57Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "> What Victor is proposing is that by default, ANNOUNCE is mutually exclusive unless you can provide an identical token. Something like:\r\n\r\nI was actually thinking of new process starting with `group=0` again, since I don't think there is currently any way in the protocol to know that the previous process ended with `group=69`.",
          "createdAt": "2023-11-15T20:20:11Z",
          "updatedAt": "2023-11-15T20:20:11Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "A related question is how long is the name/namespace combo unique.",
          "createdAt": "2024-02-07T22:28:58Z",
          "updatedAt": "2024-02-07T22:28:58Z"
        },
        {
          "author": "englishm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 to some kind of unique token here. Unsure about the details.",
          "createdAt": "2024-02-07T22:55:28Z",
          "updatedAt": "2024-02-07T22:55:28Z"
        }
      ]
    },
    {
      "number": 336,
      "id": "I_kwDOG2Ho4M52fOF-",
      "title": "Can something be considered a MoQT relay if it does not terminate QUIC?",
      "url": "https://github.com/moq-wg/moq-transport/issues/336",
      "state": "OPEN",
      "author": "afrind",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Editorial"
      ],
      "body": "My understanding is that MoQ is always hop-by-hop encrypted by virtue of working over QUIC or WebTransport, and therefore a \"relay\" as described in the draft can only inspect Track/Group/Object metadata if it terminates QUIC.  The document should clarify the requirements.",
      "createdAt": "2023-11-10T15:58:52Z",
      "updatedAt": "2024-02-20T17:21:17Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tmengKOP",
          "authorAssociation": "NONE",
          "body": "I agree with Alan. As a QUIC enthusiast, I guess the current draft implicitly suggests hop-by-hop QUIC termination at relay, e.g., which is necessary to enable cache at relay while having MOQT Message Type and OBJECT metadata as QUIC payload. Yet it is definitely more clarified for readers to explicitly see that information in an early section (e.g., sec 1.1.4).",
          "createdAt": "2023-12-20T08:38:43Z",
          "updatedAt": "2023-12-20T08:38:43Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Given MoQ is over either QUIC or WebTransport, I believe it's impractical to restrict it to only QUIC based transports.",
          "createdAt": "2024-02-20T02:39:50Z",
          "updatedAt": "2024-02-20T02:39:50Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "> Given MoQ is over either QUIC or WebTransport, I believe it's impractical to restrict it to only QUIC based transports.\r\n\r\nThe context of the question is whether one can build an MoQ relay that can view object properties without terminating the TLS session underpinning MoQ or WebTransport (eg an untrusted middlebox).",
          "createdAt": "2024-02-20T17:21:16Z",
          "updatedAt": "2024-02-20T17:21:16Z"
        }
      ]
    },
    {
      "number": 337,
      "id": "I_kwDOG2Ho4M52hXc1",
      "title": "Extend SUBSCRIBE_OK message to include information about the live edge of the track",
      "url": "https://github.com/moq-wg/moq-transport/issues/337",
      "state": "CLOSED",
      "author": "wilaw",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Needs PR",
        "Subscribe"
      ],
      "body": "Consider an edge relay, receiving and forwarding relative SUBSCRIBE requests for -5, -3, and -1 for the same track. The first object it receives back is group 37. It cannot tell where to place this object in the sequence and must therefore hold it until it knows more information. If the next object is Group 39, it still cannot forward it, because the head sate is undefined.\r\n\r\nWe can solve this problem simply by having the SUBSCRIBE_OK response indicate the latest group and object number:\r\n\r\nSUBSCRIBE_OK\r\n{\r\n  Track Namespace (b),\r\n  Track Name (b),\r\n  Track Alias (i),\r\n  Expires (i),\r\n  LastestGroup(i),\r\n  LastestObject(i)\r\n}\r\n\r\nOne consequence of adding these fields is that an edge, which has no active subscription for the track,  cannot send the SUBSCRIBE_OK response until it itself receives a SUBSCRIBE_OK after forwarding the SUBSCRIBE. This makes subscription an async process in which the acknowledgment of the subscription may take in some cases a RTT back to the origin. I think this is necessary for stable state management. \r\n",
      "createdAt": "2023-11-10T21:52:31Z",
      "updatedAt": "2024-02-18T21:12:50Z",
      "closedAt": "2024-02-18T21:12:50Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 this is required to build a relay and a non-realtime player.\r\n\r\n> One consequence of adding these fields is that an edge, which has no active subscription for the track, cannot send the SUBSCRIBE_OK response until it itself receives a SUBSCRIBE_OK after forwarding the SUBSCRIBE. This makes subscription an async process in which the acknowledgment of the subscription may take in some cases a RTT back to the origin.\r\n\r\nThis was required anyway, otherwise the relay would swallow any application SUBSCRIBE_ERROR codes. My mental model is that SUBSCRIBE_OK == HTTP response headers.",
          "createdAt": "2023-11-11T01:13:54Z",
          "updatedAt": "2023-11-11T01:13:54Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> One consequence of adding these fields is that an edge, which has no active subscription for the track, cannot send the SUBSCRIBE_OK response until it itself receives a SUBSCRIBE_OK after forwarding the SUBSCRIBE\r\n\r\nMoqt is a pub/sub protocol and is hop-by-hop protocol. A subscribe ok means the susbcribe request was validated at the relay. A OK isn't tied to getting a OK from the original publisher. Its sub/sub-ok is a async operation ( like any typical pub/sub systems out there). An ok for subscribe means a promise that if there is a matching data ( either in cache or coming in from a live publisher at some point), it will be forwarded . ",
          "createdAt": "2023-11-12T19:24:29Z",
          "updatedAt": "2023-11-12T19:24:29Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> Consider an edge relay, receiving and forwarding relative SUBSCRIBE requests for -5, -3, and -1 for the same track. The first object it receives back is group 37. It cannot tell where to place this object in the sequence and must therefore hold it until it knows more information\r\n\r\nClarifying question , if the use-case is something like VOD or non real-time flows, I think the same can be done by\r\n```\r\n1. Subscribe to live edge using relative offset and not the latest group/object\r\n2. Subscribe again to the right point by absolute offert\r\n```\r\n\r\n",
          "createdAt": "2023-11-12T19:28:58Z",
          "updatedAt": "2023-11-12T19:28:58Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> > One consequence of adding these fields is that an edge, which has no active subscription for the track, cannot send the SUBSCRIBE_OK response until it itself receives a SUBSCRIBE_OK after forwarding the SUBSCRIBE\r\n> \r\n> Moqt is a pub/sub protocol and is hop-by-hop protocol. A subscribe ok means the susbcribe request was validated at the relay. A OK isn't tied to getting a OK from the original publisher. Its sub/sub-ok is a async operation ( like any typical pub/sub systems out there). An ok for subscribe means a promise that if there is a matching data ( either in cache or coming in from a live publisher at some point), it will be forwarded .\r\n\r\nI absolutely don't want this behavior.\r\n\r\nIt means that a generic relay will always return SUBSCRIBE_OK, even if it cannot route (or authenticate) a SUBSCRIBE. A typo or finished broadcast would be indistinguishable from a valid request unless OBJECTs start to flow. SUBSCRIBE_OK would be equivalent to HTTP 100 CONTINUE, which is truly useless, and there would be no equivalent to 200 OK or 404 Not Found.\r\n\r\nPub/sub doesn't mean black hole simulator either. I've only used RabbitMQ a long time ago, but if you tried to bind a queue (ie. SUBSCRIBE) to an exchange (ie. ANNOUNCE) it will return an error if the exchange doesn't exist. Is the justification that pub/sub protocols are _supposed_ to black hole, or is this behavior that you actually want?\r\n\r\nInstead of hanging indefinitely if a relay can't route a SUBSCRIBE, wouldn't it just be better to receive a 404 Not Found? You're allowed to try again, but now there's no timers or guess work as to if the SUBSCRIBE could be routed to an origin.",
          "createdAt": "2023-11-13T01:17:41Z",
          "updatedAt": "2023-11-13T01:35:50Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> > Consider an edge relay, receiving and forwarding relative SUBSCRIBE requests for -5, -3, and -1 for the same track. The first object it receives back is group 37. It cannot tell where to place this object in the sequence and must therefore hold it until it knows more information\r\n> \r\n> Clarifying question , if the use-case is something like VOD or non real-time flows, I think the same can be done by\r\n> \r\n> ```\r\n> 1. Subscribe to live edge using relative offset and not the latest group/object\r\n> 2. Subscribe again to the right point by absolute offert\r\n> ```\r\n\r\nIt's for higher latency targets. HLS/DASH clients don't start at the latest segment, but rather start further back based on the target latency.\r\n\r\nIf I understand correctly, you're saying the relay:\r\n\r\n0. has an empty cache.\r\n1. receives a `SUBSCRIBE start=relative/3` and `SUBSCRIBE start=relative/5`.\r\n2. issues issues a live subscription upstream: `SUBSCRIBE start=relative/0`\r\n3. waits for the first OBJECT to arrive for that subscribe, using it as the live playhead: `N = object.group`\r\n4. issues a backfill subscribe upstream: `SUBSCRIBE start=absolute/N-5 end=absolute/N`\r\n5. forwards any objects based on the mapping from relative to absolute.\r\n\r\nIt works for relays, but at the cost of an extra round-trip to origin. However, it won't work for clients that want to start playback N groups back (jitter buffer size), because the player doesn't know when/what to render without first receiving N distinct groups.\r\n\r\nHere's what we would like:\r\n\r\n0. has an empty cache.\r\n1. receives a `SUBSCRIBE start=relative/3` and `SUBSCRIBE start=relative/5`.\r\n2. (re)issues a subscription upstream: `SUBSCRIBE start=relative/5`\r\n3. waits for `SUBSCRIBE_OK latest=N`\r\n4. forwards any objects based on the mapping from relative to absolute.",
          "createdAt": "2023-11-13T01:35:04Z",
          "updatedAt": "2023-11-13T02:32:36Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment:\r\n\r\nI think SUBSCRIBE_OK needs to resolve all relative Subscribe Hints that were passed in the Subscribe. Otherwise, I'm really not sure how my library will know when an Object arrives if it belongs to a particular subscription or not -- the OBJECTs that arrive have only track name and absolute group/object numbers. I see the use case for some relays wanting to optimistically SUBSCRIBE_OK, but then there would need to be a follow up message that resolves the relative hints when the relay finds out where they map.",
          "createdAt": "2023-11-14T00:56:05Z",
          "updatedAt": "2023-11-14T00:56:05Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think SUBSCRIBE_OK needs to resolve all relative Subscribe Hints that were passed in the Subscribe. Otherwise, I'm really not sure how my library will know when an Object arrives if it belongs to a particular subscription or not -- t\r\n\r\nCouple of observations\r\n  - what use-cases would involve same client sending multiple subscription hints at the same time ?\r\n  - Hints are read access points on the same track and if a client ask for multiple such points, it will get objects on the same track regardless .. how relays puts them together in such a case for a given client cannot be normatively specified \r\n  \r\n  \r\n  @afrind can you give me a concrete use-case example of \"resolve all relative Subscribe Hints that were passed in the Subscribe\" from a single client so that it helps understand the issue better.  I personally don't think the issue being discussed is directly related to this ...\r\n",
          "createdAt": "2023-11-14T17:41:02Z",
          "updatedAt": "2023-11-14T17:41:24Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> what use-cases would involve same client sending multiple subscription hints at the same time ?\r\n\r\nThe use case of an edge relay forwarding simultaneous requests from multiple connected clients. This is a common use-case for any edge or fan-out relay. \r\n",
          "createdAt": "2023-11-14T20:19:38Z",
          "updatedAt": "2023-11-14T20:19:38Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment: \r\n\r\n> > what use-cases would involve same client sending multiple subscription hints at the same time ?\r\n> \r\n> The use case of an edge relay forwarding simultaneous requests from multiple connected clients. This is a common use-case for any edge or fan-out relay.\r\n\r\nThis is definitely one use case.  Another is a client making two simultaneous subscriptions: eg live edge and range request starting some time in the past.",
          "createdAt": "2023-11-15T00:35:19Z",
          "updatedAt": "2023-11-15T00:35:19Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One thing that will not scale is every subscription needing to go back to the original publisher. Consider the cases of a million users are joining a session that starts at the top of the hour and that is published  from a mobile device.  I think that in any real system there is also going to be no single idea of the live edge. The live edge is relative to which relay you subscribed to. If the relay you are on is over a geo sync satellite, it is going to be behind ones that are not. \r\n\r\nSo here is what I think we should do. We should not allow relative subscription to things in the past. I think the uses cases I have heard for this can be deal with as subscribe to live edge forward and as once the client find out what object that is, do an absolute subscribe for any data in the past to fill in buffers etc.  So to be clear, no relative group or object sequences that are negative but still allows absolute.  This seems to meet the use cases and remove a ton of edge case design problems. \r\n\r\nTo be clear, I think we should be able to subscribe to the current group, but give me object 0 forward in that group. If it is a group per GOP, this allows one to get everything needed to decode the current frame. ",
          "createdAt": "2023-11-27T18:57:34Z",
          "updatedAt": "2023-11-27T18:57:34Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> One thing that will not scale is every subscription needing to go back to the original publisher. \r\n\r\nBut not every subscription has to go back to publisher. It only has to go back to a node that is already subscribed and understands the live edge. Furthermore, concurrent requests would be coalesced at each node. Imagine in the worst case that 1 million requests are made within 100ms to a (really powerful)  edge. That edge would only forward _one request_ to the origin. All the rest would be held pending that response. This is exactly what happens when a few million people ask for a live HAS stream. Due to fan out and request coalescing, the CDN only sends a few requests back to the actual origin.",
          "createdAt": "2023-11-27T19:34:33Z",
          "updatedAt": "2023-11-27T19:34:33Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> > One thing that will not scale is every subscription needing to go back to the original publisher.\r\n> \r\n> But not every subscription has to go back to publisher. It only has to go back to a node that is already subscribed and understands the live edge. Furthermore, concurrent requests would be coalesced at each node. Imagine in the worst case that 1 million requests are made within 100ms to a (really powerful) edge. That edge would only forward _one request_ to the origin. All the rest would be held pending that response. This is exactly what happens when a few million people ask for a live HAS stream. Due to fan out and request coalescing, the CDN only sends a few requests back to the actual origin.\r\n\r\nYeah exactly.\r\n\r\nOnly the first SUBSCRIBE will propagate upstream and the SUBSCRIBE_OK is used to bootstrap the live edge. The relay can infer the live edge while the single upstream subscribe remains active.\r\n\r\n| upstream | direction | downstream |\r\n|-|:-:|-|\r\n| SUBSCRIBE start=relative/3 | <- | SUBSCRIBE start=relative/3 |\r\n|  SUBSCRIBE_OK start=absolute/74 | -> | SUBSCRIBE_OK start=absolute/74 |\r\n| | <- | SUBSCRIBE start=relative/1 |\r\n| | -> | SUBSCRIBE_OK start=absolute/76 |\r\n| OBJECT group=75 | -> | OBJECT group=75 |\r\n\r\nBecause of the SUBSCRIBE_OK, the relay knows that the received OBJECT only gets forwarded to the first downstream subscribe. Otherwise it would have to guess the live edge.\r\n\r\nThe relay keeps track of `max_group` while the upstream subscription remains active. The initial value is set by `SUBSCRIBE_OK` but all future updates are based on received `OBJECT` messages. This way is can map from relative->absolute and reply with `SUBSCRIBE_OK` without issuing a new upstream subscription.\r\n\r\n| upstream | direction | downstream |\r\n|-|:-:|-|\r\n| OBJECT group=78 | -> | OBJECT group=78 |\r\n| OBJECT group=79 | -> | OBJECT group=79 |\r\n| | <- | SUBSCRIBE start=relative/1 |\r\n| | -> | SUBSCRIBE_OK start=absolute/78 |\r\n\r\n",
          "createdAt": "2023-11-27T21:06:36Z",
          "updatedAt": "2023-11-27T21:06:36Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "For the original use-case reported on this issue, if there are multiple subscribes at a relay with varying relative offsets,  the relay has no choice but to send each combination of subscribe and a given -ve relative offsite upstream since that identifies each unique data point in the track. \r\n\r\nThis has couple of issues\r\n\r\n - it doesn't scale across relays and also when there are very high rate of subscriptions across relays and clients\r\n - it makes the lookup and state management complicated\r\n - latencies across relays and client locations ends up producing varying results for the same query since it depends on when the query was made and how long would it take to \r\n - for conferencing cases when there are multiple publishers who can be active (have live edge), unjoined yet ( so no live edge) , the expectation for subscribes to get a OK back from original publishers will not scale in terms of latency of joins \r\n - \r\n\r\nThe more i think of it, subscribing back into paste using a relative offsets and expecting the answer to be vetted by the original publisher  \"unnecessarily complicates the protocol\".\r\n\r\n",
          "createdAt": "2023-11-29T03:40:12Z",
          "updatedAt": "2023-11-29T05:37:37Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> if there are multiple subscribes at a relay with varying relative offsets, the relay has no choice but to send each combination of subscribe and a given -ve relative offsite upstream since that identifies each unique data point in the track.\r\n\r\nThe group sequence numbers are consistent between subscriptions . If a relay receives relative subscribes of -5,-3 and -1, all it has to is send a single subscribe upstream of -5. The response would give it the live edge group as well as all the content for the various subscriptions. If the subscriptions were -345, -2, -1, the relay could decide to make two subscriptions upstream - one for -345, the other for -2, because it didn't want to force the smaller relative subscriptions to wait for the larger one. The point is, this is optimization logic for the relay. It does have a choice in what subscriptions it sends upstream based on the timing and diversity of the input subscriptions.\r\n\r\n> the expectation for subscribes to get a OK back from original publishers will not scale in terms of latency of joins\r\n\r\nWhy is the latency of the join affected? Consider a subscriber talking to an edge where the subscriber is 100ms away from the origin. We consider two scenarios: in the first case the subscriber receives a SUBSCRIBE_OK immediately after subscribing but then waits 100ms for the audio and video to arrive from the origin. In the second case the the subscriber waits 100ms to receive SUBSCRIBE_OK but it is immediately followed by the audio and video. So in both cases the subscriber gets its audio and video after 100ms. The media latency is consistent under either scenario. ",
          "createdAt": "2023-11-29T09:28:05Z",
          "updatedAt": "2023-11-29T09:28:05Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> The group sequence numbers are consistent between subscriptions . If a relay receives relative subscribes of -5,-3 and -1, all it has to is send a single subscribe upstream of -5.\r\n\r\nIf the relay logc is to send only a single subscribe upstream, then you don't need anything to be said in Subscribe OK either. Since when the first object arrives it can compute the live edge by adding 5 to the object being reported and the compute the absolute values for others (in this case for -3 and -1).  That would definitely make things simpler for sure.",
          "createdAt": "2023-11-29T14:56:31Z",
          "updatedAt": "2023-11-29T14:58:54Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> the relay could decide to make two subscriptions upstream - one for -345, the other for -2\r\n\r\nFor cases where a client wants to go back 345 groups in past, i will be very much inclined to do an absolute request after learning the latest known state of the group as an end application OR something catalog can describe more information to make the right absolute request on the first go",
          "createdAt": "2023-11-29T15:02:42Z",
          "updatedAt": "2023-11-29T15:22:26Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Since when the first object arrives it can compute the live edge by adding 5 to the object being reported and the compute the absolute values for others (in this case for -3 and -1).\r\n\r\nIt can't do this because the order of items it receives as Streams is not guaranteed. The origin may send the groups in order -5,-4,-3,-3,-1, but they could be received at the relay (or any hop) as -3, -5,-4,-1,-2. That's why you need an explicit notification from the origin as to where the live edge is. Only that plus the group sequence numbers allow the correct sequencing, not the order of arrival. ",
          "createdAt": "2023-11-29T16:12:20Z",
          "updatedAt": "2023-11-29T16:12:20Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "In this case there was just a single subscribe request with -5 was sent upstream, based on your explanation above. This avoids all the confusion which would happen when there are multiple inflight -ve offsets.",
          "createdAt": "2023-11-29T16:25:49Z",
          "updatedAt": "2023-11-29T16:25:49Z"
        }
      ]
    },
    {
      "number": 345,
      "id": "I_kwDOG2Ho4M59GT7A",
      "title": "What if/Why will never deliver an Object/Track",
      "url": "https://github.com/moq-wg/moq-transport/issues/345",
      "state": "OPEN",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Needs Discussion",
        "Object Model",
        "Subscribe",
        "Transmission"
      ],
      "body": "If the relay/origin will never be able to fulfill an entire requested SUBSCRIBE, how can it indicate that?  For example, a sequence of relays and the origin may only keep video within 30 seconds of head and discard older content.\r\n\r\nAs a related question, does the relay need to indicate that there will be gaps in Object or Group IDs so the player doesn't wait for them?\r\n\r\nHigh-Level Q: An object has not been delivered, why?\r\n\r\n1. It doesn't exist anymore.\r\n2. It never existed.\r\n3. There wasn't enough bandwidth to send it based on... (ie: priority, the subscriber's latency requirements, etc)\r\n4. It was sent in a stream/datagram by itself and reordered (I think we have this covered?)",
      "createdAt": "2024-01-24T17:59:34Z",
      "updatedAt": "2024-03-18T03:31:34Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kixcord",
          "authorAssociation": "NONE",
          "body": "Yeah so for the real-time use-case, we don't really need a signal because the viewer will skip over any gaps larger than X ms.\r\n\r\nBut in the low-latency use-case, where we want to buffer content rather than skip, then we do need an explicit signal. Otherwise the viewer will be stuck buffering indefinitely, blocked on a group that will never arrive. The same is true for the start of a subscribe; if I request starting back -5 groups, then the player will buffer until -5 is delivered unless I get an explicit signal otherwise.\r\n\r\nThe same is also true in the VOD use-case. If there's a gap in the VOD, possibly due to congestion during the live broadcast or just storage corruption, the player needs some way to know to skip over it.",
          "createdAt": "2024-01-24T18:02:24Z",
          "updatedAt": "2024-01-24T18:03:38Z"
        },
        {
          "author": "kixcord",
          "authorAssociation": "NONE",
          "body": "> The same is true for the start of a subscribe; if I request starting back -5 groups, then the player will buffer until -5 is delivered unless I get an explicit signal otherwise.\r\n\r\n@suhasHere this is also why we need something like #343. The player subscribes starting at -5 and will start playback there (for 10s target latency), buffering until then. However it doesn't know which group is -5, since it receives objects with absolute group IDs instead. If the player starts playback at the wrong group, then it will have the wrong latency.",
          "createdAt": "2024-01-24T18:08:32Z",
          "updatedAt": "2024-01-24T18:09:25Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> If the relay/origin will never be able to fulfill an entire requested SUBSCRIBE, how can it indicate that? \r\n\r\nBy echoing back the range it can fulfill in SUBSCRIBE_OK response. Let's say the SUBSCRIBE is for groups 10-20, but the origin knows that the DVR window now ends at 15 and it can only return 15-20. For example .\r\n\r\n```\r\nSUBSCRIBE\r\n{\r\n StartGroup 10,\r\n EndGroup 20\r\n..\r\n}\r\n```\r\n\r\ncould return \r\n\r\n```\r\nSUBSCRIBE_OK\r\n{\r\n StartGroup 15,\r\n EndGroup 20\r\n..\r\n}\r\n```\r\n\r\n\r\nSome consequences of this\r\n1. A relay can't cache the responses to SUBSCRIBE requests, as they will differ with the time that the request comes in.\r\n2. Relay's need to honor TTL's rigorously. Lets imagine the live stream delivers segments 0-30 and the edge relay caches all of them. A client comes later and asks for 10-20, at the time that the tail of the DVR window is at 15. If the origin is not careful to set the TTL of 0-15 such that they expire from cache , then the edge relay would just server 10-20 from cache which would invalidate the DVR window. Since relays don't read catalogs, the only way to enforce a DVR window for live streams is through TTLs\r\n3. What about gaps in the range? If the origin can return 10-20 but missing 13 and 17, how could it communicate that? One way might be to repeat the tuples of Start and End Group to describe what is available:\r\n\r\n```\r\nSUBSCRIBE_OK\r\n{\r\n StartGroup 10,\r\n EndGroup 12,\r\n StartGroup 14,\r\n EndGroup 16,\r\n StartGroup 18,\r\n EndGroup 20,\r\n}\r\n```\r\n\r\nor a cleaner syntax like\r\n\r\n```\r\nSUBSCRIBE_OK\r\n{\r\nResponseGroups  [{10,12},{14,16}, {18,20}]\r\n}\r\n```\r\n\r\n\r\n",
          "createdAt": "2024-01-25T18:24:54Z",
          "updatedAt": "2024-01-25T18:24:54Z"
        },
        {
          "author": "gwendalsimon",
          "authorAssociation": "NONE",
          "body": "> > If the relay/origin will never be able to fulfill an entire requested SUBSCRIBE, how can it indicate that?\r\n\r\nIn Today's world, when the origin has a storage corruption, the \"relay\" (aka CDN server) does not gracefully notify the client in advance. It replies by a error and the client has to deal with it. \r\nNot that MoQ should not offer a better process, but just to say that clients are also part of the game. If there is a gap in the flow, then the client can apply the right timers to not get stuck forever.\r\n\r\n> 2. Relay's need to honor TTL's rigorously. Lets imagine the live stream delivers segments 0-30 and the edge relay caches all of them. A client comes later and asks for 10-20, at the time that the tail of the DVR window is at 15. If the origin is not careful to set the TTL of 0-15 such that they expire from cache , then the edge relay would just server 10-20 from cache which would invalidate the DVR window. Since relays don't read catalogs, the only way to enforce a DVR window for live streams is through TTLs\r\n\r\nWow, this process seems extremely heavy to me.\r\nFirst, it would mean that, for every request in the past (positive StartGroup RelativePosition), the relay must check the TTL of all cached segments between StartGroup and largest group ID to check whether all segments will not be expired at the time of their respective playout. It is a lot of processing,\r\nSecond, what can the relay do if the segments are not cached (or if some segments are not cached)? Not TTL nor expiration awareness.\r\n\r\nWould it be possible to add a metadata in the ANNOUNCEMENT to indicate expiration, and possibly gaps?",
          "createdAt": "2024-01-26T09:14:24Z",
          "updatedAt": "2024-01-26T09:14:24Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> the relay must check the TTL of all cached segments between StartGroup and largest group ID to check whether all segments will not be expired at the time of their respective playout. It is a lot of processing,\r\n\r\nAgree. It would be expensive to scan the cache looking for expired objects in the range  _before_ giving the SUBSCRIBE_OK response. The more efficient time to check for expiration is when the server is reading each object in the cache, which it has to do when it serves them out. Perhaps we can send a control message - GROUP #N unavailable - and then skip over the expired objects? We could just skip over them without notifying the client, but then the client would sit there buffering and waiting for the objects it has requested. This means we should invent a means of notifying the client about unavailable groups (due to expiration, object not found etc). \r\n\r\n> what can the relay do if the segments are not cached (or if some segments are not cached)? \r\n\r\nIt must do what it always does when it doesn't have something, which is make a request upstream, towards the origin. \r\n",
          "createdAt": "2024-01-26T09:52:02Z",
          "updatedAt": "2024-01-26T09:52:02Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just getting back up to speed on this so I could be missing the key part of this ... I agree we need a way to solve Lukes issue of knowing how -5 corresponds to the live edge but the the rest of this seems unnecessary.  If a client asks for something that is has expired, it just does not get it. I don't think the relay needs to tell clients about gaps, the client can figure that out, and I am sure that I don't want the relay changing what the client asked for. ",
          "createdAt": "2024-01-29T19:22:00Z",
          "updatedAt": "2024-01-29T19:22:00Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> If a client asks for something that is has expired, it just does not get it.\r\n\r\nFine, but then the problem becomes the client still thinks it will get it and so it times-out and rebuffers waiting for it instead of taking some other corrective action. How can the client tell the difference between groups that are delayed, versus groups that will never come? ",
          "createdAt": "2024-01-29T20:58:33Z",
          "updatedAt": "2024-01-29T20:58:33Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> How can the client tell the difference between groups that are delayed, versus groups that will never come?\r\n\r\nI wonder what parts of this needs to be solved at MOQT layer vs streaming format layer. This seems a requirement specific to certain class of applications.",
          "createdAt": "2024-01-29T23:08:26Z",
          "updatedAt": "2024-01-29T23:08:26Z"
        }
      ]
    },
    {
      "number": 346,
      "id": "I_kwDOG2Ho4M59Ihp8",
      "title": "Error code for version mismatch?",
      "url": "https://github.com/moq-wg/moq-transport/issues/346",
      "state": "OPEN",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Wire Format"
      ],
      "body": "Should there be an error code for when the server terminates the session, because the client doesn't offer a version it understands?",
      "createdAt": "2024-01-25T01:13:19Z",
      "updatedAt": "2024-01-31T00:18:13Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 347,
      "id": "I_kwDOG2Ho4M59POYB",
      "title": "Additional Subscribe Errors",
      "url": "https://github.com/moq-wg/moq-transport/issues/347",
      "state": "OPEN",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Wire Format"
      ],
      "body": "I woudld think that \"track doesn't exist\" and \"unauthorized\" would be useful error codes, but they don't seem to fit in 'Invalid Range' or 'Retry Track Alias'.",
      "createdAt": "2024-01-25T20:47:18Z",
      "updatedAt": "2024-02-14T18:02:00Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed today, it'd be nice to have one indicating \"Timeout\".",
          "createdAt": "2024-02-14T18:01:59Z",
          "updatedAt": "2024-02-14T18:01:59Z"
        }
      ]
    },
    {
      "number": 348,
      "id": "I_kwDOG2Ho4M59PPRP",
      "title": "Namespace Collision with \"Generic Error\"",
      "url": "https://github.com/moq-wg/moq-transport/issues/348",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "it is a bit annoying for both application errors and subscribe errors to have something called \"Generic Error\", which have different numbers.\r\n\r\n This can obviously be solved in code, but means I'll have to use words not in the spec.",
      "createdAt": "2024-01-25T20:50:02Z",
      "updatedAt": "2024-01-25T21:28:25Z",
      "closedAt": "2024-01-25T21:28:25Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Never mind, it's not that big of a deal.",
          "createdAt": "2024-01-25T21:28:25Z",
          "updatedAt": "2024-01-25T21:28:25Z"
        }
      ]
    },
    {
      "number": 349,
      "id": "I_kwDOG2Ho4M59WYbv",
      "title": "SUBSCRIBE needs Num Parameters field",
      "url": "https://github.com/moq-wg/moq-transport/issues/349",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Needs PR",
        "Wire Format"
      ],
      "body": "if there are going to be \"track request parameters\" in subscribe, we need a way of indicating that it is present. Presumably via a NumParameters field.",
      "createdAt": "2024-01-26T22:48:15Z",
      "updatedAt": "2024-02-08T19:02:46Z",
      "closedAt": "2024-02-08T19:02:46Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment: \r\n\r\nCan you use the message length?  eg: if there are any bytes remaining after parsing required fields, parse another param?",
          "createdAt": "2024-01-27T00:20:52Z",
          "updatedAt": "2024-01-27T00:20:52Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There is no message length, right? Or did that come back?",
          "createdAt": "2024-01-27T02:43:42Z",
          "updatedAt": "2024-01-27T02:43:42Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "You are right, there's no message length, and this looks like an oversight or mis-merge?  Can you make a PR to add Num Parameters, and perhaps the group will agree to set the interop target to draft-02 + that PR?",
          "createdAt": "2024-01-31T00:17:37Z",
          "updatedAt": "2024-01-31T00:17:37Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Reading RFC 9000 section 1.3, I thought the syuntax \"x (L) ...\" meant we would have zero or more and it included the counter of how many in the encoding. I could be missing the boat here but not seeing why we have the number twice on the wire. I am always confused about the syntax used in RFC 9000 so I probably confused here but someone walk me through it. ",
          "createdAt": "2024-02-01T13:59:52Z",
          "updatedAt": "2024-02-01T13:59:52Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, some of these 9000 formats are very confusing, and I had to look again.\r\n\r\nThe format in the MOQT draft is 'Parameters (..) ...'. I can't really parse the definitions in 1.3, but this notation occurs in two places in 9000. One is ACK ranges, and ACKs have an explicit ack_range_count field. \r\n\r\nIn any case, there are several other places (SETUP, ANNOUNCE) where we have the field listed there. So:\r\n1) I think the notation is wrong\r\n2) Even if it isn't we should be consistent\r\n3) Even if it isn't, it impedes understanding and an explicit listing would be better.",
          "createdAt": "2024-02-01T15:43:04Z",
          "updatedAt": "2024-02-01T15:43:04Z"
        }
      ]
    },
    {
      "number": 350,
      "id": "I_kwDOG2Ho4M59WZYB",
      "title": "When to use Track Alias or Subscribe ID?",
      "url": "https://github.com/moq-wg/moq-transport/issues/350",
      "state": "OPEN",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Object Model",
        "Subscribe"
      ],
      "body": "Sec 6.4.2: \"If the Track Alias is already in\t\r\n \t      use, the publisher MUST close the session with a Duplicate Track\t\r\n \t      Alias error (Section 3.5).\"\r\n\r\nThis makes sense if it's a different track name. But if it's the same track for two subscriptions, they should have the same track_alias, right? What's the purpose of track alias and subscribe ID always going together in objects, anyway?\r\n \t\r\n\r\n",
      "createdAt": "2024-01-26T22:52:27Z",
      "updatedAt": "2024-03-19T06:08:24Z",
      "closedAt": null,
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Having read through this now, I think we should just eliminate Subscribe_id from the Object message types.\r\n\r\nIf there are overlapping subscriptions, senders should only send it once, and it's ambiguous what subscribe ID to use.",
          "createdAt": "2024-01-26T23:01:41Z",
          "updatedAt": "2024-01-26T23:01:41Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment: \r\n\r\n> If there are overlapping subscriptions, senders should only send it once, and it's ambiguous what subscribe ID to use.\r\n\r\nI think the idea is that you have to send the object multiple times if it matches more than one subscription.  Without subscription ID, there's no way for a receiver to know if a received object matches the relative subscribe locations it sent.  That said, we could come up with a format that allows for more than one subscription ID, which is almost certainly more compact. \r\n\r\nThere was also concern about mixing objects from different subscriptions in the same multi-object stream.",
          "createdAt": "2024-01-27T00:18:56Z",
          "updatedAt": "2024-01-27T00:18:56Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I confess to not having thought about relays as much as most, but I'm not sure how this model works for relays.\r\n\r\n1) Clearly, the relay cannot just forward each subscription, as that totally negate the scalability benefit.\r\n\r\n2) If the relay is aggrating subscriptions which come in over time, that is going to result in duplicate objects en masse? Or are we planning to have relays routinely SUBSCRIBE_FIN when a new subscription comes in, so it can send a new consolidated SUBSCRIBE?\r\n\r\n3) Or are we counting on the vast majority of client subscriptions being \"give me the next one\", so as not to require a new relay subscription to produce?",
          "createdAt": "2024-01-29T15:15:38Z",
          "updatedAt": "2024-01-29T15:15:38Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is entangled with a bunch of other issues, but I don't see the point of specifying a track ID at all -- the subscriber proposes one, the publisher can refuse it, but this number is never used again except as a (redundant) identifier in the OBJECT message.\r\n\r\nSo what's the purpose of this message?",
          "createdAt": "2024-01-29T17:00:08Z",
          "updatedAt": "2024-01-29T17:00:08Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "also: how does sending multiple copies relate to forwarding preference? i.e. if I send the same object twice, is it on the same stream or on different streams?",
          "createdAt": "2024-01-29T17:47:44Z",
          "updatedAt": "2024-01-29T17:47:44Z"
        },
        {
          "author": "hardie",
          "authorAssociation": "COLLABORATOR",
          "body": "On Mon, Jan 29, 2024 at 5:47\u202fPM Martin Duke ***@***.***>\r\nwrote:\r\n\r\n> also: how does sending multiple copies relate to forwarding preference?\r\n> i.e. if I send the same object twice, is it on the same stream or on\r\n> different streams?\r\n>\r\nThe current theory, at least as I understand it, is that it depends on how\r\nmany subscriptions there are.  If the two objects are being sent because\r\nthere are two active subscriptions, they would be on different streams even\r\nin the one-stream-per-track theory.  The larger context for this is that we\r\nexpect the client to be the one to manage the use cases where it both wants\r\na subscription from the live edge and to gather data from before the live\r\nedge for playback.  It sends two distinct subscriptions,one per desired\r\nresult, and when it starts seeing duplicate objects it can then unsubscribe\r\nfrom one of the two (it may not, if they are going to different devices, so\r\nthis is not required, but up to the UE).\r\n\r\n\u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/moq-wg/moq-transport/issues/350#issuecomment-1915257107>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AAKVXZE32NKA3UDNBVYB3SLYQ7OE3AVCNFSM6AAAAABCM2QLDKVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMYTSMJVGI2TOMJQG4>\r\n> .\r\n> You are receiving this because you are subscribed to this thread.Message\r\n> ID: ***@***.***>\r\n>\r\n",
          "createdAt": "2024-01-29T18:15:02Z",
          "updatedAt": "2024-01-29T18:15:02Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK, after some clarification on the list, I think this is the state:\r\n- the draft currently requires sending one copy per subscribe, though this is by no means settled. (See #269)\r\n- if we end up sticking with that, then track_alias is entirely pointless and should be removed\r\n- if we go to one-time transmission, then subscribe_id should be removed from Object messages.",
          "createdAt": "2024-01-29T18:43:23Z",
          "updatedAt": "2024-01-29T18:43:23Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Definitely need some discussion time on this.  \r\n\r\nThe subscribes should be used to for the client to say what it wants but because the data is not delivered in order with the control steam, there are all kinds of race conditions particularly with clients reconnecting, multiple layers of relays, things failing and HA, etc. That makes me think the data plane / objects should not have the subscription ID.  ",
          "createdAt": "2024-02-04T23:38:15Z",
          "updatedAt": "2024-02-04T23:38:15Z"
        }
      ]
    },
    {
      "number": 351,
      "id": "I_kwDOG2Ho4M59iogt",
      "title": "Is the scope of Forwarding Preference really Objects?",
      "url": "https://github.com/moq-wg/moq-transport/issues/351",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Object Model"
      ],
      "body": "Draft-02 strongly implies the forwarding preference is a per-object decision. thus the following sequences would be legal:\r\n[sequences are written as (group, object)]\r\n\r\nStream 2: (0, 1), (0, 2) (0, 3) (0, 5) -- type is StreamHeaderGroup\r\nStream 6: (0, 4) -- type is ObjectStream\r\n\r\nor\r\n\r\nStream 2: (0, 0), (1, 0), (2, 0), (3, 0) -- type is StreamHeaderTrack\r\nStream 6: (1,1) -- type is Object Stream\r\n\r\netc.\r\n\r\nIf someone can imagine a use case for this, that's great. If not, it would be easier to implement with different assumptions, e.g.\r\n\r\n(1) Forwarding preference is a track-level property. Thus the preference could be provided in the SUBSCRIBE_OK and we wouldn't evens strictly need four different object codepoints (though you would want the distinct formats, and might want to retain the codepoints for that reason)\r\n\r\n(2) Forwarding preference is group-level -- some groups could be aggregated under StreamHeaderTrack, but others could be under StreamHeaderGroup. If there is a StreamHeaderGroup for a group, there MUST NOT be object-level streams for that group.\r\n\r\nAgain, I have little sense of the use cases out there, but I think we should explicitly decide what we are doing and make it clear in  the doc.\r\n",
      "createdAt": "2024-01-29T19:09:34Z",
      "updatedAt": "2024-02-20T17:41:00Z",
      "closedAt": "2024-02-18T20:28:54Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A related question is whether forwarding preference applies across subscribes. That is, for per-group streams,\r\n\r\na current subscriber gets all of group 12 and then the stream closes.\r\n\r\na later subscribe in the same session asks for group 12. Obviously, this will need a new stream.\r\n\r\nSo maybe the answer is no, it does not apply across subscribes",
          "createdAt": "2024-01-29T20:04:11Z",
          "updatedAt": "2024-01-29T20:04:38Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree, this is very difficult for a decoder to support.\r\n\r\nThe target use-case is non-reference frames. In your first example, object 4 is optional so it gets its own stream. However the receiver doesn't know that, instead it just sees a gap between 3 and 5.\r\n\r\nDoes the receiver try to decode and catch any errors? How long does it wait before trying? If I want minimal latency, do I have to partially decode (on a per codec basis) to get the frame dependency graph?\r\n\r\nI really don't like this option. I instead want an explicit way to know that this object is a non-reference frame. \r\n\r\nIdeas:\r\n- Make a separate track for non-reference frames and SVC layers.\r\n- Receive a formula that every 3x+1 object is optional?\r\n- Receive a live object catalog containing metadata about each object.\r\n\r\nMy vote is a separate track and each track has a uniform forwarding preference. ",
          "createdAt": "2024-01-31T16:32:39Z",
          "updatedAt": "2024-01-31T16:32:39Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I like the idea of uniform forwrarding preference for a track.  That's what I had in mind when we landed that PR.\r\n\r\nI can't think of any use cases this restriction prevents.",
          "createdAt": "2024-02-08T17:37:27Z",
          "updatedAt": "2024-02-08T17:37:27Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the consensus in Denver was to have one preference per track",
          "createdAt": "2024-02-09T17:15:09Z",
          "updatedAt": "2024-02-09T17:15:09Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "just to be clear , the preference is set as track level property and can have 4 values - track, object, group and datagram.",
          "createdAt": "2024-02-09T18:02:33Z",
          "updatedAt": "2024-02-09T18:02:33Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, although for various reasons the PR I'm doing is going to make it subscription-level property. I think is hard to write it otherwise, and I can just about see a use case  for it.",
          "createdAt": "2024-02-09T18:36:42Z",
          "updatedAt": "2024-02-09T18:36:42Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "When a few of us discussed it last week, the feeling was that if it came back in the SUBSCRIBE_OK, and Objects started arriving before the SUBSCRIBE_OK, the receiver wouldn't know how to process the incoming Objects.\r\n\r\nIn the past, we've decided we don't like that, so the feeling was to land a PR to add the restriction now, and then we can talk more about wire format changes.\r\n\r\n@martinduke Is Object decoding not an issue for some reason I'm forgetting?  Or were you thinking that buffering Objects was fine?",
          "createdAt": "2024-02-18T20:28:16Z",
          "updatedAt": "2024-02-18T20:28:16Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am arguing that buffering objects is fine. The usual case, I think, is that SUBSCRIBE_OK arrives first.\r\n\r\nIt's irritating we're using a byte in the object encoding (and creating new error conditions to check for) just to avoid buffering. But I can live with keeping it for now.",
          "createdAt": "2024-02-20T17:39:41Z",
          "updatedAt": "2024-02-20T17:41:00Z"
        }
      ]
    },
    {
      "number": 353,
      "id": "I_kwDOG2Ho4M59-MX2",
      "title": "Problems with RelativeNext subscriptions",
      "url": "https://github.com/moq-wg/moq-transport/issues/353",
      "state": "OPEN",
      "author": "wilaw",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Subscribe"
      ],
      "body": "1. Consider the following sequence of groups and objects, some already produced , some that will be produced in the future. The largest group ID is currently 23 and the largest object ID is 3 (it also happens to be the last object in the group). \r\n\r\n![Screenshot 2024-02-01 at 9 15 24 PM](https://github.com/moq-wg/moq-transport/assets/2762250/421edef1-3110-4a05-8544-1e4ec2662423)\r\n\r\n\r\nOur definitions for RelativePrevious and RelativeNext are shown here. \r\n\r\n> RelativePrevious (0x2): Value is a delta from the largest sequence. 0 is the largest sequence, 1 is the largest sequence - 1, and so on.\r\n> RelativeNext (0x3): Value is a delta from the largest sequence. 0 is the largest sequence + 1, 1 is the largest sequence + 2, and so on.\r\n\r\nExample 6.4.3.1 for 'now' shows\r\n\r\n```\r\nStart Group: Mode=RelativePrevious, Value=0\r\nStart Object: Mode=RelateiveNext, Value=0\r\nEnd Group: Mode=None\r\nEnd Object: Mode=None\r\n\r\nStartGroup=Largest Group\r\nStartObject=Largest Object + 1\r\n```\r\n\r\nIn our example, largest group is 23, however Largest Object + 1 is 4, which does not exist. We need to adjust the definition of RelativeNext to allow for the fact that the next object may be in a different group.\r\n\r\n2. There may be some players who simply want the relay to send the next available Object, in this example Object 0 of group 24. \r\n\r\nThere is no current way to reliably ask for this, because StartGroup mode cannot be 'none', and we don't know which group that object will belong to. It may be in the currently largest group, or it may be in the next group. \r\n\r\nA solution here would be to relax the constraint that StartGroup mode cannot be 'none'. If we then request\r\n\r\n```\r\nStart Group: Mode=None\r\nStart Object: Mode=RelativeNext, Value=0\r\n```\r\n\r\nit would instruct the relay \"Send me your next object, no matter which group it belongs to\".\r\n\r\n5. In 6.4.3 we have examples titled 'Now',  'Current', \"previous\" and 'Next\".  \r\n\r\n'Now',  'Current'  are synonymous to most readers. We need to better titles to illustrate what is actually being requested here. Additionally, \r\n\"Previous' doesn't indicate whether we want the previous group, or previous object. Similarly for next.\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "createdAt": "2024-02-01T20:50:29Z",
      "updatedAt": "2024-02-07T00:39:50Z",
      "closedAt": null,
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment: \r\n\r\nYou are right that the example (and the text likely) don't show the full range of possibilities for what the next object will be.  The intent was that Start = Prev/0, Next/0 will get you the next object, which could be any object in the current group greater than largest, or the first object in the next group.  This is how my implementation handles it.  \r\n\r\nI don't see a way to get *only* the next object in the current draft, however, because of the ambiguity you describe. \r\n\r\n",
          "createdAt": "2024-02-07T00:39:39Z",
          "updatedAt": "2024-02-07T00:39:39Z"
        }
      ]
    },
    {
      "number": 355,
      "id": "I_kwDOG2Ho4M5-SHsb",
      "title": "Objects with unknown length and forwarding preferences",
      "url": "https://github.com/moq-wg/moq-transport/issues/355",
      "state": "OPEN",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Needs PR",
        "Wire Format"
      ],
      "body": "In our current encoding, you can stream objects without knowing their length in advance if your forwarding preference is Object or Datagram, but not if it's Track or Stream (since those require explicit lengths in the front).  I feel like those two aspects should not be tied: we should either support or not support streaming for all preferences.",
      "createdAt": "2024-02-05T14:19:55Z",
      "updatedAt": "2024-02-19T23:49:58Z",
      "closedAt": null,
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment:\r\n\r\nIn order to stream multiple objects with unknown lengths in a multi-object stream, you'd need additional framing.    \r\n\r\nAlternately, we could create single-object variants of the TRACK and GROUP stream header.",
          "createdAt": "2024-02-05T19:22:15Z",
          "updatedAt": "2024-02-05T19:22:15Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree it's weird to have a mix of unframed and framed messages.\r\n\r\nWhile I prefer unframed streams... I think we should state that MoQ objects are always framed, represent a single point in time, and have a known length. It's an optimization to withhold the length in the datagram and dedicated stream case but maybe we should include it.",
          "createdAt": "2024-02-07T01:59:09Z",
          "updatedAt": "2024-02-07T01:59:09Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In meeting we decided add a length to everything. We can add extension later to have no length if we need ( Thanks to Mike E for suggestion ) ",
          "createdAt": "2024-02-08T22:08:35Z",
          "updatedAt": "2024-02-08T22:08:35Z"
        }
      ]
    },
    {
      "number": 356,
      "id": "I_kwDOG2Ho4M5-dqe7",
      "title": "SUBSCRIBE_FIN/RST for old subscriptions",
      "url": "https://github.com/moq-wg/moq-transport/issues/356",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Subscribe"
      ],
      "body": "Sections 6.8 and 6.9 strongly imply that SUBSCRIBE_FIN/RST are sent at the true end of the track. So are they not sent at the conclusion of a SUBSCRIBE that does not cover the end of the track?\r\n\r\nFor example, if the last object of a track is (10, 12), and there's one subscribe for (4,0) to (5, 100)\r\n\r\nIs there a SUBSCRIBE_FIN?\r\n\r\nIf not, how does the subscriber know that in fact (5, 60) is the last object in that subscription?\r\n\r\nIf so, does Final Group and Final Object refer to the last object in the subscription?",
      "createdAt": "2024-02-06T21:36:07Z",
      "updatedAt": "2024-03-04T02:51:02Z",
      "closedAt": "2024-03-04T02:51:02Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment: \r\n\r\nPutting my HTTP hat on for a second, when you ask for something with unknown length, you infer from a graceful termination that the last thing you got was the true end of that resource.  If you send a range request, the graceful termination at the end does not convey that the last thing was the true end.  Once the object expires, you can issue another request to the same name and potentially get a totally different thing.\r\n\r\nDoes this model work for moq, or do we need something different?\r\n\r\n",
          "createdAt": "2024-02-07T02:33:39Z",
          "updatedAt": "2024-02-07T02:33:39Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There are three different things you might want to communicate to a receiver at the end of the subscribe:\r\n\r\n1) You got all of the objects in the range;\r\n2) You got almost all of the objects, but some were dropped for latency/bandwidth reasons\r\n3) The track was truncated for some reason\r\n\r\nand possibly, 4?\r\n4) You got everything I have but i'm not sure if that's everything",
          "createdAt": "2024-02-09T17:14:39Z",
          "updatedAt": "2024-02-09T17:14:39Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "#345 is somewhat relevant to this issue.",
          "createdAt": "2024-02-20T02:35:45Z",
          "updatedAt": "2024-02-20T02:35:45Z"
        }
      ]
    },
    {
      "number": 357,
      "id": "I_kwDOG2Ho4M5-joqx",
      "title": "Objects before SUBSCRIBE_OK",
      "url": "https://github.com/moq-wg/moq-transport/issues/357",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Subscribe"
      ],
      "body": "Since they're on different streams, an object can arrive before its SUBSCRIBE_OK. This is easy to process because the Subscribe ID and Track Alias must have been the ones that the subscriber chose.\r\n\r\nWhat if the publisher then sends a SUBSCRIBE_ERROR? Is this valid behavior or an error?\r\n\r\n(If it weren't for the Expires field, SUBSCRIBE_OK would be entirely redundant and we could get rid of it.)",
      "createdAt": "2024-02-07T15:18:37Z",
      "updatedAt": "2024-02-20T23:40:38Z",
      "closedAt": "2024-02-20T23:40:38Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment:\r\n\r\nThis is covered a bit in #310 and Luke expressed a desire to document the full state machine in #237.  My read is that you can't send objects before SUBSCRIBE OK (but they can arrive out of order).  I don't think you can send SUBSCRIBE_ERROR after SUBSCRIBE_OK (objects or no objects), instead, use SUBSCRIBE_RST?",
          "createdAt": "2024-02-07T15:29:44Z",
          "updatedAt": "2024-02-07T15:29:44Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that SUBSCRIBE_ERROR cannot follow SUBSCRIBE_OK.\r\n\r\nI think you're saying that if Objects are in flight, then SUBSCRIBE_OK must be as well, so a SUBSCRIBE_ERROR would in itself be an error. That sounds reasonable to me.",
          "createdAt": "2024-02-07T15:50:24Z",
          "updatedAt": "2024-02-07T15:50:24Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "We're clear that only one of SUBSCRIBE_OK or SUBSCRIBE_ERROR can be sent:\r\n\r\n> The subscriber making the subscribe request is notified of the result of\r\nthe subscription, via SUBSCRIBE_OK ({{message-subscribe-ok}}) or the\r\nSUBSCRIBE_ERROR {{message-subscribe-error}} control message.\r\nThe entity receiving the SUBSCRIBE MUST send only a single response to\r\na given SUBSCRIBE of either SUBSCRIBE_OK or SUBSCRIBE_ERROR.\r\n\r\nI wrote #387 to clarify that you can't send objects and a SUBSCRIBE_ERROR.",
          "createdAt": "2024-02-19T19:51:06Z",
          "updatedAt": "2024-02-19T19:51:06Z"
        }
      ]
    },
    {
      "number": 358,
      "id": "I_kwDOG2Ho4M5-kncp",
      "title": "Tighten definition of ObjectID and GroupID ",
      "url": "https://github.com/moq-wg/moq-transport/issues/358",
      "state": "OPEN",
      "author": "wilaw",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Object Model"
      ],
      "body": "Current prose should be updated to indicate that \r\n1. ObjectID and GroupID are integers. The Object header implicitly defines this, but it should be stated explicitly.\r\n2. ObjectID MUST only increment by 1\r\n3. The GroupID MUST always increase. \r\n4. The GroupID may start at any value >= 0\r\n5. The GroupID can increase by any value >= 1. ",
      "createdAt": "2024-02-07T17:28:23Z",
      "updatedAt": "2024-02-19T21:28:09Z",
      "closedAt": null,
      "comments": [
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So I think this needs to be clear that this is for object inside a given quic stream and does not apply cross stream. \r\n\r\nI would say on point 1, they are var len unsigned integers. \r\n\r\nOn #2, do we have a reason that we don't allow object to increase my more than one. \r\n\r\n\r\n",
          "createdAt": "2024-02-07T23:53:15Z",
          "updatedAt": "2024-02-07T23:53:15Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "on 2 , i don't see a need for us to enforce monotonic unitary sequence for objectIds either. If the application needs it for certain purposes, it will generate the objectIds to match that pattern.\r\n\r\nI would just say GroupId and ObjectId needs to be increasing and SHOULD NOT be duplicated. (fine to not even have the latter part)",
          "createdAt": "2024-02-08T16:51:41Z",
          "updatedAt": "2024-02-08T16:51:41Z"
        },
        {
          "author": "vitaly-castLabs",
          "authorAssociation": "NONE",
          "body": "Wouldn't it be beneficial to have ObjectIDs incrementing strictly by 1 in order to detect dropped objects? It's an extremely common scenario in video decoding: run into a gap in media and stop decoding until a new key frame arrives.\r\nAre there any real-life scenarios when arbitrary increments might be necessary?",
          "createdAt": "2024-02-12T03:16:59Z",
          "updatedAt": "2024-02-12T03:16:59Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Its application defined.  Even with today's video applications, one can have b-frames sent over different track/different stream encoding and thus causing gaps within a group. Only application is aware of that end to end and MoQT shouldn't enforce application rules.",
          "createdAt": "2024-02-12T03:33:01Z",
          "updatedAt": "2024-02-12T03:33:01Z"
        }
      ]
    },
    {
      "number": 359,
      "id": "I_kwDOG2Ho4M5-k17M",
      "title": "Update PREFER_DATAGRAM to require DATAGRAM only delivery",
      "url": "https://github.com/moq-wg/moq-transport/issues/359",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Object Model"
      ],
      "body": "This came out of interim that falling back to stream for Datagram delivery is not an great idea \r\n",
      "createdAt": "2024-02-07T18:01:32Z",
      "updatedAt": "2024-02-24T02:23:06Z",
      "closedAt": "2024-02-24T02:23:06Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "This was fixed by #360 ",
          "createdAt": "2024-02-24T02:23:06Z",
          "updatedAt": "2024-02-24T02:23:06Z"
        }
      ]
    },
    {
      "number": 361,
      "id": "I_kwDOG2Ho4M5-mWru",
      "title": "Objects with identical names should be bit identical",
      "url": "https://github.com/moq-wg/moq-transport/issues/361",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "fluffy"
      ],
      "labels": [
        "Object Model"
      ],
      "body": "This came as part of interim at Denver when discussing multiple announce for same track.\r\nThere needs to text that mandates, if 2 objects comes with same name, they need to be bit identical.\r\n\r\nAlso needs to clarify on how long the name needs to be unique",
      "createdAt": "2024-02-07T22:09:36Z",
      "updatedAt": "2024-02-18T21:02:14Z",
      "closedAt": "2024-02-18T21:02:14Z",
      "comments": []
    },
    {
      "number": 362,
      "id": "I_kwDOG2Ho4M5-mXyI",
      "title": "Add text to clarify relay behavior when there are multiple announces",
      "url": "https://github.com/moq-wg/moq-transport/issues/362",
      "state": "OPEN",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "fluffy"
      ],
      "labels": [
        "Needs PR",
        "Announce"
      ],
      "body": "At interim, to support make before break use-cases, we need to clarify relay behavior when a new announce arrives for existing published. \r\n",
      "createdAt": "2024-02-07T22:13:29Z",
      "updatedAt": "2024-02-20T00:04:31Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 363,
      "id": "I_kwDOG2Ho4M5-mtXs",
      "title": "UNSUBSCRIBE is underspecified",
      "url": "https://github.com/moq-wg/moq-transport/issues/363",
      "state": "OPEN",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Needs Discussion",
        "Subscribe"
      ],
      "body": "UNSUBSCRIBE has some items I'd like clarified.\r\n\r\nHow do you know the last Group and Object that will be delivered?  Do you get a SUBSCRIBE_RST or SUBSCRIBE_FIN?  Or maybe we want to allow the UNSUBSCRIBE to specify that last Object it wants delivered, somewhat similar to a GOAWAY.  We could also allow the subscriber to RST the SUBSCRIBE?\r\n\r\nOr maybe we don't care about knowing the final Object?",
      "createdAt": "2024-02-07T23:23:04Z",
      "updatedAt": "2024-03-04T03:10:49Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "#269 concluded we want SUBSCRIBE_UPDATE, which is probably a better featureset than the current UNSUBSCRIBE anyway.",
          "createdAt": "2024-02-08T17:32:37Z",
          "updatedAt": "2024-02-08T17:32:37Z"
        }
      ]
    },
    {
      "number": 364,
      "id": "I_kwDOG2Ho4M5-oWHO",
      "title": "Remove track namespace and track name from SUBSCRIBE_OK text",
      "url": "https://github.com/moq-wg/moq-transport/issues/364",
      "state": "CLOSED",
      "author": "zafergurel",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Editorial"
      ],
      "body": "Track namespace and track name properties were removed from SUBSCRIBE_OK message in draft 02. But they are still part of the text under \"6.5.  SUBSCRIBE_OK\" which is confusing.",
      "createdAt": "2024-02-08T07:18:17Z",
      "updatedAt": "2024-02-08T19:00:20Z",
      "closedAt": "2024-02-08T19:00:20Z",
      "comments": []
    },
    {
      "number": 365,
      "id": "I_kwDOG2Ho4M5-oXej",
      "title": "Change \"Subscription ID\" to \"Subscribe ID\" in OBJECT_PREFER_DATAGRAM",
      "url": "https://github.com/moq-wg/moq-transport/issues/365",
      "state": "CLOSED",
      "author": "zafergurel",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Editorial"
      ],
      "body": "Subscription is identified by \"Subscribe ID\" in other messages except OBJECT_PREFER_DATAGRAM.\r\n\r\n```\r\nOBJECT_PREFER_DATAGRAM Message {\r\n    Subscription ID (i), | \u00a0\r\n    Track Alias (i), | \u00a0\r\n    Group ID (i), | \u00a0\r\n    Object ID (i), | \u00a0\r\n    Object Send Order (i), | \u00a0\r\n    Object Payload (...), | \u00a0\r\n}\r\n```\r\n\r\n",
      "createdAt": "2024-02-08T07:22:58Z",
      "updatedAt": "2024-02-08T18:54:12Z",
      "closedAt": "2024-02-08T18:54:12Z",
      "comments": []
    },
    {
      "number": 368,
      "id": "I_kwDOG2Ho4M5-sBuM",
      "title": "Subscribe vs Fetch and Object states",
      "url": "https://github.com/moq-wg/moq-transport/issues/368",
      "state": "OPEN",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Subscribe"
      ],
      "body": "Posting this here, since I can't think of a better place, and we might want to make sure we have actual issues to track some of those.\r\n\r\n_Note: this issue tries to focus on what is being requested, without focusing on how those objects should be delivered (in terms of reliability, etc)._\r\n\r\nThe proposal is to introduce two logical operations in the protocol:\r\n- Subscribe.\r\n  - Subscribe indicates that all of the future objects for the specified track should be forwarded to the subscriber.\r\n  - The only argument is the starting point (do not forward objects that are before the specified point).\r\n  - There may only be one subscribe per connection.\r\n- Fetch.\r\n  - Fetch indicates that the requester desires to receive all objects within some well-defined range.\r\n  - The arguments are a starting point and an ending point.\r\n  - Fetch is supposed to be \u201cin the past\u201d, but some objects that are technically in the past might arrive later due to reordering, so it\u2019s unclear how useful declaring Fetch to be \u201cin the past\u201d actually is.\r\n\r\nThe main reason Fetch can have improved semantics over Subscribe is that it has a definite range of objects, and as a consequence:\r\n\r\n- The relay can enumerate all of the objects in the range to determine whether they are in cache or not.  Because of that, we can place an expectation that the relay will request objects from the upstream if they are missing from the cache when performing Fetch.\r\n- If the requested range is in the past, all objects can be resolved \u201csynchronously\u201d (i.e. there wouldn\u2019t be objects that are \u201cin the future\u201d, so all objects are either available or permanently gone).\r\n- While Subscribe is expected to just deliver objects as they arrive, Fetch allows for a possibility of objects being transmitted in various ways that would fit different use cases.\r\n\r\nLet\u2019s talk more about \u201cresolving\u201d objects.  A Fetch is supposed to resolve all objects in a range.  Potentially, every object can be in one of the following states:\r\n\r\n1. Object is available from relay\u2019s/publisher\u2019s memory.\r\n1. Object is partially available and is in the middle of being received.\r\n1. Object is in the future and has not been seen yet.\r\n1. Object is in the past, but the relay has not seen it yet (reordering).\r\n1. Object has been previously received and cached, but then evicted from the cache.\r\n1. Object has been explicitly described as permanently unavailable.\r\n1. Object was supposed to be received, but was temporarily dropped due to network conditions.\r\n1. (this list is meant to be exhaustive, but I am probably forgetting something)\r\n\r\nWe need to figure out how Fetch reacts to all of those.  We should also figure out how Subscribe deals with permanent and temporary drops, and whether it indicates those (or not).\r\n\r\nMy proposal was to add two messages that perform those operations:\r\n\r\n- ATOMIC_SUBSCRIBE_AND_FETCH requires the recipient to determine the \u201chead\u201d, which is the largest group/object ID received.  A Fetch is started for the range before the head, and Subscribe is started for all of the objects after.\r\n- FETCH is just a straightforward Fetch operation.\r\n\r\nWe need to analyze those with respect to various use cases, including:\r\n\r\n- Subscribing to the live head with some immediately preceding objects (\u201ccatch-up objects\u201d).  This is the most important use case, inasmuch as I believe other use cases listed below can be actually satisfied without MoQ.  Note that depending on the size of \u201ccatch-up objects\u201d, the desired transmission behavior might be different (if the range is small, those should probably be sent \u201cnewest first\u201d; if it\u2019s large, it has to be \u201coldest first\u201d, or the user would buffer).\r\n- DVR.\r\n- Clipping a fragment from the recent past as a stream highlight.\r\n- (I believe some other use cases were mentioned before, but I probably forgot)\r\n",
      "createdAt": "2024-02-08T15:34:41Z",
      "updatedAt": "2024-02-19T23:56:01Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 369,
      "id": "I_kwDOG2Ho4M5-tYIY",
      "title": "Are groups synchronized across a track namespace?",
      "url": "https://github.com/moq-wg/moq-transport/issues/369",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Presentations at the Denver interim seem to imply that group 8 represents the same point in time across all tracks in a bundle. This would certainly make a lot of things, like ABR, easier to handle.\r\n\r\nThe alternative would seem to be Catalog descriptions that indicate the relationship of time to group ID.",
      "createdAt": "2024-02-08T18:30:07Z",
      "updatedAt": "2024-02-08T19:09:04Z",
      "closedAt": "2024-02-08T19:09:04Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, I see Will's timeline proposal is another way to do this.",
          "createdAt": "2024-02-08T18:53:36Z",
          "updatedAt": "2024-02-08T18:53:36Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "How one might design this:\r\nThe Catalog tells you how many groups per second there are for a broadcast. This is determined by whatever track has the most groups per secondl\r\n\r\nIf a track needs fewer groups per second, it skips group IDs accordingly.",
          "createdAt": "2024-02-08T18:57:13Z",
          "updatedAt": "2024-02-08T18:57:13Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Will's solution is more general, and the room seems to be in favor. Closing.",
          "createdAt": "2024-02-08T19:09:04Z",
          "updatedAt": "2024-02-08T19:09:04Z"
        }
      ]
    },
    {
      "number": 370,
      "id": "I_kwDOG2Ho4M5-tbAT",
      "title": "Is there a way for client to ask relay to probe for bandwidth ",
      "url": "https://github.com/moq-wg/moq-transport/issues/370",
      "state": "OPEN",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Parked"
      ],
      "body": "This keeps coming up so wanted to keep a place holder here. ",
      "createdAt": "2024-02-08T18:38:21Z",
      "updatedAt": "2024-02-11T02:51:11Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "No, but I'd like to resolve a number of other issues first, such how ABR is going to work.  My past experience is that this is extremely difficult to get right, so doing so for a general purpose application is extraordinarily difficult.",
          "createdAt": "2024-02-11T02:51:06Z",
          "updatedAt": "2024-02-11T02:51:06Z"
        }
      ]
    },
    {
      "number": 371,
      "id": "I_kwDOG2Ho4M5-tgKt",
      "title": "Client side bandwidth estimation is difficult with app-limited traffic",
      "url": "https://github.com/moq-wg/moq-transport/issues/371",
      "state": "OPEN",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "NotTransport"
      ],
      "body": "Client side bandwidth estimation is a challenge when the client doesn't know when the sender was app-limited and when it was congestion control limited.\r\n\r\nOne solution is to add a TIMESTAMP frame that has a relative timestamp of when the packet was serialized/sent.  It could also be useful to have a bool to indicate whether the sender was app-limited prior to the packet being sent.\r\n\r\nChristian has a draft (https://www.ietf.org/archive/id/draft-huitema-quic-ts-08.html) that could be used for this purpose.  The draft was written with the idea that it would be bundled with an ACK to allow removal of latency variability on the reverse path, but it seems like it could be bundled with some or all MOQ packets to improve client bandwidth estimation.",
      "createdAt": "2024-02-08T18:50:36Z",
      "updatedAt": "2024-02-11T02:43:16Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "After more consideration, I tend to think this is not an moqt issue, but it is one worth addressing in WARP.  I'm happy to help with text if that's useful.\r\n\r\nKeeping it open because I think it could end up being critical to client side ABR.",
          "createdAt": "2024-02-11T02:43:15Z",
          "updatedAt": "2024-02-11T02:43:15Z"
        }
      ]
    },
    {
      "number": 372,
      "id": "I_kwDOG2Ho4M5-tzPj",
      "title": "Create an ability to pre-warm a track",
      "url": "https://github.com/moq-wg/moq-transport/issues/372",
      "state": "OPEN",
      "author": "wilaw",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "At the interim there was interest in creating the ability for a receiver to ask a sender to subscribe to a track but not to forward it. The purpose of this is to minimize the delay when the receiver SUBSCRIBES to the track in the future. \r\n\r\nDesign considerations\r\n1. This would need to be converted to a regular SUBSCRIBE for forward requests. So any relay receiving a PREWARM request MUST never forward it.\r\n2. Is there a matching UNPREWARM, or would a regular UNSUBSCRIBE suffice?\r\n3. Do we need a new method PREWARM or can it be a flag on the existing SUBSCRIBE?\r\n4. This is a powerful DDOS attack vector. How do we mitigate that threat in the design? ",
      "createdAt": "2024-02-08T19:36:06Z",
      "updatedAt": "2024-02-27T14:47:18Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I find this concerning from a DDoS/memory exhaustion perspective.\r\n\r\nIs the motivation for this to minimize the latency of switching resolutions for video playback?  If so, couldn't you just issue a SUBSCRIBE at a lower priority and if it starts coming quickly, then start switching relatively soon, and if it takes a while, wait to switch.  Or is there a different usecase?",
          "createdAt": "2024-02-08T20:21:55Z",
          "updatedAt": "2024-02-08T20:21:55Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Is the motivation for this to minimize the latency of switching resolutions for video playback? \r\n\r\nYes. \r\n\r\n> If so, couldn't you just issue a SUBSCRIBE at a lower priority and if it starts coming quickly, then start switching relatively soon, and if it takes a while, wait to switch\r\n\r\nThat would work for switching up, where you have the luxury of time (your switch can always occur later).  However the primary use case is in switching down, where you don't want to incur in the extra delay in the relay having to go back to origin to retrieve the new track. It also is an optimization when you have only 1 or a few clients subscribed to that relay for that presentation. Given a sufficiently large cohort of clients, the relay would be naturally warmed. \r\n\r\n> I find this concerning from a DDoS/memory exhaustion perspective.\r\n\r\nI agree on the DDOS concern, as the OP states. However, from a memory exhaustion, this is really no different from having  a multiplicity of clients each pulling a different track from the relay. 1 client pulling 3 tracks is the same relay memory requirement as 100 clients asking for those same 3 tracks. ",
          "createdAt": "2024-02-08T20:37:21Z",
          "updatedAt": "2024-02-08T20:37:21Z"
        },
        {
          "author": "gwendalsimon",
          "authorAssociation": "NONE",
          "body": "> I find this concerning from a DDoS/memory exhaustion perspective.\r\n\r\n+1 on the concern. The risk of overloading the CDN backbone unnecessarily is significant. Furthermore, any just-in-time processing (transcoding and packaging) would be useless although these are not only money but also energy reduction",
          "createdAt": "2024-02-08T20:38:06Z",
          "updatedAt": "2024-02-08T20:38:06Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Based on discussion, it seems the hope is to prewarm a resolution lower than the current one, so if a player needed to switch to a lower quality, it would succeed quickly.  One question is whether this needs to live in MOQT.\r\n\r\nI can imagine a CDN doing the work to parse catalogs (or use ML, etc) and understand what the next lowest resolution track is, and then decide whether to proactively SUBSCRIBE to it.\r\n\r\nIn my mind, MOQT is about the intent of the subscriber, and indicating \"I might want this track, but not now\" is a fairly weak signal.  Admittedly, if we had a more complex subscribe that included multiple qualities, then the full intent would be indicated.\r\n\r\nI would like to park this until we have a better handle on SUBSCRIBE, unless there's a need to resolve it earlier.",
          "createdAt": "2024-02-09T07:05:02Z",
          "updatedAt": "2024-02-09T07:05:02Z"
        },
        {
          "author": "hardie",
          "authorAssociation": "COLLABORATOR",
          "body": "On Fri, Feb 9, 2024 at 7:05\u202fAM ianswett ***@***.***> wrote:\r\n\r\n> Based on discussion, it seems the hope is to prewarm a resolution lower\r\n> than the current one, so if a player needed to switch to a lower quality,\r\n> it would succeed quickly. One question is whether this needs to live in\r\n> MOQT.\r\n>\r\n> I can imagine a CDN doing the work to parse catalogs (or use ML, etc) and\r\n> understand what the next lowest resolution track is, and then decide\r\n> whether to proactively SUBSCRIBE to it.\r\n>\r\nWe've assumed so far that the relays don't have access to the catalog (for\r\nprivacy reasons as well as practical reasons).   Revisiting that decision\r\nfor this would seem like a big step backwards.\r\n\r\nI think one of the issues here is that there are a flock of cases where\r\nthere is no pre-warming needed, because the media will be popular enough\r\nthat a relay will have multiple alternates on hand for all but a few of the\r\nearliest subscribers.  There are also cases where the publisher is CPU or\r\nbandwidth limited (like a cell phone in an RTC videoconference) where it is\r\nimpractical to expect that they are producing a lot of different\r\nresolutions.  Those two being very common cases makes it difficult to see\r\nthe utility here.\r\n\r\nThe question is whether there is a substantial body of cases where the\r\npublisher is producing multiple streams but the number of consumers is low\r\nenough that a relay won't have most of them on hand.  Luke's experience at\r\nTwitch suggests that this does happen, and it happens fairly often.  For\r\nthat case, I think we could either presume that the client subscribes to\r\nmultiple resolutions and unsubscribes to higher resolutions as bandwidth or\r\nother bounds interfere or we could introduce something like a SUBSCRIBE\r\nwith a flag that indicates that no objects are wanted at this time.  That\r\nmight be as simple as the same beginning and end object being named.\r\nWhatever the syntax, that could be taken by a relay to mean that\r\npre-warming the empty subscribed tracks would be useful, since they may be\r\nwanted later.  The decision about whether to issue the upstream subscribe\r\nwould be a combination of business logic and local capacity, so the\r\nreceiver will always have to deal with a potential delay if it changes the\r\ntrack to which it is subscribed.\r\n\r\n> In my mind, MOQT is about the intent of the subscriber, and indicating \"I\r\n> might want this track, but not now\" is a fairly weak signal. Admittedly, if\r\n> we had a more complex subscribe that included multiple qualities, then the\r\n> full intent would be indicated.\r\n>\r\n> I would like to park this until we have a better handle on SUBSCRIBE,\r\n> unless there's a need to resolve it earlier.\r\n>\r\nI'm okay parking it as long as we indicate in the draft that SUBSCRIBE's\r\nsyntax is still under development and that new signals may be added.\r\n\r\n\r\n\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/moq-wg/moq-transport/issues/372#issuecomment-1935429421>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AAKVXZBQXWBMOZROO26646DYSXDC3AVCNFSM6AAAAABDAKA6RSVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMYTSMZVGQZDSNBSGE>\r\n> .\r\n> You are receiving this because you are subscribed to this thread.Message\r\n> ID: ***@***.***>\r\n>\r\n",
          "createdAt": "2024-02-09T09:40:02Z",
          "updatedAt": "2024-02-09T09:40:02Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One of the largest problems in media delivery today is sparse clients consuming uncached edge content.  This problem is exacerbated at lower latencies, especially where target latency is a few multiples of RTT-to-origin. This is exactly the playground MoQ want to play in. I believe it will be very difficult to  build working ABR solutions at sub 350ms latency if a switch will entail a 100ms round trip to origin. \r\n\r\n> In my mind, MOQT is about the intent of the subscriber, and indicating \"I might want this track, but not now\" is a fairly weak signal.\r\n\r\nI would argue that \"I will desperately need this track in a hurry if I run in to delivery problems and I really, really need you to keep it warm at the edge\" is a pretty strong signal. \r\n\r\n> I can imagine a CDN doing the work to parse catalogs (or use ML, etc) and understand what the next lowest resolution track is, and then decide whether to proactively SUBSCRIBE to it.\r\n\r\nThe relays cannot read the catalogs, so this is not an option. The intelligence about track offerings resides in the client. \r\n\r\n> The risk of overloading the CDN backbone unnecessarily is significant. \r\n\r\nI don't think it is significant. If 5 clients arrive and happen to subscribe to 5 different tracks in a given presentation, we would call that normal playback and would expect the backbone to easily handle it. \r\n\r\n> The question is whether there is a substantial body of cases where the\r\n> publisher is producing multiple streams but the number of consumers is low\r\n> enough that a relay won't have most of them on hand.  Luke's experience at\r\n> Twitch suggests that this does happen, and it happens fairly often.\r\n\r\nAnd my experience at Akamai says exactly the same thing. It happens with live sports all the time. With highly distributed edges, the problem isn't that there aren't a lot of aggregate viewers, but that there a sparse viewers on certain edges (such as ones inside smaller ISPs, or rural areas). \r\n\r\nI think parking at this point is unnecessarily conservative. I don't see a future where every track of every Moq presentation is prewarmed. Instead I see cases where\r\n1. You only prewarm the lower bitrates of any given stack, or even just the lowest. \r\n2. You only do it for clients where the ratio of player buffer/RTT-to-origin is small. The player knows its buffer and the server could reports the distance to origin in the SUBSCRIBE_OK response, so the client could intelligently decide if prewarming would be useful. \r\n3. The delivery network will charge more for the increase in midgress traffic. Economics tend to tamper abuse. If you are delivering the Superbowl (Go SF) you will happily pay for the better QoE. \r\n4.  The delivery network can always choose not to honor prewarming and we can design a response to the client indicating  this. \r\n\r\nI would suggest we build a simple version of it into the protocol and then build POCs where we test and measure the real-world utility and cost. ",
          "createdAt": "2024-02-09T18:07:21Z",
          "updatedAt": "2024-02-09T18:07:21Z"
        },
        {
          "author": "gwendalsimon",
          "authorAssociation": "NONE",
          "body": " > > The risk of overloading the CDN backbone unnecessarily is significant.\r\n> \r\n> I don't think it is significant. If 5 clients arrive and happen to subscribe to 5 different tracks in a given presentation, we would call that normal playback and would expect the backbone to easily handle it.\r\n\r\nOne use case does not make large probabilistic numbers; of course we will handle these five clients, but this case has low probability... Network infrastructures are not dimensioned to meet the worst possible case of traffic matrix but rather some probabilistic maximum traffic. \r\n\r\nAs discussed during the interim, dimensioning a backbone (which often includes peering link and IXP) that can handle actual traffic + pre-warmed traffic is just a business question. But I can also argue that, if pre-warmed tracks are not consumed, it is a net waste of network resources, which also translates into a waste of energy. Designing a protocol that deliberately wastes resources to address a few 250ms freezes (from too aggressive video players) is questionable in 2024.\r\n\r\n> > The question is whether there is a substantial body of cases where the\r\n> > publisher is producing multiple streams but the number of consumers is low\r\n> > enough that a relay won't have most of them on hand.  Luke's experience at\r\n> > Twitch suggests that this does happen, and it happens fairly often.\r\n> \r\n> And my experience at Akamai says exactly the same thing. It happens with live sports all the time. With highly distributed edges, the problem isn't that there aren't a lot of aggregate viewers, but that there a sparse viewers on certain edges (such as ones inside smaller ISPs, or rural areas).\r\n\r\nMy experience at Synamedia (where we run multiple Edge-CDN (a.k.a multi-Tbps Telco-CDN) for broadcasters and Pay-TV services) says exactly the same. I would add two cases: 1/ Long-tail unpopular TV channels have usually the same bitrate ladder as any other TV channel (e.g. 8 video profiles), although barely nobody watch them. In our measures, we can have more than half of segments that are not consumed at all over a week. Of course even more at the edges. 2/ In countries with very good network connections, some edges serve a population having a bandwidth five to ten times bigger than the highest video profile bit-rate. In that case, all requests get to the highest track, regardless of the number of consumers. \r\n\r\n> I think parking at this point is unnecessarily conservative. I don't see a future where every track of every Moq presentation is prewarmed. Instead I see cases where\r\n> \r\n> 1. You only prewarm the lower bitrates of any given stack, or even just the lowest.\r\n\r\n+1 \r\nIt would be a \"backup survival track\", which serves only to implement a smooth switch down (to preserve the connection of the consumer in trouble) and give time to the relay for fetching the actual track requested by the consumer from the Origin. The lowest track has a marginal bit-rate, so the waste is minimized.\r\n\r\nHowever, the relay does not know which track is the survival track in the catalog since it cannot read the catalog. We may add a \"survival flag\" in the track saying \"_I'm the lowest one, please feel free to pre-warmly subscribe to me_\".\r\n\r\n> 2. You only do it for clients where the ratio of player buffer/RTT-to-origin is small. The player knows its buffer and the server could reports the distance to origin in the SUBSCRIBE_OK response, so the client could intelligently decide if prewarming would be useful.\r\n\r\nIt seems a bit over-engineered to me. The distance to Origin can vary, especially if Origin is mobile.\r\n\r\n> 4. The delivery network can always choose not to honor prewarming and we can design a response to the client indicating  this.\r\n\r\n+1\r\n \r\n> I would suggest we build a simple version of it into the protocol and then build POCs where we test and measure the real-world utility and cost.\r\n\r\nI'd love to help. Measuring real-world utility and cost will probably be challenging, since it requires building real-world use-cases. For example, it depends on the considered ABR logic at the client side. I still doubt that a player can be so wrong in his estimation that he cannot survive 500ms more with his previous track before switching down. But it is an exciting study to do.",
          "createdAt": "2024-02-10T22:07:29Z",
          "updatedAt": "2024-02-10T22:07:29Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this a good idea, and yet also a premature optimization.\r\n\r\nHere's my current thoughts on how the receiver should perform ABR. These examples use inclusive ranges and the track priority is annotated when it matters.\r\n\r\n### Switching Up\r\nI want the ability the preflight the switch while in the middle of group 5 @ 480p. \r\n```\r\nSUBSCRIBE 1080p start=6\r\nUNSUBSCRIBE 480p end=5\r\n```\r\n\r\nOr I want the ability to probe for the higher bitrate, temporarily subscribing to both to test the network speed. I'll unsubscribe to one of them depending on the arrival speed.\r\n\r\n```\r\nSUBSCRIBE 480p start=0 priority=high\r\nSUBSCRIBE 1080p start=6 priority=low\r\n```\r\n\r\nIn both cases the receiver doesn't need to pre-warm unless they switch ~100ms from the end of a group, in which case they should wait.\r\n\r\n### Switching Down\r\nI want to immediately switch down while halfway through group 5 @ 1080p:\r\n\r\n```\r\nUNSUBSCRIBE 1080p end=5 priority=low\r\nSUBSCRIBE 480p start=5 priority=high\r\n```\r\n\r\nIn this example, I'll keep receiving 1080p while the request to 480p goes to origin.\r\n\r\nPre-warming could reduce the time this takes by 100ms at most, assuming it's an unpopular broadcast. I can still download some 1080p with my limited bandwidth, so let's say we drop like 50ms of video by not pre-warming.\r\n\r\nBut does that really matter? Is it worth the additional cost? Maybe for switching down but definitely not for switching up.",
          "createdAt": "2024-02-17T03:53:58Z",
          "updatedAt": "2024-02-17T03:58:30Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "My take is that pre-warming should be part of sender-side ABR. If it's critical to avoid the RTT to origin, then it's also critical to avoid the RTT incurred by putting the receiver in charge.\r\n\r\nIt also just makes for a better API, as the server can decide if it wants to transparently pre-warm instead of relying on a benevolent client:\r\n```\r\nSUBSCRIBE 1080p or 480p or 240p\r\n```",
          "createdAt": "2024-02-17T04:01:40Z",
          "updatedAt": "2024-02-17T04:04:21Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think this a good idea, and yet also a premature optimization.\r\n> \r\n> \r\n> But does that really matter? Is it worth the additional cost? Maybe for switching down but definitely not for switching up.\r\n\r\nThanks @kixelated this post summarizes my thinking well.  I'd like to get the features of SUBSCRIBE/UNSUBSCRIBE/UPDATE_SUBSCRIBE working well enough that we can do all of these and then see what the outcome is.  We're missing priority on subscriptions right now, and that means we can't do what you describe above for client side ABR.\r\n\r\n\r\nOn Server Side ABR, I'm realizing that it might look very different for live and VoD.  A moqt relay won't know if the client is receiving bytes fast enough to avoid buffer underruns for a VoD playback.  For live at head, it knows approximately how far the delivered content is behind head.  That might also argue for an explicit communication of what the client's time sensitivity is.  A server needs to be much faster to downswitch at a 300ms jitter buffer vs 5 seconds.",
          "createdAt": "2024-02-18T20:55:14Z",
          "updatedAt": "2024-02-18T20:55:14Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> On Server Side ABR, I'm realizing that it might look very different for live and VoD. A moqt relay won't know if the client is receiving bytes fast enough to avoid buffer underruns for a VoD playback. For live at head, it knows approximately how far the delivered content is behind head. That might also argue for an explicit communication of what the client's time sensitivity is. A server needs to be much faster to downswitch at a 300ms jitter buffer vs 5 seconds.\r\n\r\nYeah, that's what I thought too. I implemented an ABR algorithm that took into account the buffer size... but it didn't end up helping. I'm not saying it's not a good signal, just that I tried it and switched to something else.\r\n\r\nMy final logic was much simpler: round down the estimated bitrate to the nearest rendition at each group boundary. And it makes sense in hind-sight: the jitter buffer size is the receiver's tolerance for over-estimations, not something that should be intentionally drained.",
          "createdAt": "2024-02-18T21:18:06Z",
          "updatedAt": "2024-02-18T21:19:03Z"
        },
        {
          "author": "zafergurel",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What about for a video conferencing application where the latency requirement  is below 150ms. For example, there may be two different layouts: speaker and presentation. In the speaker layout, a high resolution track is subscribed. When the layout is changed to the presentation, the client switches to the low resolution track. There is no ABR here, client decides which track to subscribe depending on an application-specific use case. So, for such a case, I would want to pre-warm the lowest resolution track.",
          "createdAt": "2024-02-20T10:34:08Z",
          "updatedAt": "2024-02-20T10:34:08Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "One complication is that the player SHOULD NOT assume a track has been pre-warmed, since the CDN can ignore the request. The player still has to perform the same seamless switching down/up logic, but it might be slightly faster if the pre-warm went through.",
          "createdAt": "2024-02-22T03:45:10Z",
          "updatedAt": "2024-02-22T03:45:10Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just want to note that for things like webex I would 1) expect to pay the CDN based on how much data is cached and how long it is stored as well as ingress and egress bandwidth 2)  all of this will be authenticated so the CDN knows who to bill. ",
          "createdAt": "2024-02-27T14:47:16Z",
          "updatedAt": "2024-02-27T14:47:16Z"
        }
      ]
    },
    {
      "number": 373,
      "id": "I_kwDOG2Ho4M5-ufi1",
      "title": "Add a group fin for object stream mappings.",
      "url": "https://github.com/moq-wg/moq-transport/issues/373",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "For track and group stream mappings, it is very easy for a relay to see if there are any missing objects: it knows the highest object_id and it is obvious if there are any gaps.\r\n\r\nWhen there is one object per stream, there should be some way for the publisher to announce what the highest object_id is fora  group.\r\n\r\nThe most straightforward thing to do is probably send a group fin somehow that communicates the highest object ID, but it is tricky to define how this would be reliably sent.",
      "createdAt": "2024-02-08T21:41:41Z",
      "updatedAt": "2024-02-08T22:24:53Z",
      "closedAt": "2024-02-08T22:24:53Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oops, a copy of #318 ",
          "createdAt": "2024-02-08T22:24:53Z",
          "updatedAt": "2024-02-08T22:24:53Z"
        }
      ]
    },
    {
      "number": 374,
      "id": "I_kwDOG2Ho4M5-urpV",
      "title": "DDoS protection in security section",
      "url": "https://github.com/moq-wg/moq-transport/issues/374",
      "state": "OPEN",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Parked"
      ],
      "body": "\r\nIn the security section, we should think about the type of DDOS attacks that can be made against the relays, and then check we have the right things in place for the relays to mitigate them. ",
      "createdAt": "2024-02-08T22:23:02Z",
      "updatedAt": "2024-02-08T22:24:43Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 377,
      "id": "I_kwDOG2Ho4M5_CWBc",
      "title": "What is the largest group/largest object if a relay has not received any objects?",
      "url": "https://github.com/moq-wg/moq-transport/issues/377",
      "state": "OPEN",
      "author": "afrind",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "afrind"
      ],
      "labels": [
        "Subscribe"
      ],
      "body": "This came up during interop - \r\n\r\nA relay received a subscribe with start={g=RelativeNext/0 o=Absolute/0}.  Since the relay had not received any objects, it defaulted largest to 0 and interpreted the subscribe as starting at {g=1, o=0}. When {g=0,o=0} arrived, it was not forwarded.  But there's a reasonable interpretation that it should have forwarded treated this as the beginning of the next subscription.\r\n\r\nThis is partially related to #337 and maybe #353",
      "createdAt": "2024-02-13T01:45:40Z",
      "updatedAt": "2024-03-04T17:56:20Z",
      "closedAt": null,
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "If the subscriber wanted to get the largest group, it would have made request start = {g=RelativePrevious/0, o=None} .. This would have the interpretation that subscribe starts at {g=0, o=0} when {g=0, o=0} arrives. This would also work when {g=0, o=22} arrives. \r\n\r\nIf my understanding of locations is correct, then the original request of  {g=RelativeNext/0 o=Absolute/0} is incorrect for the answer being expected .. ",
          "createdAt": "2024-02-14T07:30:21Z",
          "updatedAt": "2024-02-14T07:30:21Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it's reasonable to return 0,0\r\n\r\nThe subscriber uses RelativeNext if it doesn't want old data. If no data has been generated, then that requirement is still met.",
          "createdAt": "2024-02-14T16:06:25Z",
          "updatedAt": "2024-02-14T16:06:25Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I think it's reasonable to return 0,0\r\n\r\nBut that's ambiguous. Since Group and Object IDs are zero-based, that response also describes the situation in which the relay has received the first object from the first group, which is clearly a different state. \r\n\r\nCan we solve this problem by specifying that both GroupID and Object ID are >= 1 of they exist, and 0 if they do not? This can be used to describe the situation in which the subscription is active but the publisher has not yet produced any objects.",
          "createdAt": "2024-02-14T16:19:11Z",
          "updatedAt": "2024-02-14T16:19:11Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> > I think it's reasonable to return 0,0\r\n> \r\n> But that's ambiguous. Since Group and Object IDs are zero-based, that response also describes the situation in which the relay has received the first object from the first group, which is clearly a different state.\r\n> \r\n> Can we solve this problem by specifying that both GroupID and Object ID are >= 1 of they exist, and 0 if they do not? This can be used to describe the situation in which the subscription is active but the publisher has not yet produced any objects.\r\n\r\nOh to clarify, the SUBSCRIBE_OK should return None/None as the latest group/object. The first OBJECT delivered would be 0/0.\r\n\r\nAnd yeah we could switch object/group to be 1-indexed instead of 0-indexed. None=0",
          "createdAt": "2024-02-14T16:31:26Z",
          "updatedAt": "2024-02-14T16:31:26Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment:\r\n\r\n> If the subscriber wanted to get the largest group, it would have made request start = {g=RelativePrevious/0, o=None}\r\n\r\n> If my understanding of locations is correct, then the original request of {g=RelativeNext/0 o=Absolute/0} is incorrect for the answer being expected \r\n\r\nAgreed that in this particular case, the client was not really asking for what they wanted.  The \"Largest group/object\" language comes from the draft, though, and I think it's ambiguous what it means to a relay that hasn't seen any objects.\r\n\r\nMy interpretation of the spirit of the draft is that 0/0 would be forwarded in this case if the client asked to start Next/0 (eg: there's a bug in my relay), but if so, we should make it clear in the draft how it's supposed to work.  \r\n\r\n",
          "createdAt": "2024-02-14T16:57:25Z",
          "updatedAt": "2024-02-14T16:57:25Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Is this closed by #343?",
          "createdAt": "2024-02-19T21:26:47Z",
          "updatedAt": "2024-02-19T21:26:47Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I think I can see the intent with what's there, but the draft could use some editorial text clarifying what \"next/0\" means when subscribe OK was \"no content available\".",
          "createdAt": "2024-02-20T17:04:36Z",
          "updatedAt": "2024-02-20T17:04:36Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I thought we decided on call that we were not going to steal bits from the  group id / object id to indicate meta data what is going on.  After that call I was expecting to see some explicit flag for \"no content available\" if that is what needed to be sent. ",
          "createdAt": "2024-02-27T14:34:34Z",
          "updatedAt": "2024-02-27T14:34:34Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "> I thought we decided on call that we were not going to steal bits from the group id / object id to indicate meta data what is going on. After that call I was expecting to see some explicit flag for \"no content available\" if that is what needed to be sent.\r\n\r\nAfter merging #343, Subscribe OK has the flag you are referring to: \r\n\r\nhttps://moq-wg.github.io/moq-transport/draft-ietf-moq-transport.html#section-6.5\r\n\r\nI left this issue open because I think there's still some ambiguity that can be resolved with editorial text.",
          "createdAt": "2024-02-27T17:05:24Z",
          "updatedAt": "2024-02-27T17:05:24Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "makes sense - thanks ",
          "createdAt": "2024-02-27T18:06:13Z",
          "updatedAt": "2024-02-27T18:06:13Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "@afrind can you write some editorial text to clarify this if you have something in mind?",
          "createdAt": "2024-02-29T15:36:08Z",
          "updatedAt": "2024-02-29T15:36:08Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I tried to write some text, but I got confused.  Ignoring object locations for a second and just focusing on groups, I think this is what we want, but I'm unsure how to define \"current\" when there are no objects:\r\n\r\n| Requested Start Group | Requested End Group | Semantic | Does next seen object match subscription |\r\n| --- | --- | --- | --- |\r\n| RelativePrev/1 | RelativePrev/0 | All of the previous group | No |\r\n| RelativePrev/0 | RelativeNext/0 | All of the current group | ? |\r\n| RelativeNext/0 | RelativeNext/1 | All of the next group | ? |\r\n| RelativeNext/1 | RelativeNext/2 | All of the next+1 group | No |\r\n\r\nI think the simplest way to resolve this is to treat the next seen group ID as the \"next\" one and anything attempting to match only \"current\" matches either a) nothing or b) `max(0, next seen group ID - 1)`.  I recognize that b) may be controversial in that we don't require unitary increase in group IDs.  Practically I think subscribers should usually ask for [RelativePrev/0, None] (give me the current group if you know it or the next seen group if you don't).  \r\n\r\nIf we assume that the publisher only says \"ContentExists: false\" when it hasn't published anything, and relays only repeat this when they get it from publishers, then it's somewhat easier to assume that anything before \"next\" simply doesn't exist.  I'm unsure if this covers publisher restart cases well enough though.\r\n\r\nThere's also an asymmetry in this case in that there's no message to communicate how the relative requests were interpreted, as SUBSCRIBE_OK now does when the largest object is known.\r\n\r\nFurther, the algorithm for how to interpret relative object locations in groups with an unknown \"largest object\" may be even murkier, but let's agree what the groups mean and then move on to objects.",
          "createdAt": "2024-02-29T23:38:52Z",
          "updatedAt": "2024-02-29T23:38:52Z"
        }
      ]
    },
    {
      "number": 378,
      "id": "I_kwDOG2Ho4M5_Ptfo",
      "title": "Register moqt with IANA",
      "url": "https://github.com/moq-wg/moq-transport/issues/378",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "duplicate"
      ],
      "body": "#299 changes the scheme to moqt.  We should register this with IANA.",
      "createdAt": "2024-02-14T17:23:29Z",
      "updatedAt": "2024-02-20T02:41:14Z",
      "closedAt": "2024-02-20T02:41:14Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "This is a dupe of #268 ",
          "createdAt": "2024-02-20T02:41:14Z",
          "updatedAt": "2024-02-20T02:41:14Z"
        }
      ]
    },
    {
      "number": 379,
      "id": "I_kwDOG2Ho4M5_P4Q7",
      "title": "Single Message ID space is unnecessary given messages have context",
      "url": "https://github.com/moq-wg/moq-transport/issues/379",
      "state": "OPEN",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "kixelated"
      ],
      "labels": [
        "Control Streams"
      ],
      "body": "Currently, there's one message section and number space. It's confusing to read and it's not clear what messages can be encoded on a control stream, data stream, or datagram.\r\n\r\n### Proposal 1: Annotate Table\r\n| id | name | context |\r\n|-|-|-|\r\n| 0x0 | OBJECT_STREAM | data |\r\n| 0x1 | OBJECT_DATAGRAM | datagram |\r\n| 0x3 | SUBSCRIBE | control |\r\n| 0x4 | SUBSCRIBE_OK | control |\r\n| 0x5 | SUBSCRIBE_ERROR | control |\r\n| 0x6 | ANNOUNCE | control |\r\n| 0x7 | ANNOUNCE_OK | control |\r\n| 0x8 | ANNOUNCE_ERROR | control |\r\n| 0x9 | UNANNOUNCE | control |\r\n| 0xa | UNSUBSCRIBE | control |\r\n| 0xb | SUBSCRIBE_FIN | control |\r\n| 0xc| SUBSCRIBE_RST | control |\r\n| 0x10 | GOAWAY | control |\r\n| 0x40 | CLIENT_SETUP | control |\r\n| 0x41 | SERVER_SETUP | control |\r\n| 0x50 | STREAM_HEADER_TRACK | data |\r\n| 0x51 | STREAM_HEADER_GROUP | data |\r\n\r\n\r\n### Proposal 2: Split Numberspace\r\n**control messages (bidirectional streams)**\r\n| id | name |\r\n|-|-|\r\n| 0x0 | CLIENT_SETUP |\r\n| 0x1 | SERVER_SETUP |\r\n| 0x3 | SUBSCRIBE |\r\n| 0x4 | SUBSCRIBE_OK |\r\n| 0x5 | SUBSCRIBE_ERROR |\r\n| 0x6 | ANNOUNCE |\r\n| 0x7 | ANNOUNCE_OK |\r\n| 0x8 | ANNOUNCE_ERROR |\r\n| 0x9 | UNANNOUNCE |\r\n| 0xa | UNSUBSCRIBE |\r\n| 0xb | SUBSCRIBE_FIN |\r\n| 0xc| SUBSCRIBE_RST |\r\n| 0x10 | GOAWAY |\r\n\r\n**data messages (unidirectional streams)**\r\n| id | name |\r\n|-|-|\r\n| 0x0 | OBJECT_STREAM |\r\n| 0x1 | OBJECT_TRACK |\r\n| 0x2 | OBJECT_GROUP |\r\n\r\n**datagram messages:**\r\n| id | name |\r\n|-|-|\r\n| 0x0 | OBJECT_DATAGRAM |\r\n",
      "createdAt": "2024-02-14T17:52:42Z",
      "updatedAt": "2024-03-18T01:25:30Z",
      "closedAt": null,
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "I like the second proposal better. It is also the way our implementation works where control messages are sent over bidirectional streams and data messages on unidirectional streams. Also its easy to report an error if message are sent on the wrong streams.\r\n\r\n",
          "createdAt": "2024-02-16T04:48:12Z",
          "updatedAt": "2024-02-16T04:48:12Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I like your proposal, but I don't think this is editorial, since the first and second options wouldn't interop.",
          "createdAt": "2024-02-18T01:06:39Z",
          "updatedAt": "2024-02-18T01:06:39Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Proposal 1 is editorial, while proposal 2 _could_ be editorial. I reflowed the IDs but they could use the current values/names for now.",
          "createdAt": "2024-02-18T01:41:29Z",
          "updatedAt": "2024-02-18T01:41:46Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "How clever, fair point.  It seems like people prefer 2, do you want to write a PR for that?",
          "createdAt": "2024-02-18T20:18:56Z",
          "updatedAt": "2024-02-18T20:18:56Z"
        }
      ]
    },
    {
      "number": 380,
      "id": "I_kwDOG2Ho4M5_cY-R",
      "title": "MoQ and power consumption",
      "url": "https://github.com/moq-wg/moq-transport/issues/380",
      "state": "OPEN",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Subscribe"
      ],
      "body": "(prompted by w3c/media-source#320 and w3c/webtransport#522)\r\n\r\nIn traditional HLS/DASH-style live streaming, if the buffer is sufficiently big, the video player can do networking in bursts, rather than receive media continuously; in some circumstances (see the discussion linked above) this can lead to improved battery life.  MoQT is focused on getting media sent as soon as possible, meaning that we can't do anything of this nature even for cases where the buffer is big.  We should think about whether we want to do anyhting about this.",
      "createdAt": "2024-02-16T08:54:11Z",
      "updatedAt": "2024-02-20T00:02:25Z",
      "closedAt": null,
      "comments": [
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we already have the semantics in SUBSCRIBE to allow burst networking under a large forward buffer. Assuming your player is willing to tolerate a large buffer (say 20s), you could issue absolute SUBSCRIBES for 20s blocks of groups every 20s. You could choose how close to the live edge you wanted to retrieve the content. Since the data was produced in the past, it would be delivered at line speed, not encode speed, further reducing radio time. \r\n\r\n",
          "createdAt": "2024-02-16T11:26:43Z",
          "updatedAt": "2024-02-16T11:26:43Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "For live content, today SUBSCRIBE doesn't convey how delay tolerant the subscription is, so it seems like you'd always want to forward bytes on as quickly as possible with the assumption they have a small buffer.\r\n\r\nI think this as well as a number of other issues mean explicitly communicating a latency target/jitter buffer could be very helpful.",
          "createdAt": "2024-02-20T00:02:17Z",
          "updatedAt": "2024-02-20T00:02:17Z"
        }
      ]
    },
    {
      "number": 390,
      "id": "I_kwDOG2Ho4M5_vTz8",
      "title": "'Expires' in SUBSCRIBE_OK makes it unclear what the final group and object will be",
      "url": "https://github.com/moq-wg/moq-transport/issues/390",
      "state": "OPEN",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Subscribe"
      ],
      "body": "Subscriptions always end with either SUBSCRIBE_FIN or SUBSCRIBE_RESET, except when they Expire and then no control message is sent.  This complicates the state machine and adds another case to handle.\r\n\r\nThe subscriber needs to start a timer or something similar to know when the subscription will end, and it doesn't get to know the final group or object ID.",
      "createdAt": "2024-02-19T20:36:31Z",
      "updatedAt": "2024-03-04T22:40:55Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd like to get rid of `expires`, but my thought was that it's a signal to SUBSCRIBE again before the timeout to avoid interruption. Otherwise, there would be a SUBSCRIBE_RESET with an \"expired\" error code containing the final group/object.",
          "createdAt": "2024-02-19T20:52:26Z",
          "updatedAt": "2024-02-19T20:52:34Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that a subscriber can deal with this field, but I don't know what purpose it serves for the publisher/relay?  It's different from an idle connection timeout, because assuming there is data flowing for the subscription, it would never go idle.\r\n\r\nUnlike QUIC, I don't see value in having a 'silent close' for subscriptions, because typically we expect subscriptions to have data flowing at a somewhat regular interval.\r\n\r\nAlso, there's no guarantee that the subscription will last until the expiry time, it can always end early with SUBSCRIBE_FIN or SUBSCRIBE_RESET.",
          "createdAt": "2024-02-19T23:46:39Z",
          "updatedAt": "2024-02-19T23:46:39Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Based on last week's conversation, the Expires field doesn't change the state of the subscription by itself, a publisher would still have to send a FIN or RESET to close it.\r\n\r\nIt's still unclear as to what a subscriber should do with it.  There was a fair amount of discussion around refreshing one's authorization.  It's unclear if that would be done with a SUBSCRIBE_UPDATE or something similar or via UNSUBSCRIBE/SUBSCRIBE?",
          "createdAt": "2024-02-29T15:34:05Z",
          "updatedAt": "2024-02-29T15:34:05Z"
        }
      ]
    },
    {
      "number": 393,
      "id": "I_kwDOG2Ho4M5_vksH",
      "title": "ANNOUNCE error codes",
      "url": "https://github.com/moq-wg/moq-transport/issues/393",
      "state": "OPEN",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Announce"
      ],
      "body": "We currently don't have any specific error codes specified for announce.  We should either define some, or merge the space with subscribe errors.\r\n\r\nThe ones I have in mind are \"Internal error\", \"Announce not supported\" (aka this is a delivery-only endpoint), \"Permission denied\".",
      "createdAt": "2024-02-19T21:35:09Z",
      "updatedAt": "2024-02-21T19:56:12Z",
      "closedAt": null,
      "comments": [
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 \r\n\r\nWhat does the sender do with an \"internal Error\" ?\r\n\r\n",
          "createdAt": "2024-02-21T18:19:19Z",
          "updatedAt": "2024-02-21T18:19:19Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 \r\n\r\nMost of these errors are solely informative since we don't have a REASON string. At a minimum we need \"unauthorized\" which _could_ be automatically handled by the publisher, but more often will just be presented to the user.",
          "createdAt": "2024-02-21T18:45:46Z",
          "updatedAt": "2024-02-21T18:45:46Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "> What does the sender do with an \"internal Error\" ?\r\n\r\nProbably the same thing one would do in HTTP when you receive a 500 error (which is typically tell the user their operation cannot be finished because the server is broken).",
          "createdAt": "2024-02-21T19:56:11Z",
          "updatedAt": "2024-02-21T19:56:11Z"
        }
      ]
    },
    {
      "number": 396,
      "id": "I_kwDOG2Ho4M5_wmMi",
      "title": "How does a relay/publisher know what to prioritize or drop?",
      "url": "https://github.com/moq-wg/moq-transport/issues/396",
      "state": "OPEN",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Needs Discussion",
        "Transmission"
      ],
      "body": "It's unclear to me what objects a relay should prioritize or drop when congestion limited.  This is discussed in a few places, but I want to only focus on the question of what to send first and when to give up on sending an Object entirely.\r\n\r\nSpecific examples:\r\n\r\n1. Is there a point at which Objects from a subscription should no longer be transmitted?  If so, what determines that time?\r\n2. How does a relay decide whether to send the newest object or oldest?  Does it depend upon group boundaries?\r\n3. Can a relay infer that some Objects are droppable if they have lower priority than other Objects in the same group?\r\n\r\nMy strawman proposal is that subscriptions should have numerical priorities, so a relay knows whether it should send Objects from one subscription or another given limited bandwidth.  Additionally, subscriptions should have a TTL so relays know at what point they should stop retransmitting Objects.\r\n\r\n",
      "createdAt": "2024-02-20T03:08:57Z",
      "updatedAt": "2024-03-18T01:10:58Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "It depends on why we're dropping an OBJECT.\r\n\r\n- Viewer has skipped past OR\r\n- Relay is out storage.\r\n\r\nIn the first scenario, the receiver should be in charge since it's knows the jitter buffer size and whether it wants to block. Prioritization gets us most of the way here but maybe we add an explicit \"I don't want GROUP X\" message to save bandwidth.\r\n\r\nIn the second scenario, the sender must be in charge since. I would drop based on TTL with an explicit \"I won't send GROUP X\" message. In theory you could drop based on send order, but it's not time bounded so you end up catching way too much.\r\n\r\nIt does feel weird that they are two different units. Maybe the receiver could signal its TTL as well, but that feels wrong without advanced knowledge of the inbound content.",
          "createdAt": "2024-02-21T19:29:36Z",
          "updatedAt": "2024-02-21T19:29:36Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Is there a point at which Objects from a subscription should no longer be transmitted? If so, what determines that time?\r\n\r\nThe publisher may add an explicit \"expiration\" absolute timestamp T to Objects. Any relay forwarding an object for which now() > T may drop that object or remove it from a pending send queue if there is congestion. \r\n\r\n> How does a relay decide whether to send the newest object or oldest? Does it depend upon group boundaries?\r\n\r\nObjects can carry relative priorities, set by the publisher. These may correspond to newest or oldest, or they may not. The relay always sends highest priority items first when under congestion.\r\n\r\n> Can a relay infer that some Objects are droppable if they have lower priority than other Objects in the same group?\r\n\r\nNo, a relay should NEVER arbitrarily drop objects, it should just delay their sending, until either they expire or the relay runs out of queue memory. In both these latter cases, to should report this condition to the subscriber.\r\n",
          "createdAt": "2024-02-22T13:39:26Z",
          "updatedAt": "2024-02-22T13:39:26Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "@kixelated I do think the subscriber needs a way to indicate what objects/groups they no longer need.  The idea of a 'Stop Sending' message to indicate Objects before some point are useless is one possible mechanism.  Maybe there could be a corresponding 'Subscription truncated' message from the server to indicate all Objects before some point will no longer be sent?  This could be due to memory pressure or something else (ie: Will's timestamp).\r\n\r\n\r\nThanks @wilaw for the explanation.\r\n\r\nI'm not a big fan of absolute expiry times, because of clock skew issues, though maybe part of being a relay is having a fairly well synchronized system clock?  It's certainly not something I'd want to rely on for a client, but servers tend to be a lot better.  Also, I'm not sure you'd want the same timestamp value for a subscriber near the original publication vs around the world?\r\n\r\nAre you thinking the expiration timestamp T only applies to the live edge?  For VoD, presumably this time would be ignored, since otherwise features like rewinding 15 minutes wouldn't work.\r\n\r\nFor delivery order, I think you're saying:\r\n - Deliver highest priority first\r\n - Within a priority, deliver oldest non-expired first.",
          "createdAt": "2024-02-23T20:21:53Z",
          "updatedAt": "2024-02-23T20:21:53Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">  though maybe part of being a relay is having a fairly well synchronized system clock\r\n\r\nGiven the ubiquity of NTP solutions, this is a reasonable requirement for a relay provider. \r\n\r\n> I'm not sure you'd want the same timestamp value for a subscriber near the original publication vs around the world?\r\n\r\nPropagation time around the world is in the order of 100s of milliseconds. I'd just put a conservative expiration timestamp for all users, versus the complexity of trying to adjust for distance-from-origin. It would mean that close relays would expire content 100s of milliseconds after they could have, but that's not a problem. I expect relays to purge caches in the order of seconds (at fastest) anyhow. \r\n\r\n\r\n> Are you thinking the expiration timestamp T only applies to the live edge? For VoD, presumably this time would be ignored, since otherwise features like rewinding 15 minutes wouldn't work.\r\n\r\nNo, expiration notification must take DVR (rewinding) in to account. See my comment and examples [here](https://github.com/moq-wg/moq-transport/issues/249#issuecomment-1954743370). \r\n\r\n\r\n> For delivery order, I think you're saying:\r\n> \r\n> - Deliver highest priority first\r\n> - Within a priority, deliver oldest non-expired first.\r\n\r\nYes, although our nomenclature does not address \"oldest\" or \"newest\" so it might beter be expressed in terms of \"within a priority, deliver smallest non-expired group numbers first\"\r\n",
          "createdAt": "2024-02-24T14:34:51Z",
          "updatedAt": "2024-02-24T14:34:51Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd rather talk about this on a call when we can. ",
          "createdAt": "2024-02-27T14:28:28Z",
          "updatedAt": "2024-02-27T14:28:28Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd like to discuss this on the call tomorrow if we have time, but one simple idea came up today which was that SUBSCRIBE_UPDATE could include the ability to update the 'start' of the subscription to a group which is after the start of the subscription.\r\n\r\nThis would be a simple way to say \"I've started playing group X, so I don't need any groups <X\"",
          "createdAt": "2024-02-28T00:17:30Z",
          "updatedAt": "2024-02-28T00:17:30Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'd like to discuss this on the call tomorrow if we have time, but one simple idea came up today which was that SUBSCRIBE_UPDATE could include the ability to update the 'start' of the subscription to a group which is after the start of the subscription.\r\n> \r\n> This would be a simple way to say \"I've started playing group X, so I don't need any groups <X\"\r\n\r\nDope idea.",
          "createdAt": "2024-02-28T01:04:14Z",
          "updatedAt": "2024-02-28T01:04:14Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Why are the semantics of SUBSCRIBE_UPDATE necessary? For the use case cited above, if you don't need groups <X, then UNSUBSCRIBE and SUBSCRIBE with STARTGROUP=X. Keeping subscriptions clean (single entry point, single exit, immutable after establishment) leads to more stable systems at scale. ",
          "createdAt": "2024-02-28T07:59:19Z",
          "updatedAt": "2024-02-28T07:59:19Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We discussed this for many months. I would rather get a bit of the other stuff nailed down before we open up all the prioritization stuff. ",
          "createdAt": "2024-02-29T17:27:09Z",
          "updatedAt": "2024-02-29T17:27:09Z"
        }
      ]
    },
    {
      "number": 398,
      "id": "I_kwDOG2Ho4M5__mjP",
      "title": "Current naming is hard to keep track of <BIKESHED> ",
      "url": "https://github.com/moq-wg/moq-transport/issues/398",
      "state": "CLOSED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Propose names from my understanding of discussion call \r\n\r\nAnnounce (send by publisher)  , Annouce_OK, Annouce_Error\r\nUnAnnounce (send by publisher)  UnAnnounce_OK, UnAnnounce_Error \r\nAnnouce_End ( sent by thing that received Annouce) , AnnouceEnd_OK, AnnouceEnd_OK\r\n\r\nSubscribe (send by subscriber)  , Subscribe_OK,  Subscribe_Error\r\nUnSubscribe (send by subscriber)  , Subscribe_OK,  Subscribe_Error\r\nSubscribe_End (send by thing that received subscriber), Subscribe_OK,  Subscribe_Error\r\n\r\nMostly trying to get rid of FIN / RST and have different names for the messages that flow in opposite directions. ",
      "createdAt": "2024-02-21T18:00:40Z",
      "updatedAt": "2024-03-04T02:51:02Z",
      "closedAt": "2024-03-04T02:51:02Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't like the name of the different messages used to terminate. I'd rather have one message that transitions to the terminal state, with an optional error code and final group/object.\r\n\r\nIMO the subscription flow:\r\n```\r\n  -> SUBSCRIBE\r\n[ <- SUBSCRIBE_OK    ]\r\n[ -> SUBSCRIBE_STOP  ]\r\n  <- SUBSCRIBE_CLOSE\r\n```\r\n\r\nAnd the ANNOUNCE flow mirrors:\r\n```\r\n  -> ANNOUNCE\r\n[ <- ANNOUNCE_OK    ]\r\n[ -> ANNOUNCE_STOP  ]\r\n  <- ANNOUNCE_CLOSE\r\n```\r\n\r\nThe brackets mean a message is optional. The sender is responsible for creating and the receiver is responsible for closing, possibly at the bequest of the \r\nsender (like QUIC's STOP_SENDING).",
          "createdAt": "2024-02-21T19:05:30Z",
          "updatedAt": "2024-02-22T03:28:00Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "#392 has been merged, adding yet another term (CANCEL), but I figured we'd clean that up with this issue.",
          "createdAt": "2024-02-21T22:40:51Z",
          "updatedAt": "2024-02-21T22:40:51Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Since we are bikeshedding, I prefer ANNOUNCE_RESCIND instead of CANCEL, since an announce is more of a declarative statement than an active request from the sender.",
          "createdAt": "2024-02-21T22:54:43Z",
          "updatedAt": "2024-02-21T22:54:43Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Heh and UNANNOUNCE and UNSUBSCRIBE stick out because they don't share the same prefix.",
          "createdAt": "2024-02-22T03:28:46Z",
          "updatedAt": "2024-02-22T03:28:46Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like the names being proposed as they help make make is easier to understand. \r\n\r\nI do want to separate out one issue. The STOP / CLOSE type thing happens way after the initial SUBSCRIBE thus it can end up in a situation where auth has expired or something else has gone wrong this I like the current design that allows an OK or ERROR to be returned for those. I think it is also key for sender of the things stoping the subscribe to know that the other side has acted on that so we need the OK. ",
          "createdAt": "2024-02-27T14:25:47Z",
          "updatedAt": "2024-02-27T14:25:47Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm leaning towards CLOSED instead of CLOSE because CLOSE implies its a requested action, so to me SUBSCRIBE_CLOSE sounds like something the subscriber would send, not the publisher.\r\n\r\nFor a similar reason, I like CANCEL slightly better than STOP, but both work.\r\n\r\nUNANNOUNCE and UNSUBSCRIBE are good words, but I think it's better to follow a pattern in this case and I like @kixelated sequence of messages.",
          "createdAt": "2024-02-28T15:47:43Z",
          "updatedAt": "2024-02-28T15:47:43Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "@ianswett CANCEL and CLOSED are slightly better, sure.\r\n\r\n@fluffy there MUST still be an OK before objects can be sent. That way the receiver can tell upon receipt of the CLOSED if the subscription was ever active.",
          "createdAt": "2024-02-28T16:19:40Z",
          "updatedAt": "2024-02-28T16:19:40Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So to add an OK, we need to add another state. The question for me is what is the use case where we need to deliver that information in the end of the subscribe. ",
          "createdAt": "2024-02-29T17:29:18Z",
          "updatedAt": "2024-02-29T17:29:18Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This discusion is probably easier looking at #402 state machine diagrams ",
          "createdAt": "2024-02-29T17:30:18Z",
          "updatedAt": "2024-02-29T17:30:18Z"
        }
      ]
    },
    {
      "number": 399,
      "id": "I_kwDOG2Ho4M6APh0h",
      "title": "Organize messages by role",
      "url": "https://github.com/moq-wg/moq-transport/issues/399",
      "state": "OPEN",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Editorial"
      ],
      "body": "The discussion on PR #395 suggested a reorg of messages and how to discuss them in the Role section.\r\n\r\n> _afrind_ \r\n> If we reorganized the document into \"publisher messages\" and \"subscriber messages\", then the text here (and below) could be improved. We could say:\r\n> \r\n> The endpoint MUST NOT send any subscriber messages. If the endpoint receives any publisher messages, it MUST close the connection with \"error code TBD\".\r\n> \r\n>  _kixelated_ \r\n> +1 I would love to see this.\r\n> \r\n>  _kixelated_ \r\n> A simple way of doing it would be to add a \"sent by (role)\" column to the table of messages and IDs.\r\n\r\n",
      "createdAt": "2024-02-23T18:00:13Z",
      "updatedAt": "2024-02-23T18:04:09Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 400,
      "id": "I_kwDOG2Ho4M6AjVhV",
      "title": "Hard to understand the big picture of how this works",
      "url": "https://github.com/moq-wg/moq-transport/issues/400",
      "state": "OPEN",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I was reading the draft from the point of view of a new person that wanted to try and understand it and implement it. It's hard to get the big picture of what is happening as well as the corner cases. \r\n\r\nI think some call flow diagrams would really help people easily get what is going on. ",
      "createdAt": "2024-02-27T14:30:38Z",
      "updatedAt": "2024-02-28T16:28:08Z",
      "closedAt": null,
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "I have some call flows I have been using internally and happy to write up a PR on this .. I feel it will be super helpful ",
          "createdAt": "2024-02-28T16:28:06Z",
          "updatedAt": "2024-02-28T16:28:06Z"
        }
      ]
    },
    {
      "number": 402,
      "id": "I_kwDOG2Ho4M6Atzez",
      "title": "State machine is not clear and is making draft harder to understand ",
      "url": "https://github.com/moq-wg/moq-transport/issues/402",
      "state": "OPEN",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Would be nice to add a publisher and subscriber and state machine in the draft.",
      "createdAt": "2024-02-28T17:42:01Z",
      "updatedAt": "2024-03-04T17:42:53Z",
      "closedAt": null,
      "comments": [
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@fluffy to try and produce a straw man of what we have. ",
          "createdAt": "2024-02-28T17:42:40Z",
          "updatedAt": "2024-02-28T17:42:40Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "# Subscriber State Machine\r\n\r\n```mermaid\r\nstateDiagram\r\n    Init --> Pending: Send Subscribe\r\n    Pending --> Done : Recv SubscribeError\r\n    Pending --> Active: Recv SubscribeOk\r\n    Active --> Active : Send SubscribeUpdate\\n Recv SubscribeUpdate Error/Ok\r\n    Active --> Done : Send Usubscribe    \r\n```    ",
          "createdAt": "2024-02-28T21:31:28Z",
          "updatedAt": "2024-02-28T21:31:28Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "# Publisher State Machine\r\n\r\n```mermaid\r\nstateDiagram\r\n    Init --> Active: Recv Subscribe, Send SubscribeOk\r\n    Active --> Active: Recv SubscribeUpdate\\n  Send SubscribeUpdate Error/Ok\r\n    Active --> Done: Recv Unsubscribe\r\n    Active --> Done: Send SubscribeCancel\r\n```    ",
          "createdAt": "2024-02-28T21:31:39Z",
          "updatedAt": "2024-02-28T21:31:39Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "# Announce Sender State\r\n\r\n```mermaid\r\nstateDiagram\r\n    Init --> Pending: Send Announce\r\n    Pending --> Active: Recv AnnounceOk\r\n    Pending --> Done: Recv AnnounceError\r\n    Active --> Done: Send Unannounce\r\n    Active --> Done: Recv AnnounceCancel\r\n    \r\n```    ",
          "createdAt": "2024-02-28T21:31:52Z",
          "updatedAt": "2024-02-28T21:31:52Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "# Announce Receiver State\r\n\r\n```mermaid\r\nstateDiagram\r\n    Init --> Active: Recv Announce, \\nSend AnnounceOk\r\n    Active --> Done: Recv Unannounce\r\n    Active --> Done: Send AnnounceCancel \r\n    Init --> Done: Recv Announce, \\nSend AnnounceError\r\n    \r\n```  ",
          "createdAt": "2024-02-28T21:32:06Z",
          "updatedAt": "2024-02-28T21:32:06Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Once we get some consensu on these, I am happy to make a PR that puts them in the draft. ",
          "createdAt": "2024-02-28T21:32:49Z",
          "updatedAt": "2024-02-28T21:32:49Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I used Cancel in these, but later PR use Close for that message. I'd be happy with Cancel, Close, End, or something else. Just want to be clear that this was the same thing. ",
          "createdAt": "2024-02-29T17:25:02Z",
          "updatedAt": "2024-02-29T17:25:02Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Receiving SubscribeCancel should transition the subscriber state machine to Done I believe, just like receiving Unannounce does.",
          "createdAt": "2024-02-29T17:31:22Z",
          "updatedAt": "2024-02-29T17:31:22Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Personally, I'd rather have a single way to transition from Active to Done.\r\n\r\nFor example, In the subscribe case, I think sending unsubscribe shouldn't transition the subscription to Done.  Partially because I like to have all the data in the Closed message for monitoring/etc.\r\n\r\nI 'think' it could work either way and an implementation could chose to honor only one of the transitions instead of both if it wanted, but maybe there are potential issues I'm not considering.",
          "createdAt": "2024-02-29T17:41:19Z",
          "updatedAt": "2024-02-29T17:41:19Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Bikeshedding: You have SubscribeCancel but I'm going to call it SubscribeClosed to be consistent with @ianswett's naming. His Cancel is actually Unsubscribe so it's extra confusing.\r\n\r\n> # Subscriber State Machine\r\n> ```mermaid\r\n> stateDiagram\r\n>     Init --> Pending: Send Subscribe\r\n>     Pending --> Done : Recv SubscribeError\r\n>     Pending --> Active: Recv SubscribeOk\r\n>     Active --> Active : Send SubscribeUpdate\\n Recv SubscribeUpdate Error/Ok\r\n>     Active --> Done : Send Usubscribe    \r\n> ```\r\n\r\nYou're missing the ability for the publisher to close after sending an OK. There needs to be a line from Active to Done after receiving a SubscribeClosed.\r\n\r\nAlso there's an state missing here where you sent an Unsubscribe but don't know the final group/object yet. It's optional, but I imagine it could be useful to wait for all the information (ex. for resumption). I'd like to require the publisher send SubscribeClosed after Unsubscribe to both acknowledge and provide the final group/object.\r\n\r\nNote that if we add end group/object to Unsubscribe, then there's yet another state missing. Unsubscribe with an end group would go into a \"closing\" state, where the subscription is still active, distinct from an unsubscribe with no end group. The subscriber would need a way to transition out of this state too (sending another unsubscribe?) which is why I slightly prefer SubscribeUpdate @wilaw.\r\n\r\nAlso this is a separate issue, but what happens after SubscribeUpdate error? I think it will get hairy if the subscribe stays open using the previous state; I'd rather close it.\r\n\r\n> # Publisher State Machine\r\n> ```mermaid\r\n> stateDiagram\r\n>     Init --> Active: Recv Subscribe, Send SubscribeOk\r\n>     Active --> Active: Recv SubscribeUpdate\\n  Send SubscribeUpdate Error/Ok\r\n>     Active --> Done: Recv Unsubscribe\r\n>     Active --> Done: Send SubscribeCancel\r\n> ```\r\n\r\nMissing the ability to send SubscribeError.\r\n\r\nAs mentioned above I would like to send SubscribeClosed after receiving Unsubscribe.\r\n\r\nThese are nearly the same as my proposal but I'd like to combine SubscribeError with SubscribeClosed.",
          "createdAt": "2024-02-29T18:39:46Z",
          "updatedAt": "2024-02-29T22:39:51Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One thing I am not clear on what everything thinks ... we seem to agree that pub can send sub a message to end the subscribing. Let me call that message A, and also sub can send pub a message to end the subscrition, Let me call that B. \r\n\r\nFirst do we agree that A and B should be have messages  names ?  Second, I've lost track of current best proposal for the name(s)?  Let me know and I will update state machines above. ",
          "createdAt": "2024-03-04T17:21:27Z",
          "updatedAt": "2024-03-04T17:21:27Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> One thing I am not clear on what everything thinks ... we seem to agree that pub can send sub a message to end the subscribing. Let me call that message A, and also sub can send pub a message to end the subscrition, Let me call that B.\r\n> \r\n> First do we agree that A and B should be have messages names ? Second, I've lost track of current best proposal for the name(s)? Let me know and I will update state machines above.\r\n\r\nYeah, with A containing the final group/object sent.\r\n\r\nA = SUBSCRIBE_END\r\nB = UNSUBSCRIBE\r\n\r\nMy updated proposal is:\r\n\r\n```\r\n  -> SUBSCRIBE\r\n[ <- SUBSCRIBE_OK  ]\r\n[ -> UNSUBSCRIBE   ]\r\n  <- SUBSCRIBE_END\r\n```\r\n\r\nThe OK and UNSUBSCRIBE messages are optional because the publisher could close the subscription first. I'd like there to always be a SUBSCRIBE_END message containing the final group/object, even when the subscriber sends UNSUBSCRIBE.\r\n\r\nThis is with merging SUBSCRIBE_ERROR and SUBSCRIBE_END. The current draft does not do this, so the state machine is a tiny bit more complicated.",
          "createdAt": "2024-03-04T17:42:51Z",
          "updatedAt": "2024-03-04T17:42:51Z"
        }
      ]
    },
    {
      "number": 403,
      "id": "I_kwDOG2Ho4M6A2NM7",
      "title": "No way to prioritize one track above another",
      "url": "https://github.com/moq-wg/moq-transport/issues/403",
      "state": "OPEN",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Subscribe",
        "Transmission"
      ],
      "body": "For low latency audio and video, it's helpful to be able to prioritize one track over another, whether it's audio vs video or one quality of video vs another quality of video.\r\n\r\nThis prioritization can be very helpful for ABR as well.  One might want to request the next quality up in hopes of upswitching, but continue playing the current quality until it's clear the next quality can be delivered, so the higher quality should be lower priority.\r\n\r\nThis is somewhat related to #396",
      "createdAt": "2024-02-29T16:50:47Z",
      "updatedAt": "2024-03-18T01:10:39Z",
      "closedAt": null,
      "comments": [
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "100% agree we need to be able to do this. ",
          "createdAt": "2024-02-29T17:22:39Z",
          "updatedAt": "2024-02-29T17:22:39Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment: \r\n\r\nOne design consideration here is who can influence the prioritization.  In HTTP both the client and the origin server can send a signal, but the server (or terminating proxy) gets the final say.  \r\n\r\nWe have sendOrder/priority field which today is 100% publisher controlled.  How would a track level priority construct interact with this?",
          "createdAt": "2024-02-29T23:54:36Z",
          "updatedAt": "2024-02-29T23:54:36Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "> Individual Comment:\r\n> \r\n> One design consideration here is who can influence the prioritization. In HTTP both the client and the origin server can send a signal, but the server (or terminating proxy) gets the final say.\r\n> \r\n> We have sendOrder/priority field which today is 100% publisher controlled. How would a track level priority construct interact with this?\r\n\r\nBased on the use cases I can think of, I was thinking the subscriber requested priority is considered first, and then the publisher controlled priority is considered.\r\n",
          "createdAt": "2024-03-01T15:23:12Z",
          "updatedAt": "2024-03-01T15:24:01Z"
        }
      ]
    },
    {
      "number": 404,
      "id": "I_kwDOG2Ho4M6A-GZw",
      "title": "ContentExists makes messages hard to parse",
      "url": "https://github.com/moq-wg/moq-transport/issues/404",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "Wire Format"
      ],
      "body": "#343 and #389 introduced a `ContentExists` field to SUBSCRIBE_OK, SUBSCRIBE_FIN, and SUBSCRIBE_RESET. If I read the notation correctly, it has a size of 1 bit, which makes it hard to parse the rest of the message. Could we encode that information in the message type by using two types per message instead of a 1-bit field?",
      "createdAt": "2024-03-01T16:37:00Z",
      "updatedAt": "2024-03-18T00:39:29Z",
      "closedAt": "2024-03-18T00:39:29Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the intent is that it is one *byte* not one bit.",
          "createdAt": "2024-03-01T17:40:06Z",
          "updatedAt": "2024-03-01T17:40:06Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Maybe it should have been:\r\n\r\n```\r\n...\r\nContentExists (1),\r\nUnused (7),\r\n...\r\n```",
          "createdAt": "2024-03-01T17:41:20Z",
          "updatedAt": "2024-03-01T17:41:20Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "or just a byte field with only 2 possible values allowed (1) and (0) .. ",
          "createdAt": "2024-03-02T06:09:45Z",
          "updatedAt": "2024-03-02T06:09:45Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree we need to keep this byte aligned however we do it. ",
          "createdAt": "2024-03-04T17:08:56Z",
          "updatedAt": "2024-03-04T17:08:56Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "IMO just make it a VarInt (or byte), with only values of 0 and 1 currently valid. This encoding is temporary until we nail down all of the fields/flags so we shouldn't be making life difficult or efficient.",
          "createdAt": "2024-03-04T17:15:20Z",
          "updatedAt": "2024-03-04T17:17:00Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment: \r\n\r\nEven if it's temporary, my preference is for a one-bit field and unused/reserved bits to align, because there are no error conditions.",
          "createdAt": "2024-03-04T17:19:46Z",
          "updatedAt": "2024-03-04T17:19:46Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Have a look at PR #405 ",
          "createdAt": "2024-03-04T17:27:23Z",
          "updatedAt": "2024-03-04T17:27:23Z"
        }
      ]
    },
    {
      "number": 408,
      "id": "I_kwDOG2Ho4M6BXP4Y",
      "title": "How should a relay queue datagrams?",
      "url": "https://github.com/moq-wg/moq-transport/issues/408",
      "state": "OPEN",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Transmission"
      ],
      "body": " Does it ever make sense to queue a datagram before transmission, and if so for how long? How does this tie into object TTLs?",
      "createdAt": "2024-03-05T23:45:49Z",
      "updatedAt": "2024-03-24T23:51:23Z",
      "closedAt": null,
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment:\r\n\r\nI'm inclined to decouple the mechanism by which an object arrived and how long it can be cached.  Whatever we decide for TTL / expiry would also apply to datagrams, possibly with some wire format magic to reduce overhead.",
          "createdAt": "2024-03-05T23:50:06Z",
          "updatedAt": "2024-03-05T23:50:06Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "In my opinion, a relay SHOULD NOT cache or queue datagrams. Of course there can be some send buffer, but we're talking milliseconds.\r\n\r\nThe application wants to use datagrams because any form of transmission latency, for example retransmissions, is unacceptable. Timeliness is the property we want, not unreliability. A relay breaks that if it queues datagrams, creating an issue not dissimilar from bufferbloat.\r\n\r\nWhat are example use cases of a datagram with a TTL greater than an RTT? If a datagram is allowed to be late, why not use a stream?",
          "createdAt": "2024-03-05T23:54:13Z",
          "updatedAt": "2024-03-05T23:54:13Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment:\r\n\r\nI don't have a particular use case in mind.  Maybe the publisher chose datagrams because it didn't want to mess with retransmission, but I would still like the objects that do arrive at the relay be available to a subsequent subscribe?  Generally I don't see a reason to normatively prohibit caching an object because it arrived on a stream vs a datagram.  I'd rather the application have clear mechanisms to indicate how long something can be cached.\r\n\r\nWe haven't yet explained the normative rules for how relays make drop decisions.  Since datagrams are inherently unreliable it might be tempting to say they are always dropped first, but again, I think I'd rather use send order/priority and expiry to drive that process primarily.",
          "createdAt": "2024-03-06T00:07:44Z",
          "updatedAt": "2024-03-06T00:07:44Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 on @afrind suggestions. Objects are cacheable entities in MOQ, not the transport mechanism",
          "createdAt": "2024-03-06T00:22:48Z",
          "updatedAt": "2024-03-06T00:31:38Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "The problem with caching/queuing datagrams is that there's an inherent mismatch between the IP/QUIC layer (TTL=0) and the MoQ layer (TTL=N). Trying to ask for a higher TTL than datagrams can inherently provide is going to result in strange behavior depending on the network/relay configuration.\r\n\r\nIt also doesn't make sense to have TTL>RTT, since retransmissions via streams are strictly better than using datagrams. I don't understand why you would ever want something transient at the network layer but persistent at the relay layer.\r\n\r\nI'm fine with adding a TTL to datagrams but it needs to be measured in tens of milliseconds. Anything higher causes bufferbloat (relaybloat?) or should be handled with streams instead. But I would rather remove TTL from the datagram header and assume TTL=0, reducing the overhead in the process.",
          "createdAt": "2024-03-06T00:42:21Z",
          "updatedAt": "2024-03-06T00:45:48Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment: \r\n\r\nI think we should apply our energy figuring out what TTL/expiry means in general in moq first, then figure out how that might apply to datagrams.\r\n\r\n> The problem with caching/queuing datagrams is that there's an inherent mismatch between the IP/QUIC layer (TTL=0) and the MoQ layer (TTL=N)\r\n\r\nI don't view this problem in the same way.  The transport reliability (is it retransmitted?) and the durability of an object (how long is it valid) seem relatively orthogonal to me.\r\n\r\n> I'm fine with adding a TTL to datagrams but it needs to be measured in tens of milliseconds.\r\n\r\nIf TTL/expiry ends up being an object property, I wouldn't see any reason to normatively limit an application's ability to set the value to whatever they want.  We can have a best-practices section that explains how to get good performance from an moq application.\r\n",
          "createdAt": "2024-03-06T01:06:17Z",
          "updatedAt": "2024-03-06T01:06:17Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> The problem with caching/queuing datagrams is that there's an inherent mismatch between the IP/QUIC layer (TTL=0) and the MoQ layer (TTL=N). Trying to ask for a higher TTL than datagrams can inherently provide is going to result in strange behavior depending on the network/relay configuration.\r\n\r\nI think this is wrong way to think about it .. TTL on moq applies to objects .. Objects arrive over datagram or over stream .. MOQ TTL has same meaniig for an MOQ object regardless of how it is delivered.",
          "createdAt": "2024-03-06T03:25:42Z",
          "updatedAt": "2024-03-06T03:25:42Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think we should apply our energy figuring out what TTL/expiry means in general in moq first, then figure out how that might apply to datagrams.\r\n\r\nI'm having trouble adding datagram support and it seems even worse with TTL in the mix. The problem is that the relay has a single opportunity to send each datagram. How aggressive should it be?\r\n\r\nFor example, if a relay receive a datagram with no TTL. For all active subscribers, does it:\r\n\r\n1. Try to send it immediately, dropping it if the congestion window is full.\r\n2. Put the datagram in a priority queue, popping in send order until the congestion window is full.\r\n\r\nThe second approach means I drop fewer datagrams (especially for bursts), but it requires the QUIC library to have a callback-based API. But more importantly, it means that the relay will queue datagrams for an unbounded amount of time, aka bufferbloat. The entire point of using datagrams instead of streams is for timely delivery (below RTT) so I strongly disagree with this approach.\r\n\r\nNow what if I receive a datagram with a TTL of 100ms? I'm basically required to implement the second approach, with the TTL being the maximum allowed amount of bufferbloat. I'm allowed to ignore the TTL and transmit/drop immediately, but then the field is useless and I'm ignoring application intent. And what is the application intent anyway? Why let the relay queue for up to 100ms but disallow retransmissions?\r\n\r\nI just can't envision a use-case where datagram TTL would be useful and it's not trivial to implement either.\r\n\r\n> I think this is wrong way to think about it .. TTL on moq applies to objects .. Objects arrive over datagram or over stream .. MOQ TTL has same meaniig for an MOQ object regardless of how it is delivered.\r\n\r\nI understand the desire to label everything as an \"object\", but the reality is that streams and datagrams have different properties. A TTL for a stream is completely different than a \"TTL\" for a datagram...",
          "createdAt": "2024-03-06T07:03:33Z",
          "updatedAt": "2024-03-06T07:05:22Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Commenting as an implementer:\r\n\r\n> Put the datagram in a priority queue, popping in send order until the congestion window is full.\r\n\r\n> ...requires the QUIC library to have a callback-based API\r\n\r\nThe mvfst QUIC library maintains this priority queue without the need for callbacks.  The application writes data into the transport library (on streams or datagrams) and the transport drains those queues in priority order as CWND is available.\r\n\r\nA little bit of priority queuing is good for you -- eg: if you receive a burst of datagrams but the later received ones have higher priority.  You don't want to fill up our CWND with low pri ones.\r\n\r\nI also expect moq will give us reason to extend the capabilities of mvfst.",
          "createdAt": "2024-03-06T17:17:20Z",
          "updatedAt": "2024-03-06T17:17:20Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> Commenting as an implementer:\r\n> \r\n> > Put the datagram in a priority queue, popping in send order until the congestion window is full.\r\n> \r\n> > ...requires the QUIC library to have a callback-based API\r\n> \r\n> The mvfst QUIC library maintains this priority queue without the need for callbacks. The application writes data into the transport library (on streams or datagrams) and the transport drains those queues in priority order as CWND is available.\r\n> \r\n> A little bit of priority queuing is good for you -- eg: if you receive a burst of datagrams but the later received ones have higher priority. You don't want to fill up our CWND with low pri ones.\r\n> \r\n> I also expect moq will give us reason to extend the capabilities of mvfst.\r\n\r\nAbsolutely, you should have a small send buffer for datagrams especially for pacing.\r\n\r\nThe problem is that the size of the send buffer needs to be on a per-datagram basis to implement datagram TTLs. For example, there are two objects, one with TTL 10ms and the other with TTL 90ms. They both go into the same priority queue, but the library needs an API and mechanism to expire datagrams at different times. Most send buffers don't work that way.\r\n\r\nAdditionally, the QUIC libraries I've used don't have a way to prioritize individual datagrams. There's generally one queue with a small buffer because datagrams are intended to be sent immediately or dropped. A QUIC library needs to support both datagram prioritization and expiration for datagram TTLs to work; most libraries I've seen have neither.\r\n\r\nMoQ could pave the way for new QUIC APIs but that's optimistic. In reality, I imagine most implementations will ignore the datagram TTL and it should be an extension at best.",
          "createdAt": "2024-03-06T18:01:43Z",
          "updatedAt": "2024-03-06T18:01:43Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment:\r\n\r\nI strongly believe we shouldn't constrain MoQ based on circa 2023 library APIs and designs.  They are in user space and most are open source and have active developers.  WebTransport isn't even constrained to RFC 9000 - it's going to depend on a QUIC *extension* which hasn't even been completed yet.  ",
          "createdAt": "2024-03-06T18:14:28Z",
          "updatedAt": "2024-03-06T18:16:23Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Let me ask a question that is *not* about datagram. Say a relay receives an object from a stream on quic connection A and need to send it on a stream on quic connection B and also on a stream in a different connection C. It sends it on B, but on C the QUIC congestion controller does not allow it to be sent. At this point, it needs to buffer it until it can be sent. This buffering might happen in the QUIC stack or via back pressure of the quic stack telling the app to buffer it. But how does this work for objects sent over streams?\r\n",
          "createdAt": "2024-03-18T00:31:49Z",
          "updatedAt": "2024-03-18T00:31:49Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> Let me ask a question that is _not_ about datagram. Say a relay receives an object from a stream on quic connection A and need to send it on a stream on quic connection B and also on a stream in a different connection C. It sends it on B, but on C the QUIC congestion controller does not allow it to be sent. At this point, it needs to buffer it until it can be sent. This buffering might happen in the QUIC stack or via back pressure of the quic stack telling the app to buffer it. But how does this work for objects sent over streams?\r\n\r\nYeah, the QUIC stack could queue some stream data (ex. TCP send buffer) until it eventually it hits a limit (ex. TCP write can return EAGAIN).\r\n\r\nThe important part is how the QUIC stack drains the queue or otherwise unblocks streams. That's the entire purpose of prioritization, with `send_order` being the signal to the QUIC stack on which streams to unblock first (in strict order).\r\n\r\nSo if you write two objects via streams, A and B, they might get queued during congestion. If B has a higher priority (lower `send_order`) then it will get sent first after recovery, even if A was written first. And if newly created C enters the picture with a higher priority, then it will pre-empt both A and B.\r\n\r\nAll of the objects/streams stay queued in the application/QUIC stack awaiting their turn via `send_order`. The draft currently doesn't specify how streams/groups/objects are dropped, causing wasted bandwidth. I've got a few ideas, including using SUBSCRIBE_UPDATE with a new start group/object to signal that an old group is no longer desired.",
          "createdAt": "2024-03-18T00:55:01Z",
          "updatedAt": "2024-03-18T00:55:29Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "A practical example:\r\n\r\nEach audio frame is sent via a separate stream with descending `send_order`. That means new audio frames are transmitted first, (re)transmitting old audio as the congestion window allows. If an audio frame is not received in time for the jitter buffer, it is not rendered.\r\n\r\nNote that the sender does NOT know the size of the jitter buffer. Using datagrams assumes the jitter buffer is too small for retransmissions (<1.5x RTT), but that's often not true especially as relays are introduced. \r\n\r\nThe old audio frames are still queued for transmission, although they are lower priority than newly encoded frames and will not compete for bandwidth. The subscriber is somehow responsible for somehow signaling that they no longer want this data based on their (current) jitter buffer. Higher latency playback will allow seconds, while lower latency playback will allow milliseconds.",
          "createdAt": "2024-03-18T01:04:29Z",
          "updatedAt": "2024-03-18T01:04:49Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "One final addition to the wall of text:\r\n\r\nWe need to add some sort of TTL too, which is the maximum amount of time the publisher should have a stream cached/queued. The subscriber should have a way to lower that based on their jitter buffer size.",
          "createdAt": "2024-03-18T01:09:24Z",
          "updatedAt": "2024-03-18T01:09:24Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Note that we've tried no-queueing for datagrams before, and it doesn't really work due to pacing.  WebTransport supports [time limit](https://w3c.github.io/webtransport/#dom-webtransportdatagramduplexstream-outgoingmaxage) on how long a datagram can be in the queue, and I believe W3C WG is open to alternative suggestions (with the constraint that we can't do callbacks due to IPC nature of the sandbox).",
          "createdAt": "2024-03-18T05:36:00Z",
          "updatedAt": "2024-03-18T05:36:00Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think objects should queue the same way regardless of if they are on datagrapms or streams. In both cases there needs to be some sort of time to live to stop infinite growth and there needs to be priority/send order algorithm that determines what object gets sent next when the congestion window opens up. ",
          "createdAt": "2024-03-24T23:51:22Z",
          "updatedAt": "2024-03-24T23:51:22Z"
        }
      ]
    },
    {
      "number": 409,
      "id": "I_kwDOG2Ho4M6BZ7V6",
      "title": "ANNOUNCE_CANCEL does not have a message type",
      "url": "https://github.com/moq-wg/moq-transport/issues/409",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "ANNOUNCE_CANCEL is missing in [Table 4](https://datatracker.ietf.org/doc/html/draft-ietf-moq-transport-03#table-4). ",
      "createdAt": "2024-03-06T09:38:15Z",
      "updatedAt": "2024-03-18T00:38:12Z",
      "closedAt": "2024-03-18T00:38:12Z",
      "comments": []
    },
    {
      "number": 410,
      "id": "I_kwDOG2Ho4M6Bd2Qm",
      "title": "What happens if we get OBJECT_DATAGRAM on a Stream?",
      "url": "https://github.com/moq-wg/moq-transport/issues/410",
      "state": "OPEN",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Object Model"
      ],
      "body": "Now that Datagram is no longer just a suggestion, should there be some sort of error if we get OBJECT_DATAGRAM on a Stream?",
      "createdAt": "2024-03-06T17:41:58Z",
      "updatedAt": "2024-03-19T07:55:36Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Absolutely, and it's something I'd like to address in #407",
          "createdAt": "2024-03-06T17:46:10Z",
          "updatedAt": "2024-03-06T17:46:10Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I view this as \"protocol error\" and any time we get that we should tear down the QUIC connection with appropriate error. ",
          "createdAt": "2024-03-19T07:55:34Z",
          "updatedAt": "2024-03-19T07:55:34Z"
        }
      ]
    },
    {
      "number": 411,
      "id": "I_kwDOG2Ho4M6BebM-",
      "title": "Proposal: Subscriber Prioritization",
      "url": "https://github.com/moq-wg/moq-transport/issues/411",
      "state": "OPEN",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Transmission"
      ],
      "body": "I know we're not allowed to talk about priorities any longer but I wanted to float another option. \r\n\r\nThe subscriber is in charge of prioritization:\r\n- Add `order` to SUBSCRIBE: `ASC` or `DESC`\r\n- Add `priority` to SUBSCRIBE: `VarInt`?\r\n- Remove `send_order` from OBJECT.\r\n\r\nThe publisher prioritizes streams based on:\r\n```rust\r\nlet order = subscribe.order == DESC ? 1 : -1;\r\nsubscribe.priority > object.group * order > -object.id\r\n```\r\n\r\nDepending on the QUIC API, publisher still needs to compute a send order for each stream. It can do this by inserting each stream into a priority queue based on the above comparison, using the resulting position in the queue as the send order. This was already a requirement for QUIC APIs that did not support a u64 send order.\r\n\r\nAlternatively, a QUIC API could implement nested priority groups, perhaps something like [sendGroup](https://www.w3.org/TR/webtransport/#dom-webtransport-createsendgroup).\r\n\r\n# Pros: Order\r\nThe benefits of `order=ASC` are similar to the proposed `FETCH` API in #368.\r\n\r\n- Supports HLS/DASH-like experiences, where playback buffers instead of skips.\r\n- Supports VOD playback.\r\n- Supports advertisement playback.\r\n\r\nNote that you could perform head-of-line blocking today* by issuing a SUBSCRIBE per group. However this is quite verbose, and it creates an RTT at the end of each group where the network is not being utilized.\r\n\r\n# Pros: Priority\r\n- Supports prioritizing unrelated tracks (from different encoders).\r\n- Supports prioritizing based on focus state (sideline cam > main cam)\r\n- Supports prioritizing high bitrate (main cam > sideline cam)\r\n- The encoder is dumb, unaware of network priorities.\r\n\r\nThese could only be performed today by rewriting send order at a relay, which is impossible without catalog access.\r\n\r\n# Cons\r\n- SUBSCRIBE is even more complicated.\r\n- No interleaved prioritizes between tracks/groups. (who cares?)\r\n- Publisher has to compute/update send order on each stream/datagram created.\r\n- Relay has to deduplicate conflicting SUBSCRIBEs\r\n \r\nThe main challenge is the last one. For example, two viewers could issue:\r\n```\r\nSUBSCRIBE track=720p order=ASC priority=3\r\nSUBSCRIBE track=720p order=DESC priority=9\r\n```\r\n\r\nWhat does the relay send upstream? The idea behind publisher prioritization was to avoid this dilemma, but maybe there's another way we can solve it.",
      "createdAt": "2024-03-06T19:15:58Z",
      "updatedAt": "2024-03-18T04:17:15Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "One dumb idea for the publisher prioritization dilemma is to put the \"preferred\" priority and order for each track in ANNOUNCE. A relay could choose to use this information when fetching upstream, instead of relying on the values provided by N subscribers.\r\n\r\nHowever this would require switching ANNOUNCE to be per-track instead of per-namespace as it is currently.",
          "createdAt": "2024-03-06T19:30:04Z",
          "updatedAt": "2024-03-06T19:31:14Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "The FETCH/SUBSCRIBE split solves your largest CON above, because there can only be one active SUBSCRIBE for a track at once.\r\n\r\nOtherwise this SGTM.",
          "createdAt": "2024-03-18T04:17:14Z",
          "updatedAt": "2024-03-18T04:17:14Z"
        }
      ]
    },
    {
      "number": 412,
      "id": "I_kwDOG2Ho4M6BwFFH",
      "title": "ANNOUNCE_CANCEL is missing a code/reason",
      "url": "https://github.com/moq-wg/moq-transport/issues/412",
      "state": "OPEN",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Announce"
      ],
      "body": "It's meant to be sent by the subscriber, indicating that the announce is no longer accepted. The fields should mirror ANNOUNCE_ERROR so the subscriber can indicate stuff like authentication expired, another announce was received, etc.",
      "createdAt": "2024-03-08T22:22:11Z",
      "updatedAt": "2024-03-18T00:27:56Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 415,
      "id": "I_kwDOG2Ho4M6CXVKX",
      "title": "Errors in second example in section 6.3.4 of draft-03",
      "url": "https://github.com/moq-wg/moq-transport/issues/415",
      "state": "OPEN",
      "author": "englishm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Editorial",
        "Needs PR"
      ],
      "body": "There are two issues with this example:\r\n\r\nhttps://github.com/moq-wg/moq-transport/blob/80a1fc4eec92a05439e473edb60dcea399b3ca62/draft-ietf-moq-transport.md?plain=1#L1153-L1185\r\n\r\n1. The Object id should be unique, not duplicated.\r\n2. We shouldn't be mixing different forwarding preferences within the same track, per earlier text in this same version of the draft:\r\n\r\nhttps://github.com/moq-wg/moq-transport/blob/80a1fc4eec92a05439e473edb60dcea399b3ca62/draft-ietf-moq-transport.md?plain=1#L975-L978",
      "createdAt": "2024-03-14T19:50:54Z",
      "updatedAt": "2024-03-18T00:53:04Z",
      "closedAt": null,
      "comments": [
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Good catch. ",
          "createdAt": "2024-03-18T00:53:03Z",
          "updatedAt": "2024-03-18T00:53:03Z"
        }
      ]
    },
    {
      "number": 416,
      "id": "I_kwDOG2Ho4M6CmtWh",
      "title": "Extensibility and greasing",
      "url": "https://github.com/moq-wg/moq-transport/issues/416",
      "state": "OPEN",
      "author": "LPardue",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "At IETF 119 we discussed very briefly extensibility of the protocol. It was suggested by Ian that having _some_ extension to test the extension mechanisms/points would be useful before publication of the draft. Greasing (whether as part of MoQT or a separate extension) might be a sufficient to exercise things.",
      "createdAt": "2024-03-18T04:08:36Z",
      "updatedAt": "2024-03-24T23:46:01Z",
      "closedAt": null,
      "comments": [
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "An extension for a relay to repot metrics about a namespace to an authorized subscriber would be very nice to have. ",
          "createdAt": "2024-03-24T23:46:00Z",
          "updatedAt": "2024-03-24T23:46:00Z"
        }
      ]
    },
    {
      "number": 419,
      "id": "I_kwDOG2Ho4M6CvEvr",
      "title": "Reliable Live use-case",
      "url": "https://github.com/moq-wg/moq-transport/issues/419",
      "state": "OPEN",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I'm just going to coin a new term: **reliable live**\r\n\r\nIt's the use-case when a viewer wants to receive live content but doesn't want to skip anything, as quality is more important than latency. This is an extremely common scenario currently served by HLS/DASH and needs to be supported by MoQ too.\r\n\r\nThe player implements this by pausing playback (buffering) when the buffer is depleted until it reaches a minimum size. There's also a target latency, which is effectively the buffer size at steady state. The player will not skip over content unless there is an explicit gap. Let's assume fixed group sizes for simplicity. All of the below examples use:\r\n```\r\ngroup_size=2s\r\ntarget_buffer=5s\r\nmin_buffer=1s\r\n```\r\n\r\n## Current Draft\r\nIn the current draft, a player start playback by issuing:\r\n\r\n```\r\n-> SUBSCRIBE 480p start=-2\r\n<- SUBSCRIBE_OK 480p latest=6835\r\n```\r\n\r\nWe added #343 so the player would know to start playback at group 6833, buffering any future groups. Unfortunately the player currently doesn't know about gaps, so it could block indefinitely waiting for 6834 (or any group). We need some sort of GROUP_DROPPED message to signal that the player should skip over, much like a DISCONTINUITY in HLS. This has been touted as a feature of FETCH, but it's something we also need for SUBSCRIBE.\r\n\r\nThe bigger issue is prioritization. If the send_order is decreasing, which is required to allow players to skip over old content, then the buffer will fill _backwards_.\r\n\r\n```\r\n-> SUBSCRIBE 480p start=-2\r\n<- SUBSCRIBE_OK 480p latest=6835\r\n<- OBJECT group=6835 send_order=0\r\n<- OBJECT group=6834 send_order=1\r\n<- OBJECT group=6833 send_order=2\r\n```\r\n\r\nPlayback is blocked waiting for the first 1s of group 6833 but we receive newer groups first in their entirety, including possibly some of 6836 as it starts being generated. We will eventually be able to play this data, but this will dramatically increase startup and buffering time. This is also a problem for DVR, as the prioritization required for live does not make sense for VOD.\r\n\r\nThe broadcaster could remedy this by baking in head-of-line blocking into send_order but I don't want to do that. A participant on a conference stage may want interactive latency, while a viewer may want high quality (HoLB) instead. A viewer on a TV will want high quality, while a viewer using an interactive application will want low latency. It's not the end of the world but it's a missed opportunity.\r\n\r\nThe other option is to fetch each group one at a time like HLS/DASH:\r\n```\r\n-> SUBSCRIBE 480p start=-2 end=-1\r\n<- SUBSCRIBE_OK 480p latest=6835\r\n<- OBJECT group=6833\r\n<- SUBSCRIBE_DONE 480p\r\n-> SUBSCRIBE 480p start=6834 end=6835\r\n<- SUBSCRIBE_OK 480p latest=6835\r\n<- OBJECT group=6834\r\n<- SUBSCRIBE_DONE 480p\r\n-> SUBSCRIBE 480p start=6835 end=6836\r\n<- SUBSCRIBE_OK 480p latest=6836\r\n<- OBJECT group=6835\r\n<- SUBSCRIBE_DONE 480p\r\n```\r\n\r\nYikes, not only is this annoying and inefficient, but it increases latency. That's because the next SUBSCRIBE can only be issued only once the final object in the group has been received, causing an RTT of no network connectivity which of course corresponds with a massive I-frame that needs to be delivered. We can do better.\r\n\r\n## Fetch #368 \r\nThere are multiple fetch APIs floating around, but the gist is that FETCH returns old content while SUBSCRIBE returns new content. Here's how the player would playback from my understanding:\r\n\r\n```\r\n-> SUBSCRIBE timeline\r\n<- SUBSCRIBE_OK timeline\r\n<- OBJECT timeline\r\n-> FETCH 480p start=6833 end=6834\r\n<- FETCH_OK\r\n-> SUBSCRIBE 480p start=6835\r\n<- SUBSCRIBE_OK\r\n```\r\n\r\nThis is complicated, as it depends on an outside track to determine which group roughly corresponds to ~5s target latency for the initial FETCH. But it's actually wrong.\r\n\r\nThere's the assumption that SUBSCRIBE can be used once we're caught up to live but that's not true because of the aforementioned prioritization issue; the buffer will be filled backwards during congestion. This won't happen on startup due to FETCH but will still occur afterwards.\r\n\r\nJust like in the current draft, you either have to bake head-of-line blocking into send_order, or you need to FETCH one group at a time:\r\n\r\n```\r\n-> SUBSCRIBE timeline\r\n<- SUBSCRIBE_OK timeline\r\n<- OBJECT timeline\r\n-> FETCH 480p start=6833 end=6834\r\n<- FETCH_OK 480p latest=6835\r\n<- OBJECT group=6833\r\n-> FETCH 480p start=6834 end=6835\r\n<- FETCH_OK 480p latest=6835\r\n<- OBJECT group=6834\r\n-> FETCH 480p start=6835 end=6836\r\n<- FETCH_OK 480p latest=6836\r\n<- GROUP 6835\r\n```\r\n\r\nOr there's a world where you could switch a SUBSCRIBE to FETCH once you learn it's no longer the newest group. This is extra extra gross though.\r\n\r\n## SUBSCRIBE ORDER #411 \r\nI recently put forth another proposal to deal with this use-case:\r\n\r\n```\r\n-> SUBSCRIBE start=-2 order=ASC\r\n<- SUBSCRIBE_OK latest=6835\r\n<- OBJECT group=6833\r\n<- OBJECT group=6834\r\n<- OBJECT group=6835\r\n```\r\n\r\nNote that this is best-effort ordering: the groups are still sent on separate streams. The benefit of this approach is that another viewer could achieve lower latency by using the reverse order. This will let the player drop when the buffer is depleted, rather than buffer:\r\n\r\n```\r\n-> SUBSCRIBE start=-2 order=DESC\r\n<- SUBSCRIBE_OK latest=6835\r\n<- OBJECT group=6835\r\n<- OBJECT group=6834\r\n<- OBJECT group=6833\r\n```\r\n\r\nThe downside of this approach is that a relay has trouble knowing which variant of SUBSCRIBE to send upstream. I would advocate for always sending `order=DESC` if there's competing requests, as that's the more latency sensitive mode, but it's ultimately business logic.\r\n\r\nThe ability to deliver groups in order is one of the proposed features of FETCH, but I think we make it a flag on SUBSCRIBE instead. So is the ability to detect when a group is dropped, but that too is required for SUBSCRIBE.",
      "createdAt": "2024-03-18T21:33:58Z",
      "updatedAt": "2024-03-24T22:18:24Z",
      "closedAt": null,
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> We added #343 so the player would know to start playback at group 6833,\r\n\r\nThis isn't true always. #343 says the latest group the cache has seen. It may be 6833/ Again your example assumes the group numbers have certain property , which is fine and works for the case being made. But its an assumption though.",
          "createdAt": "2024-03-19T04:16:33Z",
          "updatedAt": "2024-03-19T04:16:33Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> We need some sort of GROUP_DROPPED message to signal that the player should skip over, much like a DISCONTINUITY in HLS. This has been touted as a feature of FETCH, but it's something we also need for SUBSCRIBE.\r\n \r\nFrom what i understand on Subscribe, Fetch proposal . The fetch proposal has a requirement to go find out gap info for the range requested.   Subscribe has no requirement to go find such information up the origin trees especially where there is an active subscription. \r\n\r\nAs i mentioned, the data plane needs to carry the information that is useful . I and few others have proposed having a explicit message or a tombstone group marks a gap might be useful regardless fetch/subscribe discussions as one is dealing with control plane and another is data plane. We need to spend sometime on what info we need in dataplane to identify the things that matter and also not overwhelm the system .\r\n",
          "createdAt": "2024-03-19T04:20:40Z",
          "updatedAt": "2024-03-19T04:21:56Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> So is the ability to detect when a group is dropped, but that too is required for SUBSCRIBE.\r\n\r\nAs mentioned above, this is not a subscribe vs fetch discussion, but rather identify what is needed in the data plane to identify any such information and how to do it.",
          "createdAt": "2024-03-19T04:25:33Z",
          "updatedAt": "2024-03-19T04:25:33Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment: \r\n\r\n> This isn't true always. #343 says the latest group the cache has seen. It may be 6833/ Again your example assumes the group numbers have certain property , which is fine and works for the case being made. But its an assumption though.\r\n\r\nFor the current draft, I assumed that if I ask for StartGroup=RelativePrev/2 and SubscribeOK says current group is 10 then I will receive groups starting from 8.  It's fine if the publisher wants to skip groups IDs, but the relay can't know that, so the only predictable relay behavior is to do simple math on group IDs, right?",
          "createdAt": "2024-03-19T04:29:16Z",
          "updatedAt": "2024-03-19T04:29:16Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> he bigger issue is prioritization. If the send_order is decreasing, which is required to allow players to skip over old content, then the buffer will fill _backwards_.\r\n\r\nI will try to stay at high level on the discussion point rather than trying to solve a certain way with a certain API.  These are the points of concern from what I understand \r\n\r\n- Subscribe with N different ways to ask for thigs\r\n\r\n\r\n\r\n> For the current draft, I assumed that if I ask for StartGroup=RelativePrev/2 and SubscribeOK says current group is 10 then I will receive groups starting from 8. It's fine if the publisher wants to skip groups IDs, but the relay can't know that, so the only predictable relay behavior is to do simple math on group IDs, right?\r\n\r\nRelays serves what it has. Relay can't make decision on application design , that's brittle. Catalog has more information on the applocation behavior and end points should use that to make a proper decision and not burden the relays. That along with dataplane markers will help identify dropped or missing things on the transmit path.",
          "createdAt": "2024-03-19T04:30:47Z",
          "updatedAt": "2024-03-19T04:32:41Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> The downside of this approach is that a relay has trouble knowing which variant of SUBSCRIBE to send upstream. I would advocate for always sending `order=DESC` if there's competing requests, as that's the more latency sensitive mode, but it's ultimately business logic.\r\n\r\nThis is pretty handwavy and might work for some applications and break for some other.  I gets murky pretty soon.  depending on what an upstream node does, it might end up creating HOL for everyone or live edge for everyone .",
          "createdAt": "2024-03-19T04:36:56Z",
          "updatedAt": "2024-03-19T06:48:15Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "To summarize , i will stay at high level of requirements and not use APIs as examples\r\n- Subscribe with relative offsets and  N ways to request things has many edges cases and issues as was presented by Ian . This makes it hard to reason especially when there are multiple hops and relays distributed across different latency paths.\r\n-  New subscribe has  clear scope and easy to reason about at any point in the system.\r\n- Fetch has a very clear scope with only absolute ranges and very easy to reason about. It has also very clear set of use-cases that is untangled from live media as presented at the Denver Interim\r\n\r\nWhat's is being asked ?\r\n- Identify gaps due to node dropping an entire group. Maybe good to have it in data plane and not tangled with subscribe vs fetch.\r\n- Influence delivery order between the groups( please not i am not using the word priority for a reason). By delivery order i mean oldest group first or newest first group.  I can see why this fits naturally with Fetch as each fetch is an independent request (end to end). For subscribe with dedup , this gets hairy pretty soon.\r\n\r\nOnce we agree on what's being asked, we can discuss ways to achieve the same.",
          "createdAt": "2024-03-19T04:46:25Z",
          "updatedAt": "2024-03-19T04:51:59Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> here's the assumption that SUBSCRIBE can be used once we're caught up to live but that's not true because of the aforementioned prioritization issue; the buffer will be filled backwards during congestion.\r\n\r\nthis isn't true. With nothing said, the objects are sent with new group first. So the receiver will get to live head first ,not the other way around.",
          "createdAt": "2024-03-19T04:54:34Z",
          "updatedAt": "2024-03-19T04:54:34Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> This is complicated, as it depends on an outside track to determine which group roughly corresponds to ~5s target latency for the initial FETCH. But it's actually wrong.\r\n\r\nI am not seeing a reason to use timeline track to achieve the functionality. One can subscribe \"last\" and get the group and do a fetch to older data based on that + catalog information, if needed. Not saying timeline track is good/bad idea, but the example is misleading IIUC.",
          "createdAt": "2024-03-19T04:57:20Z",
          "updatedAt": "2024-03-19T04:57:20Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> Unfortunately the player currently doesn't know about gaps, so it could block indefinitely waiting for 6834 (or any group)\r\n\r\nI am bit surprised to learn that players wont time out after certain wait time and mark things as missing. ",
          "createdAt": "2024-03-19T05:49:45Z",
          "updatedAt": "2024-03-19T05:49:45Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You lost me at the player does not know about gaps. It seems it is playing the data. ",
          "createdAt": "2024-03-19T06:41:19Z",
          "updatedAt": "2024-03-19T06:41:19Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> You lost me at the player does not know about gaps. It seems it is playing the data.\r\n\r\nWith group/object/datagram modes, media will arrive out of order. The goal of the reliable live player is to block awaiting every object to arrive to avoid skipping content. However, it's currently perfectly legal for the upstream to silently drop objects for any reason (ex. congestion). This will cause the reliable live player to deadlock; there's a gap in the media timestamps and it doesn't know that it will never be filled.\r\n\r\nOne solution is to use a stream per track to implicitly signal drops, assuming group/object IDs must be ascending within a stream. But this just doubles down on head-of-line blocking for everybody. The \"better\" solution is to tombstone, explicitly conveying the final group size.",
          "createdAt": "2024-03-19T06:58:38Z",
          "updatedAt": "2024-03-19T07:30:09Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> > We added #343 so the player would know to start playback at group 6833,\r\n> \r\n> This isn't true always. #343 says the latest group the cache has seen. It may be 6833/ Again your example assumes the group numbers have certain property , which is fine and works for the case being made. But its an assumption though.\r\n\r\nThe SUBSCRIBE_OK contains the largest value from cache _or_ the upstream SUBSCRIBE_OK. It was added for this explicit purpose.\r\n\r\nI don't understand what you mean about group numbers having a certain property: do you mean that they're sequential? The player needs to know definitively that groups exist since it blocks playback until each one is fully received. I don't see how else this is possible except for a separate timeline track?",
          "createdAt": "2024-03-19T07:04:37Z",
          "updatedAt": "2024-03-19T07:05:05Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> > This is complicated, as it depends on an outside track to determine which group roughly corresponds to ~5s target latency for the initial FETCH. But it's actually wrong.\r\n> \r\n> I am not seeing a reason to use timeline track to achieve the functionality. One can subscribe \"last\" and get the group and do a fetch to older data based on that + catalog information, if needed. Not saying timeline track is good/bad idea, but the example is misleading IIUC.\r\n\r\nThat's not good enough for higher target latencies. The \"last\" group will be from 0-2s ago in this example, but we want to start at least 5s back.",
          "createdAt": "2024-03-19T08:30:35Z",
          "updatedAt": "2024-03-19T08:30:49Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "@ianswett or @fluffy  can you give an example of how a reliable live player is supposed to use #421? Did I capture the message flow control and logic correctly?",
          "createdAt": "2024-03-19T08:33:30Z",
          "updatedAt": "2024-03-19T08:33:30Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> That's not good enough for higher target latencies. The \"last\" group will be from 0-2s ago in this example, but we want to start at least 5s back.\r\n\r\nCan you explain why that doesn't work ?",
          "createdAt": "2024-03-19T09:16:17Z",
          "updatedAt": "2024-03-19T09:16:17Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I have been thinking about use case of reliable live and the (common) requirement to start multiple groups back from the live head in a live stream. The current #421 proposal for SUBSCRIBE and FETCH does not allow this to happen. The reason is that the SUBSCRIBE will return the latest group and future groups and the SUBSCRIBE_OK will inform the client as to the latest group number. However, since group numbers are not predictable, even with that information the player cannot issue a FETCH for the preceding two groups. I can imagine three solutions to this problem:\r\n\r\n1. The player has to subscribe to a timeline track before it starts. This gives it information on the history of groups and then it can issue a FETCH and a SUBSCRIBE appropriately.The downsides of this approach are the extra RTT to start and the requirement for an application-level construct (the catalog) to join a transport-level track. At the moqt layer, we should have means to subscribe to a track that is independent of application features. \r\n2. We constrain GROUP numbers to increment by 1. This allows prior (and future) sequences to be predictable, by both clients and relays . It also implicitly conveys information about missing groups. Downside is we lose the flexibility in group numbering schemes. However, given the predictability that we gain, this may be a desirable trade-off. What is the primary use case for non-unitary increase and can that use-case be satisfied via some other mechanism?\r\n3. We make timelines a native part of moqt. For any track, any subscriber (end-clients and relays) can issue a control message asking for the timeline (i.e sequence of group numbers) of a track along with an optional parameter to limit the length of the response. For example TIMELINE (example.com/1234/bob/video , 5) would return the last 5 groups along with a timestamp to indicate when that snapshot was taken. A relay that had seen the last 5 groups due to an active subscription could give an immediate response. One that hadn't would have to make the same request upstream. A relay receiving multiple requests for 5,3,2 etc _could_ disambiguate them and could coalesce them in to a single TIMELINE request upstream. Real-time clients would never ask for a TIMELINE, because the SUBSCRIBE gives them what they need to start, but \"reliable live\" players would take advantage of it. \r\n",
          "createdAt": "2024-03-19T11:29:08Z",
          "updatedAt": "2024-03-19T11:29:08Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "You know, somehow it never occurred to me that group IDs were ordered but not sequential. It's a bit of a strange property and should be explicitly called out in the draft because object IDs are sequential.\r\n\r\nIs the idea to use DTS as the group ID? I imagine PTS doesn't work because B-frames.\r\n\r\nEither way, like Will said, I don't see how the reliable live case would work without sequences, or a timeline. The player needs some way to perform gap detection to know when to block awaiting network traffic. Timestamps aren't good enough because of encoder stalls; you can't assume a constant frame rate.\r\n\r\nThe application is allowed to use group sequences if it wants gap detection, like in this reliable live example. The relay doesn't have to do anything special.",
          "createdAt": "2024-03-19T15:48:53Z",
          "updatedAt": "2024-03-19T15:48:53Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> > That's not good enough for higher target latencies. The \"last\" group will be from 0-2s ago in this example, but we want to start at least 5s back.\r\n> \r\n> Can you explain why that doesn't work ?\r\n\r\nI think we're going in circles, because I'm trying. Can you prescribe how a reliable live application should work based on my examples? A diagram of the message flow would be super helpful.",
          "createdAt": "2024-03-19T15:59:36Z",
          "updatedAt": "2024-03-19T15:59:36Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "@ianswett brought up another approach to avoid a timeline. The player could SUBSCRIBE first and use the SUBSCRIBE_OK to FETCH backwards. This adds a round trip, much like the timeline, but it's definitely more generic and pretty neat. \r\n\r\n```\r\n-> SUBSCRIBE 480p\r\n<- SUBSCRIBE_OK start=6835\r\n-> FETCH 480p start=6833 end=6835\r\n<- FETCH_OK\r\n```\r\n\r\nHowever, it's not clear how to prioritize a concurrent FETCH and SUBSCRIBE; in this example we want the FETCH to be higher priority but I can envision use-cases where the opposite is true (ex. cache filling). I'm going to link #411 once again, I think we need a way to specify the priority in the SUBSCRIBE/FETCH message.\r\n\r\n```\r\n-> SUBSCRIBE 480p priority=4\r\n<- SUBSCRIBE_OK start=6835\r\n<- OBJECT group_id=6835 <part 1>\r\n-> FETCH 480p start=6833 end=6835 priority=3\r\n<- FETCH_OK\r\n<- OBJECT group_id=6833\r\n<- OBJECT group_id=6834\r\n<- OBJECT group_id=6835 <part 2>\r\n```\r\n\r\nBut this still falters after the initial FETCH, like the examples above. \r\n\r\n```\r\n-> SUBSCRIBE 480p\r\n-> FETCH start=6833 end=6835\r\n...\r\n<- OBJECT group_id=7012\r\n<- OBJECT group_id=7013\r\n...\r\n(congestion/dead zone)\r\n(player buffers, blocking on 7014)\r\n...\r\n<- OBJECT group_id=7016\r\n<- OBJECT group_id=7015\r\n<- OBJECT group_id=7014\r\n(player unbuffers)\r\n```\r\n\r\nThe send order causes the buffer to fill backwards, so we're stuck buffering for a longer time. We want the SUBSCRIBE to be in ascending order too, not just the FETCH.",
          "createdAt": "2024-03-19T16:05:58Z",
          "updatedAt": "2024-03-19T16:07:07Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> -> SUBSCRIBE 480p\r\n> <- SUBSCRIBE_OK start=6835\r\n> -> FETCH 480p start=6833 end=6835\r\n> <- FETCH_OK\r\n\r\nThis is the approach I was referring to in https://github.com/moq-wg/moq-transport/issues/419#issuecomment-2005762867",
          "createdAt": "2024-03-20T00:48:44Z",
          "updatedAt": "2024-03-20T00:48:44Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we are conflating multiple issues and trying to solve at the wrong layer, perhaps.  I do think this can be solved at the application layer and reflected in the way sender sets the priorities. ",
          "createdAt": "2024-03-20T00:54:20Z",
          "updatedAt": "2024-03-20T00:54:20Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I sent a write related to this to the list at \r\nhttps://mailarchive.ietf.org/arch/msg/moq/XZyzQiq67VaBwiTttvXJN7AYuFc/\r\n",
          "createdAt": "2024-03-24T22:18:23Z",
          "updatedAt": "2024-03-24T22:18:23Z"
        }
      ]
    },
    {
      "number": 420,
      "id": "I_kwDOG2Ho4M6CvOje",
      "title": "Explain security of 0-rtt setup ",
      "url": "https://github.com/moq-wg/moq-transport/issues/420",
      "state": "OPEN",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Note in the draft that raq QUIC can to 0-RTT moq setup but webtransport does not suppoir this. Add text to security section of why this is safe. ",
      "createdAt": "2024-03-18T21:49:13Z",
      "updatedAt": "2024-03-24T23:44:05Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Is it safe? I think replaying an ANNOUNCE message would be disruptive, taking down the existing broadcast.",
          "createdAt": "2024-03-18T22:57:43Z",
          "updatedAt": "2024-03-18T22:57:43Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "Agree with Luke. If you want a different application layer to use TLS 0-RTT then I'd expect an analysis along the lines of https://www.rfc-editor.org/rfc/rfc8470.html",
          "createdAt": "2024-03-18T23:37:45Z",
          "updatedAt": "2024-03-18T23:37:45Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I suspect the only message even eligible for this is CLIENT_SETUP which is probably safe but the analysis needs to be done. I'm assuming the client can not send any other messages before the SERVER_SETUP or whatever the response is the CLIENT_SETUP. I agree ANNOUCE is not safe. We just need to look at others. \r\n\r\nAnyways, agree we we need to do the analysis and put that in the security section. ",
          "createdAt": "2024-03-24T23:44:04Z",
          "updatedAt": "2024-03-24T23:44:04Z"
        }
      ]
    },
    {
      "number": 422,
      "id": "I_kwDOG2Ho4M6DXDeQ",
      "title": "Redundant object_id with stream per group",
      "url": "https://github.com/moq-wg/moq-transport/issues/422",
      "state": "OPEN",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Wire Format"
      ],
      "body": "When sending a stream per group, the object_id MUST increment by 1 based on my interpretation of the draft:\r\n\r\n> Object ID: The order of the object within the group. The IDs starts at 0, increasing sequentially for each object within the group.\r\n\r\nand\r\n\r\n> A relay MUST not reorder or drop objects received on a multi-object stream when forwarding to subscribers, unless it has application specific information.\r\n\r\nTechnically, the broadcaster could produce a stream that doesn't increment by one, but that doesn't make any sense and feels like a loophole to close. I much prefer things to be sequential and I don't want the application stuffing context into these relay-specific headers anyway.\r\n\r\nIf this makes sense, then we can optimize the wire encoding. **Proposed**:\r\n```\r\nSTREAM_HEADER_GROUP Message {\r\n  Subscribe ID (i),\r\n  Track Alias (i),\r\n  Group ID (i)\r\n  + First Object ID (i)\r\n  Object Send Order (i)\r\n}\r\n\r\n{\r\n  - Object ID (i),\r\n  Object Payload Length (i),\r\n  Object Payload (..),\r\n}\r\n```\r\n\r\nWe need to know the ID of the first object to handle subscriptions that start at a non-zero object. Otherwise, the receiver does +1 to compute the next object's ID. We'll save some bytes for larger groups but IMO more importantly, rule out some illegal encodings.",
      "createdAt": "2024-03-23T12:29:51Z",
      "updatedAt": "2024-03-30T15:16:18Z",
      "closedAt": null,
      "comments": [
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think sending object ID out of order may end up being common for scalable video codecs. We should talk about what the case is her before deciding what to do with this. ",
          "createdAt": "2024-03-24T23:38:34Z",
          "updatedAt": "2024-03-24T23:38:34Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think sending object ID out of order may end up being common for scalable video codecs. We should talk about what the case is her before deciding what to do with this.\r\n\r\nThat implies multiple streams per group, which I thought we ruled out. Otherwise you can't prioritize them separately, and all layers on the same priority is pretty pointless.\r\n\r\nI think SVC layers should be separate tracks. That way you can also subscribe to them independently. ",
          "createdAt": "2024-03-24T23:59:26Z",
          "updatedAt": "2024-03-25T15:59:59Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment:\r\n\r\nIs there a problem with this optimization if the publisher makes an object but doesn't send it for some reason?  I think I recall Jordi's implementation does that.",
          "createdAt": "2024-03-25T14:17:44Z",
          "updatedAt": "2024-03-25T14:17:44Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> Individual Comment:\r\n> \r\n> Is there a problem with this optimization if the publisher makes an object but doesn't send it for some reason? I think I recall Jordi's implementation does that.\r\n\r\nI think it comes down to the layering of  `object_id` and the intended usage.\r\n\r\nIn my opinion, `object_id` is for reassembly and gap detection when there's an object per stream/datagram. It's much like QUIC's `STREAM offset` in that regard, auto incrementing as each object is sent/received. It's also why my original warp draft didn't have a concept of object ID; everything was based on stream offsets.\r\n\r\nWith a sequential `object_id`, the MoQ transport library could feasibly implement a `next()` function to return objects in the original order. A relay could also use this to detect holes in the cache, for example issuing a FETCH based on a gap in `object_ids`. Both of these are automatic when using a group per stream so it's not necessary to encode `object_id`.\r\n\r\nThose are not possible if the application is allowed to choose `object_id` arbitrarily. I understand the desire to encode stuff like timestamps in group/object IDs, skipping them if the encoder falls behind, but I'm worried that we're mixing layers here.",
          "createdAt": "2024-03-25T19:54:18Z",
          "updatedAt": "2024-03-25T19:54:31Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not a fan of multiple strea per group but even with one stream,  if a relay had two objects, I would expect it to send the most important one first even if that was reversed the object id order. Of course that is wrapped up in object priority discussion about what object does the relay send next. ",
          "createdAt": "2024-03-26T22:08:24Z",
          "updatedAt": "2024-03-26T22:08:24Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'm not a fan of multiple strea per group but even with one stream, if a relay had two objects, I would expect it to send the most important one first even if that was reversed the object id order. Of course that is wrapped up in object priority discussion about what object does the relay send next.\r\n\r\nQUIC priorities work at the stream level so you can't really specify different priorities for objects within a stream. Technically you can, but the impact will be limited thanks to head-of-line blocking (akin to TCP prioritization). The current draft puts the priority in the stream header for this reason.\r\n\r\nWith a stream per group, all of the objects share the same priority and are delivered in order. The application explicitly uses this mode because it removes the need for a reassembly buffer within a group. You would use a stream/datagram per object if you want to deliver objects out of order and are willing to deal with the increased unreliability.\r\n\r\nChristian and I have talked about a possible 5th mode: a stream per group+layer for SVC. However, I think a track per layer is just a better abstraction. The catalog would contain the SVC layer details.",
          "createdAt": "2024-03-27T01:48:31Z",
          "updatedAt": "2024-03-27T01:50:30Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Every conversation seems to come back to priorities with deep confusions about how they work.  Yes quick priorities are per stream, however moq priorities are about a relay must decide what object to forward next when the congestion window opens. I don't think this has much to do with priorities, it is simply about if a producer has to send all the objects in order and I think there are lots of cases where we do not want to mandate that at the transport level, sure for lots of types of video it will me mandated at the application layer. ",
          "createdAt": "2024-03-30T15:16:17Z",
          "updatedAt": "2024-03-30T15:16:17Z"
        }
      ]
    },
    {
      "number": 423,
      "id": "I_kwDOG2Ho4M6D9GXA",
      "title": "Proposal: Gap Notifications",
      "url": "https://github.com/moq-wg/moq-transport/issues/423",
      "state": "OPEN",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Feel free to `s/SUBSCRIBE/FETCH/g` in your head.\r\n\r\n## Problem\r\nThe current draft is intentionally vague, but it allows objects to dropped in response to congestion. However, this ambiguity will cause issues for a few use-cases. \r\n\r\nConsider a subscriber that requests a range: \r\n\r\n```\r\n-> SUBSCRIBE start=4 end=7\r\n<- SUBSCRIBE_OK\r\n<- OBJECT group=7\r\n<- OBJECT group=6\r\n<- OBJECT group=4\r\n<- SUBSCRIBE_DONE\r\n```\r\n\r\nAt this moment, group=5 has been promised as part of the SUBSCRIBE but has not arrived yet. This is perfectly normal as objects may be sent over multiple streams which arrive out of order. A reliable live (#419) and VOD player will block playback as they anticipate group=5 to arrive any moment now and they do not want to skip content.\r\n\r\nHowever, if group=5 was dropped for any reason, potentially upstream, then playback will be stalled indefinitely. The only recourse is to set an arbitrary timeout and eventually assume loss, but this will cause additional buffering especially for reliable live.\r\n\r\nFurthermore, a relay that issues this request upstream will mark group=5 in its cache as pending. If a FETCH comes in for start=2 end=5, then the relay could FETCH start=2 end=3 upstream, as it can serve group=4 immediately and group=5 once it arrives at any moment.\r\n\r\nHowever, if group=5 was dropped due to a transient problem (ex. congestion), then the relay would be unaware that it could refetch group=5. Indicating that a dropped object can be retried would be very useful for patching up VODs, as the relay could refill these known holes after network recovery.\r\n\r\n\r\n## Proposal\r\n### 1. `SUBSCRIBE_OK` may contain a subset of the range requested in `SUBSCRIBE`.\r\nThe publisher commits to sending either an object or a drop notification within the specified range.\r\n\r\n```\r\nSUBSCRIBE_OK {\r\n    Subscribe ID (i),\r\n    Start Group (i)\r\n    Start Object (i)\r\n    End Group (i)\r\n    End Object (i)\r\n}\r\n```\r\n(some encoding finagling required)\r\n\r\nOtherwise, a relay that receives a `SUBSCRIBE start=0 end=10000` would be expected to send an object or dropped message for every value within the requested range, even if they left cache long ago.  For example, a DVR player requesting content from 45s ago, but everything older than 30s was already dropped from the cache.\r\n\r\nThis modified `SUBSCRIBE_OK` message tightens the bounds to prevent this.\r\n\r\n### 2. Add a `STREAM_DROPPED` that indicates drops within the `SUBSCRIBE_OK` range.\r\nThe publisher indicates that it cannot deliver the entire range as originally indicated, and one or more objects were dropped.\r\n\r\n```\r\nSTREAM_DROPPED Message {\r\n  Header (STREAM_HEADER_TRACK | STREAM_HEADER_GROUP | STREAM_HEADER_OBJECT),\r\n  Error Code (i)\r\n  Retryable (t)\r\n}\r\n```\r\n\r\nThe publisher sends this message when:\r\n* It drops objects by resetting the tail of a stream.\r\n* It drops objects by not creating a stream.\r\n* It receives a STREAM_DROPPED from upstream (relay only).\r\n\r\nThis will be a relatively rare message except during congestion, with the frequency depending on the stream mode. The entire header is sent for simplicity although some fields may be useless (ex. priority).\r\n\r\nThis message would be sent on a data stream (unidirectional) to avoid unnecessary head-of-line blocking on the control stream (bidirectional). This message is reliable, so it should not be sent on the same stream with potentially unreliable OBJECT messages.\r\n\r\nThere is no drop notification for datagrams, as the publisher does not know if they were dropped.",
      "createdAt": "2024-03-28T18:06:35Z",
      "updatedAt": "2024-03-29T14:32:01Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think this requires sequential `group_ids`, although it would be really nice. That way the MoqTransport library could then expose a reliable read function since it knows about the existence of every group/object at the MoqTransport layer. \r\n\r\nOtherwise the MoqTransport library has to expose these dropped notifications and let the application determine the existence of each group based on some pre-negotiated scheme (ew). For example, if the group_id is used to encode the PTS, then any reliable live or VOD would require a fixed group duration or some otherwise of signaling group existence (ex. timeline).",
          "createdAt": "2024-03-28T19:15:15Z",
          "updatedAt": "2024-03-28T19:18:49Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 on being on the data path. My thinking around this is to use a tomb stone object or group message. This will keep my relay and cache code agnostic to a dropped group or object. Since gap info is only needed for players to either to wait or not wait. \r\n\r\nSo my preference to be to keep on data plane and not use a new message type, but use the existing object definitoin or header definition to mark as something missing. \r\n\r\ni can propose something if it helps",
          "createdAt": "2024-03-28T23:34:36Z",
          "updatedAt": "2024-03-28T23:34:36Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "> i can propose something if it helps\r\n\r\nI'm curious to see what you have in mind and how it is different from this proposal.",
          "createdAt": "2024-03-28T23:49:00Z",
          "updatedAt": "2024-03-28T23:49:00Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> -> SUBSCRIBE start=4 end=7\r\n> <- SUBSCRIBE_OK\r\n> <- OBJECT group=7\r\n> <- OBJECT group=6\r\n> <- OBJECT group=4\r\n> <- SUBSCRIBE_DONE\r\n> \r\n> At this moment, group=5 has been promised as part of the SUBSCRIBE but has not arrived yet. \r\n\r\nBut here'n lies the problem. Since group numbers are non-sequential, as far as the relay is concerned there is **_no promise of group 5, as it may never have existed in the first place_**. 4,6,7 is a perfectly acceptable sequence of groups. **The only entities that know that 5 should exist are the original publisher and the final subscriber reading the catalog.** \r\n\r\nGaps can exist for two reasons: the original publisher did not create the object for some reason, or a relay had the object but then dropped it when forwarding under congestion:\r\n - If the publisher does not create the object, it can signal this by via either a control message (as proposed in this thread) or by creating a \"placeholder object\". This is an object which contains no playload, and in its header contains information about the error code and whether the object is retryable or not. The advantage of using the data plane to transmit this information is that this placeholder object (and the information about the drop) can be cached by every relay, whereas control messages are not cached and are not persistent. \r\n - If a relay drops an object due to congestion response, it should explicitly signal this via a control message. This allows the  receiver to not stall out waiting for the object and based on its application knowledge, it may re-request the object, or else move on. ",
          "createdAt": "2024-03-29T07:57:05Z",
          "updatedAt": "2024-03-29T07:57:05Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> But here'n lies the problem. Since group numbers are non-sequential, as far as the relay is concerned there is **_no promise of group 5, as it may never have existed in the first place_**. 4,6,7 is a perfectly acceptable sequence of groups. **The only entities that know that 5 should exist are the original publisher and the final subscriber reading the catalog.**\r\n\r\nI originally had a third proposal: \"sequential group_ids\". It would make the protocol significantly better but I don't think it's strictly required.\r\n\r\nThe application definitely needs to know if each group exists. It could do this via sequential groups or some other mechanism like a timeline. For example, suppose a simple scheme where there is a group every 2000 units for whatever reason. The player would wait an object or dropped notification for 0, 2000, 4000, 6000, etc.\r\n\r\nSuppose the relay gets a SUBSCRIBE for start=456 end=7000 or something dumb. It would send that upstream and forward any received objects or dropped messages. If it receives group 4000 but decides to drop it, then it would add its own dropped message. When it receives a SUBSCRIBE_DONE end=7000, then it forwards that too.\r\n\r\nThe relay doesn't actually care if group 1234 ever arrives; only the application knows or cares. But there's an argument for sequential groups so the relay can deterministically clean up any subscription state without waiting for an unsubscribe, because it doesn't know if there's still more data pending.",
          "createdAt": "2024-03-29T14:31:59Z",
          "updatedAt": "2024-03-29T14:31:59Z"
        }
      ]
    },
    {
      "number": 424,
      "id": "I_kwDOG2Ho4M6EFbJv",
      "title": "SUBSCRIBE_DONE and terminal state",
      "url": "https://github.com/moq-wg/moq-transport/issues/424",
      "state": "OPEN",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "**tl;dr** when does a MoqTransport subscriber signal SUBSCRIBE_DONE to the application or clean up subscription state?\r\n\r\nI ran into a bug when refactoring my relay to better support error conditions.\r\n\r\nFor subscriptions to the catalog or init track, my publisher would send a single OBJECT followed by an immediate SUBSCRIBE_DONE, since updates are (currently) not supported. It then removes the ID from the lookup table since this state is terminal.\r\n\r\nUpon receiving the SUBSCRIBE_DONE, my subscriber also removes the ID from the lookup table and returns the error to the application. However, this causes a race, as the OBJECTs in flight (on another stream) will be dropped since they reference a newly non-existent subscription. This occurs the vast majority of the time especially because the control stream is higher priority.\r\n\r\nSince SUBSCRIBE_DONE contains a final group/object, the intended behavior seems to be for the subscriber to delay until the final object is received.\r\n\r\nBut what if that object is dropped? What about the rest of the group? What happens to any other objects that might be queued (lower priority) or awaiting a retransmission?\r\n\r\nCould the subscriber wait until all objects within subscribe range are received instead? This seems useful especially for something like FETCH, however it's currently impossible for a few reasons:\r\n\r\n - group_ids are not sequential and there can be intentional gaps\r\n - objects can be dropped, causing gaps with a group \r\n - the latest object ID per group is unknown when using a stream per group.\r\n\r\nReliable live actually has the same exact issues. To generalize, its currently not possible to wait for all objects to arrive over the network.",
      "createdAt": "2024-03-29T21:27:51Z",
      "updatedAt": "2024-03-29T21:36:47Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOG2Ho4M4y3D-G",
      "title": "Address typographical errors",
      "url": "https://github.com/moq-wg/moq-transport/pull/1",
      "state": "MERGED",
      "author": "englishm-ietf",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Just a quick pass to fix some typos I noticed while reading.",
      "createdAt": "2022-02-15T13:51:26Z",
      "updatedAt": "2022-02-24T01:38:33Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "a8e121f901bf0f61a5b59fc56a913688d8b0ecdb",
      "headRepository": "englishm-ietf/warp-draft",
      "headRefName": "me/fix-typos",
      "headRefOid": "824496dbb7b8cb4eb8fc9eb6e2f81a146f2ec9f0",
      "closedAt": "2022-02-24T01:38:32Z",
      "mergedAt": "2022-02-24T01:38:32Z",
      "mergedBy": "kixelated",
      "mergeCommit": {
        "oid": "dfc827e547035aa0136bf37c2d14a9bbeee13f9e"
      },
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh I just noticed this, thanks!",
          "createdAt": "2022-02-24T01:38:27Z",
          "updatedAt": "2022-02-24T01:38:27Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 11,
      "id": "PR_kwDOG2Ho4M48SBje",
      "title": "Remove server-side ABR and elaborate more on renditions.",
      "url": "https://github.com/moq-wg/moq-transport/pull/11",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #6",
      "createdAt": "2022-07-28T21:56:05Z",
      "updatedAt": "2022-10-21T16:33:52Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "2881903c2b56fb36a596fdf9c0b97678d9bef84f",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "remove-server-abr",
      "headRefOid": "6c418eeb99a2807af61f446dba870aeeb2fb1b62",
      "closedAt": "2022-10-21T16:33:52Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 40,
      "id": "PR_kwDOG2Ho4M5C8143",
      "title": "First attempt to automatically build via Github pages.",
      "url": "https://github.com/moq-wg/moq-transport/pull/40",
      "state": "MERGED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-11-15T18:19:41Z",
      "updatedAt": "2022-11-15T18:23:43Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "776c530b843e5b2111605ade51967ac039ae7f6a",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ci",
      "headRefOid": "c76158fa6ca82f42a28bc7c31ac0e8f444fe14f4",
      "closedAt": "2022-11-15T18:23:38Z",
      "mergedAt": "2022-11-15T18:23:38Z",
      "mergedBy": "kixelated",
      "mergeCommit": {
        "oid": "bf2473ebeb4dc67003111df9275a390f42638f6c"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 41,
      "id": "PR_kwDOG2Ho4M5C83w3",
      "title": "Fix the pages automation.",
      "url": "https://github.com/moq-wg/moq-transport/pull/41",
      "state": "MERGED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-11-15T18:28:35Z",
      "updatedAt": "2022-11-15T19:13:18Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "bf2473ebeb4dc67003111df9275a390f42638f6c",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ci2",
      "headRefOid": "ffee6fb428d4bbfb0b83c0e78577f19c834bcb8c",
      "closedAt": "2022-11-15T19:13:15Z",
      "mergedAt": "2022-11-15T19:13:15Z",
      "mergedBy": "kixelated",
      "mergeCommit": {
        "oid": "6cabe0b3fce55c91ee485012f2f8ee7f79de39cc"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 43,
      "id": "PR_kwDOG2Ho4M5C-Bn2",
      "title": "Initial track PUBLISH/SUBSCRIBE",
      "url": "https://github.com/moq-wg/moq-transport/pull/43",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #13 #12 \r\n\r\nThis covers a few use-cases:\r\n\r\n1. The sender can advertise support for multiple codecs/containers.\r\n2. The receiver can request a specific track, for example: english or japannese audio.\r\n3. The receiver can request one of many tracks, so the server can perform ABR. For example: one of 480p, 720p, or 1080p.\r\n4. The receiver can request multiple tracks of the same rendition for multicast. For example: 480p, 720p, and 1080p.\r\n5. The receiver can request only tracks it supports. For example: no 1080p due to an unsupported profile.\r\n6. The receiver can seamlessly switch between enabled tracks. For example: send me the ad track while enabled, then switch to the content track.\r\n7. The sender can pre-emptively send tracks before the PLAY message, avoiding a round trip.\r\n\r\n\r\nThere's a few use-cases that aren't covered:\r\n\r\n1. The receiver wants to specify when the track should be switched (timestamp).\r\n2. The receiver wants to go rewind and request older content for a track.",
      "createdAt": "2022-11-15T23:42:03Z",
      "updatedAt": "2023-01-11T18:32:12Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "87d1085a5e3d7b2a3ec1b8bf8f06db1de4d2431b",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "tracks",
      "headRefOid": "fe01a0807d1eb6f5dd5d44d43877b40263c62439",
      "closedAt": "2023-01-11T18:32:12Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "The list of properties in `TRACK` is not exhaustive. For example, audio configuration (ex. `5.1`) is missing because I just don't know how to represent that.\r\n\r\nI like how simple `PLAY` is now, combining server-side ABR, client-side track selection, and the ability to PAUSE into a message with two fields.",
          "createdAt": "2022-11-16T18:00:29Z",
          "updatedAt": "2022-11-16T19:01:52Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I guess I have two thoughts regarding the track listing.\r\n\r\nFirst of all, I am not sure we should be describing media parameters ourselves. MP4 already has fields for video width and length (in fact, a typical moov atom would have those repeated at least twice), so ideally we would just defer to those, since otherwise we're stuck recording more and more media-specific fields, which is something deferring to an existing container was supposed to avoid.\r\n\r\nSecond, this is definitely the solution that covers the most complex scenario (delivery with multiple formats), but I would also like us to support the simplest case (which would probably be ingestion where all formats are fixed at the start), and then extend up to the complex solution where the use case requires it.  That probably means we should make adding tracks mid-session a negotiated extension.",
          "createdAt": "2022-11-17T00:03:39Z",
          "updatedAt": "2022-11-17T00:03:39Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> First of all, I am not sure we should be describing media parameters ourselves. MP4 already has fields for video width and length (in fact, a typical moov atom would have those repeated at least twice), so ideally we would just defer to those, since otherwise we're stuck recording more and more media-specific fields, which is something deferring to an existing container was supposed to avoid.\r\n\r\nThat's a great idea. We could combine init segments and `TRACK` message. The only change is that senders MUST push `INIT` messages for all tracks, whereas before it was only needed after `PLAY`.\r\n\r\n\r\nFor those not aware, here's an example of what an [MP4 parser](https://github.com/gpac/mp4box.js) will spit out. We're using fragmented MP4 in our case so any duration and totals are 0, but it's very similar.\r\n```\r\n{\r\n  \"duration\":360002,\r\n  \"timescale\":600,\r\n  \"isFragmented\":false,\r\n  \"isProgressive\":true,\r\n  \"hasIOD\":true,\r\n  \"brands\":[\"isom\"],\r\n  \"created\":\"2014-04-15T18:24:40.000Z\",\r\n  \"modified\":\"2014-04-15T18:24:40.000Z\",\r\n  \"tracks\":[\r\n    {\r\n\t  \"id\":2,\r\n\t  \"created\":\"2012-02-13T23:07:31.000Z\",\r\n\t  \"modified\":\"2014-04-16T12:22:56.000Z\",\r\n\t  \"movie_duration\":360000,\r\n\t  \"layer\":0,\r\n\t  \"alternate_group\":0,\r\n\t  \"volume\":0,\r\n\t  \"track_width\":320,\r\n\t  \"track_height\":180,\r\n\t  \"timescale\":25000,\r\n\t  \"duration\":15000000,\r\n\t  \"bitrate\":120000,\r\n\t  \"codec\":\"avc1.42c00d\",\r\n\t  \"video\":{\r\n\t    \"width\":320,\"height\":180\r\n\t  },\r\n\t  \"language\":\"und\",\r\n\t  \"nb_samples\":15000\r\n\t},\r\n\t{\r\n\t  \"id\":3,\r\n\t  \"created\":\"2012-09-12T11:14:57.000Z\",\r\n\t  \"modified\":\"2014-04-16T12:22:56.000Z\",\r\n\t  \"movie_duration\":360002,\r\n\t  \"layer\":0,\r\n\t  \"alternate_group\":0,\r\n\t  \"volume\":1,\r\n\t  \"track_width\":0,\r\n\t  \"track_height\":0,\r\n\t  \"timescale\":44100,\r\n\t  \"duration\":26460160,\r\n\t  \"bitrate\":60000,\r\n\t  \"codec\":\"mp4a.40.2\",\r\n\t  \"audio\":{\r\n\t    \"sample_rate\":44100,\r\n\t\t\"channel_count\":1,\r\n\t\t\"sample_size\":16\r\n\t  },\r\n\t  \"language\":\"und\",\r\n\t  \"nb_samples\":25840\r\n\t}\r\n  ]\r\n}\r\n```\r\n\r\nTechnically, MP4 already contains a `track_id`. We could reuse it, but I think it's prudent to make a new transport ID so it's easier to stitch without re-encoding.\r\n\r\nThe one downside with MP4 is that the INIT segment are relatively large (looks like 800 bytes for single h.264 track). I definitely agree that we should specify an alternative container in the future to tackle the large size.\r\n\r\n\r\n> Second, this is definitely the solution that covers the most complex scenario (delivery with multiple formats), but I would also like us to support the simplest case (which would probably be ingestion where all formats are fixed at the start), and then extend up to the complex solution where the use case requires it. That probably means we should make adding tracks mid-session a negotiated extension.\r\n\r\nI think we could expand upon the idea of \"default tracks\", where the sender just chooses what to push and possibly ignores any PLAY messages. This was mostly added to avoid a round-trip of latency but it also works for simple contribution scenarios where there's no choice involved.",
          "createdAt": "2022-11-17T18:13:36Z",
          "updatedAt": "2022-11-17T21:45:24Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "To be clear, I mean combining TRACK and init segments. The INIT message in your draft is something different.",
          "createdAt": "2022-11-17T20:08:04Z",
          "updatedAt": "2022-11-17T20:08:04Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks Luke for starting this PR and it is very helpful to get going.",
          "createdAt": "2022-11-18T04:53:16Z",
          "updatedAt": "2022-11-18T04:53:16Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Some open TODOs for this PR or the next one:\r\n\r\n1. Do we need acknowledgements?\r\n2. Add some timestamps so you can SUBSCRIBE to a relative or absolute timestamp.\r\n3. Signal when a track has ended.\r\n4. Naming.",
          "createdAt": "2022-11-23T23:05:30Z",
          "updatedAt": "2022-11-23T23:05:30Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed in favor of #63",
          "createdAt": "2023-01-11T18:32:05Z",
          "updatedAt": "2023-01-11T18:32:05Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5GckDQ",
          "commit": {
            "abbreviatedOid": "c6f4e61"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-16T05:17:08Z",
          "updatedAt": "2022-11-16T05:19:27Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "control stream?",
              "createdAt": "2022-11-16T05:17:08Z",
              "updatedAt": "2022-11-16T05:19:27Z"
            },
            {
              "originalPosition": 87,
              "body": "Should there be a way to request the sender to stop sending a given track?",
              "createdAt": "2022-11-16T05:18:58Z",
              "updatedAt": "2022-11-16T05:19:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Ggqtb",
          "commit": {
            "abbreviatedOid": "c6f4e61"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-16T16:52:12Z",
          "updatedAt": "2022-11-16T16:52:13Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "Absolutely; I was thinking you would send a PLAY with fewer (perhaps none) tracks.",
              "createdAt": "2022-11-16T16:52:12Z",
              "updatedAt": "2022-11-16T16:52:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5GgrDf",
          "commit": {
            "abbreviatedOid": "c6f4e61"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-16T16:53:05Z",
          "updatedAt": "2022-11-16T16:53:05Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "But after thinking about this some more, I think a PLAY/PAUSE message per track/group is just simpler to encode and less redundant.",
              "createdAt": "2022-11-16T16:53:05Z",
              "updatedAt": "2022-11-16T16:53:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5GgrQE",
          "commit": {
            "abbreviatedOid": "c6f4e61"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-16T16:53:36Z",
          "updatedAt": "2022-11-16T16:53:36Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "oops yeah",
              "createdAt": "2022-11-16T16:53:36Z",
              "updatedAt": "2022-11-16T16:53:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5GgrxU",
          "commit": {
            "abbreviatedOid": "c6f4e61"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-16T16:54:55Z",
          "updatedAt": "2022-11-16T16:54:55Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "I don't think this timestamp field is particularly well thought out. I think we remove it for now and specify something later once the use-cases are better explored.",
              "createdAt": "2022-11-16T16:54:55Z",
              "updatedAt": "2022-11-16T16:54:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Gpety",
          "commit": {
            "abbreviatedOid": "a7f7992"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-18T00:13:21Z",
          "updatedAt": "2022-11-18T00:13:21Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "PUBLISH could also work but it's a bit more awkward.",
              "createdAt": "2022-11-18T00:13:21Z",
              "updatedAt": "2022-11-18T00:13:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5GpfEH",
          "commit": {
            "abbreviatedOid": "a7f7992"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-18T00:14:37Z",
          "updatedAt": "2022-11-18T00:14:37Z",
          "comments": [
            {
              "originalPosition": 120,
              "body": "@suhasHere The idea is that a CDN can cache the payload using this path/URI. We might need a byte offset too. ",
              "createdAt": "2022-11-18T00:14:37Z",
              "updatedAt": "2022-11-18T00:14:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5GqEcA",
          "commit": {
            "abbreviatedOid": "a7f7992"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-18T04:23:49Z",
          "updatedAt": "2022-11-18T04:23:50Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "I know naming is always challenging .. SEGMENT  for video fits pretty well but for audio, it was bit confusing on the initial read.  Mainly the idea we want to get to is Segment/WarpMediaData (another name which might not be the best either ;) )  is made up of one more Media Frames \r\n\r\nOn the track, there are 2 scenarios\r\n1. Update track mid-session. For this use-case having Track as a standalone message makes sense\r\n2. Have the ability to request for sending media and advertise the tracks at the same time (like in ingest case). I was thinking of something like `PUBLISH_REQUEST` control message which has along with other things one or more tracks defined via TrackInfo/TrackDescriptors.\r\n\r\nI think we need both the standalone track message as well as something where you can embed your tracks as the first message on the control stream when you are about to start publishing.",
              "createdAt": "2022-11-18T04:23:49Z",
              "updatedAt": "2022-11-18T16:48:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5GqFiA",
          "commit": {
            "abbreviatedOid": "a7f7992"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-18T04:32:19Z",
          "updatedAt": "2022-11-18T04:32:19Z",
          "comments": [
            {
              "originalPosition": 149,
              "body": "On the Media Data Message/Segment Message, the requirement here is  we need to support a common wire encoding that works where a sender can operate in one or 2 modes \r\n\r\n- one frame per stream ( rush)\r\n   This needs one media frame per Segment Message.\r\n\r\n- one gop per stream (warp)\r\n    This needs one or more media frames depending on GOP length in a given Segment Message\r\n\r\nSay, if we had a encoding like\r\n```\r\nSegment {\r\n...\r\n... \r\nMediaFrame(...) ...  // list of one frame for rush, list of one or more frames for warp\r\n}\r\n```\r\n\r\nSomething like this can support both the cases. Also how the media frame/media object itself is represented on the wire is specific to the underlying container format (fmp4/something else).\r\n\r\n\r\nAlso, thinking through on the high level end to end flow for publishing that is common across ingest/distribution, I was thinking of  something like this \r\n\r\n- On the control stream, report its track information (textual and non-textual description of media format info .. ) and associated track Id (integer representation to be compact)\r\n- Start producing/publishing media data ( one frame per stream or gop per stream) for a given track. When doing this ensure that media frames are  tagged with the corresponding trackId. This will help relays/subscribers to correlate what frames belong to what tracks regardless of how QUIC streams gets used.\r\n- Along with that, add in the groupId/segmentId , so that relays/subscribers can know which frame belongs to which gop and thus can arrange to send to the decoder or forward it to subscribers appropriately.\r\n\r\nlove to hear your thoughts on the same\r\n",
              "createdAt": "2022-11-18T04:32:19Z",
              "updatedAt": "2022-11-18T16:16:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5GqGTs",
          "commit": {
            "abbreviatedOid": "a7f7992"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-18T04:38:26Z",
          "updatedAt": "2022-11-18T04:38:26Z",
          "comments": [
            {
              "originalPosition": 177,
              "body": "just trying to understand my vocabulary here. This is how I had it in my mind ( i might be totally off here, so please help me out )\r\n\r\n- Different renditions - HD H264 Video @ 30fps, SD AV1 video @60fps, 4K VP9 video @30fps,   opus audio @48khz ... [ I was thinking these as individually identified as tracks ]\r\n\r\n- One or more Group of pictures  (aka segments) .... [ I was thinking each of these as identified by a groupId/segmentId .. so equivalent to how CDN typically store the media segments like  1.mp4, 2.mp4  (so one file per gop) ]\r\n\r\n- Each GOP is made up of several media frames(I, P, ... ) .. [ I was thinking each such thing inside a GOP as MediaFrame/Media Object]\r\n\r\n\r\ncould you please help me understand if by group above, you mean the same or something different ?",
              "createdAt": "2022-11-18T04:38:26Z",
              "updatedAt": "2022-11-18T05:11:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Gue1u",
          "commit": {
            "abbreviatedOid": "a7f7992"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-18T18:21:15Z",
          "updatedAt": "2022-11-18T18:21:15Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "In HLS/DASH, they're known as audio segments. I don't think we need different terminology for similar concepts just because it's audio or video (ex. \"audio frame\" even though teeeechnically it's a \"group of samples\").",
              "createdAt": "2022-11-18T18:21:15Z",
              "updatedAt": "2022-11-18T18:21:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5GuhhI",
          "commit": {
            "abbreviatedOid": "a7f7992"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-18T18:29:36Z",
          "updatedAt": "2022-11-18T18:29:36Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "I'd like to optimize startup latency, and I think we can just send media without an explicit handshake.\r\n\r\nBroadcast use-case:\r\n```\r\nsender           receiver\r\n----------------------------\r\n CONNECT     -->\r\n TRACK (1)   -->\r\n TRACK (2)   -->\r\n SEGMENT (1) -->\r\n SEGMENT (2) -->\r\n             <--  CONNECT\r\n SEGMENT (1) -->\r\n SEGMENT (2) -->\r\n```\r\n\r\nViewer use-case:\r\n```\r\nsender           receiver\r\n----------------------------\r\n             <-- CONNECT\r\n CONNECT     -->\r\n TRACK (1)   -->\r\n TRACK (2)   -->\r\n TRACK (3)   -->\r\n TRACK (4)   -->\r\n SEGMENT (1) -->\r\n SEGMENT (2) -->\r\n             <--  PLAY (1,4)\r\n             <--  STOP_SENDING (2)\r\n SEGMENT (1) -->\r\n SEGMENT (4) -->\r\n```\r\n\r\nIn both cases we send media pre-emptively, instead of waiting for the receiver to receive TRACK and then issue a PLAY. If the sender guesses wrong, then receiver can issue a PLAY message and STOP_SENDING the segments it doesn't care about.",
              "createdAt": "2022-11-18T18:29:36Z",
              "updatedAt": "2022-11-18T19:02:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5GuirE",
          "commit": {
            "abbreviatedOid": "a7f7992"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-18T18:34:04Z",
          "updatedAt": "2022-11-18T18:34:04Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "If you require a handshake or acknowledgement for each subscription, it looks like:\r\n\r\nBroadcast use-case:\r\n```\r\nsender           receiver\r\n----------------------------\r\n CONNECT     -->\r\n TRACK (1)   -->\r\n TRACK (2)   -->\r\n             <--  CONNECT\r\n             <--  PLAY (1,2)\r\n SEGMENT (1) -->\r\n SEGMENT (2) -->\r\n```\r\n\r\nViewer use-case:\r\n```\r\nsender           receiver\r\n----------------------------\r\n             <-- CONNECT\r\n CONNECT     -->\r\n TRACK (1)   -->\r\n TRACK (2)   -->\r\n TRACK (3)   -->\r\n TRACK (4)   -->\r\n             <--  PLAY (1,4)\r\n SEGMENT (1) -->\r\n SEGMENT (4) -->\r\n```\r\n\r\nThe extra round-trip sucks for the broadcast scenario because it's obvious 99% of the time. ",
              "createdAt": "2022-11-18T18:34:04Z",
              "updatedAt": "2022-11-18T19:05:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Guvb0",
          "commit": {
            "abbreviatedOid": "a7f7992"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-18T19:20:35Z",
          "updatedAt": "2022-11-18T19:20:35Z",
          "comments": [
            {
              "originalPosition": 149,
              "body": "Yeah that encoding is pretty much how containers already work. \r\n\r\n* A fMP4 segment has any number of fragments, each of which can contain any number of frames.\r\n* A TS segment has any number of frames.",
              "createdAt": "2022-11-18T19:20:35Z",
              "updatedAt": "2022-11-18T19:20:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5GuwOP",
          "commit": {
            "abbreviatedOid": "a7f7992"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-18T19:23:35Z",
          "updatedAt": "2022-11-18T19:23:36Z",
          "comments": [
            {
              "originalPosition": 149,
              "body": "I don't think there's a compelling reason to hoist GoP/frame semantics into the transport layer. \r\n\r\nFor example, does a relay need to know if two segments are part of the same GoP? Not really; it just needs to know which order to deliver them. The decoder needs to know and that information is already contained in the container/codec bitstream.",
              "createdAt": "2022-11-18T19:23:35Z",
              "updatedAt": "2022-11-18T19:24:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Guzr7",
          "commit": {
            "abbreviatedOid": "a7f7992"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-18T19:35:01Z",
          "updatedAt": "2022-11-18T19:35:02Z",
          "comments": [
            {
              "originalPosition": 177,
              "body": "`rendition == track` when it's the same content, but different encoding\r\n`rendition != track` when it's different content.\r\n\r\nEach track consists of GoPs, which consist of segment(s), which consist of frame(s).\r\n\r\nI might just rename segment to \"fragment\" though, since that's really what it's called in CMAF.",
              "createdAt": "2022-11-18T19:35:01Z",
              "updatedAt": "2022-11-18T19:35:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5GvLzE",
          "commit": {
            "abbreviatedOid": "a7f7992"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-18T20:55:12Z",
          "updatedAt": "2022-11-18T20:57:56Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "Is SUBSCRIBE the same as PLAY then?",
              "createdAt": "2022-11-18T20:55:12Z",
              "updatedAt": "2022-11-18T20:57:56Z"
            },
            {
              "originalPosition": 203,
              "body": "I like the idea of explicitly cancelling them via STOP_SENDING",
              "createdAt": "2022-11-18T20:57:29Z",
              "updatedAt": "2022-11-18T20:57:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5GvOwI",
          "commit": {
            "abbreviatedOid": "4c6259a"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "General comment is that PUBLISH / SUBSCRIBE / SEGMENT are kind of misusing pub/sub terminology, right?  Shouldn't it be:\r\n\r\nADVERTISE / SUBSCRIBE / PUBLISH",
          "createdAt": "2022-11-18T21:00:38Z",
          "updatedAt": "2022-11-18T21:00:38Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5Gvj6C",
          "commit": {
            "abbreviatedOid": "a7f7992"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-18T22:14:18Z",
          "updatedAt": "2022-11-18T22:14:19Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "> General comment is that PUBLISH / SUBSCRIBE / SEGMENT are kind of misusing pub/sub terminology, right? Shouldn't it be:\r\n> \r\n> ADVERTISE / SUBSCRIBE / PUBLISH\r\n\r\nYeah, true. I wanted to capture some of the QUICR terminology, but I'm also afraid we're encroaching on generic verbs here. I much prefer the original crude media terms and can revert it if you guys agree.\r\n\r\nRTMP does [publish](https://rtmp.veriskope.com/docs/spec/#7226publish), [play](https://rtmp.veriskope.com/docs/spec/#7221play), [play2](https://rtmp.veriskope.com/docs/spec/#7222play2), [pause](https://rtmp.veriskope.com/docs/spec/#7228pause), [seek](https://rtmp.veriskope.com/docs/spec/#7227seek). It has separate messages for [audio](https://rtmp.veriskope.com/docs/spec/#714audio-message-8) and [video](https://rtmp.veriskope.com/docs/spec/#715video-message-9).\r\n\r\nI prefer:\r\n`TRACK` = `publish`\r\n`PLAY` = `play`, `play2`, `pause`\r\n`SEGMENT` = `video`, `audio`",
              "createdAt": "2022-11-18T22:14:18Z",
              "updatedAt": "2022-11-18T22:15:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Inoa-",
          "commit": {
            "abbreviatedOid": "fe01a08"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-12-14T22:39:14Z",
          "updatedAt": "2022-12-14T22:39:14Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5JBgHA",
          "commit": {
            "abbreviatedOid": "fe01a08"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This feels close, thanks for the work here.",
          "createdAt": "2022-12-20T21:01:39Z",
          "updatedAt": "2022-12-20T21:23:53Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Is it a rendition or a variant?",
              "createdAt": "2022-12-20T21:01:39Z",
              "updatedAt": "2022-12-20T21:23:53Z"
            },
            {
              "originalPosition": 102,
              "body": "So per the object model PR, a SEGMENT corresponds to a \"media object\"?  We can reconcile after one or both of them land.",
              "createdAt": "2022-12-20T21:04:31Z",
              "updatedAt": "2022-12-20T21:23:53Z"
            },
            {
              "originalPosition": 143,
              "body": "We don't need to add this now, but we'll probably want some language like QPACK has regarding flow control:\r\n\r\n1) leave the payload bytes in the flow control window until the deps are satisfied\r\n2) beware flow control deadlocks",
              "createdAt": "2022-12-20T21:06:27Z",
              "updatedAt": "2022-12-20T21:23:53Z"
            },
            {
              "originalPosition": 211,
              "body": "Probably clearer to just have UNSUBSCRIBE_TRACK?",
              "createdAt": "2022-12-20T21:08:26Z",
              "updatedAt": "2022-12-20T21:23:53Z"
            },
            {
              "originalPosition": 206,
              "body": "The object model says track IDs are unique within a broadcast, not necessarily globally unique, so I think you need to specify the broadcast URL also?",
              "createdAt": "2022-12-20T21:09:47Z",
              "updatedAt": "2022-12-20T21:23:53Z"
            },
            {
              "originalPosition": 216,
              "body": "Not all tracks are variants of each other, and it sounds like this mode of subscription would only be valid when that is true.  eg:\r\n\r\n```\r\nSUBSCRIBE_TRACK:\r\n  broadcast url: <x>\r\n  tracks: <1080p>, <480p>\r\nSUBSCRIBE_TRACK:\r\n  broadcast url: <x>\r\n  tracks: <japanese audio>\r\n```\r\n\r\nSo presumably the PUBLISH_TRACK message has some identifier which helps the receiver understand which tracks are variants (track group)?\r\n\r\nIs there more nuance to what needs to be specified for \"automatic sender-side variant selection based on congestion\" than is covered here?\r\n\r\nSince it sounds like some relay providers are not yet onboard for this feature, it is something that would need to be negotiated and fall back to client ABR selection?  Even if it is we might just want to note that for now and revisit it later.",
              "createdAt": "2022-12-20T21:15:41Z",
              "updatedAt": "2022-12-20T21:23:53Z"
            },
            {
              "originalPosition": 220,
              "body": "`MUST avoid sending` seems slightly ambiguous -- `MUST NOT send` perhaps?\r\n\r\nWhat about the broadcast case where the broadcaster is a transcoding relay feeding a CDN?",
              "createdAt": "2022-12-20T21:16:40Z",
              "updatedAt": "2022-12-20T21:23:53Z"
            },
            {
              "originalPosition": 225,
              "body": "This feels racy but I don't have an example yet.",
              "createdAt": "2022-12-20T21:18:42Z",
              "updatedAt": "2022-12-20T21:23:53Z"
            },
            {
              "originalPosition": 272,
              "body": "Are you referring to any SEGMENT messages sent with a matching Track ID?",
              "createdAt": "2022-12-20T21:20:02Z",
              "updatedAt": "2022-12-20T21:23:53Z"
            }
          ]
        }
      ]
    },
    {
      "number": 46,
      "id": "PR_kwDOG2Ho4M5DEdT9",
      "title": "Initial proposal for the wire format",
      "url": "https://github.com/moq-wg/moq-transport/pull/46",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This also merges HEADERS/SEGMENT and removes APP.",
      "createdAt": "2022-11-16T23:54:33Z",
      "updatedAt": "2022-11-19T00:10:45Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "6a627482577865bc342d8b41a830f2a44706b39c",
      "headRepository": "vasilvv/warp-draft",
      "headRefName": "wire-format",
      "headRefOid": "a32aedcbf3c4f5cbf1041f420c56fcb80a82e0aa",
      "closedAt": "2022-11-19T00:10:45Z",
      "mergedAt": "2022-11-19T00:10:45Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "87d1085a5e3d7b2a3ec1b8bf8f06db1de4d2431b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5GoasE",
          "commit": {
            "abbreviatedOid": "76bf705"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-17T20:04:52Z",
          "updatedAt": "2022-11-17T20:48:41Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "Which endpoint opens the bidirectional stream?",
              "createdAt": "2022-11-17T20:04:52Z",
              "updatedAt": "2022-11-17T20:48:41Z"
            },
            {
              "originalPosition": 117,
              "body": "Nit: can we call it `SETUP`, `SETTINGS`, or something else instead? \"init\" is somewhat used in media terminology already.",
              "createdAt": "2022-11-17T20:09:29Z",
              "updatedAt": "2022-11-17T20:48:41Z"
            },
            {
              "originalPosition": 240,
              "body": "This is fine for now but we do need a way to update/add/remove tracks, and then this will be redundant.",
              "createdAt": "2022-11-17T20:16:16Z",
              "updatedAt": "2022-11-17T20:48:41Z"
            },
            {
              "originalPosition": 54,
              "body": "There's also some latency considerations here. Do endpoints need to wait for the `INIT` message before transmitting media?",
              "createdAt": "2022-11-17T20:18:07Z",
              "updatedAt": "2022-11-17T20:48:41Z"
            },
            {
              "originalPosition": 163,
              "body": "I think we should define a concrete encoding rather than arbitrary key/value pairs. I'm not sure though; relays running different versions complicates things.",
              "createdAt": "2022-11-17T20:36:53Z",
              "updatedAt": "2022-11-17T20:48:41Z"
            },
            {
              "originalPosition": 137,
              "body": "What's the plan when relays running different versions are thrown into the mix? Implementations should not need to support every permutation of ingesting version x and distributing version y.\r\n\r\nI don't think there's much we can do except to be backwards-compatible, but I want to make sure we think about it.",
              "createdAt": "2022-11-17T20:40:08Z",
              "updatedAt": "2022-11-17T20:48:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Goy-z",
          "commit": {
            "abbreviatedOid": "76bf705"
          },
          "author": "jordicenzano",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "Great progress! Added a couple of comments",
          "createdAt": "2022-11-17T21:11:32Z",
          "updatedAt": "2022-11-17T22:32:24Z",
          "comments": [
            {
              "originalPosition": 163,
              "body": "Perhaps just specify some mandatory (or better standarized) headers?\r\nThis looks very simililar to HTTP headers to me, and those works very well",
              "createdAt": "2022-11-17T21:11:32Z",
              "updatedAt": "2022-11-17T22:32:59Z"
            },
            {
              "originalPosition": 251,
              "body": "Perhaps another name than TRACK? It seems that in this paper TRACK is \"A broadcast consists of one or more tracks. Each track has a type (audio, video, caption, etc)\". That reminds me more to \"rendition\" or \"lane\"\r\n\r\nSome food for thought:\r\n- How can we send (eficiently) separate audio/caption tracks (english, spanish, ...) with this proposal?",
              "createdAt": "2022-11-17T22:28:43Z",
              "updatedAt": "2022-11-17T22:32:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Gqb9X",
          "commit": {
            "abbreviatedOid": "76bf705"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "High level comment -- is it possible to transfer more than one piece of media at a time, each with their own TRACKs and SEGMENTs?",
          "createdAt": "2022-11-18T05:47:18Z",
          "updatedAt": "2022-11-18T20:49:22Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "HTTP/3 notably uses a pair of unidirectional streams for this kind of exchange, since it is not a request/response exchange.  However this actually is a request/response because it includes version negotiation.  We could say it's always OK to start sending v1 media messages but allow for canceling and resending in vN if the server later says it doesn't support v1?\r\n\r\nIf we're relying on WebTransport, we can't use alpn to negotiate version (ala H1/H2).",
              "createdAt": "2022-11-18T05:47:19Z",
              "updatedAt": "2022-11-18T20:49:22Z"
            },
            {
              "originalPosition": 98,
              "body": "It's a Capsule!  jk",
              "createdAt": "2022-11-18T05:49:33Z",
              "updatedAt": "2022-11-18T20:49:22Z"
            },
            {
              "originalPosition": 137,
              "body": "Version negotiation is hop-by-hop.  Imagine a chain of relays that goes from producer -> server -> cdn -> <fanout to a million clients>.  We should agree what a relay should do if it's asked to relay an extension that is not understood -- drop or forward?  Seems like there's space for both options?  Should there be feedback that goes back to the sender (hey, stop sending X message because no one is getting it)",
              "createdAt": "2022-11-18T18:08:08Z",
              "updatedAt": "2022-11-18T20:49:22Z"
            },
            {
              "originalPosition": 163,
              "body": "You do end up wasting some bytes to make it this arbitrary.  Depending on the length of a SEGMENT it might be meaningful?\r\n\r\nThe HTTP model has worked out ok for extensibility.  I assume that a relay MUST forward all headers even if it does not understand them?\r\n\r\nIs header name an ASCII string?  Lowercase?  What is a header value?",
              "createdAt": "2022-11-18T18:15:18Z",
              "updatedAt": "2022-11-18T20:49:22Z"
            },
            {
              "originalPosition": 220,
              "body": "s/parry/party/",
              "createdAt": "2022-11-18T20:47:09Z",
              "updatedAt": "2022-11-18T20:49:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Gvo2Q",
          "commit": {
            "abbreviatedOid": "76bf705"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-18T22:33:00Z",
          "updatedAt": "2022-11-18T22:33:00Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "Since we're relying on WebTransport, we could also put this information in the CONNECT request (headers?).",
              "createdAt": "2022-11-18T22:33:00Z",
              "updatedAt": "2022-11-18T22:33:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5GvpRg",
          "commit": {
            "abbreviatedOid": "76bf705"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-18T22:35:47Z",
          "updatedAt": "2022-11-18T22:35:48Z",
          "comments": [
            {
              "originalPosition": 163,
              "body": "Good point about the relay being able to forward headers it doesn't know about. ",
              "createdAt": "2022-11-18T22:35:48Z",
              "updatedAt": "2022-11-18T22:35:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5GvrC1",
          "commit": {
            "abbreviatedOid": "76bf705"
          },
          "author": "jordicenzano",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-18T22:44:39Z",
          "updatedAt": "2022-11-18T22:44:39Z",
          "comments": [
            {
              "originalPosition": 163,
              "body": "AFAIK the way CDNs are configured (for HTTP headers) is to whitelist  / blacklist the ones you want to forward (You could do `*`), that allows to send private info between origin and relays without leaking it to client (or saving bytes to the final client, the ones that matters most)",
              "createdAt": "2022-11-18T22:44:39Z",
              "updatedAt": "2022-11-18T22:44:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Gv2Gx",
          "commit": {
            "abbreviatedOid": "76bf705"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-18T23:50:26Z",
          "updatedAt": "2022-11-18T23:50:26Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "Clarified this is opened by the client. Regarding latency, as far as I can tell, there should be no difference for the delivery case, since the server can always speak as soon as it receives the version; I believe we do take an RTT for ingestion, unless we come up with something clever.",
              "createdAt": "2022-11-18T23:50:26Z",
              "updatedAt": "2022-11-18T23:50:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Gv2Ip",
          "commit": {
            "abbreviatedOid": "76bf705"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-18T23:50:34Z",
          "updatedAt": "2022-11-18T23:50:34Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "Renamed to SETUP.",
              "createdAt": "2022-11-18T23:50:34Z",
              "updatedAt": "2022-11-18T23:50:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Gv2M1",
          "commit": {
            "abbreviatedOid": "76bf705"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-18T23:50:54Z",
          "updatedAt": "2022-11-18T23:50:54Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "Removed until tracks PR lands.",
              "createdAt": "2022-11-18T23:50:54Z",
              "updatedAt": "2022-11-18T23:50:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Gv2cf",
          "commit": {
            "abbreviatedOid": "76bf705"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-18T23:53:22Z",
          "updatedAt": "2022-11-18T23:53:22Z",
          "comments": [
            {
              "originalPosition": 137,
              "body": "I imagine this works the same way as HTTP: the semantics of the objects involved are the same across any protocol versions (i.e. you have things with key-value headers attached), but the wire encoding is different, and it's up to relay to figure out how to translate one into another as necessary.",
              "createdAt": "2022-11-18T23:53:22Z",
              "updatedAt": "2022-11-18T23:53:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Gv2hx",
          "commit": {
            "abbreviatedOid": "76bf705"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-18T23:54:17Z",
          "updatedAt": "2022-11-18T23:54:17Z",
          "comments": [
            {
              "originalPosition": 251,
              "body": "I agree this might be confusing. I'm using \"track\" since that's what currently in the draft; we should probably discuss renaming this.",
              "createdAt": "2022-11-18T23:54:17Z",
              "updatedAt": "2022-11-18T23:54:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Gv2ok",
          "commit": {
            "abbreviatedOid": "76bf705"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-18T23:55:26Z",
          "updatedAt": "2022-11-18T23:55:27Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "Everything is TLV, except for the rare cases when there is no length and we then spend a year bikeshedding that.",
              "createdAt": "2022-11-18T23:55:27Z",
              "updatedAt": "2022-11-18T23:55:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Gv2vh",
          "commit": {
            "abbreviatedOid": "76bf705"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-18T23:56:35Z",
          "updatedAt": "2022-11-18T23:56:35Z",
          "comments": [
            {
              "originalPosition": 220,
              "body": "Resolved by removing this.",
              "createdAt": "2022-11-18T23:56:35Z",
              "updatedAt": "2022-11-18T23:56:35Z"
            }
          ]
        }
      ]
    },
    {
      "number": 47,
      "id": "PR_kwDOG2Ho4M5DPYum",
      "title": "Remove APP and merge HEADERS+SEGMENT",
      "url": "https://github.com/moq-wg/moq-transport/pull/47",
      "state": "MERGED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Shared between #43 and #46\r\n\r\nCloses #28",
      "createdAt": "2022-11-18T19:50:12Z",
      "updatedAt": "2022-11-18T20:29:54Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "dff86027365d7b3b20cf47284b4d61f206ba7bc7",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "merge-headers",
      "headRefOid": "ee0039dd5c046195277dadfecb31839fc66c78d5",
      "closedAt": "2022-11-18T20:29:51Z",
      "mergedAt": "2022-11-18T20:29:51Z",
      "mergedBy": "kixelated",
      "mergeCommit": {
        "oid": "a37ad2cde0d641fb5d6a81098a5be127a15c6641"
      },
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Merging because I don't think this is controversial, and we have two PRs doing the same thing.",
          "createdAt": "2022-11-18T20:29:45Z",
          "updatedAt": "2022-11-18T20:29:45Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 48,
      "id": "PR_kwDOG2Ho4M5DPcKx",
      "title": "Add containers section",
      "url": "https://github.com/moq-wg/moq-transport/pull/48",
      "state": "MERGED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Should be easy to define new containers now. Victor will make a registry in his PR (#46) instead of using the mimetype.",
      "createdAt": "2022-11-18T20:02:34Z",
      "updatedAt": "2022-11-18T20:34:02Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "a37ad2cde0d641fb5d6a81098a5be127a15c6641",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "containers",
      "headRefOid": "7efd4c59de3c5b61e910ac0cb0b6ecfa153099dc",
      "closedAt": "2022-11-18T20:33:59Z",
      "mergedAt": "2022-11-18T20:33:59Z",
      "mergedBy": "kixelated",
      "mergeCommit": {
        "oid": "e19008de89c98f9da36a7568f93a89a1641d6b0d"
      },
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Going to merge because this is just moving stuff around, and doesn't seem controversial. Although we might need to hash out naming: `container` versus `format`.",
          "createdAt": "2022-11-18T20:33:55Z",
          "updatedAt": "2022-11-18T20:33:55Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 55,
      "id": "PR_kwDOG2Ho4M5D19Co",
      "title": "Describe Warp object model",
      "url": "https://github.com/moq-wg/moq-transport/pull/55",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is mostly based on the discussions we had the last week, with some terminology choices slightly adjusted by myself to make things clearer. Terminology is very much subject to discussion and further refinement.",
      "createdAt": "2022-11-28T22:56:53Z",
      "updatedAt": "2022-12-27T13:26:57Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "87d1085a5e3d7b2a3ec1b8bf8f06db1de4d2431b",
      "headRepository": "vasilvv/warp-draft",
      "headRefName": "pubsub",
      "headRefOid": "279b081c5e13cea049eea7298798c5d5d457b7a0",
      "closedAt": "2022-12-27T13:26:57Z",
      "mergedAt": "2022-12-27T13:26:57Z",
      "mergedBy": "kixelated",
      "mergeCommit": {
        "oid": "9f42ea40b74d7d23464d6912c153736c13e5075f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5HVCTc",
          "commit": {
            "abbreviatedOid": "477c933"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Overall I like this direction",
          "createdAt": "2022-11-28T23:32:27Z",
          "updatedAt": "2022-11-28T23:37:25Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "How can an object be defined as a sequence of datagrams?  It seems like it's defined as a sequence of bytes that can be conveyed by streams or datagrams, the latter being ok if you don't mind holes in your media objects.  Or am I missing something?",
              "createdAt": "2022-11-28T23:32:27Z",
              "updatedAt": "2022-11-28T23:37:25Z"
            },
            {
              "originalPosition": 12,
              "body": "This may be a naming bikeshed, but `sequence number` implies a total ordering of media objects within a feed, but some of those media objects may overlap in timestamp for example.  Maybe just a media object identifier?",
              "createdAt": "2022-11-28T23:35:49Z",
              "updatedAt": "2022-11-28T23:37:25Z"
            },
            {
              "originalPosition": 12,
              "body": "Why a binary string as opposed to an ASCII string or a number?",
              "createdAt": "2022-11-28T23:36:19Z",
              "updatedAt": "2022-11-28T23:37:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5HVQpM",
          "commit": {
            "abbreviatedOid": "477c933"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-29T01:09:53Z",
          "updatedAt": "2022-11-29T01:09:53Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "A media object cannot have gaps. That's the point; it's the smallest decodable unit. If an object could be decoded out of order, then it should be split into multiple objects.\r\n\r\nMedia objects are fragmented into IP packets via QUIC streams, and potentially datagrams. Either way, the media object MUST be delivered to the decoder in order.\r\n\r\nI would say: \"A media object is an ordered bitstream that is transmitted relative to other objects, based on a delivery order and list of dependencies.\"\r\n\r\nPersonally I would call it a \"media fragment\". It's similar, but makes it clear that it's part of a whole, and it's used by CMAF.",
              "createdAt": "2022-11-29T01:09:53Z",
              "updatedAt": "2022-11-29T01:18:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5HVRmM",
          "commit": {
            "abbreviatedOid": "477c933"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-29T01:16:00Z",
          "updatedAt": "2022-11-29T01:16:01Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I really don't like the \"application-specific binary string\". We're obviously trying to encode data into this string with the intent that the broadcaster/viewer pre-negotiate an encoding structure, which just hurts interop.\r\n\r\nPut stuff like resolution/codec/etc into key/value pairs so generic implementations will work. Any assumptions about the structure of the feed URI is just flawed.",
              "createdAt": "2022-11-29T01:16:00Z",
              "updatedAt": "2022-11-29T01:24:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5HVSP7",
          "commit": {
            "abbreviatedOid": "477c933"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-29T01:20:23Z",
          "updatedAt": "2022-11-29T01:20:23Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I like the idea of pre-negotiating feed identifiers, kind of like how WebRTC can pre-negotiate data channel stream IDs to avoid a round trip. It doesn't mean the identifier needs to be a string label though.",
              "createdAt": "2022-11-29T01:20:23Z",
              "updatedAt": "2022-11-29T01:20:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5HVbg-",
          "commit": {
            "abbreviatedOid": "477c933"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-29T02:18:39Z",
          "updatedAt": "2022-11-29T02:18:39Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Well, track names can be really application specific, in a way that we may not foresee. For instance, if we're sending combined security camera footage, I can imagine it having video feeds called \"front door\", \"garage\", etc.",
              "createdAt": "2022-11-29T02:18:39Z",
              "updatedAt": "2022-11-29T02:18:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5HVbrt",
          "commit": {
            "abbreviatedOid": "477c933"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-29T02:19:47Z",
          "updatedAt": "2022-11-29T02:19:47Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Would you prefer integers? That works for me (though that does not necessarily preclude people encoding information into the identifiers).",
              "createdAt": "2022-11-29T02:19:47Z",
              "updatedAt": "2022-11-29T02:19:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5HVb8K",
          "commit": {
            "abbreviatedOid": "477c933"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-29T02:21:32Z",
          "updatedAt": "2022-11-29T02:21:33Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Could you elaborate? Typically, I would expect people to order their objects by DTS.",
              "createdAt": "2022-11-29T02:21:33Z",
              "updatedAt": "2022-11-29T02:21:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5HVeBO",
          "commit": {
            "abbreviatedOid": "477c933"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-29T02:36:12Z",
          "updatedAt": "2022-11-29T02:36:13Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Yeah, I don't think we need a sequence number, but rather a unique ID + presentation timestamp. The relay needs the presentation timestamp to seek backwards, but I'm not sure why it would ever need a sequence number.",
              "createdAt": "2022-11-29T02:36:12Z",
              "updatedAt": "2022-11-29T02:39:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5HcCBI",
          "commit": {
            "abbreviatedOid": "477c933"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-30T00:27:26Z",
          "updatedAt": "2022-11-30T00:27:26Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "What happens if a video and audio media object start at the same timestamp?",
              "createdAt": "2022-11-30T00:27:26Z",
              "updatedAt": "2022-11-30T00:27:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5HcH4V",
          "commit": {
            "abbreviatedOid": "477c933"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-30T01:05:39Z",
          "updatedAt": "2022-11-30T01:05:39Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Those would belong to a separate feed, and the sequence numbers are unique per feed.",
              "createdAt": "2022-11-30T01:05:39Z",
              "updatedAt": "2022-11-30T01:05:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Hg_kn",
          "commit": {
            "abbreviatedOid": "477c933"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-30T18:31:38Z",
          "updatedAt": "2022-11-30T18:31:39Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "My thought is that the receiver can ask for old media based on a timestamp and the relay would send any media objects greater than the timestamp. It's fine if there are duplicate timestamps.",
              "createdAt": "2022-11-30T18:31:38Z",
              "updatedAt": "2022-11-30T18:31:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5HhJWT",
          "commit": {
            "abbreviatedOid": "477c933"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-30T19:02:44Z",
          "updatedAt": "2022-11-30T19:02:44Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "So there's an assumption that a given feed doesn't have duplicate timestamps?  That's probably worth adding, as well as some examples?",
              "createdAt": "2022-11-30T19:02:44Z",
              "updatedAt": "2022-11-30T19:02:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Hn24q",
          "commit": {
            "abbreviatedOid": "477c933"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-01T20:34:16Z",
          "updatedAt": "2022-12-01T20:34:17Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Removed the mention of datagrams, at least for now.",
              "createdAt": "2022-12-01T20:34:16Z",
              "updatedAt": "2022-12-01T20:34:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Hn27z",
          "commit": {
            "abbreviatedOid": "477c933"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-01T20:34:28Z",
          "updatedAt": "2022-12-01T20:34:28Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Changed to just an \"object ID\".",
              "createdAt": "2022-12-01T20:34:28Z",
              "updatedAt": "2022-12-01T20:34:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Hn3NJ",
          "commit": {
            "abbreviatedOid": "477c933"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-01T20:35:30Z",
          "updatedAt": "2022-12-01T20:35:30Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Made track IDs opaque integers.",
              "createdAt": "2022-12-01T20:35:30Z",
              "updatedAt": "2022-12-01T20:35:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Hn3Ob",
          "commit": {
            "abbreviatedOid": "477c933"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-01T20:35:35Z",
          "updatedAt": "2022-12-01T20:35:35Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Made track IDs opaque integers.",
              "createdAt": "2022-12-01T20:35:35Z",
              "updatedAt": "2022-12-01T20:35:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Hn3RN",
          "commit": {
            "abbreviatedOid": "477c933"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-01T20:35:44Z",
          "updatedAt": "2022-12-01T20:35:45Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Made track IDs opaque integers.",
              "createdAt": "2022-12-01T20:35:45Z",
              "updatedAt": "2022-12-01T20:35:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5HoTWo",
          "commit": {
            "abbreviatedOid": "57ec90f"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Looks good with a couple minor questions.",
          "createdAt": "2022-12-01T22:28:22Z",
          "updatedAt": "2022-12-01T22:33:09Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "> fixed length\r\n\r\nRoberto just mentioned on list about appendable objects, so maybe this is fungible.  But for now we can keep it.",
              "createdAt": "2022-12-01T22:28:23Z",
              "updatedAt": "2022-12-01T22:33:09Z"
            },
            {
              "originalPosition": 6,
              "body": "> convey partial media chunks\r\n\r\nmedia objects?\r\n\r\nDoes this mean that a relay MUST be able to forward stream data out of order if a media object is sent on a QUIC stream?",
              "createdAt": "2022-12-01T22:30:34Z",
              "updatedAt": "2022-12-01T22:33:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5HodKP",
          "commit": {
            "abbreviatedOid": "57ec90f"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-01T23:18:26Z",
          "updatedAt": "2022-12-01T23:18:26Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I think that was regarding the manifests, not the objects themselves.",
              "createdAt": "2022-12-01T23:18:26Z",
              "updatedAt": "2022-12-01T23:18:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5HoeE9",
          "commit": {
            "abbreviatedOid": "57ec90f"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-01T23:23:40Z",
          "updatedAt": "2022-12-01T23:23:40Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "No, but if it has the first N bytes of the object, it has to forward them without waiting for the rest.  That way, even if you decide to send your media by sending a large GOP per object, as long as the encoder actually flushes frames onto the wire, they will relayed ASAP to the client.",
              "createdAt": "2022-12-01T23:23:40Z",
              "updatedAt": "2022-12-01T23:23:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Hofbt",
          "commit": {
            "abbreviatedOid": "57ec90f"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-01T23:31:59Z",
          "updatedAt": "2022-12-01T23:31:59Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "That thread also suggested manifests are themselves objects.  But if there's not consensus there, this is fine for now, and we can always change later.",
              "createdAt": "2022-12-01T23:31:59Z",
              "updatedAt": "2022-12-01T23:31:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5HogNJ",
          "commit": {
            "abbreviatedOid": "57ec90f"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-01T23:36:35Z",
          "updatedAt": "2022-12-01T23:36:36Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "> Warp media objects are not always expected to be fully available, and thus any relays have to be able to convey partial media chunks.\r\n\r\nShould we change this to say:\r\n\r\n> Warp media objects can be incomplete, and thus any relays have to be able to convey the beginning of a media object without waiting for the remainder.",
              "createdAt": "2022-12-01T23:36:35Z",
              "updatedAt": "2022-12-01T23:36:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5HogVx",
          "commit": {
            "abbreviatedOid": "57ec90f"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-01T23:37:28Z",
          "updatedAt": "2022-12-01T23:37:28Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Or maybe use the RFC 6919 normative \"REALLY OUGHT TO\"",
              "createdAt": "2022-12-01T23:37:28Z",
              "updatedAt": "2022-12-01T23:37:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Htlt2",
          "commit": {
            "abbreviatedOid": "d8bb2f5"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I like it; just some nits.",
          "createdAt": "2022-12-02T21:48:09Z",
          "updatedAt": "2022-12-02T22:11:20Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "> A media object is a sequence of bytes with a fixed length.\r\n\r\nJust like QUIC streams, the length is unknown until the end of the object. ex. an entire GoP could be a media object.",
              "createdAt": "2022-12-02T21:48:09Z",
              "updatedAt": "2022-12-02T22:11:20Z"
            },
            {
              "originalPosition": 12,
              "body": "I would remove the \"unsigned 62-bit integer\". The track ID and object ID just need to be unique; the actual encoding is irrelevant and subject to bikeshedding (ex. a string path).",
              "createdAt": "2022-12-02T21:49:49Z",
              "updatedAt": "2022-12-02T22:11:20Z"
            },
            {
              "originalPosition": 14,
              "body": "You completely lost me in the second half. \r\n\r\nI would frame pub/sub as the base behavior. Applications can avoid a round trip if they pre-negotiate the initial tracks/subscriptions. I don't think it should be an explicit mode; just a potential optimization.",
              "createdAt": "2022-12-02T21:57:58Z",
              "updatedAt": "2022-12-02T22:11:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Hty_4",
          "commit": {
            "abbreviatedOid": "57ec90f"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-02T22:17:45Z",
          "updatedAt": "2022-12-02T22:17:46Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I think what you need to say is that \"media objects are streams\". They don't have a known length upfront and they should not be buffered by relays.\r\n\r\nI'm fine with the word \"object\", but it definitely gives the wrong impression that the media is bounded. ",
              "createdAt": "2022-12-02T22:17:46Z",
              "updatedAt": "2022-12-02T22:17:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5HwHaR",
          "commit": {
            "abbreviatedOid": "d8bb2f5"
          },
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-05T02:44:25Z",
          "updatedAt": "2022-12-05T02:44:26Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Sometimes the length is known at the beginning. The media encoder produces the media object at once and then handle it to the transport, instead of writing the object into the stream?",
              "createdAt": "2022-12-05T02:44:26Z",
              "updatedAt": "2022-12-05T02:44:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Ie6b0",
          "commit": {
            "abbreviatedOid": "d8bb2f5"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-13T17:40:26Z",
          "updatedAt": "2022-12-13T17:40:27Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Removed.",
              "createdAt": "2022-12-13T17:40:26Z",
              "updatedAt": "2022-12-13T17:40:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Ie7AC",
          "commit": {
            "abbreviatedOid": "d8bb2f5"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-13T17:41:28Z",
          "updatedAt": "2022-12-13T17:41:28Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I removed the second sentence here.  What I'm trying to say is that in some cases, a peer can pub without prompting (ingestion), and in some cases it needs a sub request before sending anything (delivery).",
              "createdAt": "2022-12-13T17:41:28Z",
              "updatedAt": "2022-12-13T17:41:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5JBf0X",
          "commit": {
            "abbreviatedOid": "279b081"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2022-12-20T21:01:01Z",
          "updatedAt": "2022-12-20T21:01:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 56,
      "id": "PR_kwDOG2Ho4M5D2ETu",
      "title": "Terminology draft.",
      "url": "https://github.com/moq-wg/moq-transport/pull/56",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Still not sure if this is the best format, or if we should combine it with the other draft.\r\n\r\nThis is still very much WIP just to gather some feedback.",
      "createdAt": "2022-11-28T23:35:20Z",
      "updatedAt": "2022-12-05T20:10:31Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "87d1085a5e3d7b2a3ec1b8bf8f06db1de4d2431b",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "terminology",
      "headRefOid": "8c997ffb7b6996948d4e229598ddacc23eced8f7",
      "closedAt": "2022-12-05T20:10:30Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Would it be better to include the terminology and definitions in the base protocol draft or have a separate document?  This list is not so long that it would bloat the core protocol draft.  I think the downside might be that other drafts might have to include the protocol as an informative reference?",
          "createdAt": "2022-11-30T00:26:05Z",
          "updatedAt": "2022-11-30T00:26:05Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think this is useful by itself.",
          "createdAt": "2022-12-05T20:10:30Z",
          "updatedAt": "2022-12-05T20:10:30Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 59,
      "id": "PR_kwDOG2Ho4M5GdBrB",
      "title": "Correct minor grammatical omission in motivation",
      "url": "https://github.com/moq-wg/moq-transport/pull/59",
      "state": "MERGED",
      "author": "mgroshans",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-01-01T17:58:16Z",
      "updatedAt": "2023-01-03T20:20:45Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "9f42ea40b74d7d23464d6912c153736c13e5075f",
      "headRepository": "mgroshans/warp-draft",
      "headRefName": "patch-1",
      "headRefOid": "49cd2f93e3491d2cdfa79b8d34c3fdaee75b0cb1",
      "closedAt": "2023-01-03T20:20:10Z",
      "mergedAt": "2023-01-03T20:20:10Z",
      "mergedBy": "kixelated",
      "mergeCommit": {
        "oid": "8dc8e439ce7365dcc0d6d65d72e44a36debf8d0e"
      },
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks Michael",
          "createdAt": "2023-01-03T20:20:44Z",
          "updatedAt": "2023-01-03T20:20:44Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 60,
      "id": "PR_kwDOG2Ho4M5GkOzA",
      "title": "Upgrade ruby actions version.",
      "url": "https://github.com/moq-wg/moq-transport/pull/60",
      "state": "MERGED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-01-03T20:18:18Z",
      "updatedAt": "2023-01-03T20:29:19Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "9f42ea40b74d7d23464d6912c153736c13e5075f",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "actions",
      "headRefOid": "781aa7643ba2e3a930c1e75eeb3ae0c2a583c64b",
      "closedAt": "2023-01-03T20:29:16Z",
      "mergedAt": "2023-01-03T20:29:16Z",
      "mergedBy": "kixelated",
      "mergeCommit": {
        "oid": "7b09d878d2900d1067c4a63ae7a93fb37aba34e1"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 61,
      "id": "PR_kwDOG2Ho4M5GqK3z",
      "title": "s/segment/object",
      "url": "https://github.com/moq-wg/moq-transport/pull/61",
      "state": "MERGED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-01-04T21:32:35Z",
      "updatedAt": "2023-01-04T21:33:53Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "7b09d878d2900d1067c4a63ae7a93fb37aba34e1",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "object",
      "headRefOid": "4f8cecb25d8c2f56401ac81a8637cab651a10bdf",
      "closedAt": "2023-01-04T21:33:49Z",
      "mergedAt": "2023-01-04T21:33:49Z",
      "mergedBy": "kixelated",
      "mergeCommit": {
        "oid": "25bb264dcc7cad27501e461fcd5d8d2ad56f0ee9"
      },
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Going to merge because these are non-controversial naming changes. I still like \"fragments\" instead of \"objects\" but we'll litigate that in the WG.",
          "createdAt": "2023-01-04T21:33:45Z",
          "updatedAt": "2023-01-04T21:33:45Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 62,
      "id": "PR_kwDOG2Ho4M5HAWEv",
      "title": "Remove the dependency list.",
      "url": "https://github.com/moq-wg/moq-transport/pull/62",
      "state": "MERGED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It's difficult to populate and has fringe benefit at best. Let's revisit this in the future if it's actually useful.\r\n\r\nremoved after discussion in #58 ",
      "createdAt": "2023-01-09T18:48:50Z",
      "updatedAt": "2023-01-09T20:03:54Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "25bb264dcc7cad27501e461fcd5d8d2ad56f0ee9",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "no-dependencies",
      "headRefOid": "9c447afdca46175211180b916c273c61fb40edcb",
      "closedAt": "2023-01-09T20:02:39Z",
      "mergedAt": "2023-01-09T20:02:39Z",
      "mergedBy": "kixelated",
      "mergeCommit": {
        "oid": "e83949b3745badbe5065a557a5f758cf2e12ab47"
      },
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "To explain a bit more in-depth:\r\n\r\nThe goal of the dependency list was to give relays the information required to know which frames are droppable. This doesn't actually accomplish that goal since a frame could be a reference for a future frame. It's a lot of state to keep track of and it's unlikely to be used by even the smartest relay. It's much simpler and probably a better user experience for a relay to obey the delivery order.\r\n\r\nThe decoder doesn't actually need this list since the references are stored in the codec itself. A mismatch between the Warp dependency list and the codec reference list sounds pretty awful. Accurately populating the Warp dependency list requires parsing the codec bitstream, which is more difficult and expensive than it needs to be.\r\n\r\nThe only immediate use-case for the dependency list is to mark init segments. We could have a separate field for that, or put the init segment in the CATALOG itself. There's a possible use-case for SVC but again, a relay can just follow delivery order and the decoder _should_ be able to piece together dependencies from the underlying codec.",
          "createdAt": "2023-01-09T19:01:07Z",
          "updatedAt": "2023-01-09T20:01:41Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I went ahead and merged because I haven't heard a positive reaction to the dependency list. We can always make a PR to add it back and actually discuss the merits.",
          "createdAt": "2023-01-09T20:03:48Z",
          "updatedAt": "2023-01-09T20:03:48Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 63,
      "id": "PR_kwDOG2Ho4M5HA_CV",
      "title": "Basic catalog and track selection.",
      "url": "https://github.com/moq-wg/moq-transport/pull/63",
      "state": "MERGED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "No longer trying to boil the ocean. An endpoint advertises broadcasts and tracks via the CATALOG message and the other endpoint chooses the tracks via the SUBSCRIBE message.\r\n\r\nTODO:\r\n* Default tracks (avoid a round-trip)\r\n* Debate merging broadcast ID and URL.\r\n* Broadcast/track updates and termination.\r\n* Broadcast/track metadata.\r\n* Sender-side ABR.",
      "createdAt": "2023-01-09T21:01:28Z",
      "updatedAt": "2023-01-21T03:19:43Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "e83949b3745badbe5065a557a5f758cf2e12ab47",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "catalog",
      "headRefOid": "5babe2d60e342a5fb5b9117a04fdff4ae57e083a",
      "closedAt": "2023-01-19T00:33:45Z",
      "mergedAt": "2023-01-19T00:33:45Z",
      "mergedBy": "kixelated",
      "mergeCommit": {
        "oid": "2e4909c96471395a7f8263f80f8e97dfdfdc602c"
      },
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> Can the sender of a CATALOG also unilaterally begin sending OBJECT messages on tracks of its choice? How does the receiver stop those, or stop other track subscriptions it is no longer intereted in.\r\n\r\nNot yet. I decided to punt on that since it is an optimization with no clear approach. It could be as simple as adding a \"default\" flag to each track in the CATALOG, but it should be a separate PR.",
          "createdAt": "2023-01-09T22:53:41Z",
          "updatedAt": "2023-01-09T22:53:41Z"
        },
        {
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "body": "I think one thing is missing is some sort sequence diagram - it's hard to understand what as a sender or consumer I need to do",
          "createdAt": "2023-01-13T22:36:11Z",
          "updatedAt": "2023-01-13T22:36:11Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Okay, hitting the merge button and cutting a new draft before I go on vacation. Nothing is final!",
          "createdAt": "2023-01-19T00:33:34Z",
          "updatedAt": "2023-01-19T00:33:34Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5J_IPq",
          "commit": {
            "abbreviatedOid": "b9d1e5d"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "It's straightforward, which I like.  Can the sender of a CATALOG also unilaterally begin sending OBJECT messages on tracks of its choice?  How does the receiver stop those, or stop other track subscriptions it is no longer intereted in.",
          "createdAt": "2023-01-09T22:23:19Z",
          "updatedAt": "2023-01-09T22:31:07Z",
          "comments": [
            {
              "originalPosition": 184,
              "body": "Add a reference to where the semantics of these IDs are defined?",
              "createdAt": "2023-01-09T22:23:19Z",
              "updatedAt": "2023-01-09T22:31:07Z"
            },
            {
              "originalPosition": 195,
              "body": "Probably this should be before payload?",
              "createdAt": "2023-01-09T22:24:03Z",
              "updatedAt": "2023-01-09T22:31:07Z"
            },
            {
              "originalPosition": 220,
              "body": "Do we need to say more about the format or reference another RFC?",
              "createdAt": "2023-01-09T22:25:13Z",
              "updatedAt": "2023-01-09T22:31:07Z"
            },
            {
              "originalPosition": 112,
              "body": "Not for this PR but we should describe what to do when the message length doesn't match the actual length (eg: too many track IDs in a SUBSCRIBE)",
              "createdAt": "2023-01-09T22:28:16Z",
              "updatedAt": "2023-01-09T22:31:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5J_MSr",
          "commit": {
            "abbreviatedOid": "b9d1e5d"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-09T22:39:58Z",
          "updatedAt": "2023-01-09T22:39:58Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "I did that on purpose but I can switch it back. IMO we should define a `(b)` encoding format or something indicating a varint size followed by that many bytes.",
              "createdAt": "2023-01-09T22:39:58Z",
              "updatedAt": "2023-01-09T22:39:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5J_MmL",
          "commit": {
            "abbreviatedOid": "b9d1e5d"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-09T22:41:39Z",
          "updatedAt": "2023-01-09T22:41:39Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "Oh wow I didn't even see this. Yeah we shouldn't have this length because it's 1. redundant and 2. we don't always know the full size for each OBJECT.",
              "createdAt": "2023-01-09T22:41:39Z",
              "updatedAt": "2023-01-09T22:41:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5J_Nlt",
          "commit": {
            "abbreviatedOid": "b9d1e5d"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-09T22:46:29Z",
          "updatedAt": "2023-01-09T22:46:29Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "Plus I'm less of a fan of the specifications that always have a box length (ex. TLS, MP4). It's absolutely more difficult to encode and I'd rather go the QUIC style where versions/extensions are explicitly negotiated.",
              "createdAt": "2023-01-09T22:46:29Z",
              "updatedAt": "2023-01-09T22:46:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5J_NmH",
          "commit": {
            "abbreviatedOid": "b9d1e5d"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-09T22:46:31Z",
          "updatedAt": "2023-01-09T22:46:32Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "Where an explicit message length can help is for writing parsers that aren't smart enough to parse a partial message.  Eg: you buffer enough to read the type and length, then buffer up the the message payload, then parse.  That makes more sense for smaller messages or endpoints that will need the entire message anyways.  For OBJECT it doesn't make sense I agree.\r\n\r\nYou can remove the redundancy by removing the number of track IDs from subscribe, the parser just parses track IDs until it hits the message length (though there's still a case where the varint length exceeds the remaining message bytes).",
              "createdAt": "2023-01-09T22:46:32Z",
              "updatedAt": "2023-01-09T22:46:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5J_TvD",
          "commit": {
            "abbreviatedOid": "b9d1e5d"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-09T23:18:25Z",
          "updatedAt": "2023-01-09T23:18:25Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "Yeah, it makes decoding much easier, since you can skip unknown message type or extensions. \r\n\r\nBut it makes encoding harder because you either* have to allocate a new chunk of memory for each message, or you have to go back and populate the size afterwards. The later isn't really an option when you use varints since the number of bytes for the size is variable.\r\n\r\n\\* you can pre-compute the size before encoding but it's also gross",
              "createdAt": "2023-01-09T23:18:25Z",
              "updatedAt": "2023-01-09T23:22:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5J_Uiz",
          "commit": {
            "abbreviatedOid": "b9d1e5d"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-09T23:22:58Z",
          "updatedAt": "2023-01-09T23:22:59Z",
          "comments": [
            {
              "originalPosition": 220,
              "body": "No idea. I'll look for examples.",
              "createdAt": "2023-01-09T23:22:58Z",
              "updatedAt": "2023-01-09T23:22:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5J_c5r",
          "commit": {
            "abbreviatedOid": "b9d1e5d"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-10T00:18:09Z",
          "updatedAt": "2023-01-10T00:18:09Z",
          "comments": [
            {
              "originalPosition": 162,
              "body": "@wilaw From our discussion, one of your performance goals is to support OBJECT passthrough within a CDN. The idea was to use the broadcast URL if we know that its globally unique.\r\n\r\nBut what if you had an entry point into the video system that sanitizes the broadcast ID, making it unique within the video system? We could specify that broadcast ID SHOULD be random, and in the rare case of a collision, the ingest server could either have to rewrite each OBJECT or maybe ask that the client use a different broadcast ID?\r\n\r\nOnce that's been done, then the OBJECT can be passed through the rest of the video system without modification.\r\n\r\nThe bonus upside is that each viewer could then have a different broadcast URL while sharing the same OBJECT messages. This would be very useful for server-side ad insertion, for example, where user A and user B are watching two similar but distinct broadcasts. And of course it avoids sending the broadcast URL for each OBJECT, which will definitely add up when delivering small content like audio frames or datagrams.",
              "createdAt": "2023-01-10T00:18:09Z",
              "updatedAt": "2023-01-10T00:18:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5J_hqM",
          "commit": {
            "abbreviatedOid": "b9d1e5d"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-10T00:51:42Z",
          "updatedAt": "2023-01-10T00:51:42Z",
          "comments": [
            {
              "originalPosition": 258,
              "body": "@suhasHere as I understand, QUICR gives each object what is effectively a path so you can do wildcard subscriptions. So you could do stuff like:\r\n\r\n```\r\nSUBSCRIBE broadcastA/track*\r\nOBJECT broadcastA/track1/frame1\r\nOBJECT broadcastA/track1/frame2\r\nOBJECT broadcastA/track2/frame1\r\nOBJECT broadcastA/track2/frame2\r\n```\r\n\r\nOne thing I realized after talking to @wilaw is that subscribing to multiple broadcasts is probably out of scope. For example:\r\n\r\n```\r\nSUBSCRIBE broad* \r\nOBJECT broadcastA/track1/frame1\r\nOBJECT broadcastB/track1/frame1\r\nOBJECT broadcastC/track1/frame1\r\n<cdn implodes>\r\n```\r\n\r\nIt miiight be a valid use-case but it seems questionable. I think a subscription can be safely scoped to a single broadcast. This seems required to subscribe based on media timestamp or something else broadcast specific. It doesn't matter if it's `Broadcast ID` or `Broadcast URL`; either works so long as they match what's in the CATALOG.\r\n\r\nOkay so hypothetically we've got the broadcast ID as a separate field:\r\n\r\n```\r\nSUBSCRIBE broadcastA, track*\r\nOBJECT broadcastA, track1/frame1\r\nOBJECT broadcastA, track1/frame2\r\nOBJECT broadcastA, track2/frame1\r\nOBJECT broadcastA, track2/frame2\r\n```\r\n\r\nBut it doesn't actually make sense to use wildcards for the frame number. It's ambiguous, or doesn't give you enough control. For example:\r\n\r\n```\r\nSUBSCRIBE broadcastA, track1/frame2*\r\nOBJECT broadcastA, track1/frame2\r\nOBJECT broadcastA, track1/frame20\r\nOBJECT broadcastA, track1/frame21\r\n```\r\n\r\nIt's safe to say that you want something more expressive, probably related to timestamps. Wildcards miiight work with enough masks but probably not.\r\n\r\nOkay so let's split the object ID into its own field. It's \"object ID\" in this draft but it could reasonably be \"sequence\" or \"timestamp\".\r\n\r\n```\r\nSUBSCRIBE broadcastA, track1, frame > 23\r\nOBJECT broadcastA, track1, frame24\r\nOBJECT broadcastA, track1, frame25\r\n```\r\n\r\nNow we're left with track IDs as their own field and not part of a larger path. We certainly need the ability to select individual tracks (no wildcard) and I'd like to start with this functionality. We can always explore how to more efficiently subscribe to multiple tracks if enumerating them is too costly.",
              "createdAt": "2023-01-10T00:51:42Z",
              "updatedAt": "2023-01-10T00:54:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KEZzc",
          "commit": {
            "abbreviatedOid": "b9d1e5d"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-10T17:16:21Z",
          "updatedAt": "2023-01-10T17:16:21Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "> Yeah, it makes decoding much easier, since you can skip unknown message type or extensions.\r\n\r\nOh I forgot about this.  It's a killer feature we probably don't want to lose, except probably for OBJECT.  Once you send an OBJECT message, the length is \"til the end of the stream\".\r\n\r\n> it makes encoding harder\r\n\r\nThere's a few options.  You can serialize full-size (8 byte) varints every time.  You can also reserve the max varint size, serialize the frame, then prepend a the varint and set the start of the message offset accordingly.  Another trick we use is vectored writes, where we serialize the size and the payload in different buffers which are chained together.",
              "createdAt": "2023-01-10T17:16:21Z",
              "updatedAt": "2023-01-10T17:16:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KF_eG",
          "commit": {
            "abbreviatedOid": "b9d1e5d"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-10T22:54:49Z",
          "updatedAt": "2023-01-10T22:54:50Z",
          "comments": [
            {
              "originalPosition": 162,
              "body": "> But what if you had an entry point into the video system that sanitizes the broadcast ID, making it unique within the video system\r\n\r\nThat assumes the hypothetical entry point as visibility across the entire system. Uniqueness doesn't only have to be assured within the receiving relay but all the way through to the final edge node. That isn't practical in a multi-vendor system, for example, two CDNs stacked on top of one another with the first acting as an origin shield. It also isn't practical in a single vendor global distributed system either without some centralized registry of active broadcastIDs, which introduces its own problems of time-to-resolution and consistency.  I suspect systems would resort to a hierarchical naming scheme to ensure uniqueness. Throw in a vendor ID on top of that and now you are back to a GUID. \r\n\r\n> in the rare case of a collision, the ingest server could either have to rewrite each OBJECT or maybe ask that the client use a different broadcast ID?\r\nWe really don't want relays to have rewrite objects - that will lower their throughput. Asking the publisher to use a different broadcast ID would be preferred, but then you are back to the problems described above in ensuring uniqueness. \r\n\r\nStepping back, a globally unique identifier in each object simplifies object routing, caching and forwarding across heterogeneous systems. Its primary penalty is the size. I would contend that with GOP-per-object and frame-per-object at video bitrates this size is workable. The worst (and perhaps the design case)  is low bitrate audio streams and datagrams, in which the object size will be  in the order of 1500 bytes, in which case the 128 bit ID represents a ~8.5% reduction in the payload. So you need additional datagrams to transmit each sample/frame. Not ideal, but still workable according to Cisco as proponents of datagram-per-object that I have discussed this with. I have separate concerns however about routing these small objects at scale. It would be good to do some testing and establish performance benchmarks on a prototype. \r\n\r\n>The bonus upside is that each viewer could then have a different broadcast URL while sharing the same OBJECT messages.\r\n\r\nI think this same decoupling can be achieved by having a catalog with multiple subscription options and allowing the  subscriptions to be absolute paths rather than only relative ones.  In the example below are two catalogs. Each refers to the same primary sports streams, however both inject a custom subscription for ad content. \r\n\r\n```\r\nCatalog  customcatalogserver.com/streamid12345/unique-userID1111\r\nSubscription #0: yourverybestadcontent.com/customadcontent/1234\r\nSubscription #1: primarycontent.com/sports/football/game23/1080\r\nSubscription #1: primarycontent.com/sports/football/game23/720\r\n```\r\n\r\n```\r\nCatalog  customcatalogserver.com/streamid12345/unique-userID2222\r\nSubscription #0: yourverybestadcontent.com/customadcontent/5678\r\nSubscription #1: primarycontent.com/sports/football/game23/1080\r\nSubscription #1: primarycontent.com/sports/football/game23/720\r\n```\r\n\r\nThis would be efficient for the relay as it would retrieve and store the primary content only once. \r\n\r\nI think ads may be better served as VOD assets downloaded via subscription ahead of an insertion point, with the insertion point triggered in-stream, but that's probably commentary for a different PR. ",
              "createdAt": "2023-01-10T22:54:49Z",
              "updatedAt": "2023-01-10T22:54:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KGPjB",
          "commit": {
            "abbreviatedOid": "b9d1e5d"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-11T00:37:42Z",
          "updatedAt": "2023-01-11T00:37:42Z",
          "comments": [
            {
              "originalPosition": 258,
              "body": "> One thing I realized after talking to @wilaw is that subscribing to multiple broadcasts is probably out of scope.\r\n\r\nActually it should work. Assuming there is no semantic meaning in the store around the '/' boundary, it's not harder to do a match against\r\n\r\n`SUBSCRIBE broad* `\r\n\r\nthan is is against\r\n\r\n`SUBSCRIBE broadcastA/*`\r\n\r\nConceivably you could do \r\n\r\n`SUBSCRIBE *`\r\n\r\nand get everything. \r\n\r\nWhat we were talking about was slightly different and related to cache entry stores and serving archival content in sequence. A HTTP cache data structure is highly optimized to return a quick answer to \"is the object described by this key available?\" . As a consequence it is expensive to search across a cache and say \"find me the last keyframe in this sequence of objects\". The application was a player wanting to join a subscription from the prior GOP boundary. I think relay caches should be structured differently from HTTP caches. They could hold some form of linked list, as invariably we went to retrieve objects in a sequence. We should also store a simple flag with each object, indicating whether it is a \"starting\" object or not. We could then retrieve \"broadcastA/track1/* starting from the last flagged keyframe\". The relay would serve everything in its cache matching that request and then all future objects satisfying that filter. \r\n\r\n\r\n",
              "createdAt": "2023-01-11T00:37:42Z",
              "updatedAt": "2023-01-11T00:37:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KLlLI",
          "commit": {
            "abbreviatedOid": "b9d1e5d"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-11T20:15:26Z",
          "updatedAt": "2023-01-11T20:15:27Z",
          "comments": [
            {
              "originalPosition": 162,
              "body": "How about we merge ID and URL? I think they're both the same thing conceptually, except a varint has limited space so any encoding hierarchy is far more primitive. A variable-length ID is definitely required and I'm fine using a formatted string (URL).\r\n\r\n\r\n> > But what if you had an entry point into the video system that sanitizes the broadcast ID, making it unique within the video system\r\n> \r\n> That assumes the hypothetical entry point as visibility across the entire system. Uniqueness doesn't only have to be assured within the receiving relay but all the way through to the final edge node. That isn't practical in a multi-vendor system, for example, two CDNs stacked on top of one another with the first acting as an origin shield. It also isn't practical in a single vendor global distributed system either without some centralized registry of active broadcastIDs, which introduces its own problems of time-to-resolution and consistency. I suspect systems would resort to a hierarchical naming scheme to ensure uniqueness. Throw in a vendor ID on top of that and now you are back to a GUID.\r\n\r\nYou always need _some_ authority to ensure that an ID is unique. For example, if I push `moq://kixelated.io/12345` to two different hosts, one of them is going to have to say \"no\".\r\n\r\nA global database is the easiest way of doing this but like you mentioned, it doesn't scale. Generally you shard the ID into multiple authorities. The client doesn't know about this sharding scheme, so it needs to be told which ID to use by some authority. That could be built into the protocol, similar to how connection IDs work in QUIC: the client chooses one at random and then could get told by the server to use a different ID.\r\n\r\nBut things get hairy when multiple vendors are involved because now there are multiple authorities. A broadcast ID chosen for the Twitch system won't be applicable for the Akamai system unless there is a standardized scheme. That's possible, but I think not allowing vendors to rewrite the ID would be a constraint, not a benefit.\r\n\r\nAll I'm trying to say is that relay accepting connections from 3rd parties should be prepared to verify the broadcast ID/URL. If there's a collision, the relay either needs to rewrite the ID or reject the broadcast outright. \r\n\r\n> > in the rare case of a collision, the ingest server could either have to rewrite each OBJECT or maybe ask that the client use a different broadcast ID?\r\n> > We really don't want relays to have rewrite objects - that will lower their throughput. Asking the publisher to use a different broadcast ID would be preferred, but then you are back to the problems described above in ensuring uniqueness.\r\n> \r\n> Stepping back, a globally unique identifier in each object simplifies object routing, caching and forwarding across heterogeneous systems. Its primary penalty is the size. I would contend that with GOP-per-object and frame-per-object at video bitrates this size is workable. The worst (and perhaps the design case) is low bitrate audio streams and datagrams, in which the object size will be in the order of 1500 bytes, in which case the 128 bit ID represents a ~8.5% reduction in the payload. So you need additional datagrams to transmit each sample/frame. Not ideal, but still workable according to Cisco as proponents of datagram-per-object that I have discussed this with. I have separate concerns however about routing these small objects at scale. It would be good to do some testing and establish performance benchmarks on a prototype.\r\n\r\nYeah, I think the play is to let the ID be variable length like a QUIC connection ID. When OBS connects to Twitch it could use a fully qualified URL (~50 bytes), but internally we could rewrite it to some much smaller encoding if the overhead is a problem. In our system, I imagine the $ cost of transit would be greater than CPU cost of rewriting the ID at origin.\r\n\r\nAt the end of the day, the ID only needs to be unique within the session. It's a bonus if there's additional information encoded in it, but that requires some pre-negotiated scheme. Maybe to stream to Twitch/Akamai a broadcaster would have to use a vendor-specific scheme. But without a standardized scheme, a generic client like OBS should be able to use any broadcast ID.\r\n\r\n> > The bonus upside is that each viewer could then have a different broadcast URL while sharing the same OBJECT messages.\r\n> \r\n> I think this same decoupling can be achieved by having a catalog with multiple subscription options and allowing the subscriptions to be absolute paths rather than only relative ones. In the example below are two catalogs. Each refers to the same primary sports streams, however both inject a custom subscription for ad content.\r\n> \r\n> ```\r\n> Catalog  customcatalogserver.com/streamid12345/unique-userID1111\r\n> Subscription #0: yourverybestadcontent.com/customadcontent/1234\r\n> Subscription #1: primarycontent.com/sports/football/game23/1080\r\n> Subscription #1: primarycontent.com/sports/football/game23/720\r\n> ```\r\n> \r\n> ```\r\n> Catalog  customcatalogserver.com/streamid12345/unique-userID2222\r\n> Subscription #0: yourverybestadcontent.com/customadcontent/5678\r\n> Subscription #1: primarycontent.com/sports/football/game23/1080\r\n> Subscription #1: primarycontent.com/sports/football/game23/720\r\n> ```\r\n> \r\n> This would be efficient for the relay as it would retrieve and store the primary content only once.\r\n> \r\n> I think ads may be better served as VOD assets downloaded via subscription ahead of an insertion point, with the insertion point triggered in-stream, but that's probably commentary for a different PR.\r\n\r\nSeems fine. That would mean giving each track a URL and removing the broadcast ID/URL from the OBJECT message. Or adding another layer to the heirarchy. ",
              "createdAt": "2023-01-11T20:15:26Z",
              "updatedAt": "2023-01-11T20:20:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KLzQf",
          "commit": {
            "abbreviatedOid": "b9d1e5d"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-11T21:01:08Z",
          "updatedAt": "2023-01-11T21:01:08Z",
          "comments": [
            {
              "originalPosition": 258,
              "body": "> > One thing I realized after talking to @wilaw is that subscribing to multiple broadcasts is probably out of scope.\r\n> \r\n> Actually it should work. Assuming there is no semantic meaning in the store around the '/' boundary, it's not harder to do a match against\r\n> \r\n> `SUBSCRIBE broad* `\r\n> \r\n> than is is against\r\n> \r\n> `SUBSCRIBE broadcastA/*`\r\n> \r\n> Conceivably you could do\r\n> \r\n> `SUBSCRIBE *`\r\n> \r\n> and get everything.\r\n\r\n\r\nI envision that relays will conditionally subscribe to broadcasts. We've got thousands of edge nodes that do NOT want a copy of every broadcast. It's too much data for any individual host so we coalesce traffic based on the broadcast. A relay/edge would SUBSCRIBE only to specific broadcasts based on demand. \r\n\r\nIt might be possible to create a sharded URL scheme so a relay/edge would only need to SUBSCRIBE once on startup using a wildcard but I highly doubt it. There's just too many variables involved even for the most expressive rule engine.\r\n\r\n`SUBSCRIBE *` seems fine for a video system that only serves extremely popular broadcasts, like the superbowl or something, where the data needs to get replicated to every host. But it's barely an optimization compared to `SUBSCRIBE superbowl`.\r\n\r\nI think subscribing to all tracks within a broadcast has more merit. It effectively pre-warms the cache, since there's a high likelihood that someone watching a specific broadcast will change tracks. I understand the hesitation to group objects based on broadcast, but even with a generic path you're going to do that anyway (hence the wildcard).\r\n\r\n> What we were talking about was slightly different and related to cache entry stores and serving archival content in sequence. A HTTP cache data structure is highly optimized to return a quick answer to \"is the object described by this key available?\" . As a consequence it is expensive to search across a cache and say \"find me the last keyframe in this sequence of objects\". The application was a player wanting to join a subscription from the prior GOP boundary. I think relay caches should be structured differently from HTTP caches. They could hold some form of linked list, as invariably we went to retrieve objects in a sequence. We should also store a simple flag with each object, indicating whether it is a \"starting\" object or not. We could then retrieve \"broadcastA/track1/* starting from the last flagged keyframe\". The relay would serve everything in its cache matching that request and then all future objects satisfying that filter.\r\n\r\nI alluded to this earlier, but \"give me the most recent key frame\" is probably not good enough. A higher latency system like Twitch will want \"give me the last 4 seconds of media\" which might be multiple GoPs (the client doesn't know). There's also a desire to support DVR, which means \"give me media starting at 1:23\".\r\n\r\nThat's a compelling reason to group by broadcast, as all tracks within a broadcast are timestamp aligned. The SUBSCRIBE message could then contain a presentation timestamp, potentially relative to the start/end of the broadcast.",
              "createdAt": "2023-01-11T21:01:08Z",
              "updatedAt": "2023-01-11T21:01:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KL02u",
          "commit": {
            "abbreviatedOid": "b9d1e5d"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-11T21:07:18Z",
          "updatedAt": "2023-01-11T21:07:19Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "I'm thinking we separate control streams from data streams. That seems to be the general consensus, but it's not written in the draft. Maybe control streams could have a message length while data streams do not.\r\n\r\nBut in general I want to copy QUIC/HTTP3. I really like the encoding and I generally assume the Media over QUIC working group does too. That means no message length for now but we should absolutely tackle the versioning and backwards compatibility issue.",
              "createdAt": "2023-01-11T21:07:18Z",
              "updatedAt": "2023-01-11T21:08:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KMSjT",
          "commit": {
            "abbreviatedOid": "b9d1e5d"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-11T22:59:00Z",
          "updatedAt": "2023-01-11T22:59:00Z",
          "comments": [
            {
              "originalPosition": 162,
              "body": "Hmm, I think a URI might be a middle ground. The schema would declare how it's structured, and you could have a schema that is more restrictive?",
              "createdAt": "2023-01-11T22:59:00Z",
              "updatedAt": "2023-01-11T22:59:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KMt9j",
          "commit": {
            "abbreviatedOid": "b9d1e5d"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-12T01:37:43Z",
          "updatedAt": "2023-01-12T01:37:44Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "I think that's a really good idea - have a stream type that identifies it as a control stream or object stream.  Control streams are framed, and all messages have lengths.  Unknown messages are skipped/ignored.  Object streams could be entirely unframed, or could have some frames up front and transition to unframed when the object starts.",
              "createdAt": "2023-01-12T01:37:43Z",
              "updatedAt": "2023-01-12T01:37:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KNfBo",
          "commit": {
            "abbreviatedOid": "b9d1e5d"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-12T06:51:05Z",
          "updatedAt": "2023-01-12T06:51:05Z",
          "comments": [
            {
              "originalPosition": 162,
              "body": "> You always need _some_ authority to ensure that an ID is unique. For example, if I push `moq://kixelated.io/12345` to two different hosts, one of them is going to have to say \"no\".\r\n\r\nWe have a global system for validating uniqueness - DNS + TLS certs. Perhaps we can leverage that for MOQ. What if we define the moq broadcast URI to serve double-duty as the HTTPS verification API for permission to publish? As an example, if the client contacts any ingest server and asks to publish https://kixelated.io/12345, the ingest server first makes an HTTPS request to https://kixelated.io/12345. The request is probably accompanied by an access token given to it out-of-band to protect that API endpoint.  The ingest server expects to get back some confirmation response that we define that authorizes it to accept the publication. There could be other factors besides uniqueness that kixelated may wish to enforce (geo, time-of-day restrictions etc). . This saves the distribution system from having to maintain global uniqueness,  by delegating all streams purporting to come from the kixelated domain to kixelated. If the ingest server is only authorized to accept streams for rainbows.com, then it could reject the publish request immediately. THis could work in reverse too - the publishing app must first communicate with kixelated.com to get assigned a unique ID along with an access token, which it then hands to the ingest server when requesting publication permission. ",
              "createdAt": "2023-01-12T06:51:05Z",
              "updatedAt": "2023-01-12T06:51:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KYgUX",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Overall LGTM.",
          "createdAt": "2023-01-13T16:09:41Z",
          "updatedAt": "2023-01-13T16:24:16Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Is there a reason we introduce a new URI scheme?  If we want those to be valid WebTransport URIs, those should be https.",
              "createdAt": "2023-01-13T16:09:41Z",
              "updatedAt": "2023-01-13T16:24:17Z"
            },
            {
              "originalPosition": 314,
              "body": "Actually, what happens when we receive multiple CATALOG messages?",
              "createdAt": "2023-01-13T16:24:07Z",
              "updatedAt": "2023-01-13T16:24:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Ka366",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T21:32:53Z",
          "updatedAt": "2023-01-13T21:32:53Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "does this mean that client (player) cannot get video frame in 1 RTT? (sorry, I might be a bit late and this pull request is not the right place to ask this)",
              "createdAt": "2023-01-13T21:32:53Z",
              "updatedAt": "2023-01-13T21:34:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Ka5BF",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T21:37:34Z",
          "updatedAt": "2023-01-13T21:37:35Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "nit: \"encoder\" might be too limiting here - there are likely cases where CDN node might decide to splice something in bitstream - it's not always encoder",
              "createdAt": "2023-01-13T21:37:34Z",
              "updatedAt": "2023-01-13T21:37:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Ka8aW",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T21:49:53Z",
          "updatedAt": "2023-01-13T21:49:54Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "from our experience we found it's very useful to have more than \"error code\" - can we extend error to be error code and some text blob?\r\n\r\nFor example: there are could be multiple reasons why session was terminated - it could have been terminated by broadcaster, it could have been terminated by vendor, for example copy-right match",
              "createdAt": "2023-01-13T21:49:53Z",
              "updatedAt": "2023-01-13T21:49:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Ka873",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T21:52:34Z",
          "updatedAt": "2023-01-13T21:52:34Z",
          "comments": [
            {
              "originalPosition": 137,
              "body": "@afrind hm... our semantics of GOWAY is not session termination, right? It's an instruction to endpoint to migrate to new connection because current one will be drained",
              "createdAt": "2023-01-13T21:52:34Z",
              "updatedAt": "2023-01-13T21:52:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Ka-TC",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T21:56:08Z",
          "updatedAt": "2023-01-13T21:56:09Z",
          "comments": [
            {
              "originalPosition": 149,
              "body": "what happened to length? how relays or endpoints know message boundaries?",
              "createdAt": "2023-01-13T21:56:09Z",
              "updatedAt": "2023-01-13T21:56:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Ka_Q_",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T21:58:13Z",
          "updatedAt": "2023-01-13T21:58:13Z",
          "comments": [
            {
              "originalPosition": 184,
              "body": "I think we need 1RTT option - having endpoints exchanging information before actual media bytes starts flowing will hurt performance and is the regression from DASH playback or RUSH ingest",
              "createdAt": "2023-01-13T21:58:13Z",
              "updatedAt": "2023-01-13T21:58:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Ka_rK",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T22:00:01Z",
          "updatedAt": "2023-01-13T22:00:01Z",
          "comments": [
            {
              "originalPosition": 137,
              "body": "This isn't a GOAWAY message, rather it's an error code to be passed to the WebTransport close message (which is like QUIC CONNECTION_CLOSE).  In that case, I'm not sure the value of having a GOAWAY code here, either the session drained or it didn't, right?",
              "createdAt": "2023-01-13T22:00:01Z",
              "updatedAt": "2023-01-13T22:00:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KbB7r",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T22:09:24Z",
          "updatedAt": "2023-01-13T22:09:25Z",
          "comments": [
            {
              "originalPosition": 206,
              "body": "hm... this will be pretty size big overhead, for example if we want to have 1 frame CMAF audio chunks - that URI alone would be larger than payload :/",
              "createdAt": "2023-01-13T22:09:25Z",
              "updatedAt": "2023-01-13T22:09:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KbEKs",
          "commit": {
            "abbreviatedOid": "b9d1e5d"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T22:14:40Z",
          "updatedAt": "2023-01-13T22:14:41Z",
          "comments": [
            {
              "originalPosition": 162,
              "body": "That's a possibility, although a certificate doesn't prevent duplicates. And maybe the user is authenticated and has a valid certificate from `rainbows.com`, but they doesn't mean they are well-behaved (ex. use the same broadcast/cert twice). If I'm running a service like Twitch that accepts broadcasts from users, then I need to assume they will be malicious.\r\n\r\nA relay can only forward if it trusts the source. I think there's cases when you can do that (ex. superbowl) and public key crypto is an option. But it can't be a requirement, because I absolutely do not trust any of my users.",
              "createdAt": "2023-01-13T22:14:40Z",
              "updatedAt": "2023-01-13T22:15:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KbEcX",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T22:16:05Z",
          "updatedAt": "2023-01-13T22:16:05Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I'll revert it. I don't really care about URI semantics but somebody might.",
              "createdAt": "2023-01-13T22:16:05Z",
              "updatedAt": "2023-01-13T22:16:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KbEpx",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T22:17:16Z",
          "updatedAt": "2023-01-13T22:17:16Z",
          "comments": [
            {
              "originalPosition": 314,
              "body": "Undefined for now. CATALOG messages contain init segments, and you can't change those without potentially \r\nbreaking the decoder. We need a separate PR on how to add/remove/update tracks.",
              "createdAt": "2023-01-13T22:17:16Z",
              "updatedAt": "2023-01-13T22:19:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KbEvR",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T22:17:49Z",
          "updatedAt": "2023-01-13T22:17:49Z",
          "comments": [
            {
              "originalPosition": 220,
              "body": "what is the role of this URI?",
              "createdAt": "2023-01-13T22:17:49Z",
              "updatedAt": "2023-01-13T22:17:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KbFq_",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T22:23:37Z",
          "updatedAt": "2023-01-13T22:23:38Z",
          "comments": [
            {
              "originalPosition": 250,
              "body": "I am not sure why we need this? I would imagine endpoint somehow obtains URI, for example: broadcasting client would obtain from the Twitch/Meta/VendorX API and then it can use this URI to open up session and within session it would go thru setup, etc. and would issue subscribe - why do we need to care URI everywhere? The only thing we need is multiplex multiple broadcasts on same WebTransport connection, but that would only need broadcast ID - why do we need whole URI?",
              "createdAt": "2023-01-13T22:23:37Z",
              "updatedAt": "2023-01-13T22:24:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KbF8D",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T22:25:27Z",
          "updatedAt": "2023-01-13T22:25:28Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "The WebTransport CONNECT request requires 1 RTT already. But the client is allowed to write streams while the CONNECT request is in flight, and the server is allowed to write streams while the CONNECT response is in flight. \r\n\r\nSo with a good WebTransport implementation, this SETUP doesn't incur an extra round trip. If it was a server-initiated bidirectional stream then it would. Maybe we can explicitly put the SETUP message in the WebTransport CONNECT or something to avoid this being a possibility though.",
              "createdAt": "2023-01-13T22:25:27Z",
              "updatedAt": "2023-01-13T22:25:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KbGUL",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T22:27:47Z",
          "updatedAt": "2023-01-13T22:27:48Z",
          "comments": [
            {
              "originalPosition": 244,
              "body": "is there trigger for sender to send CATALOG message? Can sender send multiple CATALOG messages?",
              "createdAt": "2023-01-13T22:27:48Z",
              "updatedAt": "2023-01-13T22:27:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KbGdc",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T22:28:46Z",
          "updatedAt": "2023-01-13T22:28:46Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "Yeah, I think WebTransport supports an int code and string reason.",
              "createdAt": "2023-01-13T22:28:46Z",
              "updatedAt": "2023-01-13T22:28:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KbGpf",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T22:30:01Z",
          "updatedAt": "2023-01-13T22:30:01Z",
          "comments": [
            {
              "originalPosition": 137,
              "body": "The idea was to handle the case when a broadcast terminates in the middle of a GOAWAY. \"I migrated\" versus \"I didn't need to migrate\".",
              "createdAt": "2023-01-13T22:30:01Z",
              "updatedAt": "2023-01-13T22:30:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KbGrQ",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T22:30:11Z",
          "updatedAt": "2023-01-13T22:30:12Z",
          "comments": [
            {
              "originalPosition": 335,
              "body": "probably not related to this PR, but it would be useful to explain why role is needed? why can't everyone send and receive media?",
              "createdAt": "2023-01-13T22:30:11Z",
              "updatedAt": "2023-01-13T22:30:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KbG7A",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T22:31:44Z",
          "updatedAt": "2023-01-13T22:31:44Z",
          "comments": [
            {
              "originalPosition": 362,
              "body": "hm.... do we really need to spell it out here? maybe just link to fMP4 ISO spec?",
              "createdAt": "2023-01-13T22:31:44Z",
              "updatedAt": "2023-01-13T22:31:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KbHC_",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T22:32:35Z",
          "updatedAt": "2023-01-13T22:32:35Z",
          "comments": [
            {
              "originalPosition": 363,
              "body": "interesting question what happens if this doesn't match to what was advertised in CATALOG message?",
              "createdAt": "2023-01-13T22:32:35Z",
              "updatedAt": "2023-01-13T22:32:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KbHET",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T22:32:44Z",
          "updatedAt": "2023-01-13T22:32:44Z",
          "comments": [
            {
              "originalPosition": 149,
              "body": "+1 I think we need to leave this in.  In the short term, just set it to 0 for OBJECT and remove in another PR?",
              "createdAt": "2023-01-13T22:32:44Z",
              "updatedAt": "2023-01-13T22:32:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KbHG0",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T22:33:02Z",
          "updatedAt": "2023-01-13T22:33:03Z",
          "comments": [
            {
              "originalPosition": 149,
              "body": "OBJECT messages can't have a length when they contain multiple frames. We could add a special case that 0 means until the end of the stream, but I think we default to QUIC encoding for now.\r\n\r\nIf relays need to proxy arbitrary messages, then yeah we should absolutely add a length. Same goes for backwards compatibility.",
              "createdAt": "2023-01-13T22:33:02Z",
              "updatedAt": "2023-01-13T22:33:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KbIg3",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T22:41:13Z",
          "updatedAt": "2023-01-13T22:41:14Z",
          "comments": [
            {
              "originalPosition": 270,
              "body": "don't we need track type? if there are 5 video tracks and 5 audio, I need to be able to get 1 audio and 1 video, but how I know which one is which?",
              "createdAt": "2023-01-13T22:41:14Z",
              "updatedAt": "2023-01-13T22:41:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KbIvB",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T22:41:57Z",
          "updatedAt": "2023-01-13T22:41:58Z",
          "comments": [
            {
              "originalPosition": 252,
              "body": "how do we model different audio/video qualities? 1080p, 720p, etc. ",
              "createdAt": "2023-01-13T22:41:57Z",
              "updatedAt": "2023-01-13T22:41:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KbJke",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T22:44:12Z",
          "updatedAt": "2023-01-13T22:44:12Z",
          "comments": [
            {
              "originalPosition": 206,
              "body": "I agree but this is the compromise. The ask is that relays can blindly copy OBJECT messages rather than re-encode them. I strongly want to avoid any requirement that this URI is globally unique though.\r\n\r\nI would conceptually think of this like a QUIC connection ID. An endpoint can use as many bytes as it wants, and potentially proxy the connection ID rather than terminate. OBS could push a single broadcast named `moq://live` or something.\r\n\r\nBut yeah, let's pick a direction and we can revisit it as we go.",
              "createdAt": "2023-01-13T22:44:12Z",
              "updatedAt": "2023-01-13T22:44:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KbJ2s",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T22:44:58Z",
          "updatedAt": "2023-01-13T22:44:58Z",
          "comments": [
            {
              "originalPosition": 220,
              "body": "It's to identify that an OBJECT is part of a broadcast. The track ID alone is not enough since it's not unique across broadcasts.",
              "createdAt": "2023-01-13T22:44:58Z",
              "updatedAt": "2023-01-13T23:11:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KbKNO",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T22:45:58Z",
          "updatedAt": "2023-01-13T22:45:58Z",
          "comments": [
            {
              "originalPosition": 244,
              "body": "Yeah, multiple CATALOG messages for multiple broadcasts. Currently there's no way to update an existing CATALOG but we'll define something.",
              "createdAt": "2023-01-13T22:45:58Z",
              "updatedAt": "2023-01-13T22:45:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KbKg1",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T22:46:43Z",
          "updatedAt": "2023-01-13T22:46:43Z",
          "comments": [
            {
              "originalPosition": 362,
              "body": "heh I copied this from the HLS spec.",
              "createdAt": "2023-01-13T22:46:43Z",
              "updatedAt": "2023-01-13T22:46:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KbLpI",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T22:50:07Z",
          "updatedAt": "2023-01-13T22:50:07Z",
          "comments": [
            {
              "originalPosition": 363,
              "body": "The init segment is delivered via the CATALOG message so they're one and the same. ",
              "createdAt": "2023-01-13T22:50:07Z",
              "updatedAt": "2023-01-13T22:50:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KbMLn",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T22:53:39Z",
          "updatedAt": "2023-01-13T22:53:39Z",
          "comments": [
            {
              "originalPosition": 270,
              "body": "That info (codec) is in the init segment, along with a bunch of other things that typically get sent in a playlist (ex. resolution, language, profile). It didn't seem useful to duplicate that information since it was already defined for fMP4.\r\n\r\nIf you want another format, ex. m3u8 or something to declare these parameters, then that should be a separate track format (currently called \"container\" but we'll rename). The \"init payload\" would be the m3u8 playlist.",
              "createdAt": "2023-01-13T22:53:39Z",
              "updatedAt": "2023-01-13T22:53:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KbMj2",
          "commit": {
            "abbreviatedOid": "b9d1e5d"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T22:55:37Z",
          "updatedAt": "2023-01-13T22:55:37Z",
          "comments": [
            {
              "originalPosition": 220,
              "body": "I'm just going to leave this barren for now and only reference the URI spec. I'm sure somebody will care about sematics and expand.",
              "createdAt": "2023-01-13T22:55:37Z",
              "updatedAt": "2023-01-13T22:55:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KbM9x",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T22:58:46Z",
          "updatedAt": "2023-01-13T22:58:47Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "Although to be clear, this PR does introduce an extra round trip because the receiver must explicitly send SUBSCRIBE after receiving a CATALOG message. I would like to improve that though, like by advertising the default subscription in the CATALOG, but there were enough options that I'm saving it for another PR.",
              "createdAt": "2023-01-13T22:58:46Z",
              "updatedAt": "2023-01-13T23:02:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KbNCc",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T22:59:23Z",
          "updatedAt": "2023-01-13T22:59:24Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "We only need to standardize the int code though.",
              "createdAt": "2023-01-13T22:59:24Z",
              "updatedAt": "2023-01-13T22:59:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KbNKj",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T23:00:22Z",
          "updatedAt": "2023-01-13T23:00:22Z",
          "comments": [
            {
              "originalPosition": 149,
              "body": "But yeah okay I'll make another PR. Posted my comment at the same time as Alan.",
              "createdAt": "2023-01-13T23:00:22Z",
              "updatedAt": "2023-01-13T23:00:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KbOEf",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T23:07:46Z",
          "updatedAt": "2023-01-13T23:07:46Z",
          "comments": [
            {
              "originalPosition": 137,
              "body": "Do you think I should remove GOAWAY and make a separate PR? I kind of snuck it in as we were reaching the draft deadline but it's absoutely out of place.",
              "createdAt": "2023-01-13T23:07:46Z",
              "updatedAt": "2023-01-13T23:08:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KbOqX",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T23:12:51Z",
          "updatedAt": "2023-01-13T23:12:51Z",
          "comments": [
            {
              "originalPosition": 220,
              "body": "We could make the track unique, for example track URI, and then we would no longer need the broadcast URI. However since the track URI would likely just be a superset of the broadcast URI, there's really no point.",
              "createdAt": "2023-01-13T23:12:51Z",
              "updatedAt": "2023-01-13T23:13:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KbO9Z",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T23:15:29Z",
          "updatedAt": "2023-01-13T23:15:30Z",
          "comments": [
            {
              "originalPosition": 335,
              "body": "Victor added it, but I think it's so an implementation doesn't need to support both roles. Kind of like a HTTP client versus a HTTP server. It's also just a nice declaration of intent.",
              "createdAt": "2023-01-13T23:15:30Z",
              "updatedAt": "2023-01-13T23:15:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5KbPiD",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-13T23:20:49Z",
          "updatedAt": "2023-01-13T23:20:50Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "^ both a broadcaster and viewer would incur an extra RTT as a result.",
              "createdAt": "2023-01-13T23:20:50Z",
              "updatedAt": "2023-01-13T23:20:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Kmazn",
          "commit": {
            "abbreviatedOid": "dd15fd7"
          },
          "author": "jordicenzano",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "Sorry to be very late to this review. Great progress since last time I took a look.\r\nI really like this direction, now it seems we are 1 step closer to a prototype, EXCITING!!\r\nI left few comments / questions",
          "createdAt": "2023-01-17T13:48:24Z",
          "updatedAt": "2023-01-17T15:29:38Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Should we also consider data tracks? (time metadata such as subtitles, SCTE35 markers, etc)",
              "createdAt": "2023-01-17T13:48:24Z",
              "updatedAt": "2023-01-17T15:29:38Z"
            },
            {
              "originalPosition": 54,
              "body": "Did we define `brodcast ID`? Perhaps Broadcast URI?",
              "createdAt": "2023-01-17T14:13:09Z",
              "updatedAt": "2023-01-17T15:29:38Z"
            },
            {
              "originalPosition": 184,
              "body": "We could use some default values",
              "createdAt": "2023-01-17T14:32:54Z",
              "updatedAt": "2023-01-17T15:29:38Z"
            },
            {
              "originalPosition": 250,
              "body": "I agree with @kpugin , this is how I imagine this working (pretty sure I'm missing something):\r\n\r\n- Ingest\r\n  - The client/encoder gets a broadcastURI (or broadcastID) out of band\r\n  - The client/encoder initiates a webTransport to server, adding that broadcastURI/broadcastID in the SETUP message\r\n  - The server responds authorized or error\r\n    - If authorized client / encoder (perhaps sends a SUBSCRIBE announcing the tracks) and starts sending media (or sends SUBSCRIBE + media in parallel while waiting for OK/ERR)\r\n\r\nNote: I can NOT picture how CATALOG process works on the ingest case\r\n\r\n- Delivery\r\n  - The clients/players gets a broadcastURI (or broadcastID) out of band (like HLS/DASH with manifest URL)\r\n  - The client initiates a webTransport to server, adding that broadcastURI/broadcastID in the SETUP message, we can also send a CATALOG (or \"SUBSCRIBE to defaults\" without waiting setup response to avoid 1RTT more, and that will only be processed if SETUP is successful)\r\n  - The server responds authorized or error\r\n  - If authorized the server starts sending media (in case \"SUBSCRIBE to defaults\" was in the same stream)\r\n  - (if no \"SUBSCRIBE to defaults\") Client sends CATALOG for that broadcastURI (or broadcastID)\r\n  - Server responds with CATALOG response\r\n  - Client SUBSCRIBES to desired variants\r\n  - The server starts sending media",
              "createdAt": "2023-01-17T14:46:18Z",
              "updatedAt": "2023-01-17T15:29:39Z"
            },
            {
              "originalPosition": 270,
              "body": "Is there a way in fmp4 to define track groups? let me add an example of what I mean: We have a live stream with (2 video POV + 2 audio languages. All of them with 2 variants):\r\n- Video POV1\r\n   - Variant1 1080p@30fps - 10Mbps\r\n   - Variant2 720p@30fps - 6Mbps\r\n- Video POV2\r\n   - Variant1 1080p@30fps - 10Mbps\r\n   - Variant2 720p@30fps - 6Mbps\r\n- Audio POV1 EN\r\n   - Variant1 16b 44.1KHz - 128Kbps\r\n   - Variant1 16b 44.1KHz - 64Kbps\r\n- Audio POV1 ES\r\n   - Variant1 16b 44.1KHz - 128Kbps\r\n   - Variant1 16b 44.1KHz - 64Kbps\r\n  - Audio POV2 EN\r\n   - Variant1 16b 44.1KHz - 128Kbps\r\n   - Variant1 16b 44.1KHz - 64Kbps\r\n- Audio POV2 ES\r\n   - Variant1 16b 44.1KHz - 128Kbps\r\n   - Variant1 16b 44.1KHz - 64Kbps\r\n\r\nHow the player would know the different POV available, the different languages, and the relation between them. Is fmp4 / mp4 able to store those relations? (basically I'm asking for what transport stream solves with PAT - PMT tables, or other formats with manifests)\r\n\r\nNote: I did NOT add subtitles to avoid more complexity",
              "createdAt": "2023-01-17T15:13:58Z",
              "updatedAt": "2023-01-17T15:29:39Z"
            },
            {
              "originalPosition": 314,
              "body": "\"be sent on the same QUIC stream\" the same as ...? SETUP?",
              "createdAt": "2023-01-17T15:15:31Z",
              "updatedAt": "2023-01-17T15:29:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5LKHpH",
          "commit": {
            "abbreviatedOid": "dd15fd7"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-18T23:56:15Z",
          "updatedAt": "2023-01-18T23:56:16Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Absolutely.",
              "createdAt": "2023-01-18T23:56:16Z",
              "updatedAt": "2023-01-18T23:56:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5LKMF4",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-19T00:12:29Z",
          "updatedAt": "2023-01-19T00:12:29Z",
          "comments": [
            {
              "originalPosition": 250,
              "body": "Not including HTTP/3, here's the diagram thus far:\r\n\r\n### Ingest\r\n\r\n```\r\n--> client CONNECT   url=auth\r\n--> client SETUP     role=producer\r\n<-- server CONNECT   status=200\r\n<-- server SETUP     role=consumer\r\n--> client CATALOG   broadcast=superbowl track=a track=b track=c\r\n<-- server SUBSCRIBE broadcast=superbowl track=b\r\n--> client OBJECT    broadcast=superbowl track=b\r\n```\r\n\r\nI'm not sure if the client has to wait until the receipt of SETUP before it can send the CATALOG. If so, 2.5 RTTs to transfer the first frame.\r\n\r\n### Distribution\r\n```\r\n--> client CONNECT   url=auth\r\n--> client SETUP     role=consumer\r\n<-- server CONNECT   status=200\r\n<-- server SETUP     role=producer\r\n<-- server CATALOG   broadcast=superbowl track=a track=b track=c\r\n--> client SUBSCRIBE broadcast=superbowl track=b\r\n<-- server OBJECT    broadcast=superbowl track=b\r\n```\r\n\r\n2 RTTs to transfer the first frame.",
              "createdAt": "2023-01-19T00:12:29Z",
              "updatedAt": "2023-01-19T00:12:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5LKM6U",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-19T00:18:02Z",
          "updatedAt": "2023-01-19T00:18:03Z",
          "comments": [
            {
              "originalPosition": 250,
              "body": "Getting the broadcast URI out of band involves some additional RTTs. That's possible and might even be necessary, but I'd like to support clients that don't pre-negotiate. \r\n\r\nAn easy way to avoid an RTT is to include `default` tracks in the CATALOG, especially if there's not really a decision to make.\r\n\r\n@vasilvv @wilaw It would be nice if we could combine the CONNECT request/response and the SETUP message. They serve pretty similar roles.",
              "createdAt": "2023-01-19T00:18:03Z",
              "updatedAt": "2023-01-19T00:18:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5LKNC2",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-19T00:18:56Z",
          "updatedAt": "2023-01-19T00:18:56Z",
          "comments": [
            {
              "originalPosition": 252,
              "body": "I mentioned in another comment, but the (fMP4) init segment contains the media type and resolution.",
              "createdAt": "2023-01-19T00:18:56Z",
              "updatedAt": "2023-01-19T00:18:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5LKNQe",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-19T00:20:21Z",
          "updatedAt": "2023-01-19T00:20:21Z",
          "comments": [
            {
              "originalPosition": 270,
              "body": "I'm not sure. There's certainly some metadata missing in fMP4 (like bitrate) that we'll have to encode somewhere. Maybe add some fields, maybe extend fMP4, maybe make a new container, who knows.",
              "createdAt": "2023-01-19T00:20:21Z",
              "updatedAt": "2023-01-19T00:20:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5LKNdz",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-19T00:21:45Z",
          "updatedAt": "2023-01-19T00:21:46Z",
          "comments": [
            {
              "originalPosition": 314,
              "body": "I'll make a PR to address the stream ambiguity. There has to be at least one control stream per broadcast. If there's only a single control stream per broadcast (probably?), then this text can be removed",
              "createdAt": "2023-01-19T00:21:46Z",
              "updatedAt": "2023-01-19T00:21:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5LKQxW",
          "commit": {
            "abbreviatedOid": "dd15fd7"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-19T00:43:05Z",
          "updatedAt": "2023-01-19T00:43:05Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "> The first stream opened is a client-initiated bidirectional stream where the peers exchange SETUP messages ({{message-setup}}).\r\n\r\nWhat should the server do if the first stream opened is not bidirectional? Does it reject the SETUP messages? Since the server could easily open up a unidirectional stream back to the client, it seems this constraint could be relaxed, unless we move to a design in which all CONTROL messages are sent across a single bidi channel, which is a control singleton within the scope of the WT connection. ",
              "createdAt": "2023-01-19T00:43:05Z",
              "updatedAt": "2023-01-19T00:43:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5LKSAq",
          "commit": {
            "abbreviatedOid": "dd15fd7"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-19T00:51:09Z",
          "updatedAt": "2023-01-19T00:51:10Z",
          "comments": [
            {
              "originalPosition": 335,
              "body": "I also believe that ROLE parameter is redundant.  A consumer is any client that issues a SUBSCRIBE request.  A producer is any client that sends OBJECT and CATALOG messages. Each client is going to have to the work at the application layer to protect itself against out-of-context, malformed or irrelevant messages that it receives. Declaring a role doesn't obviate a client from a receiver from validating all incoming messages. \r\n",
              "createdAt": "2023-01-19T00:51:09Z",
              "updatedAt": "2023-01-19T00:51:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5LKUBa",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-19T01:05:07Z",
          "updatedAt": "2023-01-19T01:05:07Z",
          "comments": [
            {
              "originalPosition": 250,
              "body": "One option is to define a WARP url such that any setup parameters are transmitted as part of the path. For example\r\n\r\nhttps://<host>:<port>/<setup>/<application-defined ...>\r\n\r\nhttps://twitch.com:4433/protocol=warp,v=1,role=consumer,sendDefault=true/stream12345\r\n\r\nThis would allow the server to immediately start sending the default tracks to the client upon authentication of the WT connection. \r\n\r\nSee prior comments on this PR that we could probably deprecate ROLE parameter to simplify the setup. \r\n",
              "createdAt": "2023-01-19T01:05:07Z",
              "updatedAt": "2023-01-19T01:05:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5LWGwC",
          "commit": {
            "abbreviatedOid": "442f1e0"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-20T17:45:11Z",
          "updatedAt": "2023-01-20T17:45:11Z",
          "comments": [
            {
              "originalPosition": 206,
              "body": "We could go the \"optional compression\" route where if both client and server agree they can stick the URL in a table and transmit an ID here in place?  Relays that prefer larger network overhead but fewer lookup tables and not support such compression?",
              "createdAt": "2023-01-20T17:45:11Z",
              "updatedAt": "2023-01-20T17:45:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5LX_Oc",
          "commit": {
            "abbreviatedOid": "dd15fd7"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-21T03:19:43Z",
          "updatedAt": "2023-01-21T03:19:43Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "I believe the usual behavior is that you don't read any stream data on any stream until you find one that starts with a SETUP message.",
              "createdAt": "2023-01-21T03:19:43Z",
              "updatedAt": "2023-01-21T03:19:43Z"
            }
          ]
        }
      ]
    },
    {
      "number": 67,
      "id": "PR_kwDOG2Ho4M5IRR_v",
      "title": "Relays support within MoQ Architecture",
      "url": "https://github.com/moq-wg/moq-transport/pull/67",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR is first step towards addressing #54 . \r\n\r\nThanks to Will Law from Akamai for contributing text and discussions around the same\r\n\r\nThis PR depends on concepts from #69 ",
      "createdAt": "2023-01-22T01:26:10Z",
      "updatedAt": "2023-05-05T16:55:25Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "19c8e1ca846960e68ff0be11bd2e101433370603",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "relays",
      "headRefOid": "63a949ea06e8c195a43ff1a9a94ddc03cc59f491",
      "closedAt": "2023-05-05T16:55:25Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Are we ok with merging this PR ?",
          "createdAt": "2023-01-24T19:07:15Z",
          "updatedAt": "2023-01-24T19:07:15Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "> Are we ok with merging this PR ?\r\n\r\nFrom what I understand, this PR depends on some of the definitions used in #69.  Does it actually make sense to merge it before #69?  (if you think it does, I'll review this later today or tomorrow)",
          "createdAt": "2023-01-25T22:04:29Z",
          "updatedAt": "2023-01-25T22:04:29Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we should hold off merging any PRs until after (or maybe during) the interim.  Just like with the IETF draft deadline, we want everyone to have read the same version of the draft.",
          "createdAt": "2023-01-25T22:47:40Z",
          "updatedAt": "2023-01-26T00:28:20Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think we should hold off merging any PRs until after (or maybe during) the interim. Just like with the IETF draft deadline, we want everyone to have read the same version of the draft. From: Victor Vasiliev ***@***.***> Reply-To: kixelated/warp-draft ***@***.***> Date: Wednesday, January 25, 2023 at 2:04 PM To: kixelated/warp-draft ***@***.***> Cc: Subscribed ***@***.***> Subject: Re: [kixelated/warp-draft] Relays support within MoQ Architecture (PR #67) Are we ok with merging this PR ? From what I understand, this PR depends on some of the definitions used in #69. Does it actually make sense to merge it before #69? (if you think it does, I'll review this later today or tomorrow) \u2014Reply ZjQcmQRYFpfptBannerStart This Message Is From an External Sender ZjQcmQRYFpfptBannerEnd Are we ok with merging this PR ? From what I understand, this PR depends on some of the definitions used in #69<#69>. Does it actually make sense to merge it before #69<#69>? (if you think it does, I'll review this later today or tomorrow) \u2014 Reply to this email directly, view it on GitHub<[#67 (comment)](https://github.com/kixelated/warp-draft/pull/67#issuecomment-1404286265)>, or unsubscribe<https://github.com/notifications/unsubscribe-auth/AB7AQ2MWU6P6TP62KJTW5YLWUGPPTANCNFSM6AAAAAAUCWIL6I>. You are receiving this because you are subscribed to this thread.Message ID: ***@***.***>\r\n\r\nMerges of PR is not generating a new version of the draft. I am bit confused on the process being followed",
          "createdAt": "2023-01-25T23:41:05Z",
          "updatedAt": "2023-01-25T23:41:05Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "> Merges of PR is not generating a new version of the draft. I am bit confused on the process being followed\r\n\r\nThat's a good point, but having two different versions (editors copy vs the published rev) may be more confusing at this stage.  What is the goal of merging now vs in 6 days?  We can highlight this PR (and others) in the agenda if we want interim participants to be versed in it?",
          "createdAt": "2023-01-26T00:39:56Z",
          "updatedAt": "2023-01-26T00:39:56Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @wilaw for a detailed review and suggestions. I have committed most of it .. I will do a new commit with others as well .",
          "createdAt": "2023-01-26T05:06:39Z",
          "updatedAt": "2023-01-26T05:06:39Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Has this been overtaken by events?  I assume that #126, #127 and #128 are closer to the text we want to merge?",
          "createdAt": "2023-04-21T19:06:19Z",
          "updatedAt": "2023-04-21T19:06:19Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5LtvLt",
          "commit": {
            "abbreviatedOid": "c799fd4"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-25T23:40:35Z",
          "updatedAt": "2023-01-25T23:40:36Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "```suggestion\r\nA subscribe message instructs a relay to forward to the client all objects matching the subscription identifier. Typically this sequence of objects will comprise a media track. Each media object carries identifiers which, when concatenated, uniquely identify that object across all nodes of the delivery network. \r\n```\r\n",
              "createdAt": "2023-01-25T23:40:35Z",
              "updatedAt": "2023-01-25T23:42:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Ltvp3",
          "commit": {
            "abbreviatedOid": "c799fd4"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-25T23:43:11Z",
          "updatedAt": "2023-01-25T23:43:11Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "```suggestion\r\n* Reliability - relays can improve the overall reliability \r\n               of the delivery system by providing alternate paths for \r\n               routing content.\r\n```\r\n",
              "createdAt": "2023-01-25T23:43:11Z",
              "updatedAt": "2023-01-25T23:43:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5LtydW",
          "commit": {
            "abbreviatedOid": "c799fd4"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-26T00:02:47Z",
          "updatedAt": "2023-01-26T00:02:48Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "```suggestion\r\nAfter successful validation of a subscription request, the relay saves the subscription by maintaining a mapping of the (Broadcast URI,track ID) tuple against the WebTransport connection associated with each subscriber. \r\nThis enables relays to forward matching cached objects if available as well as all future matching media objects. \r\n```",
              "createdAt": "2023-01-26T00:02:47Z",
              "updatedAt": "2023-01-26T00:02:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5LtzDf",
          "commit": {
            "abbreviatedOid": "c799fd4"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-26T00:06:48Z",
          "updatedAt": "2023-01-26T00:06:48Z",
          "comments": [
            {
              "originalPosition": 92,
              "body": "Most RTC applications follow a centralized SFU or MCU model in which all published media is forwarded to an origin. This enables a host of features such as billing, access control, content validation, caption generation, object extraction, text-to-speech etc. If a relay directly routes a published object to a subscriber without passing it through the origin, then those features cannot be enabled. ",
              "createdAt": "2023-01-26T00:06:48Z",
              "updatedAt": "2023-01-26T00:06:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5LtzPI",
          "commit": {
            "abbreviatedOid": "c799fd4"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-26T00:08:02Z",
          "updatedAt": "2023-01-26T00:08:03Z",
          "comments": [
            {
              "originalPosition": 106,
              "body": "```suggestion\r\nPublishers begin with publishing \"Catalog\" messages that identify the \r\n```",
              "createdAt": "2023-01-26T00:08:02Z",
              "updatedAt": "2023-01-26T00:08:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5LtzUE",
          "commit": {
            "abbreviatedOid": "c799fd4"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-26T00:08:35Z",
          "updatedAt": "2023-01-26T00:08:35Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "```suggestion\r\nauthorized in one of the following ways\r\n```",
              "createdAt": "2023-01-26T00:08:35Z",
              "updatedAt": "2023-01-26T00:08:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5LtzaQ",
          "commit": {
            "abbreviatedOid": "c799fd4"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-26T00:09:14Z",
          "updatedAt": "2023-01-26T00:09:15Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "```suggestion\r\n   messages directly to the Origin or possibly traversing another Relay.\r\n```",
              "createdAt": "2023-01-26T00:09:14Z",
              "updatedAt": "2023-01-26T00:09:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Lt0FM",
          "commit": {
            "abbreviatedOid": "c799fd4"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-26T00:12:01Z",
          "updatedAt": "2023-01-26T00:12:02Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "```suggestion\r\nparticipate in forwarding the published media objects whose Broadcast URI and Track ID \r\nmatches the Broadcast URI and Track ID specified in the Catalog. \r\n```",
              "createdAt": "2023-01-26T00:12:01Z",
              "updatedAt": "2023-01-26T00:12:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Lt1XQ",
          "commit": {
            "abbreviatedOid": "c799fd4"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-26T00:15:35Z",
          "updatedAt": "2023-01-26T00:15:36Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "```suggestion\r\nRelays makes use of the Object Delivery Order specified in each Object's header to make forward or drop decisions when reacting to congestion in the underlying QUIC stack. \r\nThe same data can be used to make caching decisions.\r\n```",
              "createdAt": "2023-01-26T00:15:35Z",
              "updatedAt": "2023-01-26T00:15:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Lt1fr",
          "commit": {
            "abbreviatedOid": "c799fd4"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-26T00:15:55Z",
          "updatedAt": "2023-01-26T00:15:56Z",
          "comments": [
            {
              "originalPosition": 137,
              "body": "```suggestion\r\nRelays are discovered via application defined ways that are out of scope of this \r\n```",
              "createdAt": "2023-01-26T00:15:55Z",
              "updatedAt": "2023-01-26T00:15:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Lt3hY",
          "commit": {
            "abbreviatedOid": "c799fd4"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-26T00:27:18Z",
          "updatedAt": "2023-01-26T00:27:18Z",
          "comments": [
            {
              "originalPosition": 147,
              "body": "How would it READ out of order? Sending priority with QUIC does not control receipt order ",
              "createdAt": "2023-01-26T00:27:18Z",
              "updatedAt": "2023-01-26T00:27:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5LugSn",
          "commit": {
            "abbreviatedOid": "c799fd4"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-26T04:57:30Z",
          "updatedAt": "2023-01-26T04:57:31Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "@wilaw  There is still an open discussion on priority and delivery order. Priority can be mapped to delivery order at the QUIC priority level .. Hence I had made it generic for now ",
              "createdAt": "2023-01-26T04:57:30Z",
              "updatedAt": "2023-01-26T04:57:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5LugZS",
          "commit": {
            "abbreviatedOid": "c799fd4"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-26T04:58:36Z",
          "updatedAt": "2023-01-26T04:58:36Z",
          "comments": [
            {
              "originalPosition": 147,
              "body": "@wilaw Yes ,  I am not sure of it. I would be OK to remove it .. ",
              "createdAt": "2023-01-26T04:58:36Z",
              "updatedAt": "2023-01-26T04:58:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5LugqW",
          "commit": {
            "abbreviatedOid": "c799fd4"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-26T05:01:33Z",
          "updatedAt": "2023-01-26T05:01:33Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "@wilaw  Having Broadcast URI in every packet is wastage of bits and also redundant information and the same can be differently represented when using streams too\r\n\r\n I would encourage MOQ WG to think about how do we avoid this redundancy.",
              "createdAt": "2023-01-26T05:01:33Z",
              "updatedAt": "2023-01-26T05:01:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5LultX",
          "commit": {
            "abbreviatedOid": "c799fd4"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-26T05:47:00Z",
          "updatedAt": "2023-01-26T05:47:01Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "I agree that a UTF8 URI  is unnecessarily verbose in every segment. If it was a number it would be more concise and equally functional. We do need a unique identifier in every object. We can't scope uniqueness to streams or Webtransport sessions, because then relays will need to open new Webtransport connections for every new Broadcast ID. For UGC streaming across different providers, there could be hundreds of thousands of unique broadcasts that a delivery system must route. It cannot keep that many WT sessions open between every node pair. We should definitely discuss this at the interim. ",
              "createdAt": "2023-01-26T05:47:00Z",
              "updatedAt": "2023-01-26T05:47:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5LyHoP",
          "commit": {
            "abbreviatedOid": "c799fd4"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-26T16:55:00Z",
          "updatedAt": "2023-01-26T16:55:00Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "The spec needs to say , what I am calling \"WarpStreamId\" is globally unique and some notes on the same. Agree we need to add some text to that extent.",
              "createdAt": "2023-01-26T16:55:00Z",
              "updatedAt": "2023-01-26T16:55:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5LyX0t",
          "commit": {
            "abbreviatedOid": "c799fd4"
          },
          "author": "gwendalsimon",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-26T17:36:58Z",
          "updatedAt": "2023-01-26T17:36:59Z",
          "comments": [
            {
              "originalPosition": 92,
              "body": "Here you force the RTC application to have a centralized Origin. It should be optional imho.\r\n\r\nAnother solution: the Origin can be regarded as a Relay, which is free to subscribe to any Media Representation. That is, no need to define a special Origin object, nor to implement any specific policy for forwarding. Origin would receive any new Media Object as part of its subscription.\r\n\r\nSide note: \"significant\" is not necessary in the last sentence.    ",
              "createdAt": "2023-01-26T17:36:58Z",
              "updatedAt": "2023-01-26T17:36:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5L0K9h",
          "commit": {
            "abbreviatedOid": "7c403af"
          },
          "author": "xdfy",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-27T00:32:36Z",
          "updatedAt": "2023-01-27T00:32:36Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Would it make sense to cover other types of performance-related relays? For example, we could add \"A relay can also communicate with the underlying network to enable network-specific support for certain types of traffic.\", or similar. (This new proposed sentence is in reference to relays that could be used at ingress point of wireless networks and extract metadata for XR traffic support)\r\n",
              "createdAt": "2023-01-27T00:32:36Z",
              "updatedAt": "2023-01-27T00:32:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5L0Mk1",
          "commit": {
            "abbreviatedOid": "7c403af"
          },
          "author": "xdfy",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-27T00:44:14Z",
          "updatedAt": "2023-01-27T00:44:15Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\nfor a delivery protocol based on a publish/subscribe metaphor \r\n```\r\nor\r\n```suggestion\r\nfor the delivery protocol to be based on a publish/subscribe metaphor \r\n```",
              "createdAt": "2023-01-27T00:44:15Z",
              "updatedAt": "2023-01-27T00:44:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5L0NQe",
          "commit": {
            "abbreviatedOid": "7c403af"
          },
          "author": "xdfy",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-27T00:49:15Z",
          "updatedAt": "2023-01-27T00:49:15Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "The following suggestion (1) removes 'client' since (I assume) both client and server can be publisher/subscriber, and (2) keep the same information but suggest that some other relays may not participate in such overlay.\r\n\r\n```suggestion\r\nwhere some endpoints, called publishers, publish media objects and \r\nsome endpoints, called subscribers, consume those media objects.\r\nSome relays can leverage this publish/subscribe metaphor to form an overlay delivery network similar/in-parallel\r\n```",
              "createdAt": "2023-01-27T00:49:15Z",
              "updatedAt": "2023-01-27T01:47:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5L0NXu",
          "commit": {
            "abbreviatedOid": "7c403af"
          },
          "author": "xdfy",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-27T00:50:08Z",
          "updatedAt": "2023-01-27T00:50:08Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "```suggestion\r\nThe subscribe messages allow subscription to aspects of Media Representations\r\n```",
              "createdAt": "2023-01-27T00:50:08Z",
              "updatedAt": "2023-01-27T00:50:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5L0PT3",
          "commit": {
            "abbreviatedOid": "7c403af"
          },
          "author": "xdfy",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-27T01:03:32Z",
          "updatedAt": "2023-01-27T01:03:32Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "\"publishes for a wide class of media objects\" could be something like \"WarpStreams carrying different media types\" or \"WarpStreams carrying different types of media objects\"? Maybe it's fine as it is, but this comment is to draw your attention on this, to check if there are a better/more common terms (in this draft) to use here. ",
              "createdAt": "2023-01-27T01:03:32Z",
              "updatedAt": "2023-01-27T01:49:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5L0Skr",
          "commit": {
            "abbreviatedOid": "7c403af"
          },
          "author": "xdfy",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-27T01:19:37Z",
          "updatedAt": "2023-01-27T01:19:38Z",
          "comments": [
            {
              "originalPosition": 140,
              "body": "(The goal is to be editorial only)\r\n```suggestion\r\nthe address of new relay. The client uses the new relay for all of its \r\nsubscriptions and then unsubscribes from the old relay and closes its connection to it.\r\n```",
              "createdAt": "2023-01-27T01:19:37Z",
              "updatedAt": "2023-01-27T01:19:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5L0TjI",
          "commit": {
            "abbreviatedOid": "7c403af"
          },
          "author": "xdfy",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-27T01:26:52Z",
          "updatedAt": "2023-01-27T01:26:52Z",
          "comments": [
            {
              "originalPosition": 147,
              "body": "If you don't mind me trying, would something like this work? \"To mitigate this, a relay SHOULD forward QUIC stream data immediately and without re-ordering, subject to flow control limits.\"",
              "createdAt": "2023-01-27T01:26:52Z",
              "updatedAt": "2023-01-27T01:26:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5L0Y3O",
          "commit": {
            "abbreviatedOid": "7c403af"
          },
          "author": "xdfy",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-27T01:47:21Z",
          "updatedAt": "2023-01-27T01:47:22Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Possibly consider adding another sentence to be more explicit about the ability to define any type of relay.\r\n```suggestion\r\nto what CDN provides today. While this type of overlay is expected to be a major application of relays, other types of relays can also be defined to offer various types of services.\r\n```",
              "createdAt": "2023-01-27T01:47:21Z",
              "updatedAt": "2023-01-27T01:47:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5L0bdt",
          "commit": {
            "abbreviatedOid": "7c403af"
          },
          "author": "xdfy",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-27T01:49:54Z",
          "updatedAt": "2023-01-27T01:49:55Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "```suggestion\r\n`SubscriptionId` in the subscribe request. However, Relays MUST be \r\n```",
              "createdAt": "2023-01-27T01:49:54Z",
              "updatedAt": "2023-01-27T01:49:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5L0d4y",
          "commit": {
            "abbreviatedOid": "7c403af"
          },
          "author": "xdfy",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-27T02:03:57Z",
          "updatedAt": "2023-01-27T02:03:57Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "Is authorization of subscription a requirement for all relays? Or would it be possible for some relays (e.g., which are not caching content) to only forward subscriptions (and responses) without validating?",
              "createdAt": "2023-01-27T02:03:57Z",
              "updatedAt": "2023-01-27T02:25:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5L0fT_",
          "commit": {
            "abbreviatedOid": "7c403af"
          },
          "author": "xdfy",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-27T02:16:15Z",
          "updatedAt": "2023-01-27T02:16:15Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "```suggestion\r\n2. Relays forward the received Catalog message towards Origin, \r\n```",
              "createdAt": "2023-01-27T02:16:15Z",
              "updatedAt": "2023-01-27T02:16:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5L6_y6",
          "commit": {
            "abbreviatedOid": "c4d094f"
          },
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-28T03:17:03Z",
          "updatedAt": "2023-01-28T03:17:04Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "+1",
              "createdAt": "2023-01-28T03:17:03Z",
              "updatedAt": "2023-01-28T03:17:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5L6_44",
          "commit": {
            "abbreviatedOid": "c4d094f"
          },
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-28T03:20:30Z",
          "updatedAt": "2023-01-28T03:20:31Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "\"wide class of media objects\" is more general. An detailed example would be helpful.",
              "createdAt": "2023-01-28T03:20:30Z",
              "updatedAt": "2023-01-28T03:20:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5L7IIK",
          "commit": {
            "abbreviatedOid": "c4d094f"
          },
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-28T03:50:23Z",
          "updatedAt": "2023-01-28T03:50:24Z",
          "comments": [
            {
              "originalPosition": 92,
              "body": "I agree the Origin should be optional. Origin is just another relay. The topology and the policy of the relay should be left to relay service provider to determine.",
              "createdAt": "2023-01-28T03:50:23Z",
              "updatedAt": "2023-01-28T03:50:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5L7URu",
          "commit": {
            "abbreviatedOid": "7c403af"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-28T07:38:39Z",
          "updatedAt": "2023-01-28T07:38:39Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "@xdfy yes that is totally possible based on the architecture/topology of the Relay network. The cases that I am aware of, do the authz at the entry network (edges) primarily.  The draft needs to talk about how pub/sub gets authorized within the moq exchange. I am happy to get more feedback on the exact text or suggestions to address the same.",
              "createdAt": "2023-01-28T07:38:39Z",
              "updatedAt": "2023-01-28T07:38:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5MAm9O",
          "commit": {
            "abbreviatedOid": "c4d094f"
          },
          "author": "xdfy",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-30T14:04:30Z",
          "updatedAt": "2023-01-30T14:04:31Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "(Proposing an edit based on my previous comment, only changing 'communicate' with 'expose metadata')\r\n```suggestion\r\n                compared to the client connecting directly to the origin. A relay can also expose metadata to the underlying network to enable network-specific support for certain types of traffic.\r\n```",
              "createdAt": "2023-01-30T14:04:30Z",
              "updatedAt": "2023-01-30T14:04:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5MBDgM",
          "commit": {
            "abbreviatedOid": "c4d094f"
          },
          "author": "xdfy",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-30T15:04:32Z",
          "updatedAt": "2023-01-30T15:04:32Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "Thank you for your response @suhasHere. Here is some example text making validation by relay optional.\r\n\r\n```suggestion\r\nforward the media.\r\n\r\nRelays MAY validate subscriptions, for example to \r\nprotect against malicious uses of resources such as compute and storage.\r\nUpon receiving a subscription, a relay can perform one of the following actions:\r\n\r\n1. the relay can validate the subscription, using information provided in the subscription message. If the validation is successful, the relay sends, to the subscriber, the data objects related to the subscription. The relay may obtain these data objects from local cache or from remote sources.\r\n2. the relay can forward the subscription message towards the origin.\r\n```",
              "createdAt": "2023-01-30T15:04:32Z",
              "updatedAt": "2023-01-30T15:04:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5MB5Cf",
          "commit": {
            "abbreviatedOid": "c4d094f"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-30T16:53:02Z",
          "updatedAt": "2023-01-30T16:53:02Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "I have thoughts. \r\n\r\n- I agree with @xdfy's suggestion that we provide details on various types of relays.\r\n- I wonder if this document is the right place for these details. \r\n- As I understand the charter, we have (at least)  \r\n\r\n> The working group will define MoQ so that the media publication protocol can leverage **coordinating relays, caches, or replication points** wherever applicable to improve the delivery performance\r\n\r\nI'm trying to understand the subtleties between \"relays\", \"caches\", and \"replication points\", especially given that the charter also talks about \r\n\r\n> * **rate adaptation strategies** based on **changing codec rates, changing chosen media encoding/qualities, or other mechanisms**\r\n\r\nand I'm guessing people are thinking these rate adaptation strategies could happen somewhere between the origin server and the ultimate media consumer. \r\n\r\nI'm trying to describe network entities in the requirements draft (as part of resolving [issue #81](https://github.com/fiestajetsam/draft-gruessing-moq-requirements/issues/81) there), and I'm finding myself making assumptions that I shouldn't be making on my own. \r\n\r\n- has there been a discussion about the specifics of relays that I missed (that's **certainly** possible)? ",
              "createdAt": "2023-01-30T16:53:02Z",
              "updatedAt": "2023-01-30T17:03:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5MEl7N",
          "commit": {
            "abbreviatedOid": "c4d094f"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-31T01:38:52Z",
          "updatedAt": "2023-01-31T01:40:59Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "> We can't scope uniqueness to streams or Webtransport sessions, because then relays will need to open new Webtransport connections for every new Broadcast ID\r\n\r\nWebTransport session is different than a connection, and there's not really a definition of a WebTransport connection (maybe a new HTTP connection with a single WebTransport session?).  Opening multiple WebTransport sessions within a single connection shouldn't be cryptographically expensive.  Mostly it creates server side state mapping a QUIC stream ID to a URL.",
              "createdAt": "2023-01-31T01:38:52Z",
              "updatedAt": "2023-01-31T01:40:59Z"
            },
            {
              "originalPosition": 147,
              "body": "mvfst has a peek API that allows the application to see any data received that can't be delivered yet due to head-of-line blocking.",
              "createdAt": "2023-01-31T01:40:54Z",
              "updatedAt": "2023-01-31T01:40:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5MqkJc",
          "commit": {
            "abbreviatedOid": "63a949e"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This PR introduces a fairly specific picture of how one can build a fairly broad range of systems using MoQ, which revolves around relays as an entity that is responsible for maintaining the data path between multiple publishers and multiple subscribers.  It also has an entity named \"the origin\", which is as far as I understand is different from what is meant by the origin in HTTP (HTTP origins are always on the datapath, whereas this PR seems to imply it does not have to be) -- clarifying what \"the origin\" means, or rewriting it so that it does not rely on this, would help make things easier to follow.\r\n\r\nInstead of describing the relay architecture (which will inevitably vary depending on the application), I believe we should focus on the question of \"_what does existence of relays mean for the protocol?_\".  At the interim, we had some requirements brought up, one of which was \"relays have to be able to forward catalogs and objects without parsing them\".  I think we should start by _removing all parts from this PR that do not lead to a requirement or a constraint on the protocol design_ (and for the text that remains, *spelling out the protocol requirements explicitly*).",
          "createdAt": "2023-02-07T00:45:57Z",
          "updatedAt": "2023-02-07T01:19:15Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Do we actually need to description of all relay benefits here?  I assume that it very much depends on the role of the relay, plus I am not sure the specific points listed here would actually influence the wire protocol.",
              "createdAt": "2023-02-07T00:45:57Z",
              "updatedAt": "2023-02-07T01:19:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5NIjgX",
          "commit": {
            "abbreviatedOid": "63a949e"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-10T21:47:47Z",
          "updatedAt": "2023-02-10T21:47:48Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I'm sort of missing your point here. It sounds like you are saying we don't need relays. We do need relays and I think we need to describe architecturally how they fit in and how they work and what they accomplish. I'm not arguing that this way of doing relays or anything is the right way, but just that we do need sort out how this works in the draft. ",
              "createdAt": "2023-02-10T21:47:47Z",
              "updatedAt": "2023-02-10T21:47:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5NIlrd",
          "commit": {
            "abbreviatedOid": "63a949e"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-10T21:52:55Z",
          "updatedAt": "2023-02-10T21:52:55Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "As a side note, I don't see the origin in HTTP the same way you do. The whole point of todays HTTP CDNs today seem like it is to remove the origin from being involved in any ached request.  I understand this might be semantics in that the DNS moved the origin to the CDN, but I think it is the similar in that all we are really talking about is the relays have a business relationship with someone, and that someone authorizes the clients.  That someone got called origin but perhaps there is a better name.  One way or another, I don't see any way to avoid something like this. \r\n",
              "createdAt": "2023-02-10T21:52:55Z",
              "updatedAt": "2023-02-10T21:52:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 69,
      "id": "PR_kwDOG2Ho4M5IRStO",
      "title": "Updated Data Model ",
      "url": "https://github.com/moq-wg/moq-transport/pull/69",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR attempts to address #68\r\n\r\nthe goal of this PR is to\r\n- Define terminologies that is generic (hopefully with less ambiguities) across application domains\r\n- Define relationships between different resources that make up  the data model \r\n- Specify interactions between entities of the MoQ architecture when dealing with the data model\r\n",
      "createdAt": "2023-01-22T01:46:48Z",
      "updatedAt": "2023-05-05T16:55:38Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "19c8e1ca846960e68ff0be11bd2e101433370603",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "data-model",
      "headRefOid": "74ad3b49d3110e3d4f418e41484b07a1fc6a8752",
      "closedAt": "2023-05-05T16:55:38Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This looked like a good generic starting point to me. ",
          "createdAt": "2023-01-22T15:20:15Z",
          "updatedAt": "2023-01-22T15:20:15Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "This PR has two parts; I will go over each part individually.\r\n\r\n------\r\n\r\nThe first part is a rewrite of the existing model section that replaces the broadcast/track/object model with a five-level model.  Since the PR does not diff easily, I am going to attempt to summarize the changes while trying to express my opinion on them one-by-one.\r\n\r\n1. The old concept of \"broadcast\" has been renamed into WarpMediaSession.  I think I like the term \"media session\" (though I'm not so sure about using CamelCase for all the terms).\r\n1. What was formerly known as \"tracks\" is now split into \"media representation\" and \"WARP stream\".  Those appear to be in one-to-one correspondence, though I do not understand what is the actual difference between those two.  I can't say I am particularly fond of the term \"representation\", and I object to use of word \"stream\" for anything that is not a QUIC stream, since that makes things confusing.  If the issue is that \"tracks\" are too specific to live media, we can use \"media feeds\", which I think was in the original model PR.\r\n1. A layer of \"object groups\" is added that reflects the dependencies between objects.  I am not sure an extra level here is useful compared to the previous approach of just annotating the dependency properties directly in the objects themselves, but I do agree that we should have something of this nature.\r\n1. The media objects are still referred to as media objects, though there is some text about encryption and authentication of those.  I don't believe that text belongs in the model, since encryption is fundamentally an issue specific to a particular media format.\r\n\r\n------\r\n\r\nThe second part of this PR is the \"Scope / Goals of the Data Model\" section that introduces the notion of publishers, subscribers and relays into the draft.  I don't believe this should be a part of the model by itself (it is probably more appropriate to the section describing how the relays work), for two reasons.\r\n\r\nThe first reason is that this is not applicable to all use cases. For example, it focuses on the notion that the media receivers need to subscribe to things before receiving them, but there are plenty of cases where one side can just open a connection and start sending media (live ingestion, streaming media from a laptop to a smart device, etc). It also suggests a handshake mechanism between the publisher and the origin server, which is not a distinction that has to exist in all scenarios.\r\n\r\nThe second reason is that I believe that the fact that the media is being relayed should be mostly opaque to the endpoints producing and consuming media.  Setting authentication question aside, a generic HLS player can play media based on a playlist URL alone, not knowing where it's served from (this applies to HTTP in general); similarly, a generic RTMP ingestion client can send media to an RTMP server based on a server URL (plus auth key) alone, without caring what happens next to it.  As player and ingestion client vendors are likely going to constitute the majority of the target audience of this document long-term, I believe the model section should minimize description of parts that are not immediately relevant to them.\r\n\r\n--------\r\n\r\nMy general issue while reviewing this PR is that it tries to address a lot of problems at once, and since it does not explain exactly what are the specific problems it is trying to address, I mostly have to infer those myself.  It would be helpful if the issue #68 specifically spelled out what the issues are; as in, what is the use case affected, what is needed for that specific use case, and why the current model does not allow that to happen.",
          "createdAt": "2023-01-28T05:40:28Z",
          "updatedAt": "2023-01-28T05:40:28Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Responding to  _A layer of \"object groups\" is added that reflects the dependencies between objects. I am not sure an extra level here is useful compared to the previous approach of just annotating the dependency properties directly in the objects themselves, but I do agree that we should have something of this nature._\r\n\r\nApplications group media objects - like WARP does in one group per gop, RUSH does one video frame, some other examples where they group things based on the VR tiles and so on. The dependency relation is application defined and is implicit when an application puts one or more objects in a group.  There is no explicit dependency list carried and is not needed as well.\r\nBut having a way to identify group boundaries will help subscribers ask the media at the right granularity and for relays to provide the media objects without having to know about all possible application dependencies. \r\nThe PR has few examples of such grouping and the model is flexible to extend for new class of applications that are evolving in this space.",
          "createdAt": "2023-01-28T07:25:35Z",
          "updatedAt": "2023-01-28T08:11:10Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Responding to _What was formerly known as \"tracks\" is now split into \"media representation\" and \"WARP stream\". Those appear to be in one-to-one correspondence, though I do not understand what is the actual difference between those two. I can't say I am particularly fond of the term \"representation\", and I object to use of word \"stream\" for anything that is not a QUIC stream, since that makes things confusing. If the issue is that \"tracks\" are too specific to live media, we can use \"media feeds\", which I think was in the original model PR._\r\n\r\nThe name tracks is overloaded, representation is somewhere in between (DASH uses it) , Stream for sure is unusable, but not WarpStream. I am not too attached to names, as long as the names are generic to MoQ applications and not just one class of MoQ applications (as it is today for some aspects)",
          "createdAt": "2023-01-28T07:30:30Z",
          "updatedAt": "2023-01-28T07:39:35Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Responding to _The second reason is that I believe that the fact that the media is being relayed should be mostly opaque to the endpoints producing and consuming media. Setting authentication question aside, a generic HLS player can play media based on a playlist URL alone, not knowing where it's served from (this applies to HTTP in general); similarly, a generic RTMP ingestion client can send media to an RTMP server based on a server URL (plus auth key) alone, without caring what happens next to it. As player and ingestion client vendors are likely going to constitute the majority of the target audience of this document long-term, I believe the model section should minimize description of parts that are not immediately relevant to them._\r\n\r\nI agree and disagree on the points raised here.  Relays are part of the MoQ architecture. some applications might be totally fine with having no relays but that's not the case for all the applications. Relays might be optional in some architectures and application combinations , in which case the corresponding section of the draft doesn't apply but for the cases where Relays play a role, there is definitely a need for the Relays to understand both the protocol and the data model. This PR addresses that fact.\r\n\r\n",
          "createdAt": "2023-01-28T07:34:06Z",
          "updatedAt": "2023-01-28T07:34:06Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "> Relays are part of the MoQ architecture. some applications might be totally fine with having no relays but that's not the case for all the applications. Relays might be optional in some architectures and application combinations , in which case the corresponding section of the draft doesn't apply but for the cases where Relays play a role, there is definitely a need for the Relays to understand both the protocol and the data model. \r\n\r\nI think we should be careful to distinguish between the MoQ data model and the MoQ architecture.\r\n\r\nLet me explain what I mean here, using HTTP as an example.  HTTP has a fairly simple data model (the protocol exchanges request/response messages that have a method, a target/status code, some header/trailer fields and a body).  It has three wire protocols, all of which are at their heart, just an expression of that data model.  But I don't think there really is such a thing as a single \"HTTP architecture\".  HTTP is used in an extremely wide range of scenarios, that include direct connections, a wide array of intermediaries, caches, etc.  RFC 9110 acknowledges a lot of them, provides some mechanisms that are only applicable to specific roles (e.g. Section 7.6 describes mechanisms specific to intermediaries), but ultimately, rather than defining a unified \"HTTP architecture\", it merely describes the common approaches and how they fit together.\r\n\r\nSimilarly, when talking about MoQ, rather than thinking about a single MoQ architecture, I think our work here mostly revolves around creating the building blocks that one can architect the solution they need.  More specifically, we should:\r\n1. Figure out what are the things being exchanged in the protocol (objects/tracks/broadcasts/sessions/object groups/etc) -- this is the *data model*.\r\n1. Provide some common methods of exchanging those objects (direct push, subscriptions) -- this is also the part of the data model, though there is more flexibility around some parts of this being optional.\r\n1. Enumerate the ways in which we expect those to be used, explaining how you build systems made of boxes that speak MoQ, and what those boxes would do with the data items and methods defined above.\r\n\r\nNote that in this scenario, everyone has to understand and implement the first part, but they can only implement the relevant methods and boxes for the architecture they care about.  The only people who have to care about all the possible boxes are people designing the protocol (i.e. us).\r\n\r\n(it's 4am on Saturday, so this is me mostly writing my thoughts on this down before I forget -- I'll almost certainly need to elaborate more at the interim)\r\n\r\n**TL;DR** \"what does MoQ do?\" and \"what does one do with MoQ?\" are two different questions, those should be described in different sections, and relays are mostly an answer to the second question",
          "createdAt": "2023-01-28T09:26:49Z",
          "updatedAt": "2023-01-28T09:26:49Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> > Relays are part of the MoQ architecture. some applications might be totally fine with having no relays but that's not the case for all the applications. Relays might be optional in some architectures and application combinations , in which case the corresponding section of the draft doesn't apply but for the cases where Relays play a role, there is definitely a need for the Relays to understand both the protocol and the data model.\r\n> \r\n> I think we should be careful to distinguish between the MoQ data model and the MoQ architecture.\r\n> \r\n> Let me explain what I mean here, using HTTP as an example. HTTP has a fairly simple data model (the protocol exchanges request/response messages that have a method, a target/status code, some header/trailer fields and a body). It has three wire protocols, all of which are at their heart, just an expression of that data model. But I don't think there really is such a thing as a single \"HTTP architecture\". HTTP is used in an extremely wide range of scenarios, that include direct connections, a wide array of intermediaries, caches, etc. RFC 9110 acknowledges a lot of them, provides some mechanisms that are only applicable to specific roles (e.g. Section 7.6 describes mechanisms specific to intermediaries), but ultimately, rather than defining a unified \"HTTP architecture\", it merely describes the common approaches and how they fit together.\r\n> \r\n> Similarly, when talking about MoQ, rather than thinking about a single MoQ architecture, I think our work here mostly revolves around creating the building blocks that one can architect the solution they need. More specifically, we should:\r\n> \r\n> 1. Figure out what are the things being exchanged in the protocol (objects/tracks/broadcasts/sessions/object groups/etc) -- this is the _data model_.\r\n> 2. Provide some common methods of exchanging those objects (direct push, subscriptions) -- this is also the part of the data model, though there is more flexibility around some parts of this being optional.\r\n> 3. Enumerate the ways in which we expect those to be used, explaining how you build systems made of boxes that speak MoQ, and what those boxes would do with the data items and methods defined above.\r\n> \r\n> Note that in this scenario, everyone has to understand and implement the first part, but they can only implement the relevant methods and boxes for the architecture they care about. The only people who have to care about all the possible boxes are people designing the protocol (i.e. us).\r\n> \r\n> (it's 4am on Saturday, so this is me mostly writing my thoughts on this down before I forget -- I'll almost certainly need to elaborate more at the interim)\r\n> \r\n> **TL;DR** \"what does MoQ do?\" and \"what does one do with MoQ?\" are two different questions, those should be described in different sections, and relays are mostly an answer to the second question\r\n\r\nThe protocol draft is supposed to talk about protocol elements, data model and how the entities (publishers/subscribers/relays) interact to understand the protocol. If we do it in one section or 3 sections , it is up to us , but the spec should address these things to align with the charter. If we don't thjnk that's the case, may be good thing to raise it to the WG ?",
          "createdAt": "2023-01-28T16:11:13Z",
          "updatedAt": "2023-01-28T16:11:13Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Responding to _As player and ingestion client vendors are likely going to constitute the majority of the target audience of this document long-term, I believe the model section should minimize description of parts that are not immediately relevant to them_\r\n\r\nThis might be a good thing to bring to the WG and the list ..",
          "createdAt": "2023-01-29T03:44:16Z",
          "updatedAt": "2023-01-29T03:44:16Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "What's the disposition of this PR in light of the newer one?  Should we close it, or do we intend to iterate on both?",
          "createdAt": "2023-03-06T23:26:37Z",
          "updatedAt": "2023-03-06T23:26:37Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Has this been overtaken by events, such as #121?  Can we close?",
          "createdAt": "2023-04-21T19:07:38Z",
          "updatedAt": "2023-04-21T19:07:38Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5L6-Cn",
          "commit": {
            "abbreviatedOid": "bfbd346"
          },
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-28T02:49:43Z",
          "updatedAt": "2023-01-28T02:49:44Z",
          "comments": [
            {
              "originalPosition": 184,
              "body": "```suggestion\r\nwithin a WarpMediaSession, to request the right granularity of the media \r\n```",
              "createdAt": "2023-01-28T02:49:43Z",
              "updatedAt": "2023-01-28T02:49:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5L6-Dj",
          "commit": {
            "abbreviatedOid": "bfbd346"
          },
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-28T02:50:13Z",
          "updatedAt": "2023-01-28T02:50:14Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "```suggestion\r\n    -  Request media to be delivered everything in group currently being published and \r\n```",
              "createdAt": "2023-01-28T02:50:14Z",
              "updatedAt": "2023-01-28T02:50:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5L6-ZS",
          "commit": {
            "abbreviatedOid": "bfbd346"
          },
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-28T02:57:02Z",
          "updatedAt": "2023-01-28T02:57:03Z",
          "comments": [
            {
              "originalPosition": 221,
              "body": "```suggestion\r\ndifferent quality (4K, HD and SD)\r\n```\r\n4K the highest quality. Sort the quality order from high to low.",
              "createdAt": "2023-01-28T02:57:02Z",
              "updatedAt": "2023-01-28T02:57:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5L6-_5",
          "commit": {
            "abbreviatedOid": "bfbd346"
          },
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-28T03:06:46Z",
          "updatedAt": "2023-01-28T03:06:46Z",
          "comments": [
            {
              "originalPosition": 254,
              "body": "Is Ingest a relay? Is Ingest a publisher side Relay-Edge? By using Relay-edge, are you implying other types of relay such as Relay-Origin/Relay-Central?",
              "createdAt": "2023-01-28T03:06:46Z",
              "updatedAt": "2023-01-28T03:06:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5L6_bY",
          "commit": {
            "abbreviatedOid": "bfbd346"
          },
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-28T03:11:39Z",
          "updatedAt": "2023-01-28T03:11:40Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "What is the relationship between the Media Representation and WarpStream? Do they map 1:1? Looks like the Media Representation URI is a verbose ID corresponding to WarpStreamID.",
              "createdAt": "2023-01-28T03:11:39Z",
              "updatedAt": "2023-01-28T03:11:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5L7S_o",
          "commit": {
            "abbreviatedOid": "bfbd346"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-28T07:16:56Z",
          "updatedAt": "2023-01-28T07:16:57Z",
          "comments": [
            {
              "originalPosition": 254,
              "body": "@VMatrix1900 .. Ingest is a publisher in this context and by Relay-Edge , i meant to indicate the relay at the edge. It might be better to term it as just the Relay as you have noticed",
              "createdAt": "2023-01-28T07:16:57Z",
              "updatedAt": "2023-01-28T07:16:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5L7TWM",
          "commit": {
            "abbreviatedOid": "bfbd346"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-28T07:20:13Z",
          "updatedAt": "2023-01-28T07:20:13Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "Media Representation is application level concept and Warp Stream was the protocol level idea where it represent a flow of media objects for a given representation. The separation was to emphasize the fact that each application has their own way to represent such representations but at the MOQ protocol level, they are uniformly called Warp Streams .. ",
              "createdAt": "2023-01-28T07:20:13Z",
              "updatedAt": "2023-01-28T07:20:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5L7Zbb",
          "commit": {
            "abbreviatedOid": "bfbd346"
          },
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-28T08:51:34Z",
          "updatedAt": "2023-01-28T08:51:35Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "Is the Media Session application level concept or protocol level concept? By data model are we talking about the application level concept or protocol level concept or both?",
              "createdAt": "2023-01-28T08:51:34Z",
              "updatedAt": "2023-01-28T08:51:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5L7rNc",
          "commit": {
            "abbreviatedOid": "3dd5d28"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I agree with Victor. It's very difficult to figure out what you want to address and why. Could you try to break it up into smaller issues/PRs for the sake of discussion?\r\n\r\nMy best guess is:\r\n\r\n1. Rename \"broadcast\" to \"WarpMediaSession\".\r\n2. Add \"Representation\", which is member of a broadcast and contains a single track...?\r\n3. Rename \"track\" to \"WarpMediaStream\"?\r\n4. Add \"WarpObjectsGroup\", which is a member of a track, contains objects, and is independently decodable?\r\n5. Require a globally unique broadcast URL. #70 \r\n6. Add the ability to use an object per slice. #57 \r\n7. Add a sequence number for objects.\r\n8. Add the ability to subscribe starting at a GOP boundary. #52 kinda?\r\n9. Add the ability to subscribe starting at a specific frame?",
          "createdAt": "2023-01-28T14:30:42Z",
          "updatedAt": "2023-01-28T15:02:29Z",
          "comments": [
            {
              "originalPosition": 119,
              "body": "Definitely needs a new name then.",
              "createdAt": "2023-01-28T14:30:42Z",
              "updatedAt": "2023-01-28T15:01:41Z"
            },
            {
              "originalPosition": 87,
              "body": "Did you mean to put this twice?",
              "createdAt": "2023-01-28T14:31:35Z",
              "updatedAt": "2023-01-28T15:01:41Z"
            },
            {
              "originalPosition": 90,
              "body": "I'm really confused too. If representations are an application level concept, why does the protocol care?",
              "createdAt": "2023-01-28T14:35:43Z",
              "updatedAt": "2023-01-28T15:01:42Z"
            },
            {
              "originalPosition": 112,
              "body": "Why not merge the two?",
              "createdAt": "2023-01-28T14:36:51Z",
              "updatedAt": "2023-01-28T15:01:41Z"
            },
            {
              "originalPosition": 115,
              "body": "What is the \"application's Origin server\" in the context of a client like OBS? How does one stream to Facebook or Twitch from their computer?",
              "createdAt": "2023-01-28T14:38:10Z",
              "updatedAt": "2023-01-28T15:01:41Z"
            },
            {
              "originalPosition": 116,
              "body": "There's absolutely no way that you can require something be **_globally unique_** and then say \"figure it out\". If a user installs OBS on their computer, it absolutely needs some mechanism to generate and verify that a broadcast URL is globally unique.",
              "createdAt": "2023-01-28T14:41:01Z",
              "updatedAt": "2023-01-28T15:01:41Z"
            },
            {
              "originalPosition": 151,
              "body": "From what I understand with the other examples, a \"WarpObjectGroup\" is meant to be independently decodable. I don't think the abstraction works for slice-based delivery. \r\n\r\nIMO objects can be independently decodable, or depend on one or more other objects. Trying to group them into individual buckets won't work if a slice depends on multiple slices.",
              "createdAt": "2023-01-28T14:48:48Z",
              "updatedAt": "2023-01-28T15:01:41Z"
            },
            {
              "originalPosition": 155,
              "body": "\"the entire GOP sequence\" is a weird term.",
              "createdAt": "2023-01-28T14:50:05Z",
              "updatedAt": "2023-01-28T15:01:41Z"
            },
            {
              "originalPosition": 166,
              "body": "So a sequence number?",
              "createdAt": "2023-01-28T14:50:32Z",
              "updatedAt": "2023-01-28T15:01:41Z"
            },
            {
              "originalPosition": 176,
              "body": "It's confusing that `MediaObjectId` and `ObjectId` are two different things.",
              "createdAt": "2023-01-28T14:51:48Z",
              "updatedAt": "2023-01-28T15:01:42Z"
            },
            {
              "originalPosition": 176,
              "body": "Also is this meant to be a concatenation?",
              "createdAt": "2023-01-28T14:52:26Z",
              "updatedAt": "2023-01-28T15:01:42Z"
            },
            {
              "originalPosition": 328,
              "body": "What is the origin server?",
              "createdAt": "2023-01-28T14:58:06Z",
              "updatedAt": "2023-01-28T15:01:42Z"
            },
            {
              "originalPosition": 327,
              "body": "Is the idea that both endpoints pre-negotiate the `WarpStreamId`? How does that work with generic clients like OBS, ffmpeg, etc?",
              "createdAt": "2023-01-28T14:58:39Z",
              "updatedAt": "2023-01-28T15:01:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5L7zSa",
          "commit": {
            "abbreviatedOid": "3dd5d28"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-28T16:16:35Z",
          "updatedAt": "2023-01-28T16:16:35Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "> I agree with Victor. It's very difficult to figure out what you want to address and why. Could you try to break it up into smaller issues/PRs for the sake of discussion?\r\n> \r\n> My best guess is:\r\n> \r\n> 1. Rename \"broadcast\" to \"WarpMediaSession\".\r\n> 2. Add \"Representation\", which is member of a broadcast and contains a single track...?\r\n> 3. Rename \"track\" to \"WarpMediaStream\"?\r\n> 4. Add \"WarpObjectsGroup\", which is a member of a track, contains objects, and is independently decodable?\r\n> 5. Require a globally unique broadcast URL. #70\r\n> 6. Add the ability to use an object per slice. #57\r\n> 7. Add a sequence number for objects.\r\n> 8. Add the ability to subscribe starting at a GOP boundary. #52 kinda?\r\n> 9. Add the ability to subscribe starting at a specific frame?\r\n\r\nThat's a good break up.  Thanks\r\nWe need to work on a data model and it needs to be dealt in one place. Splitting across the PRs will just cause more confusions and it's hard to have discussions made coherently. ",
              "createdAt": "2023-01-28T16:16:35Z",
              "updatedAt": "2023-01-29T03:42:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5L7zcN",
          "commit": {
            "abbreviatedOid": "3dd5d28"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-28T16:22:41Z",
          "updatedAt": "2023-01-28T16:22:41Z",
          "comments": [
            {
              "originalPosition": 327,
              "body": "There is no negotiation here. can you provide details on the flow of steps that happens today with these generic clients...",
              "createdAt": "2023-01-28T16:22:41Z",
              "updatedAt": "2023-01-28T16:22:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5L74br",
          "commit": {
            "abbreviatedOid": "3dd5d28"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-28T18:09:19Z",
          "updatedAt": "2023-01-28T18:09:19Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "That should have been 2 different examples. Copy paste error ",
              "createdAt": "2023-01-28T18:09:19Z",
              "updatedAt": "2023-01-28T18:09:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5L749D",
          "commit": {
            "abbreviatedOid": "3dd5d28"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-28T18:27:17Z",
          "updatedAt": "2023-01-28T18:27:17Z",
          "comments": [
            {
              "originalPosition": 327,
              "body": "I guess today publishers will get a URL. This would require a URL (for WebTransport) and another URL for the `WarpStreamId`. Actually aren't there multiple `WarpStreamIds`? Do you need to pre-negotiate one for every rendition?",
              "createdAt": "2023-01-28T18:27:17Z",
              "updatedAt": "2023-01-28T18:27:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5L75QN",
          "commit": {
            "abbreviatedOid": "3dd5d28"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-28T18:38:38Z",
          "updatedAt": "2023-01-28T18:38:39Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "I want to discuss each of these separately. \r\n\r\nA few of them are good changes (6, 7, 8). Some of the changes are up for debate and deserve their own issue, like (1, 4, 5, 9). Some of the changes are just questionable (2, 3) and really just drag the rest of the PR down. \r\n\r\nBut you absolutely don't need to rewrite the object model. It's perfectly acceptable to create a PR that simultaneously amends the object model while adding the corresponding wire format. I really don't think there's a huge discrepancy between the current object model and the one that you're proposing. ",
              "createdAt": "2023-01-28T18:38:38Z",
              "updatedAt": "2023-01-28T18:38:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5L8NBu",
          "commit": {
            "abbreviatedOid": "bfbd346"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-29T04:11:28Z",
          "updatedAt": "2023-01-29T04:11:28Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "Here is what I had in mind, do let me know if it helps or should we adjust it differently.\r\n\r\nEach MoQ application will have their own way to identify publisher media capabilities that list media types, their quality attributes (codec, bitrates and so on). They are typically some sort of textual descriptions. Then for each of those there will be stream of grouped media objects that is actually sent.\r\n\r\nI totally understand the reason why this might cause confusion. It might be better served, it we can just say \r\n\r\n\r\n_Warp Media Streams identify media objects belonging to a publisher's media capability/representation. A given Media Representation, in an application defined way,  identifies capabilities of a publisher's media source(s) within a WarpMediaSession. Representations identifies things such as media source type, codec info, bitrate and other attribute qualities_\r\n\r\nWould something like this work ?",
              "createdAt": "2023-01-29T04:11:28Z",
              "updatedAt": "2023-01-29T04:11:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5L8Oud",
          "commit": {
            "abbreviatedOid": "3dd5d28"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-29T05:16:45Z",
          "updatedAt": "2023-01-29T05:16:45Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "Yeah that won't work. We need to support generic clients. #71\n\nAny information required to broadcast or view needs to be part of the protocol. That can be as simple as specifying container/manifest formats with enough information (so relays can ignore it), but it cannot be left up to the application.",
              "createdAt": "2023-01-29T05:16:45Z",
              "updatedAt": "2023-01-29T05:17:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5MEbMz",
          "commit": {
            "abbreviatedOid": "65ba27a"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-31T00:30:42Z",
          "updatedAt": "2023-01-31T00:40:40Z",
          "comments": [
            {
              "originalPosition": 188,
              "body": "This text appears duplicated with 336-338",
              "createdAt": "2023-01-31T00:30:43Z",
              "updatedAt": "2023-01-31T00:40:40Z"
            },
            {
              "originalPosition": 191,
              "body": "Why out of band?\r\n\r\nAlso, better to use publisher/consumer rather than client/server terminology, since for ingest, the client is the publisher.",
              "createdAt": "2023-01-31T00:33:11Z",
              "updatedAt": "2023-01-31T00:40:40Z"
            },
            {
              "originalPosition": 259,
              "body": "I think there are features/performance that can be unlocked by a \"media gateway\" that does parse the CATALOG, such as the ability for a subscriber to ask the gateway to automatically switch between qualities within a latency bound, but perhaps such a function doesn't need to be considered a \"relay\".",
              "createdAt": "2023-01-31T00:39:26Z",
              "updatedAt": "2023-01-31T00:40:40Z"
            }
          ]
        }
      ]
    },
    {
      "number": 72,
      "id": "PR_kwDOG2Ho4M5IyD44",
      "title": "Data model updates",
      "url": "https://github.com/moq-wg/moq-transport/pull/72",
      "state": "MERGED",
      "author": "wilaw",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Some suggested changes around proposed data model hierarchy, naming, function and operation. ",
      "createdAt": "2023-01-30T06:15:38Z",
      "updatedAt": "2023-01-30T06:19:57Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "data-model",
      "baseRefOid": "3dd5d28e8adb84a28b653dbb41fc3d08da8e3bf0",
      "headRepository": null,
      "headRefName": "data-model",
      "headRefOid": "de61fcef2200847501312bedd5a355b5d65479ad",
      "closedAt": "2023-01-30T06:19:57Z",
      "mergedAt": "2023-01-30T06:19:57Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "9d74db4ab9ac7da4b4d54dc30212472be8d76fc2"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 86,
      "id": "PR_kwDOG2Ho4M5JCgVU",
      "title": "Describe join points",
      "url": "https://github.com/moq-wg/moq-transport/pull/86",
      "state": "CLOSED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a very basic proposal that should allow us to solve the probem of \"how do I join an existing media broadcast\", and, partially, \"how do I seek\", without complexities involved in explicitly spelling out dependencies.",
      "createdAt": "2023-02-01T19:38:31Z",
      "updatedAt": "2023-03-12T16:00:57Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "f90089763f48ef29921988a5c488da7dc6e48935",
      "headRepository": "vasilvv/warp-draft",
      "headRefName": "join-point",
      "headRefOid": "475d12b0b2b92038807704d2c6631a8c1acadcbd",
      "closedAt": "2023-03-12T16:00:57Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "need to think about it . this as object can be useful on its own .. May be call it as StartGroupInfo to be more generic.\r\n\r\nThis along with groupId (instead of being a boolean) will address other use-cases that are not only time based .. ",
          "createdAt": "2023-02-01T21:53:32Z",
          "updatedAt": "2023-02-01T21:53:32Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm fine adding a \"group sequence\" like QuicR. Monotonically incrementing so you can detect gaps when doing frame-based delivery.\r\n\r\nI'm not sure if it actually needs to be in the object model though. I don't think the object model should explain how every minor piece of functionality works.",
          "createdAt": "2023-02-01T22:10:36Z",
          "updatedAt": "2023-02-01T22:11:04Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'm fine adding a \"group sequence\" like QuicR. Monotonically incrementing so you can detect gaps when doing frame-based delivery.\r\n>\r\n@kixelated do you mean adding it to the object header ?\r\n \r\n> I'm not sure if it actually needs to be in the object model though. I don't think the object model should explain how every minor piece of functionality works.\r\n\r\n",
          "createdAt": "2023-02-01T22:19:38Z",
          "updatedAt": "2023-02-01T23:19:30Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "```\r\nOBJECT Message {\r\n  Broadcast URI (b),\r\n  Track ID (i),\r\n  Object ID (i),\r\n  Object Delivery Order (i),\r\n->Group Sequence (i),\r\n  Object Payload (b),\r\n}\r\n```",
          "createdAt": "2023-02-01T23:50:35Z",
          "updatedAt": "2023-02-01T23:50:35Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> ```\r\n> OBJECT Message {\r\n>   Broadcast URI (b),\r\n>   Track ID (i),\r\n>   Object ID (i),\r\n>   Object Delivery Order (i),\r\n> ->Group Sequence (i),\r\n>   Object Payload (b),\r\n> }\r\n> ```\r\n\r\n\r\nthat would work ... to be uniform across the names in there, would something like this be OK\r\n\r\n```\r\nOBJECT Message {\r\n   Broadcast URI (b),\r\n   Track ID (i),\r\n   Object ID (i),\r\n ->Group ID (i), // add text to define its a sequence \r\n   Object Delivery Order (i),\r\n   Object Payload (b),\r\n }\r\n ```\r\n\r\nMay be it should be done in its own PR ??",
          "createdAt": "2023-02-01T23:54:28Z",
          "updatedAt": "2023-02-02T00:20:22Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "It has to be monotonically increasing to detect gaps, so I think \"sequence\"\nis more accurate than ID.\n\nOn Wed, Feb 1, 2023, 3:54 PM Suhas Nandakumar ***@***.***>\nwrote:\n\n> OBJECT Message {\n>   Broadcast URI (b),\n>   Track ID (i),\n>   Object ID (i),\n>   Object Delivery Order (i),\n> ->Group Sequence (i),\n>   Object Payload (b),\n> }\n>\n> that would work ... to be uniform across the names in there, would\n> something like this be OK\n>\n> OBJECT Message {\n>    Broadcast URI (b),\n>    Track ID (i),\n>    Object ID (i),\n>  ->Group ID (i), // add text to define its a sequence\n>    Object Delivery Order (i),\n>    Object Payload (b),\n>  }\n>\n> \u2014\n> Reply to this email directly, view it on GitHub\n> <https://github.com/kixelated/warp-draft/pull/86#issuecomment-1412921124>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AADJVVRF6GOJHJR54GFX3C3WVLZT7ANCNFSM6AAAAAAUOEJXFU>\n> .\n> You are receiving this because you were mentioned.Message ID:\n> ***@***.***>\n>\n",
          "createdAt": "2023-02-02T00:55:29Z",
          "updatedAt": "2023-02-02T00:55:29Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "To elaborate, to me an ID is just unique. There's no concept of ordering between IDs. It's basically an opaque blob that only implements equality.\n\nA sequence on the other hand, is a number that increases over time with each occurrence. It's still unique, but conveys creation order.\n\n\"Object ID\" maaaay also need to be increasing now and renamed to \"Object Sequence\". That's because if I want Object 123 in Group 6, I need to download every Object < 123 in Group 6.\n\nBut I suppose downloading every object in Group 6 would be fine if delivery order is maintained. I would leave it as an ID for now.",
          "createdAt": "2023-02-02T15:22:49Z",
          "updatedAt": "2023-02-02T15:23:19Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "ObjectId is a sequence too. Since being part of a group announces sort of dependency (one is delivery order) and also helps not keeping objectIDs flat.\r\nWhile we are at it, we should go for something like\r\n\r\n```\r\nOBJECT Message {\r\n   Broadcast URI (b),\r\n   Track ID (i),\r\n   Object Sequence (i),\r\n   Group Sequence(i),\r\n   Object Delivery Order (i),\r\n   Object Payload (b),\r\n }\r\n```\r\n\r\nWe can then tackle about the issues that were raised on Broadcast URI field later.",
          "createdAt": "2023-02-02T15:41:35Z",
          "updatedAt": "2023-02-02T15:41:35Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Has this been overtaken by groups?",
          "createdAt": "2023-03-06T23:23:04Z",
          "updatedAt": "2023-03-06T23:23:04Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah Cullen, that's the direction we went. A boolean is more frail during packet loss compared to a sequence number or ID.",
          "createdAt": "2023-03-12T16:00:56Z",
          "updatedAt": "2023-03-12T16:00:56Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5MSGTt",
          "commit": {
            "abbreviatedOid": "475d12b"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "What is a \"join point\"? Do you mean independently decodable?\r\n\r\nAnd it should use a sequence number rather than a boolean to handle packet loss. Basically group ID from QuicR.",
          "createdAt": "2023-02-01T20:25:02Z",
          "updatedAt": "2023-02-01T20:25:02Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5Ponab",
          "commit": {
            "abbreviatedOid": "475d12b"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I think a better way to indicate the start of a new join point is to have the group id and a new group ID indicates , well a new group, which is what we want ",
          "createdAt": "2023-03-12T15:58:19Z",
          "updatedAt": "2023-03-12T15:58:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 89,
      "id": "PR_kwDOG2Ho4M5JH4We",
      "title": "Add object/group sequence",
      "url": "https://github.com/moq-wg/moq-transport/pull/89",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-02-02T15:50:11Z",
      "updatedAt": "2023-02-03T01:35:05Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "f90089763f48ef29921988a5c488da7dc6e48935",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "messages",
      "headRefOid": "371d3bf71630bfecbb4f2b638a60cdbcb3a73187",
      "closedAt": "2023-02-02T19:59:22Z",
      "mergedAt": "2023-02-02T19:59:22Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "c7feeb4777b1dd696e3eac6037eea3e5f84b9954"
      },
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Merging based on in-person discussions.",
          "createdAt": "2023-02-02T19:59:26Z",
          "updatedAt": "2023-02-02T19:59:26Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "You merged a litttttle early. The wire format is good, but the accompanying text could use some tweaks. \r\n\r\nFor example, it's not specified when the object sequence number should be incremented. It must be done on every independently decodable OBJECT.\r\n\r\nI'll make another PR.",
          "createdAt": "2023-02-02T20:23:28Z",
          "updatedAt": "2023-02-02T20:55:36Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5MYY5g",
          "commit": {
            "abbreviatedOid": "4bd3b11"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-02T16:50:32Z",
          "updatedAt": "2023-02-02T16:50:33Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Please indicate that group sequence numbers are scoped to the track.",
              "createdAt": "2023-02-02T16:50:32Z",
              "updatedAt": "2023-02-02T16:50:33Z"
            }
          ]
        }
      ]
    },
    {
      "number": 90,
      "id": "PR_kwDOG2Ho4M5JJj1e",
      "title": "Add some clarification for group sequence.",
      "url": "https://github.com/moq-wg/moq-transport/pull/90",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We might need more text but I'm about to jump on a plane.\r",
      "createdAt": "2023-02-02T21:19:36Z",
      "updatedAt": "2023-04-26T18:54:16Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "c7feeb4777b1dd696e3eac6037eea3e5f84b9954",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "group-clarification",
      "headRefOid": "d2c2b4b0f5ed509094aa9dd718aec4bfc4afc54a",
      "closedAt": "2023-04-26T18:54:16Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@kixelated  I will send the review feedback in couple of days. Thanks ",
          "createdAt": "2023-04-01T11:13:22Z",
          "updatedAt": "2023-04-01T11:13:22Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Has this been overtaken by events?",
          "createdAt": "2023-04-21T19:08:27Z",
          "updatedAt": "2023-04-21T19:08:27Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> Has this been overtaken by events?\r\n\r\nI think so. ",
          "createdAt": "2023-04-21T23:16:26Z",
          "updatedAt": "2023-04-21T23:16:26Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5Mf6wa",
          "commit": {
            "abbreviatedOid": "67ed010"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-03T17:45:41Z",
          "updatedAt": "2023-02-03T17:45:42Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Does it need to be incremented **by one** or any increment is ok?",
              "createdAt": "2023-02-03T17:45:41Z",
              "updatedAt": "2023-02-03T17:45:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5MgGAd",
          "commit": {
            "abbreviatedOid": "67ed010"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-03T18:11:08Z",
          "updatedAt": "2023-02-03T18:11:09Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "I think any number is fine, so long as it increases. It gives the receiver less information about the number of GoPs (which it doesn't need to know) but it lets the sender insert discontinuities.\r\n\r\nI don't think we could enforce +1 anyway since OBJECTs can be lost. The receiver needs to be prepared for gaps.",
              "createdAt": "2023-02-03T18:11:09Z",
              "updatedAt": "2023-02-03T18:41:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PHhKq",
          "commit": {
            "abbreviatedOid": "67ed010"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T23:19:53Z",
          "updatedAt": "2023-03-06T23:21:16Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Is the MUST too strong here, would MAY suffice?  eg: even if I'm kicking off a new OBJECT and its independently decodable, can I keep the same group for my own reasons?",
              "createdAt": "2023-03-06T23:19:53Z",
              "updatedAt": "2023-03-06T23:21:17Z"
            },
            {
              "originalPosition": 15,
              "body": "Do you also need to say it starts with 0 at the beginning of the group?",
              "createdAt": "2023-03-06T23:21:11Z",
              "updatedAt": "2023-03-06T23:21:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PonVy",
          "commit": {
            "abbreviatedOid": "67ed010"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-12T15:56:19Z",
          "updatedAt": "2023-03-12T15:56:20Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I don't think I get why this is changing - the original text seems fine. ",
              "createdAt": "2023-03-12T15:56:20Z",
              "updatedAt": "2023-03-12T15:56:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PpDB_",
          "commit": {
            "abbreviatedOid": "67ed010"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T02:23:57Z",
          "updatedAt": "2023-03-13T02:23:57Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Yeah I'll loosen the text a bit.\r\n\r\nThis PR is aimed at giving group some properties. As it currently exists, being a member of a group means absolutely nothing, and the relay can't use this information for the intended purpose.",
              "createdAt": "2023-03-13T02:23:57Z",
              "updatedAt": "2023-03-13T02:23:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PpJSN",
          "commit": {
            "abbreviatedOid": "c0079ca"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T02:58:49Z",
          "updatedAt": "2023-03-13T02:58:49Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "@suhasHere Feel free to overwrite this. I wanted to give an example of how I would phrase it.",
              "createdAt": "2023-03-13T02:58:49Z",
              "updatedAt": "2023-03-13T02:58:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PuIL7",
          "commit": {
            "abbreviatedOid": "c0079ca"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T16:36:48Z",
          "updatedAt": "2023-03-13T16:39:12Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Since Group ID doesn't appear optional (all objects must be in a group), Group ID indicates the group this object belongs to.",
              "createdAt": "2023-03-13T16:36:48Z",
              "updatedAt": "2023-03-13T16:39:12Z"
            },
            {
              "originalPosition": 33,
              "body": "s/scoped to/must be unique within/?",
              "createdAt": "2023-03-13T16:37:29Z",
              "updatedAt": "2023-03-13T16:39:12Z"
            },
            {
              "originalPosition": 45,
              "body": "Do we need explanation of why delivery order can be different that sequence?  Is delivery order scoped to a group, track, or a session?",
              "createdAt": "2023-03-13T16:38:59Z",
              "updatedAt": "2023-03-13T16:39:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PvIPo",
          "commit": {
            "abbreviatedOid": "c0079ca"
          },
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T18:57:11Z",
          "updatedAt": "2023-03-13T18:57:12Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "should this be object sequence? Or \"sequence within a group\"?",
              "createdAt": "2023-03-13T18:57:11Z",
              "updatedAt": "2023-03-13T18:57:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PvIwY",
          "commit": {
            "abbreviatedOid": "c0079ca"
          },
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T18:58:40Z",
          "updatedAt": "2023-03-13T18:58:40Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "> but only within the same group and with a smaller sequence number.\r\n\r\nwhat about B-frames?",
              "createdAt": "2023-03-13T18:58:40Z",
              "updatedAt": "2023-03-13T18:58:40Z"
            }
          ]
        }
      ]
    },
    {
      "number": 91,
      "id": "PR_kwDOG2Ho4M5JJv5s",
      "title": "Replace \"Warp session\" with \"Warp connection\"",
      "url": "https://github.com/moq-wg/moq-transport/pull/91",
      "state": "CLOSED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It turns out that \"session\" here is ambiguous, since in some contexts, it can be interpreted as an entity that exists across multiple hops, which is not the intention here.\r\n\r\nThis keeps \"WebTransport session\" as-is, since that is a terminology used by the WebTransport draft.",
      "createdAt": "2023-02-02T22:02:13Z",
      "updatedAt": "2023-04-21T17:10:31Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "c7feeb4777b1dd696e3eac6037eea3e5f84b9954",
      "headRepository": "vasilvv/warp-draft",
      "headRefName": "session",
      "headRefOid": "91cb621f21d6b3782cadc11a1dc6c05061319e82",
      "closedAt": "2023-04-21T17:10:31Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't love having a \"warp connection\" inside a \"webtransport session\", since I think that may cause other confusion. However if other folks are comfortable with it, go ahead.",
          "createdAt": "2023-02-03T18:22:54Z",
          "updatedAt": "2023-02-03T18:22:54Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah I agree with Alan, I actually think this is slightly more confusing in the hop-to-hop case and even more confusing in the end-to-end case. A Warp connection could outlive a QUIC connection..?\r\n\r\nI would say we first settle on if a Warp session can outlive a WebTransport session (resumption?). And if so, find a new name that is not connection or session.",
          "createdAt": "2023-02-03T18:44:22Z",
          "updatedAt": "2023-02-03T20:11:04Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Abandon in favor of text in #135.",
          "createdAt": "2023-04-21T17:10:29Z",
          "updatedAt": "2023-04-21T17:10:29Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 92,
      "id": "PR_kwDOG2Ho4M5JqA8U",
      "title": "Congestion response by groups and priorities.",
      "url": "https://github.com/moq-wg/moq-transport/pull/92",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Please do not merge this! For review only.",
      "createdAt": "2023-02-09T21:00:18Z",
      "updatedAt": "2023-02-09T21:00:28Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "c7feeb4777b1dd696e3eac6037eea3e5f84b9954",
      "headRepository": null,
      "headRefName": "congestion-response",
      "headRefOid": "103be617a0d0acddce01faef00c52b6bc2377c13",
      "closedAt": "2023-02-09T21:00:28Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 93,
      "id": "PR_kwDOG2Ho4M5J5tpe",
      "title": "Congestion response by groups and priorities.",
      "url": "https://github.com/moq-wg/moq-transport/pull/93",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is a PR to address issue #58. It presents how markings of groups can be used for congestion responses, and introduces a potential discussion of submarkings within groups.",
      "createdAt": "2023-02-14T01:30:30Z",
      "updatedAt": "2023-04-27T18:29:22Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "903daa528293df746a96f58bfef7df438a8e617a",
      "headRepository": null,
      "headRefName": "congestion-response",
      "headRefOid": "141934315549a835930db07b42bfc54172d88e9a",
      "closedAt": "2023-04-27T18:29:22Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "@huitema Do we still want to merge this PR, along with some text indicating lack of consensus around #139, or should we close and start a new one.",
          "createdAt": "2023-04-21T19:10:00Z",
          "updatedAt": "2023-04-21T19:10:00Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@afrind I would like to first merge the main branch into that PR branch, to check whether the proposed changes are at the right place. For example, we have work in progress on PR #106 -- can we get that one checked first? Based on that, I would decide whether the most convenient is to update this PR or create a new one.",
          "createdAt": "2023-04-21T19:23:00Z",
          "updatedAt": "2023-04-21T19:23:00Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5Nai6n",
          "commit": {
            "abbreviatedOid": "70405bd"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-15T05:04:28Z",
          "updatedAt": "2023-02-15T05:04:28Z",
          "comments": [
            {
              "originalPosition": 74,
              "body": "Thanks for bringing these points.  having a priority specified by the application, say , p-frames within a group are less important to b-frames or some other application specified way to define the intra-priorities will give applications flexibility in defining the experiences.\r\n\r\n",
              "createdAt": "2023-02-15T05:04:28Z",
              "updatedAt": "2023-02-15T05:04:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5NaoyT",
          "commit": {
            "abbreviatedOid": "70405bd"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This PR is a good start in the direction. Have some suggestions.",
          "createdAt": "2023-02-15T05:40:13Z",
          "updatedAt": "2023-02-15T05:41:53Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "I think this assumes - one stream per gop - based application grouping. I think the base moq transport should be flexible to allow different media groupings as observed in #69 .\r\n\r\nMore specifically, following are being floated around, but not the only ones\r\n- one gop per stream ==> one group has all the video frames  forming a gop and they all go in a single QUIC Stream\r\n- one video frame per stream ==> a single QUIC Stream carries a single frame as the Media Object. If the applications wants to group set of video frames under a single group, then all the media objects carry same groupid but can be transported over multiple QUIC streams. \r\n\r\nI would probably phrase the proposed change as \r\n\r\n **For exchanging media, OBJECT messages belonging to a group are delivered over one or more unidirectional streams based on application's preferred mapping of the OBJECt's group to underlying QUIC Stream(s).**\r\n\r\n\r\n",
              "createdAt": "2023-02-15T05:40:13Z",
              "updatedAt": "2023-02-15T05:41:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Nmpu6",
          "commit": {
            "abbreviatedOid": "70405bd"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-16T17:41:54Z",
          "updatedAt": "2023-02-16T19:00:40Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Plus we don't want relays to be codec dependent.",
              "createdAt": "2023-02-16T17:42:40Z",
              "updatedAt": "2023-02-16T19:00:40Z"
            },
            {
              "originalPosition": 15,
              "body": "More broadly, media is dropped at the network level when the encoder or ABR is too slow to adapt. Relays do actually perform ABR, except it's driven by the viewers who can't tell the source of the congestion.",
              "createdAt": "2023-02-16T17:50:58Z",
              "updatedAt": "2023-02-16T19:00:40Z"
            },
            {
              "originalPosition": 58,
              "body": "We should talk about this more offline. The frequent tail drop phenomena is very real but I think it's may be due to a small receiver buffer.\r\n\r\nWhen frames are round-robined, the I-frame (ex. 2 RTTs) will be slightly delayed because it's competing with other frames for bandwidth (ex. actually takes 3 RTTs). The receiver jitter buffer should be sized based on the I-frame arrival delay since it will be the most latent frame.\r\n\r\nWhen frames are prioritized, the I-frame will actually be delivered sooner (ex. 2 RTTs), at the expense of other frames (ex. normally 1 RTT, now 3RTTs). The receiver jitter buffer should not be sized on the I-frame any longer, but I think the net result is the same (ex. 3 RTTs).\r\n\r\nThis absolutely requires a whiteboard. I'm not convinced that the net result is the same, but I'd like some proof that we can't use a simple priority queue.",
              "createdAt": "2023-02-16T18:24:56Z",
              "updatedAt": "2023-02-16T19:00:40Z"
            },
            {
              "originalPosition": 60,
              "body": "Could these objects be part of a different GROUP instead? I really like the concept of SVC layers mapping to QUIC streams, and I consider non-reference frames as a temporal SVC layer.",
              "createdAt": "2023-02-16T18:26:45Z",
              "updatedAt": "2023-02-16T19:00:40Z"
            },
            {
              "originalPosition": 83,
              "body": "OBJECTs can be more than one frame and you _should_ only split OBJECTs into smaller pieces if you plan on delivering them independently, ie. over separate streams. I don't think we should rule out multiple OBJECTs per stream, but it's not the intended use-case either.\r\n\r\nMy intention was that OBJECT = \"one or more frames that depend on each other\". Well technically it went through a bunch of different names, like FRAGMENT and LAYER. I think OBJECT and GROUP should be merged, and I like the name GROUP because it implies multiple frames are possible.\r\n\r\nLet's say GROUP is a collection of frames and a GROUP could depend on another GROUP. References frames can be in their own GROUP while non-reference frames could be in separate GROUP(s) that depend on the base group. Priorities are defined at the GROUP level, and each GROUP is sent over it's own stream so you can actually prioritize/drop.\r\n\r\nBasically SVC layer = GROUP.",
              "createdAt": "2023-02-16T18:40:57Z",
              "updatedAt": "2023-02-16T19:00:41Z"
            },
            {
              "originalPosition": 68,
              "body": "First off, \"dropping\" is exclusive to real-time latency. It makes that assumption that the relay knows about the latency budget of all downstream viewers, which true for real-time media (can't go above 300ms) but absolutely not true for other use-cases.\r\n\r\nWarp solves this by starving media rather than dropping. The receiver jitter buffer is ultimately what decides when a frame should be dropped. Streams can be reset to save resources, but it's not intended as a response to congestion.\r\n\r\nIt's a minor point, but I want to be clear that there's no deadline to deliver a frame. A viewer in brazil on a cell phone should still be able to watch a broadcast with higher latency.\r\n\r\n--\r\n\r\nSecond off, I want relays to be deterministic. We don't relay A to decide to drop some frame after 300ms, while relay B decides to drop different frames after 3s. My experience with WebRTC is that every library/hop has custom business logic and uses a different strategy to deal with congestion that doesn't always mesh. It's also why you get a poor experience when you mix protocols with different latency strategy, like WebRTC+HLS or RTMP+WebRTC.\r\n\r\nWarp solves this by using a simple priority queue. It's a strict scheme so relays can easily implement it and there's no ambiguity. I think we could make it more complicated, like priorities could change over time, but it still needs to be simple enough to implement to actually be useful. \r\n\r\nAka we need to avoid HTTP/2 prioritization.",
              "createdAt": "2023-02-16T18:56:04Z",
              "updatedAt": "2023-02-16T19:00:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5NoH6Q",
          "commit": {
            "abbreviatedOid": "70405bd"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-16T22:13:48Z",
          "updatedAt": "2023-02-16T22:13:48Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "We always mix data model and transport semantics. This confuses the design of the protocol.\r\n\r\nThe Data Model PR was created to help separate these two.\r\n\r\nHere is how I was thinking the data model and transport semantics map\r\n\r\nA Track is made up of group of objects. Grouping allows semantics on how these objects can be grouped to provided the necessary properties\r\nI\r\n\r\nFor video use-cases\r\n An object is a video frame or smaller, say a slice.\r\n  In the pure WARP world, a group is a GOP and objects (video frame) belonging to a group are transmitted over a single QUIC Stream. Here GOP acts as IDR sync point too.\r\n\r\n  In the pure RUSH world, an object (video frame is  transmitted in its own QUIC Streams. If the grouping semantics is IDR Sync point, then objects are tagged with the groupId of the current GOP.  If there are other grouping semantics they can be tagged/grouped appropriately. Regardless of grouping, the RUSH mode always sends each encoded video object in its own stream.\r\n",
              "createdAt": "2023-02-16T22:13:48Z",
              "updatedAt": "2023-02-16T22:13:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5NoT21",
          "commit": {
            "abbreviatedOid": "70405bd"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-16T23:03:45Z",
          "updatedAt": "2023-02-16T23:03:45Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Relays cannot perform ABR if the object contents are encrypted, or if the relay does not know what codec is used.",
              "createdAt": "2023-02-16T23:03:45Z",
              "updatedAt": "2023-02-16T23:03:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5NoUAW",
          "commit": {
            "abbreviatedOid": "70405bd"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-16T23:04:26Z",
          "updatedAt": "2023-02-16T23:04:26Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Yes. I will try to add text for that.",
              "createdAt": "2023-02-16T23:04:26Z",
              "updatedAt": "2023-02-16T23:04:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5NoV6O",
          "commit": {
            "abbreviatedOid": "70405bd"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-16T23:11:45Z",
          "updatedAt": "2023-02-16T23:11:45Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "@kixelated you are envisaging a form of hierarchical encoding in which different encoding layers are sent on different QUIC streams. In theory that's very interesting -- hierarchical encoding is indeed a way to deal with large fan-out \"locally\". This is in fact very similar to what I am describing here with intra-stream drop priorities, with each drop priority corresponding to a layer of the encoding. Then there is the mapping to QUIC streams. Yes, we could go to \"one object == one stream\". But if we do multiple objects per streams, relays can still adapt, by deciding which objects to add to the stream and which ones to drop.",
              "createdAt": "2023-02-16T23:11:45Z",
              "updatedAt": "2023-02-16T23:11:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5NoWHX",
          "commit": {
            "abbreviatedOid": "70405bd"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-16T23:12:49Z",
          "updatedAt": "2023-02-16T23:12:49Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "Gropus are about synchronization, restart points, etc. We need something finer grain for traffic adaptation in real time conferences.",
              "createdAt": "2023-02-16T23:12:49Z",
              "updatedAt": "2023-02-16T23:12:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5NoYFR",
          "commit": {
            "abbreviatedOid": "70405bd"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-16T23:23:27Z",
          "updatedAt": "2023-02-16T23:23:27Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "Let's mark this for discussion. Yes, we should probably have some controlling parameter, probably by track, because different applications will have different latency goals. On the drop versus starve, I see them as variations. Starving pushes the decision to the network, based on priorities and scheduling in the transport stack. Dropping allows relays to make decisions locally. Matter of taste...\r\n\r\nAlso, for relays, we have to consider that some connections will carry multiple media streams, with different media stream. Think for example of the relay sending data to the next relay in Lower Elbonia. The satellite link to Lower Elbonia is congested. How does the relay decide which traffic to drop? Are the priorities absolute, valid across multiple origins, or relative?",
              "createdAt": "2023-02-16T23:23:27Z",
              "updatedAt": "2023-02-16T23:23:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5NoYgR",
          "commit": {
            "abbreviatedOid": "70405bd"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-16T23:25:54Z",
          "updatedAt": "2023-02-16T23:25:54Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "I think all this pushes us towards \"one object per QUIC stream\" for MoQ. But then we are getting an issue of ordering, and also of drop decisions.",
              "createdAt": "2023-02-16T23:25:54Z",
              "updatedAt": "2023-02-16T23:25:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5NpMzp",
          "commit": {
            "abbreviatedOid": "70405bd"
          },
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-17T03:24:06Z",
          "updatedAt": "2023-02-17T03:24:06Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Relay can perform the ABR if it knows the version of the video object(group size) and the sync points(group boundary). ",
              "createdAt": "2023-02-17T03:24:06Z",
              "updatedAt": "2023-02-17T03:24:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5NpNFz",
          "commit": {
            "abbreviatedOid": "70405bd"
          },
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-17T03:26:27Z",
          "updatedAt": "2023-02-17T03:26:27Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "I agree that the relay needs to be deterministic. ",
              "createdAt": "2023-02-17T03:26:27Z",
              "updatedAt": "2023-02-17T03:26:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5NpX33",
          "commit": {
            "abbreviatedOid": "70405bd"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-17T04:53:50Z",
          "updatedAt": "2023-02-17T04:53:50Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "If in the WARP mode, it is one gop per QUIC Stream as I mentined here\r\n\r\nIn the pure WARP world, a group is a GOP and objects (video frame) belonging to a group are transmitted over a single QUIC Stream. Here GOP acts as IDR sync point too.\r\n\r\nFor RUSH like delivery, it is one object per QUIC Stream\r\n\r\nIt is application choice on how they want to send it and the transport should expose the needed tools",
              "createdAt": "2023-02-17T04:53:50Z",
              "updatedAt": "2023-02-17T04:53:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5NukNs",
          "commit": {
            "abbreviatedOid": "70405bd"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-17T18:53:44Z",
          "updatedAt": "2023-02-17T18:53:45Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "I am applying that change.",
              "createdAt": "2023-02-17T18:53:44Z",
              "updatedAt": "2023-02-17T18:53:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Nu0DP",
          "commit": {
            "abbreviatedOid": "44a1bba"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "The PR looks is headed in the right direction and is a good starting point to carry out further discussions.",
          "createdAt": "2023-02-17T19:50:32Z",
          "updatedAt": "2023-02-17T19:50:32Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5N-nLP",
          "commit": {
            "abbreviatedOid": "44a1bba"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-21T22:28:34Z",
          "updatedAt": "2023-02-21T23:00:31Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Note that this assumes that the responsibility for picking the version of the stream is on the receiver, which is not something we may necessarily always want, since the sender can typically react faster to the network congestion than the receiver would.",
              "createdAt": "2023-02-21T22:28:35Z",
              "updatedAt": "2023-02-21T23:00:31Z"
            },
            {
              "originalPosition": 16,
              "body": "Note that while this PR talks about dropping media, dropping is not the only congestion response mechanism available here, e.g. the current draft focuses a lot on prioritization.  The text should probably reflect that.",
              "createdAt": "2023-02-21T22:37:48Z",
              "updatedAt": "2023-02-21T23:00:31Z"
            },
            {
              "originalPosition": 13,
              "body": "I'm not sure I understand this sentence.  I thought the congestion response was primarily about the change in network conditions -- not sure what \"excess load\" has to do with that.",
              "createdAt": "2023-02-21T22:39:04Z",
              "updatedAt": "2023-02-21T23:00:31Z"
            },
            {
              "originalPosition": 76,
              "body": "One thing to keep in mind is that we should be able to know or infer the priority of an object without having it always available.  E.g. if we have a single \"droppable\" bit, and we have a sequence\r\n\r\n10 non-droppable\r\n11 droppable\r\n12 non-droppable\r\n\r\nthen the receiver should be able to know that 10 and 12 alone are sufficient without having access to 11's header.",
              "createdAt": "2023-02-21T22:58:48Z",
              "updatedAt": "2023-02-21T23:00:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5OmIOz",
          "commit": {
            "abbreviatedOid": "70405bd"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-28T20:58:42Z",
          "updatedAt": "2023-02-28T20:58:42Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "Okay, so let's say that OBJECTs within a GROUP depend on all previous OBJECTs in the group, based on sequence number. The intention is to inform a relay about all prior dependencies required to deliver the most recent frame primarily for startup.\r\n\r\nThis is a QUIC stream but with extra steps. It is objectively better to send OBJECTs within the same GROUP over the same QUIC stream so relays and applications can delegate reordering to the QUIC library.\r\n\r\nI think @huitema wants to tweak the definition of a GROUP to say that OBJECTs depend on _some_ OBJECTS within the same GROUP, which would break this. Specifically, non-reference frames within a group can be dropped. This effectively creates a hierarchy of GROUP, SUBGROUP, and OBJECT.\r\n\r\nMy intention with the combined Warp draft was to combine all three into a single OBJECT type. I think that's possible.",
              "createdAt": "2023-02-28T20:58:42Z",
              "updatedAt": "2023-02-28T21:01:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5OmL__",
          "commit": {
            "abbreviatedOid": "70405bd"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-28T21:09:34Z",
          "updatedAt": "2023-02-28T21:09:34Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "I want to distance ourselves from the notion that OBJECT = frame or OBJECT = GoP depending on the \"mode\".\r\n\r\nAn OBJECT is a deliverable unit. It's media bundled together with instructions for a relay. An encoder will split media into multiple OBJECTs if it wants certain properties during congestion. That's it.",
              "createdAt": "2023-02-28T21:09:34Z",
              "updatedAt": "2023-02-28T21:09:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5OmZxq",
          "commit": {
            "abbreviatedOid": "70405bd"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-28T21:31:14Z",
          "updatedAt": "2023-02-28T21:31:14Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "that's exactly my point .. its application's choice on how to divide things into groups and objects and only the end points need to know about that.  My point above was, this draft shouldn't say there is only one way to do so either.  ",
              "createdAt": "2023-02-28T21:31:14Z",
              "updatedAt": "2023-02-28T21:34:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Omc3f",
          "commit": {
            "abbreviatedOid": "70405bd"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-28T21:39:26Z",
          "updatedAt": "2023-02-28T21:39:27Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "> My intention with the combined Warp draft was to combine all three into a single OBJECT type. I think that's possible.\r\n\r\nI think letting application define the grouping of objects provide many useful functionalities on how they want to group objects and how such a grouping maps to transport options and also keeps the transport media application generic. I think @huitema's priorities are useful when multiple objects are grouped together because certain applications thinks such a grouping is beneficial, then can you provide some additional information for the relays to control the granularity for better congestion response.",
              "createdAt": "2023-02-28T21:39:27Z",
              "updatedAt": "2023-02-28T21:41:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5OnjIe",
          "commit": {
            "abbreviatedOid": "70405bd"
          },
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-01T03:35:28Z",
          "updatedAt": "2023-03-01T03:35:29Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "> that's exactly my point .. its application's choice on how to divide things into groups and objects and only the end points need to know about that. My point above was, this draft shouldn't say there is only one way to do so either.\r\n\r\nI agree. The data model is the interface between the application and the MoQ protocol. It only defines how objects are organised and how they are related to each other. With a clear relationship defined, different applications can determine how their data is mapped to different objects/groups. The draft can list a few usage examples.",
              "createdAt": "2023-03-01T03:35:28Z",
              "updatedAt": "2023-03-01T03:35:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5OtQ9A",
          "commit": {
            "abbreviatedOid": "70405bd"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-01T19:28:28Z",
          "updatedAt": "2023-03-01T19:28:28Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "GROUP is a useful property for a relay because it defines dependencies. The relay should deliver OBJECT 1 and OBJECT 2 before OBJECT 3 within GROUP A. Warp uses streams to transparently declare and enforce that dependency, but I'll bring that particular topic to the list.\r\n\r\nHowever SUBGROUP, or whatever you want to call it, actually weakens GROUP. Now it's situational if OBJECT 1 and OBJECT 2 should be delivered before OBJECT 3, and even worse it's vague. \r\n\r\nLet's suppose that OBJECT 2 is a non-reference frames and is marked with a lower priority. During congestion, the relay could decide to drop/starve OBJECT 2 in favor of sending OBJECT 3 based on some bespoke business logic.\r\n\r\nHowever, that's dependent on the relay knowing about OBJECT 2. If it hasn't received the object yet, which would be common during any upstream congestion, then it won't know that it's a non reference frame.\r\n\r\nFaced with this gap of unknown proportions, the relay has to make a logical leap and decide to transmit OBJECT 3 without knowing if it depends on OBJECT 2. If OBJECT 2 was a reference frame and OBJECT 3 is not decodable, then we may have wasted limited bandwidth during congestion.",
              "createdAt": "2023-03-01T19:28:28Z",
              "updatedAt": "2023-03-01T20:04:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5O2oQ9",
          "commit": {
            "abbreviatedOid": "44a1bba"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-03T00:32:23Z",
          "updatedAt": "2023-03-03T00:37:32Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Yeah, this is an overly pedantic comment so ignore me.",
              "createdAt": "2023-03-03T00:32:23Z",
              "updatedAt": "2023-03-03T00:37:32Z"
            },
            {
              "originalPosition": 60,
              "body": "Yeah, I'm going to drop the \"everything should be a stream/group\" idea for now. It's a potential simplification that can wait until we're much further along and everything actually works.",
              "createdAt": "2023-03-03T00:36:25Z",
              "updatedAt": "2023-03-03T00:37:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5O3EbT",
          "commit": {
            "abbreviatedOid": "70405bd"
          },
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-03T03:45:21Z",
          "updatedAt": "2023-03-03T03:45:21Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "i would really want to be able to build relay that can do ABR, but that doesnt need to decrypt media payload",
              "createdAt": "2023-03-03T03:45:21Z",
              "updatedAt": "2023-03-03T03:45:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5O3Eno",
          "commit": {
            "abbreviatedOid": "44a1bba"
          },
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-03T03:46:54Z",
          "updatedAt": "2023-03-03T03:46:55Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "and one of such responses should be ABR",
              "createdAt": "2023-03-03T03:46:54Z",
              "updatedAt": "2023-03-03T03:46:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PHflm",
          "commit": {
            "abbreviatedOid": "44a1bba"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T23:15:46Z",
          "updatedAt": "2023-03-06T23:17:08Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "@vasilvv I'm confused -- does the receiver have the metadata about 11 that indicates that it's droppable?  Or does it only have 10 and 12 and know they are non-droppable?",
              "createdAt": "2023-03-06T23:15:46Z",
              "updatedAt": "2023-03-06T23:17:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PonMB",
          "commit": {
            "abbreviatedOid": "44a1bba"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-12T15:52:00Z",
          "updatedAt": "2023-03-12T15:52:00Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I think it still means network load in this case. So relay is has 10 mbps stream coming in for a given track and is fanning it out to two users A and B. A can easily take the 10 mbps but th link to B is temporarily congested and can only take 5 mbps. Relay can't send 10 down that link to B and has to do something. ",
              "createdAt": "2023-03-12T15:52:00Z",
              "updatedAt": "2023-03-12T15:52:00Z"
            }
          ]
        }
      ]
    },
    {
      "number": 94,
      "id": "PR_kwDOG2Ho4M5J_5Zo",
      "title": "Data model",
      "url": "https://github.com/moq-wg/moq-transport/pull/94",
      "state": "MERGED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is a PR to propose changes in the data model PR.\r\n\r\nLargely work in progress, but I wanted to first propose an organization.",
      "createdAt": "2023-02-15T04:00:39Z",
      "updatedAt": "2023-02-17T05:02:16Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "data-model",
      "baseRefOid": "65ba27a87ab4ed781c250a714909238f50c95f42",
      "headRepository": null,
      "headRefName": "data-model",
      "headRefOid": "0139f789ccd32a1ddc78c5466b45d5f80ad671f8",
      "closedAt": "2023-02-17T05:02:16Z",
      "mergedAt": "2023-02-17T05:02:16Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "74ad3b49d3110e3d4f418e41484b07a1fc6a8752"
      },
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "The introductory text seems clear to me.  I have questions about what it means for an object to be 'atomic' - since it can necessarily be larger than an MTU it might not get delivered.  It can be repaired of course, but what are the consequences to other objects in the group or track if the object never completely arrives?  Are there restrictions on receivers attempting to use partial objects?  This reader is excited to read the next chapter :D ",
          "createdAt": "2023-02-16T01:23:23Z",
          "updatedAt": "2023-02-16T01:23:23Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@afrind The main consequence of \"atomic\" is that it is way better to send one complete object than two incomplete objects. That should very much guide scheduling of transmissions at relays. The other consequence is that if publisher can split a big blob of data into several objects that can be processed independently, they should. For example, instead of sending \"the entire GOB as an object\", they would get better results sending the GOB as a series of objects, with each object boundary becoming a proper \"cut mark\". And yes, I have to develop the text. I checked in a partial PR to Suhas' PR, mostly to test my editing chain...",
          "createdAt": "2023-02-16T02:21:46Z",
          "updatedAt": "2023-02-16T02:21:46Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "thanks Christian for detailed text. I will merge it into my branch and do an updated version based on this.",
          "createdAt": "2023-02-17T05:01:53Z",
          "updatedAt": "2023-02-17T05:01:53Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 95,
      "id": "PR_kwDOG2Ho4M5KkcJf",
      "title": "Updated: Data Model and Relay (Post Interim Updates)",
      "url": "https://github.com/moq-wg/moq-transport/pull/95",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR combines #69 and #67. \r\n\r\n1. Data Model has been updated to keep tracks as the central concept for Moq Transport to reflect the direction of discussions at the interim\r\n\r\n2. Reflect on the some of the points being discussed on the identifiers email started by Ted Hardie (https://mailarchive.ietf.org/arch/msg/moq/UqG0nPGOB3lZVzBaKox2MK9TeZY/)\r\n\r\n3.  Merged relay PR into a single PR since data model and relays depend on each other and keeping it separate added more confusion.\r\n\r\nCo-authored by Christian Huitema, Will Law (from #69 ) and thanks to inputs from interim participants and reviewers of the Original PRs  (kixelated, Vmatrix1900, vasilvv, wilaw, fluffy, afrind, xfdy, gwendalsimon, specerDawkins)\r\n\r\n\r\n\r\nThanks ",
      "createdAt": "2023-02-23T03:35:55Z",
      "updatedAt": "2023-05-05T16:57:20Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "c7feeb4777b1dd696e3eac6037eea3e5f84b9954",
      "headRepository": "suhasHere/warp-draft",
      "headRefName": "dm-relays-interim",
      "headRefOid": "20371d110e3e50cac5d6bc9a2da975c7564968a6",
      "closedAt": "2023-05-05T16:57:20Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you for writing this up!  This looks promising.\r\n\r\nI'll try to finish my review comments on Monday, but before that, I wanted to ask for a few things that should simplify reviewing this (as the PR is quite large as it currently is):\r\n(1) Could we have the description of how things are named/identified be split into its own section (maybe as subsection of the model section)?\r\n(2) Could this be split into the multiple PRs?  If not, that's fine, but usually splitting things makes them easier to merge.",
          "createdAt": "2023-02-26T23:42:34Z",
          "updatedAt": "2023-02-26T23:42:34Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> Thank you for writing this up! This looks promising.\r\n> \r\n> I'll try to finish my review comments on Monday, but before that, I wanted to ask for a few things that should simplify reviewing this (as the PR is quite large as it currently is): (1) Could we have the description of how things are named/identified be split into its own section (maybe as subsection of the model section)? (2) Could this be split into the multiple PRs? If not, that's fine, but usually splitting things makes them easier to merge.\r\n\r\n@vasilvv on splitting in to multiple PRs. I am happy to do so, as that was how it was done originally. But there was a confusion on using terminology between the PRs and I heard from few reviewers that it was being hard to go back and forth between the PRs. \r\nMay I suggest the following, we review this PR in a whole and I will work on splitting into multiple PRs once we have sufficient reviews and nearing to committing ? please let me know your thoughts ?",
          "createdAt": "2023-02-28T18:39:57Z",
          "updatedAt": "2023-02-28T18:39:57Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> I really think the relay text should be split into a separate document. It outlines a possible architecture, a possible way of encoding IDs, a possible way of building the application, etc. None of these really have any impact on the transport protocol and it suffers from CAN syndrome.\r\n\r\nRelays and protocol interactions needs to be part of base protocol spec. If not, there isn't a way to tell the relay behavior  when it gets moq messages and it might just fail the protocol to work or make it incorrectly work.",
          "createdAt": "2023-03-01T23:48:44Z",
          "updatedAt": "2023-03-01T23:48:44Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> My high level feedback is that everything is a suggestion. You could do this, or you could do that, or you could do this, or you could do that. Nothing is concrete and there's no useful properties or assurances.\r\n\r\nI do agree there is mix of high level/logical concepts and the atoms that are needed to be defined. If we can try to get an agreement on the concrete things that work for most of the use-cases, I am sure we can fix the logic things and wordings around it. Those highlevel concepts are added to set a stage for anyone coming in from different application groups to get the context on why we have the concrete things",
          "createdAt": "2023-03-02T00:20:35Z",
          "updatedAt": "2023-03-02T00:20:35Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I apologize for not being more careful about indicating the hat I'm wearing while reviewing PRs.  Please consider my comments on this PR as an individual.",
          "createdAt": "2023-03-07T17:02:49Z",
          "updatedAt": "2023-03-07T17:02:49Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Has this been overtaken by events and can be closed in favor of newer PRs?",
          "createdAt": "2023-04-21T19:10:35Z",
          "updatedAt": "2023-04-21T19:10:35Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5OHzka",
          "commit": {
            "abbreviatedOid": "5c55141"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I entered a few comments, but I think this is a good addition to the spec.",
          "createdAt": "2023-02-23T06:23:23Z",
          "updatedAt": "2023-02-23T06:33:18Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "I am concerned that these examples are too generic, and miss the important property of considering a group boundary as a synchronization point. Please add something about groups and synchronization points.",
              "createdAt": "2023-02-23T06:23:23Z",
              "updatedAt": "2023-02-23T06:33:18Z"
            },
            {
              "originalPosition": 86,
              "body": "We should not discuss message formats in the data model. We are merely looking at properties of the groups, objects, etc. We may or may not have an \"object header\". For example, if we are mapping a group to a QUIC stream and if we assume that the objects are in sequence, we may have a group header and avoid repeating track-id and group-id for every object. If we assume that the object-id are in sequence, we could compress that too. It should be sufficient to say that the identifiers are carried by the transport protocol.",
              "createdAt": "2023-02-23T06:27:57Z",
              "updatedAt": "2023-02-23T06:33:18Z"
            },
            {
              "originalPosition": 100,
              "body": "Typo: composit*i*on.",
              "createdAt": "2023-02-23T06:28:40Z",
              "updatedAt": "2023-02-23T06:33:19Z"
            },
            {
              "originalPosition": 107,
              "body": "I would prefer to say \"subscribers encountering congestion\" than using \"who\", which implies that subscribers are human beings.",
              "createdAt": "2023-02-23T06:30:32Z",
              "updatedAt": "2023-02-23T06:33:19Z"
            },
            {
              "originalPosition": 224,
              "body": "... objects to relays ... (delete \"a\")",
              "createdAt": "2023-02-23T06:32:26Z",
              "updatedAt": "2023-02-23T06:33:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5OH895",
          "commit": {
            "abbreviatedOid": "5c55141"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-23T07:14:32Z",
          "updatedAt": "2023-02-23T07:14:33Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "good point @huitema .. ",
              "createdAt": "2023-02-23T07:14:32Z",
              "updatedAt": "2023-02-23T07:14:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5OthLf",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "My high level feedback is that everything is a suggestion. You could do this, or you could do that, or you could do this, or you could do that. Nothing is concrete and there's no useful properties or assurances.\r\n\r\nI really think the relay text should be split into a separate document. It outlines a possible architecture, a possible way of encoding IDs, a possible way of building the application, etc. None of these really have any impact on the transport protocol and it suffers from CAN syndrome.\r\n\r\nThe data model stuff has some potential but again, there needs to be stronger guarantees. For example the concept of a GROUP absolutely needs to have a property otherwise it should not exist. Saying \"the application can use groups for whatever it wants\" is meaningless.",
          "createdAt": "2023-03-01T20:12:46Z",
          "updatedAt": "2023-03-01T21:49:55Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Not a fan of this paragraph, especially for non-media folks.\r\n\r\nIt should be more to the point, something like: \"A track is an individual media encoding. The application synchronizes and renders multiple tracks. ex. audio/video, multiple participants, etc.\"\r\n\r\nIt also uses the \"media stream\" terminology which sounds like it's another term for \"track\". It's fair to disambiguate (\"track is known as XYZ in RFC ABC\"), but [the terminology is quite fragmented](https://github.com/kixelated/warp-draft/pull/56/files#diff-662d524695ea694207f7249d6d09daf068f14a5251bef95a8a05ef535c74e8b5R64).\r\n\r\nSame comment goes for the above paragraph.",
              "createdAt": "2023-03-01T20:12:46Z",
              "updatedAt": "2023-03-01T21:49:55Z"
            },
            {
              "originalPosition": 30,
              "body": "No encoding in the object model...",
              "createdAt": "2023-03-01T20:28:47Z",
              "updatedAt": "2023-03-01T21:49:56Z"
            },
            {
              "originalPosition": 69,
              "body": "What are the properties of a group? It can't be this vague otherwise it's useless; literally just some metadata attached by the application.\r\n\r\nIf we follow the GoP example, then objects within a group can _only_ depend on prior objects in a group. Warp uses streams to go a step further; objects within a group depend on all prior objects within a group.",
              "createdAt": "2023-03-01T20:33:53Z",
              "updatedAt": "2023-03-01T21:49:56Z"
            },
            {
              "originalPosition": 73,
              "body": "Why would you do this?",
              "createdAt": "2023-03-01T20:34:14Z",
              "updatedAt": "2023-03-02T05:16:12Z"
            },
            {
              "originalPosition": 81,
              "body": "This level of detail should go elsewhere IMO.",
              "createdAt": "2023-03-01T20:35:20Z",
              "updatedAt": "2023-03-01T21:49:56Z"
            },
            {
              "originalPosition": 84,
              "body": "Similar to the above, but what properties does \"cachable\" imply? How is an object cachable while a group is not?",
              "createdAt": "2023-03-01T20:36:10Z",
              "updatedAt": "2023-03-01T21:49:56Z"
            },
            {
              "originalPosition": 98,
              "body": "What is an origin? Why does it matter?",
              "createdAt": "2023-03-01T20:48:15Z",
              "updatedAt": "2023-03-02T05:17:18Z"
            },
            {
              "originalPosition": 130,
              "body": "> Objects are received by \"subscribing\" to it.\r\n\r\nSubscribing to what? You definitely don't subscribe to individual objects.",
              "createdAt": "2023-03-01T21:23:50Z",
              "updatedAt": "2023-03-01T21:49:56Z"
            },
            {
              "originalPosition": 143,
              "body": "This is known as \"Quality of Service\". Performance is generally the number of CPU cycles used.",
              "createdAt": "2023-03-01T21:25:05Z",
              "updatedAt": "2023-03-01T21:49:56Z"
            },
            {
              "originalPosition": 165,
              "body": "Punt this to the application. There's no reason to introduce the concept of origin ID at all, and especially not dictate that the origin ID should be parsed out of the track ID. There's so many different ways to determine the origin and it seems completely out of scope.",
              "createdAt": "2023-03-01T21:27:15Z",
              "updatedAt": "2023-03-02T05:18:11Z"
            },
            {
              "originalPosition": 205,
              "body": "I don't understand if this is meant to be an example or something authoritive. You can just say the origin CAN be encoded in the Emission ID or Track ID. \r\n\r\nI also don't see why the Emision ID and the Track ID need to have the same prefix. They should be separate fields like in the current draft (ex. Track ID is scoped to Broadcast ID). ",
              "createdAt": "2023-03-01T21:27:51Z",
              "updatedAt": "2023-03-01T21:49:56Z"
            },
            {
              "originalPosition": 214,
              "body": "What? Where did broadcast ID come from (I thought it was renamed to emission). How could the edge not know about this, especially if it was required to perform authentication as specified above?",
              "createdAt": "2023-03-01T21:35:37Z",
              "updatedAt": "2023-03-02T05:25:48Z"
            },
            {
              "originalPosition": 226,
              "body": "Maybe you should just make a separate \"possible architectures\" document. I don't see how anything in this section is relevant to the transport protocol. The same goes for some of the previous sections; advice on how to encode IDs just seems wildly out of scope.\r\n\r\n",
              "createdAt": "2023-03-01T21:39:52Z",
              "updatedAt": "2023-03-01T21:49:56Z"
            },
            {
              "originalPosition": 235,
              "body": "I thought the publisher was the origin? Origin is a synonym for \"source\" after all.\r\n\r\nI think you're absolutely trying to impose an architecture. Broadcasters push to some central hub which then starts the fanout process. However, I think that misses a huge number of use cases, and it's really not clear why the transport protocol even cares about the existence of this architecture.\r\n\r\n",
              "createdAt": "2023-03-01T21:44:40Z",
              "updatedAt": "2023-03-01T21:49:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Ouhll",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-01T23:49:27Z",
          "updatedAt": "2023-03-01T23:49:28Z",
          "comments": [
            {
              "originalPosition": 235,
              "body": "> I thought the publisher was the origin? Origin is a synonym for \"source\" after all.\r\n\r\nthat is one possibility, but not the only one.",
              "createdAt": "2023-03-01T23:49:27Z",
              "updatedAt": "2023-03-01T23:49:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5OuoCA",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-02T00:12:00Z",
          "updatedAt": "2023-03-02T00:12:01Z",
          "comments": [
            {
              "originalPosition": 205,
              "body": "trackId need not be scoped to a emission. A Composition can serve tracks from different emitters and server their own too. Protocol shouldn't constrain it",
              "createdAt": "2023-03-02T00:12:00Z",
              "updatedAt": "2023-03-06T04:18:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5OuoHu",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-02T00:12:33Z",
          "updatedAt": "2023-03-02T00:12:33Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "yes, it might be good in the message structure section",
              "createdAt": "2023-03-02T00:12:33Z",
              "updatedAt": "2023-03-02T00:12:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5OuoT7",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-02T00:13:39Z",
          "updatedAt": "2023-03-02T00:13:39Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "May be i wasn't clear here. I was suggesting something like RUSH, where each object is in its own stream. Agree the text as-is is not meaning that",
              "createdAt": "2023-03-02T00:13:39Z",
              "updatedAt": "2023-03-02T00:13:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5OuoYb",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-02T00:14:05Z",
          "updatedAt": "2023-03-02T00:14:06Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "This is inline with @huitema comment as well. I will add text to explain the group properties",
              "createdAt": "2023-03-02T00:14:05Z",
              "updatedAt": "2023-03-02T00:14:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5OupSf",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-02T00:17:22Z",
          "updatedAt": "2023-03-02T00:17:22Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "may be its poor choice of word. the intent was to say \"application can choose to group objects in different ways for a given track\"",
              "createdAt": "2023-03-02T00:17:22Z",
              "updatedAt": "2023-03-02T00:17:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Ovayq",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-02T05:25:24Z",
          "updatedAt": "2023-03-02T05:25:24Z",
          "comments": [
            {
              "originalPosition": 205,
              "body": "What's the difference between a composition and emission then? I thought compositions were tracks from different origins/emitters.",
              "createdAt": "2023-03-02T05:25:24Z",
              "updatedAt": "2023-03-02T05:25:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5OvbKr",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-02T05:27:32Z",
          "updatedAt": "2023-03-02T05:27:32Z",
          "comments": [
            {
              "originalPosition": 235,
              "body": "Can you define \"origin\" then? The term just appears out of nowhere.",
              "createdAt": "2023-03-02T05:27:32Z",
              "updatedAt": "2023-03-02T05:27:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5O2x_N",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks for taking a stab here.\r\n\r\nHigh level feedback:\r\n\r\n* We should separate object model and relays into different PRs.  Yes there's overlap to some degree, in that Relay may depend on Object Model, but it we have to get the object model right first, and keeping the PR focused will allow faster review and iteration.\r\n* While we're figuring out the model, let's leave as much wire encoding details out and keep it high level.  We can follow up with any necessary wire changes.",
          "createdAt": "2023-03-03T01:33:15Z",
          "updatedAt": "2023-03-03T02:10:57Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "I think he means to say that this section should offer only concepts and not specify anything about how these concepts are transmitted on the wire.",
              "createdAt": "2023-03-03T01:33:16Z",
              "updatedAt": "2023-03-03T02:10:59Z"
            },
            {
              "originalPosition": 69,
              "body": "My comment is along the same line -- what are the basic properties of an \"object\" and a \"group\"?  Is an object atomic -- that is to say, it is only useful if the entire object is present, and a partial object has no value?  Objects have metadata -- can groups also have metadata?  Are groups atomic -- eg: can a receiver use a group that is missing its tail, or missing a section in the middle?\r\n\r\nThere's also a question below about \"cacheability\".  To say something is cacheable to me also implies that it has a name or identifier - is this true of objects?  Groups?\r\n\r\nWho decides what a group is?  Is it purely the publisher's decision, or can relays \"regroup\" objects?  Another way to phrase it - are groups end-to-end or hop-by-hop? I think end-to-end but it might be good to make that explicit.\r\n\r\nDo groups have a fixed length or can they be \"appended\" over time?",
              "createdAt": "2023-03-03T01:44:03Z",
              "updatedAt": "2023-03-03T02:10:59Z"
            },
            {
              "originalPosition": 98,
              "body": "Yes perhaps just define and use emitter (as the one sending the tracks) since Origin has a lot of weight behind it.",
              "createdAt": "2023-03-03T01:45:54Z",
              "updatedAt": "2023-03-03T02:10:59Z"
            },
            {
              "originalPosition": 104,
              "body": "Suggested:\r\n\r\nA Composition is a collection of media tracks from one or more emissions.",
              "createdAt": "2023-03-03T01:48:37Z",
              "updatedAt": "2023-03-03T02:10:58Z"
            },
            {
              "originalPosition": 108,
              "body": "I would avoid language like \"tries not to\" or using the subject \"we\".\r\n\r\nI'm also confused about the scope of a catalog.  Is the catalog scoped to a composition (which can contain tracks from multiple emissions) or is it scoped to a single emission?  The word \"session\" also appears here, and the relationship between session and emission is not clear.",
              "createdAt": "2023-03-03T01:50:45Z",
              "updatedAt": "2023-03-03T02:10:58Z"
            },
            {
              "originalPosition": 110,
              "body": "Again the language here doesn't read like a specification.  Something like:\r\n\r\nConsumers choose which tracks to subscribe to from the catalog.\r\n\r\nI guess that opens a different question -- is it valid to subscribe to a track that is not listed in the catalog, or before the catalog is received?",
              "createdAt": "2023-03-03T01:53:06Z",
              "updatedAt": "2023-03-03T02:10:59Z"
            },
            {
              "originalPosition": 130,
              "body": "I don't think the \"we expect...\" adds much here.\r\n\r\nThe sentence about how objects are identified would probably read better in the definition of an object - or maybe a whole section on identifiers.",
              "createdAt": "2023-03-03T01:55:41Z",
              "updatedAt": "2023-03-03T02:10:59Z"
            },
            {
              "originalPosition": 143,
              "body": "Or latency?",
              "createdAt": "2023-03-03T01:56:34Z",
              "updatedAt": "2023-03-03T02:10:59Z"
            },
            {
              "originalPosition": 145,
              "body": "Origin appears in this sentence in both upper and lowercase.  Does it mean different things?",
              "createdAt": "2023-03-03T01:57:23Z",
              "updatedAt": "2023-03-03T02:10:59Z"
            },
            {
              "originalPosition": 156,
              "body": "The 'We expect' sentence is duplicated from the above, and I don't think we need it in either place.",
              "createdAt": "2023-03-03T01:58:53Z",
              "updatedAt": "2023-03-03T02:10:59Z"
            },
            {
              "originalPosition": 158,
              "body": "Do you mean 'on behalf of the subscribers' rather than subscriptions?",
              "createdAt": "2023-03-03T01:59:28Z",
              "updatedAt": "2023-03-03T02:10:59Z"
            },
            {
              "originalPosition": 159,
              "body": "Why do we have to say that relays MUST authorize subscriptions.  An HTTP cache \"really ought to\" authorize CDN requests, but it doesn't have to per any specification I don't think?",
              "createdAt": "2023-03-03T02:02:00Z",
              "updatedAt": "2023-03-03T02:10:59Z"
            },
            {
              "originalPosition": 159,
              "body": "> have to find out how to provide the desired content\r\n\r\nWe can probably remove this sentence?",
              "createdAt": "2023-03-03T02:02:36Z",
              "updatedAt": "2023-03-03T02:10:59Z"
            },
            {
              "originalPosition": 226,
              "body": "+1 \r\n\r\nAt this point I think we should be writing the smallest amount possible in the transport document.",
              "createdAt": "2023-03-03T02:05:58Z",
              "updatedAt": "2023-03-03T02:10:59Z"
            },
            {
              "originalPosition": 239,
              "body": "Details like keeping a queue are really implementation specific and can be left out here.",
              "createdAt": "2023-03-03T02:06:46Z",
              "updatedAt": "2023-03-03T02:10:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5O3Eci",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-03T03:45:29Z",
          "updatedAt": "2023-03-03T03:45:30Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "+1 with @afrind ",
              "createdAt": "2023-03-03T03:45:29Z",
              "updatedAt": "2023-03-03T03:45:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5O3EsR",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-03T03:47:33Z",
          "updatedAt": "2023-03-03T03:47:34Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "@afrind agree that simplifies it",
              "createdAt": "2023-03-03T03:47:33Z",
              "updatedAt": "2023-03-03T03:47:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5O7ovT",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "jordicenzano",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "Thanks for working on this, I'm sorry but I'm very late to the party here, also I'm very new to standards so take my comments with a piece of salt\r\n\r\nIn general I would love to (wish list):\r\n- Add more block diagrams to focus the problem to tackle and set the right context for the reader\r\n- Clarify what use cases (architectures) we want to tackle: ingest live edge, delivery delivery live edge (to millions), rewind? vod? Highlights? video conference (1 to thousands)? All of them?\r\n- Less \"text\" and more specific low level descriptions with enough details to enable any developer to start building a POC",
          "createdAt": "2023-03-03T16:38:17Z",
          "updatedAt": "2023-03-04T18:02:24Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "It would be possible to show something like the following, or add some examples, IDK for others but for me is difficult to follow those vague specs:\r\n\r\nAssuming streamId, server, intention, and params are in the WT session, we could do something like:\r\n\r\nStreamID: Unique in the app domain: `12345`\r\nintention: Ingest or delivery\r\nparams: `vDesiredBufferSize`, `aDesiredBufferSize`, `rewindMs`, etc\r\n\r\n```\r\ntrackId/groupId/elementId\r\n```\r\n\r\ntrackId: `h264360p2Mbps`, `aac32k`\r\ngroupId: Elements that depend on each other? : `1` OR `2` Or... [GUID] (ex: GOPS)\r\nelementId: `1`, `2`, or  `[GUID]` (Ex: frames)\r\n\r\nPD: Ideally `groupId` and `elementId` would be monotonically increasing providing a simple way to find next item to send/fetch (implementation should NOT rely on that, gaps can happen)\r\n\r\nWT session:\r\n```\r\nhttps://[HOST]:[PORT]/[APPID]/[streamID]?[params]\r\n```\r\nexample:\r\n`https://fblive.com:4433/moq-ingest/12345`\r\n`https://fblive.com:4433/moq-delivery/12345?vj=2000&aj=2000&rw=0`",
              "createdAt": "2023-03-03T16:38:17Z",
              "updatedAt": "2023-03-04T18:02:24Z"
            },
            {
              "originalPosition": 73,
              "body": "Super confusing to me, sorry",
              "createdAt": "2023-03-03T16:39:16Z",
              "updatedAt": "2023-03-04T18:02:24Z"
            },
            {
              "originalPosition": 84,
              "body": "What header/metadata is needed for the relay? Just IMHO if we want to do ingest / egress relay with live edge, rewind, and highlights / vod:\r\n- 'Cache-Control': max-age=AA`, // Indicates server to cache this data for AA seconds (except init segments)\r\n- 'TrackID': mediaType, \r\n- 'Timestamp': timestamp, // PTS in time scale\r\n- 'Duration': duration, // Duration in time scale (very nice to have)\r\n- 'Type': chunkType, // key, delta, init (perhaps in trackID?)\r\n- 'Seq-Id': seqId, // Unique and monotonically increasing inside specific media type track\r\n- 'First-Frame-Clk': firstFrameClkms, // EPOCH ms when the 1st sample in that element was captured (Optional)\r\n- Timescale: ts timescale (or we could put this in some header, but I think that complicates a bit the protocol)\r\n\r\nPS: Perhaps some groupId too? (if groups are needed)\r\n",
              "createdAt": "2023-03-03T16:54:12Z",
              "updatedAt": "2023-03-04T18:02:24Z"
            },
            {
              "originalPosition": 104,
              "body": "If I understood properly it seems `Emission` are a collection of tracks from same emitter and `Composition` is the same from different emitters.\r\n\r\nJust a thought: It seems to me we are trying to design an application system more than a media transport protocol, could be composition something at app level. Meaning we deal with `emissions` (similar to transport stream), and somebody can design a compositor that ingest N `emissions` and create another one (emission) as result of compositing inputs",
              "createdAt": "2023-03-03T16:59:38Z",
              "updatedAt": "2023-03-04T18:02:24Z"
            },
            {
              "originalPosition": 73,
              "body": "Could we get away with sync points (specified in metadata), so we would NOT need the groups concept. Seems a nice simplification (if possible)",
              "createdAt": "2023-03-04T08:43:41Z",
              "updatedAt": "2023-03-04T18:02:24Z"
            },
            {
              "originalPosition": 110,
              "body": "Are we thinking in server side ABR push mode, or typical client side ABR here?\r\n\r\nIf clients subscribes to track, how server side ABR works?\r\n\r\nIn case we want to enable server side ABR PERHAPS the player can subscribe to all suitable tracks (renditions) for them and server sends the most appropriate based on available BW?\r\n\r\nSome ideas dump:\r\n\r\n- Server presents available tracks: [[view1-h264-720p-1Mbps, view1-h264-640p-750Kbps], [view2-h264-640p-750Kbps]] (2nd level array could represent ABR group?)\r\n\r\n- Client subscribe to this ABR group: [view1-h264-720p-1Mbps, view1-h264-640p-750Kbps]\r\n\r\n- Server pushes data from that ABR group to the best of its abilities (BW estimation, etc...)",
              "createdAt": "2023-03-04T09:03:28Z",
              "updatedAt": "2023-03-04T18:02:24Z"
            },
            {
              "originalPosition": 107,
              "body": "This seems to describe client side ABR, are we thinking on server side ABR too?\r\n\r\nPerhaps we should allow both ABR types in the protocol (more complex, but more flexible too)",
              "createdAt": "2023-03-04T09:04:02Z",
              "updatedAt": "2023-03-04T18:05:33Z"
            },
            {
              "originalPosition": 84,
              "body": "Is \"object\" atomic? In other words, does object map to a QUIC stream?\r\n\r\n> and thus relays have to be able to convey partial objects\r\n\r\nWhat do you mean?\r\n- Read while write? Accept holes?",
              "createdAt": "2023-03-04T09:10:41Z",
              "updatedAt": "2023-03-04T18:05:45Z"
            },
            {
              "originalPosition": 156,
              "body": "Could you add an example of `SubscriptionId`, sorry but I found it very difficult to me to picture it?",
              "createdAt": "2023-03-04T09:13:03Z",
              "updatedAt": "2023-03-04T18:02:24Z"
            },
            {
              "originalPosition": 165,
              "body": "Just to simplify we could use a similar process as DRM. The content can be encrypted and **the application** can get the description key out of band",
              "createdAt": "2023-03-04T17:34:26Z",
              "updatedAt": "2023-03-04T18:06:37Z"
            },
            {
              "originalPosition": 180,
              "body": "I'm not an expert in standards but I find this extremely vague for a protocol spec, example:\r\n- \"This step depends on the way...\"\r\n- \"Some relays...\"\r\n- \"from a set of subscribers\"\r\n- \"some cases\"\r\n- etc\r\nnothing is defined",
              "createdAt": "2023-03-04T17:37:53Z",
              "updatedAt": "2023-03-04T18:02:24Z"
            },
            {
              "originalPosition": 222,
              "body": "> When a relay receives a publish request with data, it will forward it both towards the Origin and to any clients or relays that have a matching subscriptions\r\n\r\nIs this a privacy risk? Can I send a publish request and then receive data from any client connecting?",
              "createdAt": "2023-03-04T17:44:33Z",
              "updatedAt": "2023-03-04T18:06:54Z"
            },
            {
              "originalPosition": 226,
              "body": "Do you mean \"Content Management System\" (CMS)\r\n\r\nAlso are losing focus here? What  CMS interactions have to do with media transport protocol?",
              "createdAt": "2023-03-04T17:45:01Z",
              "updatedAt": "2023-03-04T18:07:08Z"
            },
            {
              "originalPosition": 237,
              "body": "I'm sure I'm missing something but in the case we want to do server side ABR, the relay needs to know track metadata, needs to know bitrates, timing, etc in order to push the right object at the right time. How relays will know that if \"Catalog message content themselves are opaque to the Relays\"",
              "createdAt": "2023-03-04T17:51:03Z",
              "updatedAt": "2023-03-04T18:07:34Z"
            },
            {
              "originalPosition": 239,
              "body": "Are we just considering the live edge case? What about rewind or highlights / VOD? Are they out of scope?",
              "createdAt": "2023-03-04T17:52:02Z",
              "updatedAt": "2023-03-04T18:02:24Z"
            },
            {
              "originalPosition": 245,
              "body": "GOAway related: That message should also carry some information (last Id or timing or ...) if we want to do a (potentially) seamless transition",
              "createdAt": "2023-03-04T17:53:47Z",
              "updatedAt": "2023-03-04T18:09:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PAXNu",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T04:16:59Z",
          "updatedAt": "2023-03-06T04:17:00Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "> My comment is along the same line -- what are the basic properties of an \"object\" and a \"group\"? Is an object atomic -- that is to say, it is only useful if the entire object is present, and a partial object has no value? Objects have metadata -- can groups also have metadata? Are groups atomic -- eg: can a receiver use a group that is missing its tail, or missing a section in the middle?\r\n> \r\n[Suhas] Objects correspond to an encoded and encrypted video frame. Yes if the entire p-frame or entire idr-frame is not received (say we lost some packets  , not sure how would that happen if each video frame is sent on stream though), it is still usable and depends on the decoder. Some HW decoders choke, but most of the SW decoders I have tried can deal to some decent extent.\r\n \r\n[Suhas] \"can a receiver use a group that is missing its tail, or missing a section in the middle?\" --> this is purely user experience choice. Applications can mark objects within group with relative priorities ( say 60hz p-frame is less important than 30hz p-frame in a 2 temporal layer group). Relays can choose the drop the less important ones to satisfy the congestion response. Since groups represent a sycn point, IDR frame being the object-0,  clients can render video to certain quality if IDr is received , but the experience will be impacts if there are drops regardless. If each object in a group is sent in its own stream and if certain streams were closed based on application decision (like RUSH), yes one can expect certain object to be missing in the group. OTOH if group is mapped to a QUIC Stream and all the objects in the current group ( GOP ) is sent on a QUIC stream (like WARP), one would get the atomic property. This is applications choice and we shouldn't mandate a decision for the application. I should be able to use WARP mode or RUSH mode and transport should provide me the necessary tools. \r\n\r\n> There's also a question below about \"cacheability\". To say something is cacheable to me also implies that it has a name or identifier - is this true of objects? Groups?\r\n\r\n[Suhas] MoQ Objects are cached. GroupId, TrackId and other header metadata provide materials to key for the object lookup in the cache.\r\n> \r\n> Who decides what a group is? Is it purely the publisher's decision, or can relays \"regroup\" objects? Another way to phrase it - are groups end-to-end or hop-by-hop? I think end-to-end but it might be good to make that explicit.\r\n> \r\n> Do groups have a fixed length or can they be \"appended\" over time?\r\n\r\n[Suhas[ Groups for video will be IDR transitions, so group Id increases on every IDR generation with objectId inside each group starting from 0 and increasing until the next IDR. Depending on the size of IDR interval, objects carry the same groupId under a given IDR. \r\n",
              "createdAt": "2023-03-06T04:16:59Z",
              "updatedAt": "2023-03-06T04:17:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PAXmG",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T04:20:12Z",
          "updatedAt": "2023-03-06T04:20:12Z",
          "comments": [
            {
              "originalPosition": 226,
              "body": "Non normative supporting text should be fine to have to setup the context. ",
              "createdAt": "2023-03-06T04:20:12Z",
              "updatedAt": "2023-03-06T04:20:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PAXyK",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T04:21:50Z",
          "updatedAt": "2023-03-06T04:21:50Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "Emission is not transport level construct either. We are talking about delivering tracks and they come from either an emission or a composition. I wonder why one is fine but not the other",
              "createdAt": "2023-03-06T04:21:50Z",
              "updatedAt": "2023-03-06T04:21:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PAY-p",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T04:27:45Z",
          "updatedAt": "2023-03-06T04:27:45Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "@afrind  may be I am missing something here. If the subscriptions are not authorized, how would the relay trust to participate in the delivery ? ",
              "createdAt": "2023-03-06T04:27:45Z",
              "updatedAt": "2023-03-06T04:27:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PAZAx",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T04:28:03Z",
          "updatedAt": "2023-03-06T04:28:03Z",
          "comments": [
            {
              "originalPosition": 239,
              "body": "Agreed",
              "createdAt": "2023-03-06T04:28:03Z",
              "updatedAt": "2023-03-06T04:28:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PAcC8",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T04:49:07Z",
          "updatedAt": "2023-03-06T04:49:08Z",
          "comments": [
            {
              "originalPosition": 180,
              "body": "@jordicenzano the reason why the above set of words are used is because this draft doesn't talk about Relay architecture or management. It then delves into role of relays in the protocol when publish/subscribe are received.\r\n\r\nI am happy to make the distinction clear and suggestions welcome.",
              "createdAt": "2023-03-06T04:49:08Z",
              "updatedAt": "2023-03-06T04:49:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PAcOy",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T04:50:38Z",
          "updatedAt": "2023-03-06T04:50:38Z",
          "comments": [
            {
              "originalPosition": 222,
              "body": "the expected flow is both publishes and subscribes needs to be authorized. So the answer is No and one would get the media objects corresponding to the subscribed tracks alone.\r\n",
              "createdAt": "2023-03-06T04:50:38Z",
              "updatedAt": "2023-03-06T04:50:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PAcga",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T04:52:45Z",
          "updatedAt": "2023-03-06T04:52:45Z",
          "comments": [
            {
              "originalPosition": 226,
              "body": "CMS has nothing to do with the transport protocol. This is setting up text for anyone who is reading the protocol spec coming from different application backgrounds ( ingest & distrbution vs conferencing). These systems have different ways the MoQ session gets setup. Here we are refering to setup the context and then move into specifics.",
              "createdAt": "2023-03-06T04:52:45Z",
              "updatedAt": "2023-03-06T04:52:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PAxXT",
          "commit": {
            "abbreviatedOid": "5c55141"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T06:52:08Z",
          "updatedAt": "2023-03-06T06:52:08Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "Sync Points enable multiple functionalities\r\n- Join in at the right boundary\r\n- Implement necessary congestion response at the group boundaries in relays\r\n- Cache strategies across group boundaries\r\n\r\n",
              "createdAt": "2023-03-06T06:52:08Z",
              "updatedAt": "2023-03-06T06:52:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PBrg0",
          "commit": {
            "abbreviatedOid": "5c55141"
          },
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T09:44:18Z",
          "updatedAt": "2023-03-06T09:44:19Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "Sync Points are neccessary for new client to join at the right point.",
              "createdAt": "2023-03-06T09:44:18Z",
              "updatedAt": "2023-03-06T09:44:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PBtfj",
          "commit": {
            "abbreviatedOid": "5c55141"
          },
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T09:48:00Z",
          "updatedAt": "2023-03-06T09:48:00Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "Client side ABR is pull based. Server side ABR is push based. To support push-based, we need to extend the current pub/sub model.",
              "createdAt": "2023-03-06T09:48:00Z",
              "updatedAt": "2023-03-06T09:48:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PEiy0",
          "commit": {
            "abbreviatedOid": "5c55141"
          },
          "author": "jordicenzano",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T15:44:06Z",
          "updatedAt": "2023-03-06T15:44:07Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "Sorry, I think you understood the opposite of what I wanted to say. Let me rephrase:\r\nCan we just define sync points in MOQ, and just use that to indicate group boundaries. If yes, then perhaps we would NOT need to define groups, and that seems like a nice simplification.",
              "createdAt": "2023-03-06T15:44:06Z",
              "updatedAt": "2023-03-06T15:44:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PEjsG",
          "commit": {
            "abbreviatedOid": "5c55141"
          },
          "author": "jordicenzano",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T15:46:00Z",
          "updatedAt": "2023-03-06T15:46:00Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "@VMatrix1900 you are totally right! Then my question is: What mode do we want MOQ to support on delivery side? push (server -> consumer/player ), pull ( server <- consumer / player), both?",
              "createdAt": "2023-03-06T15:46:00Z",
              "updatedAt": "2023-03-06T15:46:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PFyrD",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T18:00:00Z",
          "updatedAt": "2023-03-06T18:08:42Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "If I'm reading your comment correctly, then \r\n\r\n1. Objects are intended to be atomic\r\n2. Groups are not required to be atomic.  Some applications can deal with a group that has holes or a missing tail.\r\n3. Groups have metadata that can be used by relays (for example, an index or timestamp?)\r\n4. Objects are cached.  To make an HTTP analogy - Objects are like HTTP resources.  Requesting a group is like sending a N GET requests, one for each object. \r\n5. Groups are end-to-end.  Relays cannot change the group of an object.\r\n6. Objects have fixed length.  Groups are appendable.\r\n\r\nPlease correct me if I'm misunderstanding.\r\n\r\nThis raises some more questions for me:\r\n\r\n1. Are all objects within a group always ordered?\r\n2. How does a relay or application know how many total objects are in a group?\r\n3. While Groups are end-to-end, the mapping of group to QUIC stream seems like it could be a hop-by-hop decision.  If a relay received all Objects in a group over the same QUIC stream, must it send it to all subscribers in the same way? \r\n If so, should that be encoded in the group metadata in some way?\r\n5. If a caching relay is missing part of a group, is there specified behavior when a new subscriber asks for that group (eg: must it attempt to fetch it from an upstream publisher)?",
              "createdAt": "2023-03-06T18:00:01Z",
              "updatedAt": "2023-03-06T18:08:42Z"
            },
            {
              "originalPosition": 104,
              "body": "I think Emission is a transport level concept: A collection of tracks, scoped to a WT session, defined by a catalog.",
              "createdAt": "2023-03-06T18:01:27Z",
              "updatedAt": "2023-03-06T18:08:42Z"
            },
            {
              "originalPosition": 159,
              "body": "Of course authorization is important.  I think we should not discuss it in this PR, as it's fairly orthogonal to the primary transport concepts (how to move media from one place to another).  I was making the HTTP analogy -- I'm not sure but I suspect the transport RFCs that define how to move bits or define intermediaries aren't opinionated about authorization.  And you can imagine relays that are public and don't authorize, etc.",
              "createdAt": "2023-03-06T18:04:01Z",
              "updatedAt": "2023-03-06T18:08:42Z"
            },
            {
              "originalPosition": 226,
              "body": "I agree we need some amount of context to define the transport protocol, but in general, we should be trying to minimize it, especially now as we're just trying to get a baseline document we can adopt.",
              "createdAt": "2023-03-06T18:08:15Z",
              "updatedAt": "2023-03-06T18:08:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PGEzd",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T18:42:18Z",
          "updatedAt": "2023-03-06T18:42:18Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "Groups provide a generic framework for anyone building things like sync points. I feel at the moq transport layer, we need to build tools with properties on which applications can innovate. Groups as defined today are not necessarily complicated. I would like to learn understand the concern further ",
              "createdAt": "2023-03-06T18:42:18Z",
              "updatedAt": "2023-03-06T18:42:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PGGYI",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T18:46:55Z",
          "updatedAt": "2023-03-06T18:46:55Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "As much I like to have relay more involved in media flows , I feel it's can of worms. We don't want to end up relays needing to look like SFU, McU, Mixer eventually.\n\nAs of today, Relays are pure store and forward engines and some authz stuff for keeping things flowing. It scales and distributes well.\n\n\nMore application logic goes in , the more would be ask for things like that. For video conferencing example, I can imagine an Sfu talking to relay to do smart switch ( active speaker) and relays don't need to care about any of such details in the payload header. Server side ABr is a very similar usecase and it would be nice to move it to appropriate application server to do that job. \n\nMy 2 cents \n\n",
              "createdAt": "2023-03-06T18:46:55Z",
              "updatedAt": "2023-03-06T18:48:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PGMG7",
          "commit": {
            "abbreviatedOid": "5c55141"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T19:01:44Z",
          "updatedAt": "2023-03-06T19:01:44Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "I think we need to define the protocol to work for simple relays (store and forward) as @suhasHere suggests, but not preclude extensions that could do \"smarter\" things at relays like server-side ABR.",
              "createdAt": "2023-03-06T19:01:44Z",
              "updatedAt": "2023-03-06T19:01:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PGYdQ",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T19:39:14Z",
          "updatedAt": "2023-03-06T19:39:15Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Yeah sorry, I should have elaborated, I meant what @afrind said.\r\n\r\nI think the object model should be a summary of the protocol. Here are some high level components and how they interact. Specifics should go into their own sections further down the document, like encoding should be near the bottom in the messages section.",
              "createdAt": "2023-03-06T19:39:14Z",
              "updatedAt": "2023-03-06T19:39:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PGeiA",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T19:55:25Z",
          "updatedAt": "2023-03-06T19:55:25Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "My intention is each OBJECT is decoded in order. They could have an unknown length and they could be truncated early. The ability to process a truncated OBJECT depends on the decoder: it could render complete frames and/or complete slices.\r\n\r\nGROUP needs a useful definition for sure. There's a lot of overlap with OBJECT.",
              "createdAt": "2023-03-06T19:55:25Z",
              "updatedAt": "2023-03-06T19:56:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PGfuq",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T19:58:43Z",
          "updatedAt": "2023-03-06T19:58:44Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "RUSH would still indicate that OBJECTs are in the same group, even if they're sent over separate streams. Otherwise startup would not work; the most recent object is not decodable.",
              "createdAt": "2023-03-06T19:58:43Z",
              "updatedAt": "2023-03-06T19:58:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PGoG-",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T20:24:49Z",
          "updatedAt": "2023-03-06T20:24:49Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "@kixelated yes for the original/current draft OBJECT is appendable and not atomic (can be tail dropped), so part of the proposed change here as I understand it is to make OBJECT something smaller (fixed length, atomic) and introduce GROUP to offer the other properties (appendable, tail-droppable).",
              "createdAt": "2023-03-06T20:24:49Z",
              "updatedAt": "2023-03-06T20:24:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PG370",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T21:15:04Z",
          "updatedAt": "2023-03-06T21:15:05Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "Yeah exactly, in other words this is stating that an OBJECT is a frame. I don't think that was the intention though.\r\n\r\nFundamentally, a relay does not care about frame boundaries. It cares about bytes and if they are independent (separate stream) or dependent (same stream). Video introduces some wrinkles because of different priorities (delivery order) and partially dependent streams (ie. non reference frames).\r\n\r\nI want some simple building blocks that can express those relationships. That was the purpose behind combining RUSH and Warp into a single OBJECT type",
              "createdAt": "2023-03-06T21:15:04Z",
              "updatedAt": "2023-03-06T21:15:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PHAal",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T21:42:21Z",
          "updatedAt": "2023-03-06T21:42:22Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "In as much as frames are involved in prioritization and dropping, it seems like relays do need to be aware of them?  \r\n\r\nIn Suhas' 30/60 fps example above -- he's describing both in the same GROUP, with different priorities.  In the current Warp, you could put the 30s in one OBJECT and the 60s in another, but you can't selectively deprioritize (or drop) just a few 60s in the middle of a stream.  Instead, you have to deprioritize the entire 60 fps OBJECT until the next boundary.\r\n\r\nOr another way -- this proposal allows for OBJECTs in the same GROUP to be transmitted over a different stream.  This allows more flexibility for prioritization and partial reliability, at the expense of some application reassembly perhaps?  If we envision a world where everything in a GROUP is dependent on what came before, however, the mapping over multiple streams isn't all that useful.",
              "createdAt": "2023-03-06T21:42:21Z",
              "updatedAt": "2023-03-06T21:42:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PHHnq",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T22:03:32Z",
          "updatedAt": "2023-03-06T22:03:33Z",
          "comments": [
            {
              "originalPosition": 108,
              "body": "If a catalog defines tracks from different emitters, it is scoped to a composition. Isn't it ?",
              "createdAt": "2023-03-06T22:03:33Z",
              "updatedAt": "2023-03-06T22:03:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PHIAU",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T22:04:57Z",
          "updatedAt": "2023-03-06T22:04:57Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "I beg to differ. A collection of tracks from one or more emitters, scoped to a WT Session, as defined by a catalog is fine definition too.\r\n\r\nI feel we should deal with MoQ Tracks at the transport level and rest is application choosing of how to put things and where",
              "createdAt": "2023-03-06T22:04:57Z",
              "updatedAt": "2023-03-06T22:04:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PHJfS",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T22:10:22Z",
          "updatedAt": "2023-03-06T22:10:22Z",
          "comments": [
            {
              "originalPosition": 108,
              "body": "I prefer a catalog being scoped to a single emission (and hence by definition a single emitter).  We can say that a resource that defines a composition is out of scope for moq, at least for now?  In a web analogy, an HTML page defines a composition of resources from potentially different entities, but the HTTP specifications don't include many details about that works.",
              "createdAt": "2023-03-06T22:10:22Z",
              "updatedAt": "2023-03-06T22:10:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PHLJM",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T22:16:16Z",
          "updatedAt": "2023-03-06T22:16:16Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "I think there's value in a transport level construct grouping tracks into an emission/broadcast -- for example, it affords a simple mechanism to say \"I'm not watching this anymore\" and cancel all related track subscriptions.  See also #98, which proposes the scope of a WT session to be a single emission/broadcast.\r\n\r\nBut it seems there's still disagreement so perhaps a good point of discussion for the interim.",
              "createdAt": "2023-03-06T22:16:16Z",
              "updatedAt": "2023-03-06T22:16:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PHMZv",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T22:20:50Z",
          "updatedAt": "2023-03-06T22:20:51Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "The transport needs to be aware of the emission/broadcast (or maybe composition?) so it is able to prioritize based on delivery order. The delivery order is scoped to a single emission and is not comparable between emissions.",
              "createdAt": "2023-03-06T22:20:50Z",
              "updatedAt": "2023-03-06T22:20:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PHck-",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T23:06:21Z",
          "updatedAt": "2023-03-06T23:06:21Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Agreed. I am happy to make that change once we get to concepts in the object model",
              "createdAt": "2023-03-06T23:06:21Z",
              "updatedAt": "2023-03-06T23:06:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PHhVf",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T23:20:43Z",
          "updatedAt": "2023-03-06T23:20:43Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "Saying OBJECT can be a GOP or it can be a Video frame or it can be Video Slice  is pretty vague and it is not normative and confusing.\r\n\r\nI propose the following specific details/properties for the video media delivery over MoQ.\r\n\r\n- OBJECT is a encoded and/or encrypted video frame\r\n- Group is set of such objects that belong to a single sync point (in this case IDR boundary), where the first object (object-0) is always IDR\r\n- Objects within in a group are sequentially put in the encoding order and carry priorities for relative importance (60hz vs 30hz example)\r\n-  Group is incremented at every IDR boundary\r\n\r\nNow how do we map something like this to QUIC Stream. We tend to mix data model with transport mapping and that causes lot of confusion\r\n\r\nA Warp application will \r\n  - Put each group in its own QUIC Stream\r\n  \r\nA RUSH application will\r\n   - put each object  (marked with appropriate group Id) in its own QUIC Stream. How these objects are put in decoding order for decoding a given group is exactly same as how RUSH does it today.  As long as Object 0 for a group is received, one can be sure that there will be IDR received.\r\n\r\n\r\nGroups provides a relatively media agnostic handle to provide sync point access, congestion response boundaries and cache boundaries",
              "createdAt": "2023-03-06T23:20:43Z",
              "updatedAt": "2023-03-07T00:16:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PHhn5",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T23:21:59Z",
          "updatedAt": "2023-03-06T23:22:00Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "> this proposal allows for OBJECTs in the same GROUP to be transmitted over a different stream.\r\n\r\nThis is how RUSH works when each OBJECT is a video frame unless I have misunderstood.",
              "createdAt": "2023-03-06T23:22:00Z",
              "updatedAt": "2023-03-06T23:22:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PHhxu",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T23:22:42Z",
          "updatedAt": "2023-03-06T23:22:42Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "yes .. that was my intent too. I do see the confusion.",
              "createdAt": "2023-03-06T23:22:42Z",
              "updatedAt": "2023-03-06T23:22:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PHqa8",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T23:54:51Z",
          "updatedAt": "2023-03-06T23:54:52Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "> This is how RUSH works when each OBJECT is a video frame unless I have misunderstood.\r\n\r\nYou are right.",
              "createdAt": "2023-03-06T23:54:52Z",
              "updatedAt": "2023-03-06T23:54:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PHxxl",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-07T00:31:16Z",
          "updatedAt": "2023-03-07T00:31:17Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Agree, we should remove all occurrences of media stream.",
              "createdAt": "2023-03-07T00:31:16Z",
              "updatedAt": "2023-03-07T00:31:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PINKi",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-07T02:45:51Z",
          "updatedAt": "2023-03-07T02:45:51Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "I appreciate the clear distinction that frame == OBJECT.\r\n\r\nBut of course I would strongly advocate keeping OBJECT agnostic to the media fragmentation. It's some bytes in a media container and that's all the relay needs to know. The underlying media container is responsible for delimiting frame boundaries.\r\n\r\nForcing media to be fragmentated at frame boundaries hurts backwards compatibility with HLS/DASH (edge must parse) and explodes the number of streams required. The only benefit is that an OBJECT has an explicit size (atomic). I don't think this is a useful property, especially considering that streams have unbounded sizes, and certainly not a reason to narrow the functionality of the protocol.\r\n\r\nPersonally, I think dropping non-reference frames is a bait (temporal scalability). Everybody has the idea at some point (myself included) but I don't think it stacks up logically or experimentally. The idea is that you encode media at a X% higher bitrate to compensate for the lower quality, so you can drop up to Y% of the bitrate during congestion to degrade the frame rate rather than drop the tail. Citation needed: it's something like a 10% higher bitrate so 20% of the bits are \"nicer\" to drop during a rare congestion event (1% depending on the viewer?).\r\n\r\nHigh quality encodings will never use non-reference frames which this is increasingly true with newer codecs. It can only hurt the encoding efficiency to prevent a reference. Real-time latency encodings don't use non-reference frames either because they introduce latency (ex. WebRTC) or aren't worth the trade-off. \r\n\r\nDropping the tail of the GROUP is the only option in both extremes and that encompasses virtual all use-cases today. The only exception are hardware encoders that use fixed GoP structures, but consider that as an unintended performance side effect rather than intentional behavior.\r\n\r\nFinally, this design won't even work for the other forms of SVC. We definitely want to support dropping the frame rate (temporal scalability), but we also want to support stuff like dropping the resolution or quality instead. This can only be done by representing SVC layers at the transport level. Although I also think SVC falls into the same \"bait\" category...",
              "createdAt": "2023-03-07T02:45:51Z",
              "updatedAt": "2023-03-07T02:54:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PIfL3",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-07T04:40:02Z",
          "updatedAt": "2023-03-07T04:40:03Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "> But of course I would strongly advocate keeping OBJECT agnostic to the media fragmentation\r\n\r\nI am bit surprised. This would fall into same category of your objection for groups to be agnostic to media fragmentation .. I think we need to be very clear for the app builders to get them direction",
              "createdAt": "2023-03-07T04:40:02Z",
              "updatedAt": "2023-03-07T04:47:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PIiho",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-07T05:00:14Z",
          "updatedAt": "2023-03-07T05:00:14Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "How about this as a compromise:\r\n\r\nOBJECT: One or more frames, no holes, has a property that specifies if it can be tail dropped\r\nGROUP: One or more ordered OBJECTs.  If a receiver has (complete) OBJECTs 1...N in a group, they are guaranteed to be able to decode N + 1.  If they are missing some, then it's application defined.  We'll define some metadata for relays to be able to make decisions in the face of congestion.\r\nTRACK: One or more ordered GROUPs\r\n\r\nThis does give multiple ways to send the same thing, but perhaps given that we want the same base protocol to accomplish a variety of use cases, and allow for experimentation as we iterate, maybe that's an ok tradeoff?",
              "createdAt": "2023-03-07T05:00:14Z",
              "updatedAt": "2023-03-07T05:00:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PI1c4",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-07T06:36:56Z",
          "updatedAt": "2023-03-07T06:36:57Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "> I am bit surprised. This would fall into same category of your objection for groups to be agnostic to media fragmentation .. I think we need to be very clear for the app builders to get them direction\r\n\r\nGROUP had no properties. It wasn't actually possible for a relay to do anything based on how it was defined. It just needs some very basic properties, like \"ordered\".\r\n\r\n\r\n> OBJECT: One or more frames, no holes, has a property that specifies if it can be tail dropped\r\n> GROUP: One or more ordered OBJECTs. If a receiver has (complete) OBJECTs 1...N in a group, they are guaranteed to be able to decode N + 1. If they are missing some, then it's application defined. We'll define some metadata for relays to be able to make decisions in the face of congestion.\r\n> TRACK: One or more ordered GROUPs\r\n\r\nThat works, with some small nits:\r\n- OBJECT: I wouldn't even mention frames. It's an \"ordered media fragment\". The size may be unknown and the contents could be partially decodable when the tail is dropped. Very similar properties to a QUIC stream.\r\n- GROUP: That definition works for now but will need to be massaged for Christian's intra group priorities. The fact that N+1 depends on 1...N is the important bit for a relay.\r\n- TRACK: Sure.",
              "createdAt": "2023-03-07T06:36:57Z",
              "updatedAt": "2023-03-07T06:36:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PI-qs",
          "commit": {
            "abbreviatedOid": "20371d1"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-07T07:08:07Z",
          "updatedAt": "2023-03-07T07:08:07Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "I am still trying to understand why MOQ OBJECT need to have an ability to scan over one or more video frames. That is the role of a group and groups can be partially decodable, when its tail is dropped. \r\n\r\nBy making MoQ OBJECT undefined or unspecified, it is very confusing. I strongly recommend us to not mix grouping of things at different levels and we must keep these properties separate. \r\n\r\n\r\n",
              "createdAt": "2023-03-07T07:08:07Z",
              "updatedAt": "2023-03-07T13:32:52Z"
            }
          ]
        }
      ]
    },
    {
      "number": 96,
      "id": "PR_kwDOG2Ho4M5Kk0qZ",
      "title": "LATER:  Not Ready for Review - Control channel for track management and Subscribe updates",
      "url": "https://github.com/moq-wg/moq-transport/pull/96",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Address #81  \r\n\r\nThis PR adds support for control channel ( a bidirectional QUIC Stream) for managing media over one or more unidirectional QUIC Streams.\r\n\r\n\r\nThis PR also \r\n- Updates Subscribe message\r\n- Adds Subscribe_Reply message\r\n- Adds Flags parameters to the Object Header for intra-group priorities and more. \r\n\r\nDepends in part on #95 ",
      "createdAt": "2023-02-23T06:00:44Z",
      "updatedAt": "2023-05-05T19:47:48Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "c7feeb4777b1dd696e3eac6037eea3e5f84b9954",
      "headRepository": "suhasHere/warp-draft",
      "headRefName": "control-channel",
      "headRefOid": "7bb5ee97309d6dbd98818d02c833981686476305",
      "closedAt": "2023-05-05T19:47:47Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "llyxperf",
          "authorAssociation": "NONE",
          "body": "It seems like a subscribe message can request only one track.Doesn't that make the request for the emission more redundant?",
          "createdAt": "2023-02-27T08:06:32Z",
          "updatedAt": "2023-02-27T08:06:32Z"
        },
        {
          "author": "VMatrix1900",
          "authorAssociation": "NONE",
          "body": "That is my concern too. What if a client want to subscribe to all tracks of a broadcast/emission? Can we expand the subscribe message to carry multiple track IDs?",
          "createdAt": "2023-02-27T09:11:43Z",
          "updatedAt": "2023-02-27T09:11:43Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> That is my concern too. What if a client want to subscribe to all tracks of a broadcast/emission? Can we expand the subscribe message to carry multiple track IDs?\r\n\r\nThe current proposed model is simplistic in nature, keep it scoped to track and allowing binding the control channel and the corresponding 1 or more data channels to their lifetime and also keeps the scope of session management (more than one track) out of scope.\r\n\r\n I am not totally opposed to having bulk subscribe, but it does bring in additional complexities one way or the other. Love to hear more thoughts \r\n",
          "createdAt": "2023-02-28T18:40:23Z",
          "updatedAt": "2023-02-28T20:43:22Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> > That is my concern too. What if a client want to subscribe to all tracks of a broadcast/emission? Can we expand the subscribe message to carry multiple track IDs?\r\n> \r\n> The current proposed model is simplistic in nature, keep it scoped to track and allowing binding the control channel and the corresponding 1 or more data channels to their lifetime and also keeps the scope of session management (more than one track) out of scope.\r\n> \r\n> I am not totally opposed to having bulk subscribe, but it does bring in additional complexities one way or the other. Love to hear more thoughts\r\n\r\nHaving thought about it some more, i do feel we can have subscribe with multiple trackIds with the binding that says, the associated control channel's lifetime is bound to media transfer state for all the tracks. This keeps protocol simpler and also enables one authorization for all the tracks listed",
          "createdAt": "2023-03-01T03:13:51Z",
          "updatedAt": "2023-03-01T03:14:19Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "This overlaps with #122 but also addresses some of #138.  Maybe we should close to avoid the merge conflicts and have a separate PR to address control vs data streams after we get consensus on that issue?",
          "createdAt": "2023-04-21T19:15:29Z",
          "updatedAt": "2023-04-21T19:16:06Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@afrind once #123 is merged, i plan to rebase this PR and keep it focussed on what is needed for #138 , since it has most of what is being discussed in there",
          "createdAt": "2023-04-24T16:26:26Z",
          "updatedAt": "2023-04-24T16:26:26Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Could this PR just be made again #123 so we can see what is in it. Hard to review as it is now because of the overlap  ",
          "createdAt": "2023-05-05T16:50:58Z",
          "updatedAt": "2023-05-05T16:50:58Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": " Shall be updated to address  #138  once other PRs are merged",
          "createdAt": "2023-05-05T16:59:11Z",
          "updatedAt": "2023-05-05T16:59:11Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "@suhasHere can we close PRs that aren't ready for review? Just hit the re-open button when it's ready.",
          "createdAt": "2023-05-05T17:07:53Z",
          "updatedAt": "2023-05-05T17:07:53Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing temporarily until we're ready to work on this.",
          "createdAt": "2023-05-05T19:47:47Z",
          "updatedAt": "2023-05-05T19:47:47Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5Omzn4",
          "commit": {
            "abbreviatedOid": "7bb5ee9"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "As far as I understand, this PR does the following major changes to the SUBSCRIBE message:\r\n1. Adds the ability to subscribe to individual objects and groups.\r\n2. Adds a SUBSCRIBE_REPLY message.\r\n3. Adds authentication mechanisms.\r\n\r\nPoint 1 sounds reasonable, but may need more text in the draft explaining how it works.\r\nPoint 2 currently mostly SGTM.\r\nPoint 3 feels somewhat premature, since we don't have an authentication model in this draft. I would remove them for now until we have one.",
          "createdAt": "2023-02-28T22:58:01Z",
          "updatedAt": "2023-03-01T00:06:39Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "> When a endpoint client or relay\r\n\r\nI think we should just use \"an endpoint\" everywhere, because (1) for most points, a relay should not be different from an end-user client for most purposes, and (2) there might be scenarios where the server would want to initiate things.\r\n\r\n(note that I am using \"endpoint\" in \"any networking thing that speaks MoQ\", not necessarily an end-user that encodes or decodes media).",
              "createdAt": "2023-02-28T22:58:01Z",
              "updatedAt": "2023-03-01T00:06:39Z"
            },
            {
              "originalPosition": 36,
              "body": "I like this because this is how WebTransport works, and in that sense this has a lot of fairly well-understood properties. On the other hand, does this actually give us much compared to just sending all control messages on a single stream? Those are fairly small, and ideally high priority, which means there isn't that much advantage to be gained from avoiding head-of-line blocking on those.",
              "createdAt": "2023-02-28T22:58:13Z",
              "updatedAt": "2023-03-01T00:06:39Z"
            },
            {
              "originalPosition": 177,
              "body": "Minor editorial nitpick: instead of saying \"Flags (8)\", you should just list what the flags are right in the definition.",
              "createdAt": "2023-02-28T23:00:54Z",
              "updatedAt": "2023-03-01T00:06:39Z"
            },
            {
              "originalPosition": 194,
              "body": "LatencyMode does not really make sense here to me, since latency is not really a property of an object, but rather a property of the subscription (e.g. if I am streaming a live gaming event, the stream in the commenters booth can be near-realtime, while the same stream watched via a live streaming website could have 10 seconds of buffer delay).",
              "createdAt": "2023-02-28T23:02:54Z",
              "updatedAt": "2023-03-01T00:06:39Z"
            },
            {
              "originalPosition": 89,
              "body": "I feel like all of the sentences are hard to follow, probably because we still don't have definition of \"the origin\" (or authorization model in general).",
              "createdAt": "2023-02-28T23:15:02Z",
              "updatedAt": "2023-03-01T00:06:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Onfup",
          "commit": {
            "abbreviatedOid": "7bb5ee9"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-01T03:09:14Z",
          "updatedAt": "2023-03-01T03:09:14Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "more than HOL blocking, this ties the fate of control and media transfer. Given that media transfer can happen on one or more data channels (depending on the application mapping), control channel lifetime tied to data channels makes is cleaner and simpler",
              "createdAt": "2023-03-01T03:09:14Z",
              "updatedAt": "2023-03-01T03:09:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Onfzd",
          "commit": {
            "abbreviatedOid": "7bb5ee9"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-01T03:09:47Z",
          "updatedAt": "2023-03-01T03:09:47Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "+1 I am leaning towards the term MoQ Entity . since that term is surfacing in the identifiers discussions",
              "createdAt": "2023-03-01T03:09:47Z",
              "updatedAt": "2023-03-01T03:09:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Onf-k",
          "commit": {
            "abbreviatedOid": "7bb5ee9"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-01T03:11:02Z",
          "updatedAt": "2023-03-01T03:11:02Z",
          "comments": [
            {
              "originalPosition": 194,
              "body": "I was considering it more as hint to relay to decide on what to do in terms of caching and reaction to congestion (what gets dropped off the cache) .. ",
              "createdAt": "2023-03-01T03:11:02Z",
              "updatedAt": "2023-03-01T03:11:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5OngK3",
          "commit": {
            "abbreviatedOid": "7bb5ee9"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-01T03:12:25Z",
          "updatedAt": "2023-03-01T03:12:26Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "Origin is the application server / domain that owns the broadcast/emission.",
              "createdAt": "2023-03-01T03:12:25Z",
              "updatedAt": "2023-03-01T03:12:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5OvbZ8",
          "commit": {
            "abbreviatedOid": "7bb5ee9"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-02T05:28:52Z",
          "updatedAt": "2023-03-02T05:28:53Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "+1 to \"endpoint\".",
              "createdAt": "2023-03-02T05:28:53Z",
              "updatedAt": "2023-03-02T05:28:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Oveh3",
          "commit": {
            "abbreviatedOid": "7bb5ee9"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-02T05:46:59Z",
          "updatedAt": "2023-03-02T07:12:01Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "The first sentence is way too complicated and uses passive voice. It should be something like: \"The publisher creates a control stream for each broadcast.\"\r\n\r\ns/bilateral/bidirectional\r\n\r\nI don't think it should be per track. I think it should be per broadcast, based on the current SETUP / CATALOG / SUBSCRIBE message.\r\n\r\n> ...carrying a series of control messages in both directions\r\n> Control Channels are \"one way\"...\r\n\r\nI don't understand how it can be \"one way\" if it's a bidirectional stream with messages in both directions.",
              "createdAt": "2023-03-02T05:46:59Z",
              "updatedAt": "2023-03-02T07:12:02Z"
            },
            {
              "originalPosition": 34,
              "body": "What does \"belonging to a group\" mean and why does it matter? Especially if followed by \"one or more undirectional streams\".\r\n\r\nThis whole paragraph is a convoluted way of saying that OBJECTs are sent over unidirectional streams.",
              "createdAt": "2023-03-02T05:51:00Z",
              "updatedAt": "2023-03-02T07:12:01Z"
            },
            {
              "originalPosition": 28,
              "body": "Can we call them \"streams\" instead of \"channels\". \r\n\r\nFor example, HTTP/3 has:\r\n* control streams\r\n* request streams\r\n* push streams\r\n* etc",
              "createdAt": "2023-03-02T05:53:47Z",
              "updatedAt": "2023-03-02T07:12:01Z"
            },
            {
              "originalPosition": 36,
              "body": "What is \"the media\"? You should be more explicit: \"the closure of a control stream signals the termination of the associated broadcast\".",
              "createdAt": "2023-03-02T05:55:05Z",
              "updatedAt": "2023-03-02T07:12:01Z"
            },
            {
              "originalPosition": 36,
              "body": "I like multiple control streams. There's really no reason why a relay needs to interleave separate broadcasts and introduce HOL, which matters when you're relaying 1k broadcasts.",
              "createdAt": "2023-03-02T05:59:19Z",
              "updatedAt": "2023-03-02T07:12:02Z"
            },
            {
              "originalPosition": 32,
              "body": "If there's a control stream per broadcast, then you should add a note that all control messages MUST be sent over the corresponding control stream. \r\n\r\nI would state that each control stream MUST start with a SETUP message containing a broadcast ID. All control messages sent over the control stream are scoped to only that broadcast.",
              "createdAt": "2023-03-02T06:01:41Z",
              "updatedAt": "2023-03-02T07:12:02Z"
            },
            {
              "originalPosition": 89,
              "body": "I'm biased since I wrote the old text, but yeah it's difficult to read. \r\n\r\nCan you move SUBSCRIBE back below CATALOG? That way messages are ordered by ID and the diff is easier.",
              "createdAt": "2023-03-02T06:07:17Z",
              "updatedAt": "2023-03-02T07:12:02Z"
            },
            {
              "originalPosition": 99,
              "body": "How would you encode this? \r\n\r\nWrapping a field in brackets means optional... but in QUIC it's because the message type indicates if specific fields are present. You gotta reserve 0 otherwise.",
              "createdAt": "2023-03-02T06:11:42Z",
              "updatedAt": "2023-03-02T07:12:01Z"
            },
            {
              "originalPosition": 109,
              "body": "> Optional fields `Group ID` and `Object ID` identifies further details corresponding to the subcribed objects.\r\n\r\nWhat? You gotta explain each field.",
              "createdAt": "2023-03-02T06:12:42Z",
              "updatedAt": "2023-03-02T07:12:01Z"
            },
            {
              "originalPosition": 98,
              "body": "I added a `(b)` notion if you want to use that instead, but it doesn't really matter. ",
              "createdAt": "2023-03-02T06:14:48Z",
              "updatedAt": "2023-03-02T07:12:01Z"
            },
            {
              "originalPosition": 112,
              "body": "You're confusing encryption with authentication. They're not quite the same thing.\r\n\r\nThis is an \"Auth Token\". It could be encrypted... but it's usually a random string or salted hash.",
              "createdAt": "2023-03-02T06:23:26Z",
              "updatedAt": "2023-03-02T07:12:01Z"
            },
            {
              "originalPosition": 112,
              "body": "Should this be in SUBSCRIBE? I don't think so.\r\n\r\nOne of the most powerful features of relays is the ability to deduplicate requests. A CDN edge will receive thousands of separately authenticated requests that get converted into a single upstream request. This protects the origin from a flood of traffic.\r\n\r\nPropagating every SUBSCRIBE request upstream is an outage waiting for happen. It also gets messy because each edge now issues hundreds of potentially duplicate SUBSCRIBE requests that the upstream has to deduplicate.  300k viewers watching a broadcast means 300k active subscriptions at the origin... and 300k cumulative at each tier of the replication tree.\r\n\r\nIn my opinion, authentication needs to be hop-to-hop and either based on the WebTransport CONNECT or the SETUP message. Please make a separate PR for authentication anyway.",
              "createdAt": "2023-03-02T06:38:20Z",
              "updatedAt": "2023-03-02T07:12:02Z"
            },
            {
              "originalPosition": 120,
              "body": "Sorry what? Why? Huh?",
              "createdAt": "2023-03-02T06:39:30Z",
              "updatedAt": "2023-03-02T07:12:01Z"
            },
            {
              "originalPosition": 123,
              "body": "I thought that was the subscription ID.",
              "createdAt": "2023-03-02T06:40:05Z",
              "updatedAt": "2023-03-02T07:12:01Z"
            },
            {
              "originalPosition": 129,
              "body": "Wait what?\r\n\r\nYou have to sign **_every_** single OBJECT if you want authenticity. Otherwise it's trivial to spoof an origin by replaying a valid SUBSCRIBE_REPLY followed by forged OBJECTs. There's no way around it.\r\n\r\nIf you want authenticity, then I would increase recommend some out-of-band exchange (aka DRM). It doesn't have to be complicated; even a symmetric stream cipher (like AES-128 in HLS) is good enough for many use cases. Either way, DRM should be negotiated by the application and specified by the media container, so OUT OF SCOPE.",
              "createdAt": "2023-03-02T07:02:24Z",
              "updatedAt": "2023-03-02T07:12:01Z"
            },
            {
              "originalPosition": 139,
              "body": "typo",
              "createdAt": "2023-03-02T07:05:39Z",
              "updatedAt": "2023-03-02T07:12:01Z"
            },
            {
              "originalPosition": 166,
              "body": "At the very least you need some indication of the signature scheme and some keying info. There's no way the relay is able to verify the signature otherwise. I'm not even sure what this signature is meant to accomplish.",
              "createdAt": "2023-03-02T07:08:08Z",
              "updatedAt": "2023-03-02T07:12:01Z"
            },
            {
              "originalPosition": 160,
              "body": "Where did `Relay Redirect URL` come from? This sounds very similar to GOAWAY.",
              "createdAt": "2023-03-02T07:08:51Z",
              "updatedAt": "2023-03-02T07:12:01Z"
            },
            {
              "originalPosition": 194,
              "body": "Yeah no, two latency modes is not acceptable. We're trying to bridge the gap, not widen it.",
              "createdAt": "2023-03-02T07:10:12Z",
              "updatedAt": "2023-03-02T07:12:02Z"
            },
            {
              "originalPosition": 195,
              "body": "When would `IsDiscardable` be set?",
              "createdAt": "2023-03-02T07:10:53Z",
              "updatedAt": "2023-03-02T07:12:01Z"
            },
            {
              "originalPosition": 196,
              "body": "What is priority within a given group? How is the relay supposed to act on this information? How does it relate to `delivery order` and `IsDiscardable`?",
              "createdAt": "2023-03-02T07:11:48Z",
              "updatedAt": "2023-03-02T07:12:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5O3GdD",
          "commit": {
            "abbreviatedOid": "7bb5ee9"
          },
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-03T04:01:18Z",
          "updatedAt": "2023-03-03T04:01:43Z",
          "comments": [
            {
              "originalPosition": 120,
              "body": "yeah, I am not sure what this tries to achieve - I want subscribe once and then unsubscribe or close connection, thats it",
              "createdAt": "2023-03-03T04:01:18Z",
              "updatedAt": "2023-03-03T04:01:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5O3GuZ",
          "commit": {
            "abbreviatedOid": "7bb5ee9"
          },
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-03T04:03:25Z",
          "updatedAt": "2023-03-03T04:03:26Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "why do I need to send subsciption request to origin? ",
              "createdAt": "2023-03-03T04:03:25Z",
              "updatedAt": "2023-03-03T04:03:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5O3HT1",
          "commit": {
            "abbreviatedOid": "7bb5ee9"
          },
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-03T04:08:09Z",
          "updatedAt": "2023-03-03T04:08:10Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "i dont understand a need for reply? It could be useful to get status OK or Failure, but why cant end point just send some \"error message\" and close control stream?",
              "createdAt": "2023-03-03T04:08:10Z",
              "updatedAt": "2023-03-03T04:08:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5O9KRn",
          "commit": {
            "abbreviatedOid": "7bb5ee9"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-03T22:04:30Z",
          "updatedAt": "2023-03-03T22:04:31Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Control Stream works fine",
              "createdAt": "2023-03-03T22:04:30Z",
              "updatedAt": "2023-03-03T22:04:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5O9KZi",
          "commit": {
            "abbreviatedOid": "7bb5ee9"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-03T22:05:09Z",
          "updatedAt": "2023-03-03T22:05:09Z",
          "comments": [
            {
              "originalPosition": 99,
              "body": "Its an optional field as defined in the RFC9000",
              "createdAt": "2023-03-03T22:05:09Z",
              "updatedAt": "2023-03-03T22:05:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5O9Lg3",
          "commit": {
            "abbreviatedOid": "7bb5ee9"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-03T22:08:22Z",
          "updatedAt": "2023-03-03T22:08:22Z",
          "comments": [
            {
              "originalPosition": 120,
              "body": "I am fine with it .. This is needed for relays to know if it needs to keep the state active. Having standard renewal period will keep them alive at the Relays and the Relays don't have to guess.",
              "createdAt": "2023-03-03T22:08:22Z",
              "updatedAt": "2023-03-03T22:08:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5O9LjH",
          "commit": {
            "abbreviatedOid": "7bb5ee9"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-03T22:08:31Z",
          "updatedAt": "2023-03-03T22:08:32Z",
          "comments": [
            {
              "originalPosition": 123,
              "body": "yes, we don't need it",
              "createdAt": "2023-03-03T22:08:31Z",
              "updatedAt": "2023-03-03T22:08:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5O9Ng3",
          "commit": {
            "abbreviatedOid": "7bb5ee9"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-03T22:15:13Z",
          "updatedAt": "2023-03-03T22:15:14Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "May be its not clear in the way its written. Let me try to capture the thinking\r\n\r\n- There are flows where there is a agreement between the Relay and the application server domain that will enable the Relays do carry out authorization on behalf of the origin \r\n- There are cases where such agreement isn't possible and the authorization request needs to be forwarded to the origin.\r\n\r\nAnd why do we need a REPLY message and why not just cancel the stream under error - Yes, that's a good suggestion. however for the cases where multiple tracks are in a subscribe request and only few of them are authorized for the user, the REPLY will capture the aythorized tracks.\r\n\r\n",
              "createdAt": "2023-03-03T22:15:13Z",
              "updatedAt": "2023-03-03T22:15:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5O9OGV",
          "commit": {
            "abbreviatedOid": "7bb5ee9"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-03T22:16:15Z",
          "updatedAt": "2023-03-03T22:16:15Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "Also on should it be called EncryptedPayload - I am not tied to the name of the field other than the intended utility\r\n\r\nWe can call it AuthorazationPayload ",
              "createdAt": "2023-03-03T22:16:15Z",
              "updatedAt": "2023-03-03T22:16:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5O9OLI",
          "commit": {
            "abbreviatedOid": "7bb5ee9"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-03T22:16:19Z",
          "updatedAt": "2023-03-03T22:16:20Z",
          "comments": [
            {
              "originalPosition": 139,
              "body": "+1",
              "createdAt": "2023-03-03T22:16:20Z",
              "updatedAt": "2023-03-03T22:16:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5O9OgA",
          "commit": {
            "abbreviatedOid": "7bb5ee9"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-03T22:17:17Z",
          "updatedAt": "2023-03-03T22:17:18Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "Agreed. Also I will fix this ",
              "createdAt": "2023-03-03T22:17:17Z",
              "updatedAt": "2023-03-03T22:17:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5O9Oh8",
          "commit": {
            "abbreviatedOid": "7bb5ee9"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-03T22:17:26Z",
          "updatedAt": "2023-03-03T22:17:27Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "good point",
              "createdAt": "2023-03-03T22:17:26Z",
              "updatedAt": "2023-03-03T22:17:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5O9OrD",
          "commit": {
            "abbreviatedOid": "7bb5ee9"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-03T22:18:11Z",
          "updatedAt": "2023-03-03T22:18:11Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "IsDiscardable is set for those frames that has no one depending on it. I can add the clarification",
              "createdAt": "2023-03-03T22:18:11Z",
              "updatedAt": "2023-03-03T22:18:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5O9PQy",
          "commit": {
            "abbreviatedOid": "7bb5ee9"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-03T22:20:28Z",
          "updatedAt": "2023-03-03T22:20:29Z",
          "comments": [
            {
              "originalPosition": 196,
              "body": "Relays will use priority as lower the number , the important the object is.  Applications can encode priority to influence the experience they need. Say if the group has 60hz and 30 hz frames, the application can choose to mark 30hz frames to be of more important than the 60hz ones. Relays need not have to understand application semantics and they look at simple priority rule.",
              "createdAt": "2023-03-03T22:20:28Z",
              "updatedAt": "2023-03-03T22:20:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5O-O7m",
          "commit": {
            "abbreviatedOid": "7bb5ee9"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-04T04:23:48Z",
          "updatedAt": "2023-03-04T04:23:49Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Above assumes that control stream  is tied to a broadcast.\r\nWhat this PR is saying is,  Control Stream is tied to one or more track (and their data streams). With this, if an application want to tie all the tracks within a broadcast to control stream , then that should be fine. But that is just one way to do. \r\n\r\nI think we should keep ourselves from forcing a solution as a requirement but rather mention property that defines the relation between itself and the data streams. Then it is per use-case basis to decide on how to set that up.",
              "createdAt": "2023-03-04T04:23:48Z",
              "updatedAt": "2023-03-04T04:23:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PGiVs",
          "commit": {
            "abbreviatedOid": "7bb5ee9"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T20:06:32Z",
          "updatedAt": "2023-03-06T20:36:39Z",
          "comments": [
            {
              "originalPosition": 99,
              "body": "Optional fields in QUIC only work because the message type indicates if fields are present. You would have to do something similar if you want to reuse how RFC 9000 represents optional fields.\r\n\r\n> The Type field in the STREAM frame takes the form 0b00001XXX (or the set of values from 0x08 to 0x0f). The three low-order bits of the frame type determine the fields that are present in the frame:\r\n\r\nThe same is true for ACK, which has two message types based on the presence of ECN markings.\r\n\r\nWhat I'm trying to say is that it's impossible to encode/decode this message. There's not enough information on if the group ID or object ID fields are present.",
              "createdAt": "2023-03-06T20:06:32Z",
              "updatedAt": "2023-03-06T20:36:39Z"
            },
            {
              "originalPosition": 120,
              "body": "Why couldn't a SUBSCRIBE last until an UNSUBSCRIBE message, or the session is closed?\r\n\r\nThe idea of missing some OBJECTs because the SUBSCRIBE message is not frequent enough is terrifying. At the very least you would have to negotiate something like QUIC's max_idle_timeout. If your goal is to detect dead connections, then that QUIC idle timeout is more than enough.",
              "createdAt": "2023-03-06T20:11:09Z",
              "updatedAt": "2023-03-06T20:36:39Z"
            },
            {
              "originalPosition": 129,
              "body": "It sounds like you envision completely unauthorized relays, who \"borrow\" authorization from viewers to fetch from any origin in the world. It's certainly an option, but it really hurts the fanout potential of relays, mostly because the a single origin has to authenticate every viewer (...every 5 seconds).\r\n\r\nThe HTTP ecosystem is designed around \"authorized relays\". A viewer will connect to a CDN (ex. Akamai) and will be authorized for a particular request/broadcast. This can be a simple as knowing the URL, since guessing a long random URL is basically the same as guessing a password or auth token.\r\n\r\nOn the first viewer, the CDN authorizes itself with an upstream. Note that the upstream might not be the origin, which is often the case when chaining CDNs (see Will's email). That request is authorized, either based on a pre-negotiated token or a unique path as provided/decoded by user. This pre-established chain of upstreams continues until the origin is reached.\r\n\r\n---\r\n\r\nRegardless, what you're really grasping at here is \"how do I know if a relay modified the content?\" The answer is you can't without signing everything that originates from the origin. Otherwise a relay could take the viewer's authorization token, forward it to the origin, but then rewrite OBJECTs for some nefarious purpose.\r\n\r\nThe same is true for HTTP CDNs. If you ask Akamai to give you the Google homepage, then there's no way to trust the actual response unless it's signed using Google's public certificate. How the web actually works if that the Google homepage (authenticated) will tell you to load a given Akamai URL, effectively giving it a stamp of approval. The resulting response is NOT signed by Google but rather this implicit chain of trust.\r\n\r\nTo put it in MoQ terms, if whitehouse.gov embeds a video with an Akamai URL, then you can trusts it. Meanwhile if some random website embeds Akamai URL and says it's an official stream, then you can't trust it, and Akamai can even say \"no\" via CORS. If you really want to validate that Akamai hasn't been hacked for some geo-political purpose, then you use DRM to sign the media content to avoid tampering.",
              "createdAt": "2023-03-06T20:36:17Z",
              "updatedAt": "2023-03-06T20:37:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PGzcF",
          "commit": {
            "abbreviatedOid": "7bb5ee9"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T21:00:25Z",
          "updatedAt": "2023-03-06T21:00:25Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "> - There are flows where there is a agreement between the Relay and the application server domain that will enable the Relays do carry out authorization on behalf of the origin\r\n> - There are cases where such agreement isn't possible and the authorization request needs to be forwarded to the origin.\r\n\r\nThat last bullet is the exact opposite. A viewer MUST NOT be able to connect to an arbitrary CDN and ask for an arbitrary origin.\r\n\r\nCDNs work via a very complicated billing and routing song and dance; the best route will almost never be the cheapest. Both the application and the CDN need a way of controlling what traffic flows where.\r\n\r\nFor example, a viewer tries to watch a Twitch stream from San Francisco. There could be any number of CDNs with an edge in San Francisco, but to use them we have to sign a contract and pay for that traffic, often based on peak* bandwidth utilization. A CDN won't serve traffic for free.\r\n\r\nTwitch has an edge in San Jose so we assign the traffic there because it's close enough and significantly cheaper. Although we peer based on the ISP, so that might not even be true for specific ISPs. And our San Jose data center could be at max capacity, and then we have to decide if we fall over to a CDN or a further away edge. \r\n\r\nThere's also cache-hit ratios to take into account. It's significantly more expensive to serve the first viewer for a broadcast from an edge than the hundredth viewer. In fact, we will often assign the first viewer to an edge across an ocean, so we can use our limited capacity on more important broadcasts.\r\n\r\nIt all boils down to a giant optimization problem based on way too many factors. The closest data center is not the best and the viewer cannot expect to pull media from wherever it wants. The relay needs the ability to authorize each viewer.",
              "createdAt": "2023-03-06T21:00:25Z",
              "updatedAt": "2023-03-06T21:02:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PHRdE",
          "commit": {
            "abbreviatedOid": "7bb5ee9"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-06T22:33:43Z",
          "updatedAt": "2023-03-06T23:05:52Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Not a bad DISCUSS, but it's probably broader than just this PR.",
              "createdAt": "2023-03-06T22:33:43Z",
              "updatedAt": "2023-03-06T23:05:52Z"
            },
            {
              "originalPosition": 32,
              "body": "I'm curious what is the motivation for a control stream per track? ",
              "createdAt": "2023-03-06T22:36:45Z",
              "updatedAt": "2023-03-06T23:05:52Z"
            },
            {
              "originalPosition": 34,
              "body": "+1 for clarity.  Perhaps the part we need to discuss (related to #95) is whether OBJECTs in the same GROUP can go over different unidirectional streams?",
              "createdAt": "2023-03-06T22:41:50Z",
              "updatedAt": "2023-03-06T23:05:52Z"
            },
            {
              "originalPosition": 36,
              "body": "This is also tied to #98 - because if that is merged, then the WT stream can be used as a bidirectional control channel for the broadcast.",
              "createdAt": "2023-03-06T22:44:54Z",
              "updatedAt": "2023-03-06T23:05:52Z"
            },
            {
              "originalPosition": 32,
              "body": "Is it worth noting that H3 implemented this as a pair of unidirectional control streams rather than a single bidirectional one?  How much overlap is there in the set of messages sent by a publisher vs a receiver?  How many of the messages are \"request/response\" vs one-way?",
              "createdAt": "2023-03-06T22:46:24Z",
              "updatedAt": "2023-03-06T23:05:52Z"
            },
            {
              "originalPosition": 36,
              "body": "Again, I would like to see the per-track use-case before we add the complexity of control stream per-track.  Are there also messages that apply to the entire session and not to any tracks?",
              "createdAt": "2023-03-06T22:48:34Z",
              "updatedAt": "2023-03-06T23:05:52Z"
            },
            {
              "originalPosition": 89,
              "body": "It seems like you are saying a subscription request must be forwarded by a relay to an Origin, but I assume that one of the purposes for having a relay is to prevent end clients from bothering the origin.\r\n\r\nAgree this is hard to understand -- it's the first mention of `SubscriptionId` for one, and it seems strange that to subscribe I need to have a control channel set up for that id first?  How do I do that?\r\n\r\n+1 to Victor's earlier comment that authorization text should be punted for now (possibly til after adoption)",
              "createdAt": "2023-03-06T22:53:44Z",
              "updatedAt": "2023-03-06T23:05:52Z"
            },
            {
              "originalPosition": 112,
              "body": "At the risk of piling on, I agree that we can probably move faster at this stage by agreeing on the minimal set, which doesn't include auth (yet!).  So I'd recommend removing this field for now.",
              "createdAt": "2023-03-06T22:59:27Z",
              "updatedAt": "2023-03-06T23:05:52Z"
            },
            {
              "originalPosition": 120,
              "body": "Given that this implementation detail requires more discussion than the basic idea of control streams, maybe separate it out.",
              "createdAt": "2023-03-06T23:00:26Z",
              "updatedAt": "2023-03-06T23:05:52Z"
            },
            {
              "originalPosition": 194,
              "body": "I'm unclear why you chose to add the flags field in this PR about control streams and subscriptions.",
              "createdAt": "2023-03-06T23:04:10Z",
              "updatedAt": "2023-03-06T23:05:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PJv6b",
          "commit": {
            "abbreviatedOid": "7bb5ee9"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-07T09:19:42Z",
          "updatedAt": "2023-03-07T09:19:42Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Yes , they can go, like in RUSH",
              "createdAt": "2023-03-07T09:19:42Z",
              "updatedAt": "2023-03-07T09:19:42Z"
            }
          ]
        }
      ]
    },
    {
      "number": 97,
      "id": "PR_kwDOG2Ho4M5KlPFr",
      "title": "Add support for publish req/reply message ",
      "url": "https://github.com/moq-wg/moq-transport/pull/97",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR depends on #96 \r\n\r\nAdds support for publish req/reply message to link with the control channel. \r\n\r\nKnown Issue: Discuss how the Catalog message interaction works and base it on the resolution from #66 , #85 ",
      "createdAt": "2023-02-23T08:02:56Z",
      "updatedAt": "2023-05-05T16:57:55Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "c7feeb4777b1dd696e3eac6037eea3e5f84b9954",
      "headRepository": "suhasHere/warp-draft",
      "headRefName": "pub_authz",
      "headRefOid": "e34a3b938e6b8182b02abe321d20fafb58077355",
      "closedAt": "2023-05-05T16:57:55Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Can you change this PR so the base branch is #96 ? I can't review it without the unique diffs.",
          "createdAt": "2023-03-02T07:13:37Z",
          "updatedAt": "2023-03-02T07:13:37Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Overtaken by #122 and #123, correct?  Can this be closed?",
          "createdAt": "2023-04-21T19:11:11Z",
          "updatedAt": "2023-04-21T19:11:11Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Is this still relevant  ?\r\n",
          "createdAt": "2023-05-05T16:47:52Z",
          "updatedAt": "2023-05-05T16:47:52Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 98,
      "id": "PR_kwDOG2Ho4M5LLk22",
      "title": "Merge broadcast URN with the WebTransport URL.",
      "url": "https://github.com/moq-wg/moq-transport/pull/98",
      "state": "MERGED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "There's quite a few benefits for such a minor change:\r\n\r\n* broadcast selection is now explicitly authorized\r\n* prioritization works at the WebTransport level\r\n* OBJECT headers are much smaller.\r\n* CATALOG messages are simpler (too simple).\r\n* OBJECT messages no longer need to be rewritten.\r\n* Only one control stream is needed. (TODO)\r\n* Generic clients work via a single URL now.\r\n\r\nSee the mailing list for more in-depth rationale.",
      "createdAt": "2023-03-03T01:06:54Z",
      "updatedAt": "2023-04-07T21:25:58Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "4a7f215272cc14a143c0c197f5b2175b3460124b",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "remove-broadcast",
      "headRefOid": "4221c8512b05a5b6db0370e916bb7dbd4668dd27",
      "closedAt": "2023-03-13T23:51:51Z",
      "mergedAt": "2023-03-13T23:51:51Z",
      "mergedBy": "kixelated",
      "mergeCommit": {
        "oid": "19c8e1ca846960e68ff0be11bd2e101433370603"
      },
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that we shouldn't really need an extra layer of pooling if we can just use WebTransport pooling for this.\r\n\r\nOne minor concern I have is that we *are* chartered to specify MoQ that works both over raw QUIC and over WT, but I guess we can just say that if you use raw QUIC, you don't get pooling (given the motivations I can anticipate for using MoQ without WT, that sounds like a fair trade-off).\r\n\r\nWill review the text in detail later.",
          "createdAt": "2023-03-03T18:07:32Z",
          "updatedAt": "2023-03-03T18:07:32Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I like this concept, as it pushes any \"pooling\" complexity up one layer to WebTransport rather than reinventing (and re-arguing) all of those details here -- I just saw \"flow control\" mentioned on the list.",
          "createdAt": "2023-03-06T22:05:28Z",
          "updatedAt": "2023-03-06T22:05:28Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I apologize for not being more careful about indicating the hat I'm wearing while reviewing PRs.  Please consider my comments on this PR as an individual.",
          "createdAt": "2023-03-07T17:03:31Z",
          "updatedAt": "2023-03-07T17:03:31Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "As an individual: \r\n\r\nThis may be a question for WebTransport -- how are streams across different WebTransport sessions prioritized?  The WebTransport CONNECT request can have an HTTP Priority header -- one logical interpretation is that all streams belonging to that session be prioritized \"under\" that top level prioritization.  eg: if I have two sessions at the same urgency and incremental on, session A has 3 streams and session B has 1, then I might expect the scheduler to round-robin at the session level (rather than the QUIC stream level), splitting the bandwidth 50/50 between A and B.  Is that correct?",
          "createdAt": "2023-03-07T17:49:03Z",
          "updatedAt": "2023-03-07T17:49:03Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5O2usf",
          "commit": {
            "abbreviatedOid": "39f5004"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-03T01:08:50Z",
          "updatedAt": "2023-03-03T01:08:50Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I can revert this change if requested.\r\n\r\nI felt there was too much attention to a single, latency reduction feature in the object model which is just meant to be a summary. So I tried to summarize the feature into a single sentence.",
              "createdAt": "2023-03-03T01:08:50Z",
              "updatedAt": "2023-03-03T01:19:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5O2vvJ",
          "commit": {
            "abbreviatedOid": "39f5004"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-03T01:16:28Z",
          "updatedAt": "2023-03-03T01:16:29Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "@suhasHere We can now replace this with a single control stream for the entire session (the same one used for SETUP?).",
              "createdAt": "2023-03-03T01:16:29Z",
              "updatedAt": "2023-03-03T01:16:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5O2wBC",
          "commit": {
            "abbreviatedOid": "39f5004"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-03T01:18:35Z",
          "updatedAt": "2023-03-03T01:18:36Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "@wilaw The CATALOG is criminally simple now. Let's do your suggestion in #66.",
              "createdAt": "2023-03-03T01:18:35Z",
              "updatedAt": "2023-03-03T01:18:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5POUXs",
          "commit": {
            "abbreviatedOid": "a8de508"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-07T17:31:00Z",
          "updatedAt": "2023-03-07T17:31:00Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "> Depending on the the application, the sender may decide to unilaterally push tracks without an explicit subscription to reduce latency.\r\n\r\nHow would this work with a relay? The relay would have no incoming subscription request to match the arriving objects against and would not know what to do with the traffic. ",
              "createdAt": "2023-03-07T17:31:00Z",
              "updatedAt": "2023-03-07T17:31:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PvT0C",
          "commit": {
            "abbreviatedOid": "a8de508"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM as-is, but you may want to update the definition of the broadcast to explain why we choose to bundle those tracks.",
          "createdAt": "2023-03-13T19:31:19Z",
          "updatedAt": "2023-03-13T19:35:22Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I think per discussion, we should replace \"produced by a single origin\" with \"can be prioritized between each other\", since this seems to be the most salient property here.",
              "createdAt": "2023-03-13T19:31:19Z",
              "updatedAt": "2023-03-13T19:35:22Z"
            },
            {
              "originalPosition": 44,
              "body": "We should probably remove this for now.  Recall that we don't actually expose status codes in the Web API, so we may need to add something like this to the SETUP message at some point.",
              "createdAt": "2023-03-13T19:34:17Z",
              "updatedAt": "2023-03-13T19:35:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PHGAl",
          "commit": {
            "abbreviatedOid": "af7b25b"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "flushing old review comments",
          "createdAt": "2023-03-06T21:58:52Z",
          "updatedAt": "2023-03-13T22:12:48Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I think the example was illustrative, but could maybe go in a different place in the document? ",
              "createdAt": "2023-03-06T21:58:52Z",
              "updatedAt": "2023-03-13T22:12:48Z"
            },
            {
              "originalPosition": 35,
              "body": "Is `requested broadcast` the right terminology if the client is a publisher?",
              "createdAt": "2023-03-06T21:59:39Z",
              "updatedAt": "2023-03-13T22:12:48Z"
            },
            {
              "originalPosition": 36,
              "body": "\"this information\" seems ambiguous.  I think you now mean information to identify the broadcast and possibly authentication/authorization information?",
              "createdAt": "2023-03-06T22:01:04Z",
              "updatedAt": "2023-03-13T22:12:48Z"
            },
            {
              "originalPosition": 44,
              "body": "I find the MAY here a little weak.  The text already states that a non-200 code is returned for errors.  If we want to standardize on particular HTTP error codes for certain error conditions, then we should make the normative language stronger.  If not, then just one or two of these in a \"for example\" will communicate the idea.",
              "createdAt": "2023-03-06T22:02:51Z",
              "updatedAt": "2023-03-13T22:12:48Z"
            },
            {
              "originalPosition": 101,
              "body": "`...in the broadcast ` was still providing some value.",
              "createdAt": "2023-03-06T22:03:39Z",
              "updatedAt": "2023-03-13T22:12:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PwUg1",
          "commit": {
            "abbreviatedOid": "132ebbd"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T22:44:51Z",
          "updatedAt": "2023-03-13T22:44:52Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Reverted the example.",
              "createdAt": "2023-03-13T22:44:51Z",
              "updatedAt": "2023-03-13T22:44:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PwUwa",
          "commit": {
            "abbreviatedOid": "132ebbd"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-13T22:46:05Z",
          "updatedAt": "2023-03-13T22:46:05Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5PwaVF",
          "commit": {
            "abbreviatedOid": "f97fe61"
          },
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T23:12:47Z",
          "updatedAt": "2023-03-13T23:12:47Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "> a broadcast ID and authentication token\r\n\r\nnit: since we replacing \"broadcast\" with \"track bundle\", should we say just \"an ID\" instead of \"broadcast ID\"",
              "createdAt": "2023-03-13T23:12:47Z",
              "updatedAt": "2023-03-13T23:12:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PwbKq",
          "commit": {
            "abbreviatedOid": "f97fe61"
          },
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T23:14:58Z",
          "updatedAt": "2023-03-13T23:14:59Z",
          "comments": [
            {
              "originalPosition": 116,
              "body": "unique globally or unique within track bundle?",
              "createdAt": "2023-03-13T23:14:58Z",
              "updatedAt": "2023-03-13T23:14:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PwbsS",
          "commit": {
            "abbreviatedOid": "f97fe61"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T23:16:25Z",
          "updatedAt": "2023-03-13T23:16:25Z",
          "comments": [
            {
              "originalPosition": 116,
              "body": "Track bundle; fixed.",
              "createdAt": "2023-03-13T23:16:25Z",
              "updatedAt": "2023-03-13T23:16:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Pwbzn",
          "commit": {
            "abbreviatedOid": "f97fe61"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T23:16:44Z",
          "updatedAt": "2023-03-13T23:16:44Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "seems gud",
              "createdAt": "2023-03-13T23:16:44Z",
              "updatedAt": "2023-03-13T23:16:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SDSx3",
          "commit": {
            "abbreviatedOid": "4221c85"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-07T21:22:48Z",
          "updatedAt": "2023-04-07T21:25:57Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "except when it is not. Can we figure out how to write this to work for both raw quic and webetransport ",
              "createdAt": "2023-04-07T21:22:48Z",
              "updatedAt": "2023-04-07T21:25:57Z"
            },
            {
              "originalPosition": 19,
              "body": "My proposal would be once Victor sets up the PR on raw quick that we get the info in the URL from a connect message if we are not using web transport. I think that can keep the code about the same. ",
              "createdAt": "2023-04-07T21:25:10Z",
              "updatedAt": "2023-04-07T21:25:57Z"
            }
          ]
        }
      ]
    },
    {
      "number": 99,
      "id": "PR_kwDOG2Ho4M5L1yhK",
      "title": "Object Model V3 (post 2nd virtual interim)",
      "url": "https://github.com/moq-wg/moq-transport/pull/99",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is the 3rd attempt to capture some of the discussions out of the 2nd virtual interim\r\n",
      "createdAt": "2023-03-12T17:55:40Z",
      "updatedAt": "2023-03-13T23:08:45Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "c7feeb4777b1dd696e3eac6037eea3e5f84b9954",
      "headRepository": "suhasHere/warp-draft",
      "headRefName": "objects",
      "headRefOid": "b200599e180be30c9c0dae814717f0d5e7ecaa88",
      "closedAt": "2023-03-13T23:08:44Z",
      "mergedAt": "2023-03-13T23:08:44Z",
      "mergedBy": "afrind",
      "mergeCommit": {
        "oid": "d196f0f9f21c483a7d3b0fb60b6966aa3615e1f9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5PozPx",
          "commit": {
            "abbreviatedOid": "4f1d701"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-12T22:33:52Z",
          "updatedAt": "2023-03-13T00:06:36Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "\"origin\" is a bit of an ambiguous term here, and I'm not sure this quite captures the reason we choose to bundle those in the first place.  How about something like \"share the timestamp space\"?",
              "createdAt": "2023-03-12T22:33:52Z",
              "updatedAt": "2023-03-13T00:06:37Z"
            },
            {
              "originalPosition": 15,
              "body": "I don't understand the rationale behind requiring an object to contain the smallest decodable entity possible.  Even if you assume an object is always encrypted, you can still put multiple ciphertexts inside an object (and the relays would not know that, since, well, the objects are opaque).\r\n\r\nI believe we would have an easier time defining objects if we focus on how they are sent/received (transport aspect), rather than how they are encoded/decoded (application aspect).  As far as I can see, the two properties we have right now are:\r\n* Objects are the smallest thing that has headers.\r\n* Objects are the smallest thing that can be transmitted independently of each other (i.e. on different streams).\r\n\r\nDoes this sound right to you?",
              "createdAt": "2023-03-12T23:42:55Z",
              "updatedAt": "2023-03-13T00:06:37Z"
            },
            {
              "originalPosition": 20,
              "body": "> The first object in the group MUST have the necessary dependency information needed to processs the rest of the objects. However, certain grouping MAY allow other objects within the group to carry dependency information. \r\n\r\nI feel like this is a really weird way to phrase this when in reality we almost always expect the objects in the group to depend on other objects that are not the first object of the group.  Could you reword this?",
              "createdAt": "2023-03-13T00:03:23Z",
              "updatedAt": "2023-03-13T00:06:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PoznM",
          "commit": {
            "abbreviatedOid": "4f1d701"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Remarkably better than V1 and V2. There's still a few rough areas, but it's headed in the right direction.",
          "createdAt": "2023-03-12T22:44:44Z",
          "updatedAt": "2023-03-13T02:11:24Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "It's weird that some words are sometimes capitalized (Relay and Object). IMO bold them in the definition like the old text and keep them lowercase.\r\n",
              "createdAt": "2023-03-12T22:44:44Z",
              "updatedAt": "2023-03-13T02:11:24Z"
            },
            {
              "originalPosition": 8,
              "body": "Keep in mind that objects can hold non-media payloads. I think media specific examples are good, but the wording here should be more generic.\r\n\r\n---\r\n\r\nWhat does \"makes sense to decode\" mean? I get what you're trying to say, but there's a lot of missing context this early in the specification. For example, it's not even mentioned that objects are delivered independently and can be lost. That's underlying reason why we're fragmenting into objects in the first place. Either remove this text or elaborate.\r\n\r\nMinor nit: I would simplify \"may not be independently decodable\" and combine it with the group membership thing. An object only a member of a group because it implies dependencies.\r\n\r\nLet me review the rest of the draft first and try to offer some concrete suggestions.",
              "createdAt": "2023-03-12T23:03:16Z",
              "updatedAt": "2023-03-13T02:11:24Z"
            },
            {
              "originalPosition": 11,
              "body": "Add some non-media examples (stream of metadata), some more fringe features (captions), and simplify the media examples (don't mention P frame or even \"audio frame\").\r\n\r\nAnd I know you want to scope an object down to a single frame/slice, but there's no reason to add that restriction. An object can contain any number of bytes, and number of samples, any number of slices, any number of frames, any number of layers, etc. A relay doesn't actually care what's inside in the object payload, that's up to the negotiated codec.",
              "createdAt": "2023-03-12T23:15:19Z",
              "updatedAt": "2023-03-13T02:11:24Z"
            },
            {
              "originalPosition": 13,
              "body": "> Objects are not partially decodable.\r\n\r\nObjects may be partially decodable. Even in your frame example, a decoder may still be able to use the first slices, or even a partial slice if they're willing to artifact.\r\n\r\nThe object payload is intended to be delivered in order, but may be starved or abruptly reset. A decoder may utilize an incomplete object payload. Note that this is the premise behind being able to drop the tail of a GoP.",
              "createdAt": "2023-03-12T23:28:20Z",
              "updatedAt": "2023-03-13T02:11:24Z"
            },
            {
              "originalPosition": 14,
              "body": "> The end to end encryption and authentication operations are performed across the whole object, thus rendering partial objects unusable\r\n\r\nThis reads like there's aways end-to-end encryption and authentication. I like it as an example of when an object can't be partially decoded, but it's not true in all cases.\r\n\r\nAnd to be clear, some DRM schemes aren't actually performed across the whole object. I know some only encrypt the mdat container but not the rest of the container. It's also possible to not authenticate (not recommended: stream cipher), or authenticate at a smaller interval (multiple AEAD), as opposed to authenticating the entire object (single AEAD).\r\n\r\nI'm sure we will eventually specify some end-to-end encryption scheme within MoQ. AEAD encoding the entire OBJECT payload sounds like a great idea. Until then, and even after then, partial decodability depends on the application/codec.",
              "createdAt": "2023-03-12T23:36:42Z",
              "updatedAt": "2023-03-13T02:21:12Z"
            },
            {
              "originalPosition": 15,
              "body": "Yeah, I agree, the fragmentation boundary should be based on when objects have different properties or should be transmitted independently. Requiring the minimum possible fragmentation is both vague and creates a lot of objects to manage.\r\n\r\nI would tweak your \"can be transmitted independently\" Victor. Technically you could transmit each slice, audio sample, or even byte independently. There's no benefit to transmitting these independently for most applications, so it's usually not worth the overhead or complexity. Likewise transmitting individual frames has no benefit for most video encodings so it should be optional.",
              "createdAt": "2023-03-13T00:48:29Z",
              "updatedAt": "2023-03-13T02:11:24Z"
            },
            {
              "originalPosition": 15,
              "body": "> Objects MUST be uniquely identifiable within the MoQ delivery system.\r\n\r\nWhat is the \"MoQ delivery system\"? How are objects identified? Who is this MUST directed to? (draft authors?)\r\n\r\nYou should remove this sentence; I don't think it adds anything anyway.",
              "createdAt": "2023-03-13T00:55:32Z",
              "updatedAt": "2023-03-13T02:19:47Z"
            },
            {
              "originalPosition": 20,
              "body": "> Groups are composition of objects and they carry the necessary dependecy information needed to process the objects in the group\r\n\r\nThis message implies that GROUPs have metadata, but there's no GROUP message. I get what you're trying to say, but it's just a bit awkward.",
              "createdAt": "2023-03-13T00:57:13Z",
              "updatedAt": "2023-03-13T02:11:24Z"
            },
            {
              "originalPosition": 20,
              "body": "> Groups are composition of objects and they carry the necessary dependecy information needed to process the objects in the group. \r\n\r\nYeah this sentence is just wrong. The first object in a group does not know about the existence of future objects, let along contain a dependency graph like the sentence implies.",
              "createdAt": "2023-03-13T00:59:23Z",
              "updatedAt": "2023-03-13T02:21:45Z"
            },
            {
              "originalPosition": 20,
              "body": "> In such cases, the objects that carry information required to resolve dependencies MUST be marked appropriately in their headers.\r\n\r\nWhat does this mean? I don't understand who this MUST is targeting or how to mark these objects.",
              "createdAt": "2023-03-13T02:05:36Z",
              "updatedAt": "2023-03-13T02:11:24Z"
            },
            {
              "originalPosition": 22,
              "body": "This section is awkward. These aren't even examples; these are requirements. \r\n\r\nMy feedback for this entire section is that it the target audience is wrong. IMO, the goal of the object model is to summarize the protocol and the high level interactions for implementers. Instead, this text reads like requirements directed at draft authors.",
              "createdAt": "2023-03-13T02:09:40Z",
              "updatedAt": "2023-03-13T02:11:24Z"
            },
            {
              "originalPosition": 39,
              "body": "+1\r\n\r\nAt the very least you have to add \"origin\" to the terminology section, because I'm not even sure we agree on what that means.",
              "createdAt": "2023-03-13T02:10:40Z",
              "updatedAt": "2023-03-13T02:22:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PpCWu",
          "commit": {
            "abbreviatedOid": "4f1d701"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T02:18:23Z",
          "updatedAt": "2023-03-13T02:18:24Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "hmm, maybe something like:\r\n\r\n> An **object** is a fragment of a track. Each object is delivered and prioritized independently such that the track can be partially decoded in the event of congestion. An object may only depend on prior objects within the same group.\r\n\r\nIt's a little awkward because it mentions track. It might be a reason to list the object model top-down instead of bottom-up.",
              "createdAt": "2023-03-13T02:18:23Z",
              "updatedAt": "2023-03-13T02:18:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PpQPi",
          "commit": {
            "abbreviatedOid": "4f1d701"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T03:56:56Z",
          "updatedAt": "2023-03-13T03:56:56Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "this text is unchanged from the existing draft.",
              "createdAt": "2023-03-13T03:56:56Z",
              "updatedAt": "2023-03-13T03:56:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PpREe",
          "commit": {
            "abbreviatedOid": "4f1d701"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T04:03:40Z",
          "updatedAt": "2023-03-13T04:03:41Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I don't think transmitting object as a GOP is much useful and also leaving object definition undefined is pretty hard for implementing any useful strategies",
              "createdAt": "2023-03-13T04:03:40Z",
              "updatedAt": "2023-03-13T06:45:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PpRWc",
          "commit": {
            "abbreviatedOid": "4f1d701"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T04:05:52Z",
          "updatedAt": "2023-03-13T04:05:52Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "> > Groups are composition of objects and they carry the necessary dependecy information needed to process the objects in the group.\r\n> \r\n> Yeah this sentence is just wrong. The first object in a group does not know about the existence of future objects, let along contain a dependency graph like the sentence implies.\r\n\r\nAll this is saying is group defines some form of dependency relationship . Yes for video each object depends on the previous ones .. But that might not be the case for a different media or different grouping. ",
              "createdAt": "2023-03-13T04:05:52Z",
              "updatedAt": "2023-03-13T04:05:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PrBzr",
          "commit": {
            "abbreviatedOid": "4f1d701"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T10:30:25Z",
          "updatedAt": "2023-03-13T10:30:25Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Ah, good point.  I'll send a separate PR for that.",
              "createdAt": "2023-03-13T10:30:25Z",
              "updatedAt": "2023-03-13T10:30:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PrfAX",
          "commit": {
            "abbreviatedOid": "4f1d701"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T11:21:09Z",
          "updatedAt": "2023-03-13T12:06:49Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "I feel like the wording would probably make more sense if it were \"here are the things that you can do with groups\".",
              "createdAt": "2023-03-13T11:21:09Z",
              "updatedAt": "2023-03-13T12:06:49Z"
            },
            {
              "originalPosition": 20,
              "body": "Would \"an object cannot depend on any other object that is not in the same group\" be a sufficient description of what groups do?",
              "createdAt": "2023-03-13T11:33:27Z",
              "updatedAt": "2023-03-13T12:06:49Z"
            },
            {
              "originalPosition": 15,
              "body": "> I would tweak your \"can be transmitted independently\" Victor. Technically you could transmit each slice, audio sample, or even byte independently.\r\n\r\nThat's a fair point, \"MoQ will not transmit independently\" would be more accurate.\r\n\r\n> I don't think transmitting object as a GOP is much useful\r\n\r\nThere are some cases in which being able to do that is useful (e.g. you're taking pre-existing HLS segments and sending them as MoQ objects), and the advantage of dropping objects in the middle of GOP is not that large (e.g. when your GOPs are much smaller than your buffer).\r\n\r\n> leaving object definition undefined is pretty hard for implementing any useful strategies\r\n\r\nWell, it's currently defined as a \"sequence of bytes with a finite length\" (plus a header), and I believe that the rest should be up to the specific track format.  What kind of strategies do you have in mind?",
              "createdAt": "2023-03-13T11:57:04Z",
              "updatedAt": "2023-03-13T12:06:49Z"
            },
            {
              "originalPosition": 13,
              "body": "Also, regardless of whether they are decodable, they should always be partially deliverable.  For instance, if a relay receives the first half of a large object (which would be common for I-frames in high quality video), it should start forwarding those bytes to the subscribers immediately, instead of waiting for the rest of the object.  Doing otherwise would cause extra latency.",
              "createdAt": "2023-03-13T12:02:53Z",
              "updatedAt": "2023-03-13T12:06:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Pt5Tj",
          "commit": {
            "abbreviatedOid": "4f1d701"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T16:05:35Z",
          "updatedAt": "2023-03-13T16:32:11Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "This seems to be the heart of the disagreement.\r\n\r\n@suhasHere : do you have an example of specific negative consequences if the object property is relaxed from \"Objects are not partially decodable\" to \"Objects may be partially decodable\"?\r\n\r\nSince the only one doing decoding is the ultimate receiver of the media, I imagine it might require extra logic in that endpoint.  If that is the concern, can it be mitigated by adding a property to the object header that indicates if it is partially decodable?\r\n\r\n@kixelated @vasilvv : To transmit a GOP using the model in this PR, it sounds like you can -- make the GOP a single object, but it would need to be delivered in its entirety.  That seems counter to the goals, since tail dropping a GOP is the original use-case for Warp and seems like it should be supported.  The alternative is to break the GOP into two or more objects and assign send them in a group.  It sounds like the concern with this approach is 1) metadata overhead, 2) processing overhead to break up pre-existing segments to transmit them this way.  Is that correct?",
              "createdAt": "2023-03-13T16:05:35Z",
              "updatedAt": "2023-03-13T16:32:11Z"
            },
            {
              "originalPosition": 20,
              "body": "This is the other key point to resolve - what is the dependency relationship of objects in a group?   I think I've heard consistent pushback in the working group against attempting to encode too much dependency information on the wire (eg: the full tree is too much).\r\n\r\nThis snippet from #93 is one option:\r\n\r\n>  Applications can define groups however they see fit, as long as the following property applies:\r\n> \r\n> * If a decoder has received all previous objects from the beginning of a group\r\n  up to the current one, then the current one can be properly decoded and rendered.\r\n\r\nThis is consistent with @vasilvv 's suggestion above  -- \"cannot depend on any other object that is not in the same group\"\r\n\r\n@suhasHere : Does this definition work for the use cases you are envisioning or can you share examples where it won't work?",
              "createdAt": "2023-03-13T16:30:18Z",
              "updatedAt": "2023-03-13T16:32:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PuXTc",
          "commit": {
            "abbreviatedOid": "4f1d701"
          },
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T17:06:02Z",
          "updatedAt": "2023-03-13T17:06:03Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "> The end to end encryption and\r\nauthentication operations are performed across the whole object, thus\r\nrendering partial objects unusable.\r\n\r\nHm... \"whole object\" means metadata as well? That's probably not what we want. Also, text should probably say \"MAY be encrypted\" - we shouldn't require e2e encryption",
              "createdAt": "2023-03-13T17:06:02Z",
              "updatedAt": "2023-03-13T17:06:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PudCt",
          "commit": {
            "abbreviatedOid": "4f1d701"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T17:19:52Z",
          "updatedAt": "2023-03-13T17:19:53Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "> but it would need to be delivered in its entirety\r\n\r\nI don't see why this needs to be true.  You can process an object as you receive it, the same way HTTP clients process an HTTP response body as it arrives.  The main difference comes from whether you can do things like sending B frames at lower priority.\r\n\r\n> It sounds like the concern with this approach is 1) metadata overhead, 2) processing overhead to break up pre-existing segments to transmit them this way. Is that correct?\r\n\r\nYes, though I also want to have some flexibility here.  So, for instance, if I have a large buffer and I am doing live video delivery to the client, I would want an object per GOP to maximize efficiency; if I am doing live ingestion and I am trying to minimize latency, I would want to require the peer to send me at most one frame per object.",
              "createdAt": "2023-03-13T17:19:52Z",
              "updatedAt": "2023-03-13T17:19:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Puj-H",
          "commit": {
            "abbreviatedOid": "4f1d701"
          },
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T17:29:02Z",
          "updatedAt": "2023-03-13T17:29:03Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "hm... what about tracks that don't have or don't need init objects?",
              "createdAt": "2023-03-13T17:29:02Z",
              "updatedAt": "2023-03-13T17:29:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PukG8",
          "commit": {
            "abbreviatedOid": "4f1d701"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T17:29:21Z",
          "updatedAt": "2023-03-13T17:29:21Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Given we are coming short in time on draft deadline. I would suggest, we keep this as open issue and have both the options listed in the draft. This seems to be totally fine to have benefits from the larger WG discussion.\r\nThoughts ?\r\n\r\nI would propose the same with TrackIds being globally unique and why it wouldn't work technically.\r\n\r\n@afrind  love to hear your thought from chair perspective too",
              "createdAt": "2023-03-13T17:29:21Z",
              "updatedAt": "2023-03-13T17:29:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PulhC",
          "commit": {
            "abbreviatedOid": "4f1d701"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T17:33:00Z",
          "updatedAt": "2023-03-13T17:33:01Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "> Objects may be partially decodable.\r\n\r\nImplies there is something smaller than objects. What do we call them ? Sub-objects ?\r\n\r\nRather , i would lean towards objects are the smallest atomic unit that makes sense for the application. Anything larger that needs to be grouped , will be part of the group. \r\n\r\nThis provides a very clear distinction of object and group.",
              "createdAt": "2023-03-13T17:33:00Z",
              "updatedAt": "2023-03-13T17:33:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Pul3D",
          "commit": {
            "abbreviatedOid": "4f1d701"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T17:33:55Z",
          "updatedAt": "2023-03-13T17:33:56Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I would strongly suggest us to consider ietF BCP on encryption schemes. I would rather follow what BCP says than keeping the option open for MAY BE.\r\n",
              "createdAt": "2023-03-13T17:33:55Z",
              "updatedAt": "2023-03-13T17:33:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Pul8Z",
          "commit": {
            "abbreviatedOid": "4f1d701"
          },
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T17:34:08Z",
          "updatedAt": "2023-03-13T17:34:08Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "nit: does text needs to say \"media\"? are captions media? What about some head tracking data for VR?",
              "createdAt": "2023-03-13T17:34:08Z",
              "updatedAt": "2023-03-13T17:34:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PumHE",
          "commit": {
            "abbreviatedOid": "4f1d701"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T17:34:34Z",
          "updatedAt": "2023-03-13T17:34:34Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "may be reword it as\r\n\r\nGroups are composition of objects, where the objects in a group carry the necessary dependecy information needed to process the objects in the group",
              "createdAt": "2023-03-13T17:34:34Z",
              "updatedAt": "2023-03-13T17:34:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PumhZ",
          "commit": {
            "abbreviatedOid": "4f1d701"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T17:35:41Z",
          "updatedAt": "2023-03-13T17:35:42Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Shouldn't require vs when E2E encrypted to be useful are 2 different things. We need it to work for latter too",
              "createdAt": "2023-03-13T17:35:42Z",
              "updatedAt": "2023-03-13T17:35:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PumyF",
          "commit": {
            "abbreviatedOid": "4f1d701"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T17:36:21Z",
          "updatedAt": "2023-03-13T17:36:22Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "this is the original text. I did raise concerns on it multiple times .. Agree with your question",
              "createdAt": "2023-03-13T17:36:21Z",
              "updatedAt": "2023-03-13T17:36:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Pusgc",
          "commit": {
            "abbreviatedOid": "4f1d701"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T17:49:05Z",
          "updatedAt": "2023-03-13T17:49:06Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "> I don't think transmitting object as a GOP is much useful and also leaving object definition undefined is pretty hard for implementing any useful strategies\r\n\r\nYou're going to have to elaborate.\r\n\r\nWhy does a relay care if an object is partially decodable? Like Victor mentioned, a relay SHOULD forward incomplete objects anyway otherwise it adds latency at each hop. If the decoder could process incomplete objects... why disallow it?\r\n\r\n> @kixelated @vasilvv : To transmit a GOP using the model in this PR, it sounds like you can -- make the GOP a single object, but it would need to be delivered in its entirety. That seems counter to the goals, since tail dropping a GOP is the original use-case for Warp and seems like it should be supported. The alternative is to break the GOP into two or more objects and assign send them in a group. It sounds like the concern with this approach is 1) metadata overhead, 2) processing overhead to break up pre-existing segments to transmit them this way. Is that correct?\r\n\r\nYeah exactly. \r\n\r\nI would claim that 99% of the time there's no reason to break segments into frames. This is especially true for high-latency use cases that just want to send CMAF segments as the OBJECT payload for both backwards compatibility and simplicity. But it's also true for real-time use-cases that can't afford the latency or quality hit of non-reference frames (WebRTC).\r\n\r\nWe should absolutely support the ability to send each frame as an object, but it should be the niche case and not the mold. It's only useful when using temporal scalability, which I would not recommend enabling on purpose given the trade-offs, demonstrated by the lack of usage in the industry despite being easy in RTP. The only exception is when a hardware encoder uses a fixed GoP structure, but even then it's usually not worth the hassle.\r\n\r\nFor more generic use-cases, the usefulness of objects improves dramatically if they are not atomic. In fact, this is the core difference between SCTP messages and QUIC streams. I have split segments into frames and sent them over SCTP (WebRTC data channels) and it does not work *because* messages are atomic.\r\n\r\nSo please, loosen the restriction on objects; it does not improve the protocol in any way.",
              "createdAt": "2023-03-13T17:49:06Z",
              "updatedAt": "2023-03-13T17:54:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PuxMt",
          "commit": {
            "abbreviatedOid": "4f1d701"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T18:00:07Z",
          "updatedAt": "2023-03-13T18:00:07Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "> Implies there is something smaller than objects. What do we call them ? Sub-objects ?\r\n\r\nYou don't need to call them anything, they're just an object with only some bytes in the beginning available.\r\n\r\nImagine we're sending raw 16-bit PCM audio over MoQ.  If we require each atomically decodable unit to be an object, then our objects are now 2 bytes long.  We would then have to put a header on every two bytes, which does not sound like a desirable property.",
              "createdAt": "2023-03-13T18:00:07Z",
              "updatedAt": "2023-03-13T18:00:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Puxds",
          "commit": {
            "abbreviatedOid": "4f1d701"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T18:00:49Z",
          "updatedAt": "2023-03-13T18:00:50Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Yeah, I agree Alan. In #90 I stated the same thing as:\r\n\r\n> A object can depend on another objects, but only within the same group and with a smaller sequence number. This guarantees that an object is decodable if all prior members of the group have been delivered.\r\n\r\nI think @huitema wording is better in some aspects and worse in others. Let's try to pin that down.",
              "createdAt": "2023-03-13T18:00:49Z",
              "updatedAt": "2023-03-13T18:00:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Puxnk",
          "commit": {
            "abbreviatedOid": "4f1d701"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T18:01:15Z",
          "updatedAt": "2023-03-13T18:01:16Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Well, you presumably need something to tell you what's in that track.  \"init object\" is format-specific, and it's basically just a header for the track.",
              "createdAt": "2023-03-13T18:01:15Z",
              "updatedAt": "2023-03-13T18:01:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PuyUW",
          "commit": {
            "abbreviatedOid": "4f1d701"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T18:03:09Z",
          "updatedAt": "2023-03-13T18:03:09Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I think the encryption scheme should be specific to the track format (i.e. the transport itself does not know if it's encrypted or not).",
              "createdAt": "2023-03-13T18:03:09Z",
              "updatedAt": "2023-03-13T18:03:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PvRkW",
          "commit": {
            "abbreviatedOid": "4f1d701"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T19:24:34Z",
          "updatedAt": "2023-03-13T19:24:34Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Yeah, right now we shove dependencies for all groups/objects into the catalog as the init payload, specified on a per format basis. \r\n\r\nWe should either:\r\n1. fully punt that to the catalog, so it's a property of the catalog format itself (ex. base64 encoded in HLS)\r\n2. fully treat it as an object (ex. object 234 depends on object 0), which will make more sense when we properly support layered encoding\r\n\r\nI don't like mentioning the init object at all in the object model. ",
              "createdAt": "2023-03-13T19:24:34Z",
              "updatedAt": "2023-03-13T19:24:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PvR2Z",
          "commit": {
            "abbreviatedOid": "4f1d701"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T19:25:25Z",
          "updatedAt": "2023-03-13T19:25:26Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "I love that Victor commented on his own text. :P",
              "createdAt": "2023-03-13T19:25:26Z",
              "updatedAt": "2023-03-13T19:25:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PvSKc",
          "commit": {
            "abbreviatedOid": "4f1d701"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T19:26:22Z",
          "updatedAt": "2023-03-13T19:26:23Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Exactly, the relay is agnostic to any encoding or encryption.",
              "createdAt": "2023-03-13T19:26:23Z",
              "updatedAt": "2023-03-13T19:26:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PvSq2",
          "commit": {
            "abbreviatedOid": "4f1d701"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T19:27:56Z",
          "updatedAt": "2023-03-13T19:27:56Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Yeah, I haven't found the best way to word it. Something like GROUPs indicate crude dependencies for relays, while the more detailed dependencies are encoded at a lower level (ex. the codec) transparent to the relay.",
              "createdAt": "2023-03-13T19:27:56Z",
              "updatedAt": "2023-03-13T19:28:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PvbWf",
          "commit": {
            "abbreviatedOid": "0209d3e"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T19:42:59Z",
          "updatedAt": "2023-03-13T19:42:59Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "the overhead claim is incorrect. Data model shouldn't even touch about transport mapping",
              "createdAt": "2023-03-13T19:42:59Z",
              "updatedAt": "2023-03-13T19:42:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PvcX_",
          "commit": {
            "abbreviatedOid": "0209d3e"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T19:44:23Z",
          "updatedAt": "2023-03-13T19:44:24Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Also having backward compatibility with HLS is a nice thing , but not the requirement in MOQ and it should not block the future applications. ",
              "createdAt": "2023-03-13T19:44:23Z",
              "updatedAt": "2023-03-13T19:44:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Pvch4",
          "commit": {
            "abbreviatedOid": "0209d3e"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T19:44:55Z",
          "updatedAt": "2023-03-13T19:44:55Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "I would like to remove HLS reference here. Since RTP reference will turn this entire thinking around",
              "createdAt": "2023-03-13T19:44:55Z",
              "updatedAt": "2023-03-13T19:44:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Pvcwn",
          "commit": {
            "abbreviatedOid": "0209d3e"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T19:45:39Z",
          "updatedAt": "2023-03-13T19:45:40Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "We don't have agreement on \"An object is not\r\nnecessarily independently decodable\" in this para",
              "createdAt": "2023-03-13T19:45:39Z",
              "updatedAt": "2023-03-13T19:45:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Pvh9h",
          "commit": {
            "abbreviatedOid": "0209d3e"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T19:59:33Z",
          "updatedAt": "2023-03-13T19:59:33Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I thought this just means that an object can depend on other objects?  Otherwise you can't put an individual P-frame into an object.",
              "createdAt": "2023-03-13T19:59:33Z",
              "updatedAt": "2023-03-13T19:59:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PvjIC",
          "commit": {
            "abbreviatedOid": "0209d3e"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T20:03:05Z",
          "updatedAt": "2023-03-13T20:06:59Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "@suhasHere I'm confused.  Do you mean that objects are necessarily independently decodable?  I meant to convey that an object might or might not be independently decodable -- you can't assume anything because it's an object.\r\n\r\nDo you mean to say that metadata might indicate that it is independently decodable?  If so I don't think that's in conflict with this text.",
              "createdAt": "2023-03-13T20:03:05Z",
              "updatedAt": "2023-03-13T20:07:00Z"
            },
            {
              "originalPosition": 32,
              "body": "> the overhead claim is incorrect. Data model shouldn't even touch about transport mapping\r\n\r\nThis is what I heard from the other authors and it seems to me like adding OBJECT framing will add non-zero bytes so it seems legit.\r\n\r\n> HLS\r\n\r\nI was capturing the comment from @vasilvv here but I can remove the specific protocol reference and say something like existing segments.",
              "createdAt": "2023-03-13T20:06:44Z",
              "updatedAt": "2023-03-13T20:07:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PvmhG",
          "commit": {
            "abbreviatedOid": "0209d3e"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T20:13:38Z",
          "updatedAt": "2023-03-13T20:13:38Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I think the wording is confusing. Can we flip \"not independent\" to \"may depend\"?\r\n",
              "createdAt": "2023-03-13T20:13:38Z",
              "updatedAt": "2023-03-13T20:13:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PvnWr",
          "commit": {
            "abbreviatedOid": "0209d3e"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T20:16:19Z",
          "updatedAt": "2023-03-13T20:16:19Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "s/cannot/must not\r\n\r\nIf objects are allowed to be partially decodable, that's option 1.",
              "createdAt": "2023-03-13T20:16:19Z",
              "updatedAt": "2023-03-13T20:16:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Pv1ju",
          "commit": {
            "abbreviatedOid": "0209d3e"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T20:57:22Z",
          "updatedAt": "2023-03-13T20:57:22Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "It really comes down to fragmentation. Is the application allowed to decide how to fragment the media into objects?\r\n\r\nFor example, fMP4 has a configurable fragmentation interval. You can set it as long as a fragment per frame, or as high as a fragment per GoP, and anywhere in between. It's meant to specify the overhead versus latency trade-off. DASH typically uses a fragment per GoP while LL-DASH typically uses a fragment per frame.\r\n\r\nI see parallels with OBJECT, which is also why it was named FRAGMENT at one point in history. The number of fragments and their boundaries depends on the codec and application. It's the difference between processing single digit fragments per second with shared metadata, or processing hundreds of fragments per second each with their own independent metadata and ordering.\r\n\r\nNow technically fMP4 requires buffering the entire fragment because the sample metadata is a header, but that's a limitation with MP4 rather than a general rule. It's also why latency is part of the trade-off instead of just overhead. ",
              "createdAt": "2023-03-13T20:57:22Z",
              "updatedAt": "2023-03-13T20:59:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Pv2wc",
          "commit": {
            "abbreviatedOid": "0209d3e"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T21:01:09Z",
          "updatedAt": "2023-03-13T21:01:10Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "If an application is allowed to decide how to fragment media into objects, then it stands to reason that an application is allowed to decide on how to decode said objects.\r\n\r\nWe already agree that a relay must not buffer objects, so there's nothing preventing the application from partially decoding an object, just like an application may partially decode individual RTP payloads (split across packets).",
              "createdAt": "2023-03-13T21:01:09Z",
              "updatedAt": "2023-03-13T21:01:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PwAAZ",
          "commit": {
            "abbreviatedOid": "c7f4d43"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM if Suhas confirms that option 2 is what he's asking for.",
          "createdAt": "2023-03-13T21:29:30Z",
          "updatedAt": "2023-03-13T21:29:30Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5PwMS2",
          "commit": {
            "abbreviatedOid": "c7f4d43"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This should be a reasonable starting point for further discussion.",
          "createdAt": "2023-03-13T22:15:54Z",
          "updatedAt": "2023-03-13T22:15:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 100,
      "id": "PR_kwDOG2Ho4M5L7VUT",
      "title": "Define object groups",
      "url": "https://github.com/moq-wg/moq-transport/pull/100",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-03-13T19:27:45Z",
      "updatedAt": "2023-03-13T23:48:43Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "d196f0f9f21c483a7d3b0fb60b6966aa3615e1f9",
      "headRepository": "vasilvv/warp-draft",
      "headRefName": "object-groups",
      "headRefOid": "05c6b692bf1524370b8b4e4714976f3d068a4fca",
      "closedAt": "2023-03-13T23:40:24Z",
      "mergedAt": "2023-03-13T23:40:24Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "4a7f215272cc14a143c0c197f5b2175b3460124b"
      },
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe this reflects the common point we can all agree on, while reflecting the space for discussion.  Please correct me if got this wrong.",
          "createdAt": "2023-03-13T19:30:01Z",
          "updatedAt": "2023-03-13T19:30:01Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5PvZGM",
          "commit": {
            "abbreviatedOid": "9531ab6"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T19:39:07Z",
          "updatedAt": "2023-03-13T19:39:08Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "> Beginning of an object group can be used as a point at which the receiver can start receiving a track without having any other object groups available.\r\n\r\nEh the wording here is weird. What does the \"receiver can start receiving\" even mean?\r\n\r\nCan we at least say that each group is independent? Thinking about it a bit, that's all we need; it's actually fine to drop the \"smaller sequence\" property because delivery order effectively encodes that anyway.",
              "createdAt": "2023-03-13T19:39:08Z",
              "updatedAt": "2023-03-13T19:39:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PvgH3",
          "commit": {
            "abbreviatedOid": "9531ab6"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T19:53:52Z",
          "updatedAt": "2023-03-13T19:53:53Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "\"start consuming\" might be better to avoid tautology.\r\n\r\nI can add \"an object within a group cannot depend on an object within any other group\" if @suhasHere agrees with that.",
              "createdAt": "2023-03-13T19:53:52Z",
              "updatedAt": "2023-03-13T19:53:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Pvheb",
          "commit": {
            "abbreviatedOid": "9531ab6"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T19:58:05Z",
          "updatedAt": "2023-03-13T19:58:05Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I think that's the property you're trying to convey, and we should say it explicitly.",
              "createdAt": "2023-03-13T19:58:05Z",
              "updatedAt": "2023-03-13T19:58:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PviF3",
          "commit": {
            "abbreviatedOid": "9531ab6"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T19:59:56Z",
          "updatedAt": "2023-03-13T19:59:56Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "and I would give an example of why this property is useful. ex. The relay can determine whether to transmit objects at group boundaries (startup, ABR, etc).",
              "createdAt": "2023-03-13T19:59:56Z",
              "updatedAt": "2023-03-13T20:00:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PvpDV",
          "commit": {
            "abbreviatedOid": "9531ab6"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T20:21:37Z",
          "updatedAt": "2023-03-13T20:21:38Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "s/Beginning/The beginning/",
              "createdAt": "2023-03-13T20:21:37Z",
              "updatedAt": "2023-03-13T20:21:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Pv6sF",
          "commit": {
            "abbreviatedOid": "9531ab6"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T21:13:34Z",
          "updatedAt": "2023-03-13T21:13:34Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "> I think that's the property you're trying to convey, and we should say it explicitly.\r\n\r\nThe property in the current PR text is a somewhat weaker property (e.g. the current wording technically allows you to have H.264 open GOPs, while the stricter wording would prevent that).  I am personally fine with stricter wording, though.",
              "createdAt": "2023-03-13T21:13:34Z",
              "updatedAt": "2023-03-13T21:13:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PwFWJ",
          "commit": {
            "abbreviatedOid": "9531ab6"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T21:49:55Z",
          "updatedAt": "2023-03-13T21:49:55Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "> without having any other object groups available\r\n\r\nThat implies that groups are independent. If you want weaker text, then remove that last part of the sentence.\r\n\r\n> The beginning of an object group can be used as a point at which the receiver can start consuming a track",
              "createdAt": "2023-03-13T21:49:55Z",
              "updatedAt": "2023-03-13T21:49:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PwFr2",
          "commit": {
            "abbreviatedOid": "69c7672"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T21:51:21Z",
          "updatedAt": "2023-03-13T21:51:21Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Are groups orderedable by group ID?",
              "createdAt": "2023-03-13T21:51:21Z",
              "updatedAt": "2023-03-13T21:51:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PwGJ2",
          "commit": {
            "abbreviatedOid": "9531ab6"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T21:53:21Z",
          "updatedAt": "2023-03-13T21:53:22Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Of course that sentence is useless, but that's the point.\r\n\r\nI would go a step further and say that senders choose objects to transmit based on the group. This makes ABR possible, not just startup. But of course that's a stronger statement and we don't have the time to discuss.",
              "createdAt": "2023-03-13T21:53:21Z",
              "updatedAt": "2023-03-13T21:54:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PwGxp",
          "commit": {
            "abbreviatedOid": "69c7672"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T21:55:51Z",
          "updatedAt": "2023-03-13T21:55:52Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "They will need to be (how do you determine the newest group?), but let's punt that for now.",
              "createdAt": "2023-03-13T21:55:52Z",
              "updatedAt": "2023-03-13T21:55:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PwKpM",
          "commit": {
            "abbreviatedOid": "9531ab6"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T22:09:50Z",
          "updatedAt": "2023-03-13T22:09:51Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "> That implies that groups are independent. If you want weaker text, then remove that last part of the sentence.\r\n\r\nFrom what I understand, in H.264 with an open GOP support, your group can start with a bunch of B-frames that depend on the previous GOP (or end with B-frames referencing the future GOP?), and you're just supposed to skip those when seeking.  This works just fine (you still always have an I-frame), but none of your GOPs are ever fully independent.",
              "createdAt": "2023-03-13T22:09:50Z",
              "updatedAt": "2023-03-13T22:09:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5PwY3g",
          "commit": {
            "abbreviatedOid": "69c7672"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-13T23:07:23Z",
          "updatedAt": "2023-03-13T23:07:23Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5PwoQj",
          "commit": {
            "abbreviatedOid": "05c6b69"
          },
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T23:48:42Z",
          "updatedAt": "2023-03-13T23:48:42Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "we also need to define how subscriber would know about what groups have already been produced",
              "createdAt": "2023-03-13T23:48:42Z",
              "updatedAt": "2023-03-13T23:48:42Z"
            }
          ]
        }
      ]
    },
    {
      "number": 106,
      "id": "PR_kwDOG2Ho4M5MsIpb",
      "title": "Rename \"delivery order\" to \"send order\"",
      "url": "https://github.com/moq-wg/moq-transport/pull/106",
      "state": "MERGED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Matches the terminology used by W3C is generally much better.\r\nThis is the order at which objects are sent, but does not guarantee delivery in this order.\r\nDoesn't preclude further conversations about prioritization.",
      "createdAt": "2023-03-23T00:04:38Z",
      "updatedAt": "2023-04-21T23:16:20Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "903daa528293df746a96f58bfef7df438a8e617a",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "send-order",
      "headRefOid": "88aaa80c3b55e64563a17718cafc3c00ef5a925d",
      "closedAt": "2023-04-21T23:16:17Z",
      "mergedAt": "2023-04-21T23:16:17Z",
      "mergedBy": "kixelated",
      "mergeCommit": {
        "oid": "c57d17cba99a0a76f76ac52ff2265a6fba53a20a"
      },
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "This is just a rename so maybe merge it after fixing conflicts (you'll need another approval), or abandon?  Based on the discussion today we'll be updating the priority section to indicate other possibilities for expressing priority.",
          "createdAt": "2023-04-21T19:20:22Z",
          "updatedAt": "2023-04-21T19:20:48Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5SCgg3",
          "commit": {
            "abbreviatedOid": "9e262f9"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I do think that send order make more sense than delivery order but the parts of this that have to do with the prioritization scheme should probably be moved to a new section of the draft where we talk about the algorithms to decide what to send next. ",
          "createdAt": "2023-04-07T16:51:19Z",
          "updatedAt": "2023-04-07T16:51:19Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5TOcNt",
          "commit": {
            "abbreviatedOid": "9e262f9"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good to me. I would like to see this merged soon, so we can make the proper references to \"send order\" in the additional PRs.",
          "createdAt": "2023-04-21T19:21:17Z",
          "updatedAt": "2023-04-21T19:21:17Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5TPHcN",
          "commit": {
            "abbreviatedOid": "88aaa80"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-21T23:01:46Z",
          "updatedAt": "2023-04-21T23:01:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 121,
      "id": "PR_kwDOG2Ho4M5NraIi",
      "title": "IETF116 : Update track definition",
      "url": "https://github.com/moq-wg/moq-transport/pull/121",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR updates the track definition to reflect consensus at IETF 116",
      "createdAt": "2023-04-05T13:43:23Z",
      "updatedAt": "2023-04-21T06:00:21Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "1c67df978089f0413c6b51889254e45454a1fec7",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "116-track",
      "headRefOid": "ede0c5948ee69c2f91b217433272ef7f3700814c",
      "closedAt": "2023-04-21T06:00:21Z",
      "mergedAt": "2023-04-21T06:00:21Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "b2cae1f06562bba1dece98d0d3d061efc1f73417"
      },
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@vasilvv  @afrind  I have pushed a new commit that should address your feedback\r\nPlease let me know .. thanks",
          "createdAt": "2023-04-10T15:47:47Z",
          "updatedAt": "2023-04-10T15:47:47Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I think I understand now better what is being proposed, which is good.  Unfortunately, now that I have a better understanding of the proposal, I am not sure I agree with it.\r\n\r\nAs far as I understand, the idea is:\r\n\r\n1. Track prefix identifies the CDN customer to the relay, plus some extra context information.\r\n2. Track suffix identifies the actual track within the prefix.\r\n3. The information about where to connect to in order to publish or subscribe the track is not contained within the track name.\r\n\r\nObserve, that as a general principle, when publishing or subscribing to a track, a client needs to know two things: where to connect to, and what kind of extra context to provide to the server in order to access the specific track.  Based on this observation, I have two objections to the proposed design:\r\n\r\n1. Track names that don't have a host and a port are not useful, since they don't actually tell the client how to access them.\r\n2. As far as I can tell, the distinction between the track prefix and the track suffix is an internal detail of relay/application -- a client can't actually do anything with the knowledge of whether the track belongs to a specific CDN customer.\r\n\r\nI believe we should identify tracks by a tuple of `(network endpoint, endpoint-scoped track name)`.  An individual application can, of course, encode the customer name (what's referred to as _provider_ in this PR) in the track name component; alternatively, it can add a layer on top of MoQ transport that overrides the network endpoint name with an alternative network endpoints of choice (I assume that's what Suhas means when he says \"relay discovery\").",
          "createdAt": "2023-04-13T15:34:06Z",
          "updatedAt": "2023-04-13T15:34:06Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> I believe we should identify tracks by a tuple of `(network endpoint, endpoint-scoped track name)`.\r\n\r\nI want to tease it a bit further. Why would the network end-point info be part of the track names.  This mixes layers of abstraction. \r\n\r\nTrack Names are application scoped (don't think they are end point scoped, since an end-point is working under an application scope to produce or consume media)\r\n\r\nNetwork-end-point info can be communicated outside the track since it is connection scoped.  Is there a reason these 2 things needs to be combined ?",
          "createdAt": "2023-04-13T15:53:52Z",
          "updatedAt": "2023-04-13T15:53:52Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> 2\\. As far as I can tell, the distinction between the track prefix and the track suffix is an internal detail of relay/application -- a client can't actually do anything with the knowledge of whether the track belongs to a specific CDN customer.\r\n\r\nThe relay looks at the track name and it doesn't know where the prefix and suffix is. the track name is used to find out next steps since it contains the fully qualified resource name\r\n",
          "createdAt": "2023-04-13T16:04:02Z",
          "updatedAt": "2023-04-13T16:04:02Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "> I want to tease it a bit further. Why would the network end-point info be part of the track names. This mixes layers of abstraction.\r\n\r\nOkay, maybe there's a bit of confusion of what \"track name\" means.  Let's say for the purpose of this comment that \"track name\" is the thing you send in a pub/sub request (and we'd have some other thing, \"global track location\", that is a tuple of network endpoint and track name).\r\n\r\n> Track Names are application scoped (don't think they are end point scoped, since an end-point is working under an application scope to produce or consume media)\r\n\r\nThat's one way to structure an application, but there's somewhat of a problem here.  Application is not really a physical concept -- it's an agreement of several servers to do the same thing.  That is to say, you can have an application under domain `videoconferencing.example`, and you can structure it in a way that both `moq://cdn-x.example` and `moq://cdn-y.example` would serve the same data if you ask for a track named `videoconferencing.example/conference/person-a/video`.  However, the only things that happen on the wire are (1) the client connects to either `cdn-x.example` or `cdn-y.example`, and (2) it sends a subscribe request with a string `videoconferencing.example/conference/person-a/video`.  In that sense, even if we say that \"the track is scoped to videoconferencing.example\", the _de facto scope_ of any track name is the host you connect to, and any additional conditions you define (e.g. the track prefix being the name of the application) are naming conventions telling the server how to reply (note that in reality, the server can reply with anything).  If we say \"all tracks must be prefix + suffix\", we're adding an additional constraint, and I believe that this constraint reduces the flexibility we have (a little bit more on this below).\r\n\r\n> The relay looks at the track name and it doesn't know where the prefix and suffix is. the track name is used to find out next steps since it contains the fully qualified resource name\r\n\r\nI assume you mean that the relay would read the track name, which we would split into prefix `videoconferencing.example` and suffix `conference/person-a/video`, and use the rules for `videoconferencing.example` to figure out where to get `conference/person-a/video`.  That's one possible way to set things up (let's call this **Scenario A**), but there are also other approaches possible here, for instance:\r\n\r\n**Scenario B**.  The CDN has two customers, `videoconferencing.example` and `live.example`.  Both point their A record (or even NS record) to `cdn.example`'s IP address.  `cdn.example` then identifies the traffic going to its IP address based on the SNI (if using WebTransport, `:authority` header can also be used).\r\n\r\n**Scenario C**.  The CDN is owned entirely by one customer, let's say `vod.example`.  In that case, there is only one customer, so there's no need for a customer identifier -- you'd have a track name like `oHg5SJYRHA0/video`, and the VoD CDN would have some service-specific logic to find a backend where that track is stored.\r\n\r\nNote that, while track prefix with application name is useful in Scenario A, it's not necessary in B or C (both are real ways people deploy applications today), and if your application relies on a CDN that uses approach in Scenario A, you hopefully already know about that and it's included in your track names in a way that a CDN would be able to parse, so I'm not sure we should always require it.",
          "createdAt": "2023-04-13T23:26:32Z",
          "updatedAt": "2023-04-13T23:26:32Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@afrind PR has been updated to reflect your most recent feedback. thanks",
          "createdAt": "2023-04-20T16:51:59Z",
          "updatedAt": "2023-04-20T16:51:59Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What utility is the URI definition serving? It is not used for the physical connection (WebTransport or QUIC). The 'moq://' protocol designator is not used elsewhere in the spec. Wouldn't we simply store the namespace and name as separate headers in every object?\r\n\r\n```\r\nTrack Namespace = acme.meetings.com\r\nTrack Name = meeting123/audio\r\n```\r\n\r\nIf we want to store them as a single item, then it could be stored as\r\n\r\n`Track Name: acme.meetings.com/meeting123/audio`\r\n\r\nwith the rule that the first / separates the namespace from the name. \r\n",
          "createdAt": "2023-04-20T18:35:31Z",
          "updatedAt": "2023-04-20T18:35:31Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@vasilvv most recent commit must address your feedback",
          "createdAt": "2023-04-21T04:48:12Z",
          "updatedAt": "2023-04-21T04:48:12Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5R9XPT",
          "commit": {
            "abbreviatedOid": "2b98ce4"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I like the idea of track prefix / track suffix, and I am excited that we are making progress on this.  That said, I do have some question about properties specifically.",
          "createdAt": "2023-04-06T14:51:15Z",
          "updatedAt": "2023-04-06T15:44:56Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "I don't think this is general enough (e.g. a track can be just metadata).  I think \"a sequence of objects\" is actually probably sufficient, so I'd just remove this paragraph.",
              "createdAt": "2023-04-06T14:51:15Z",
              "updatedAt": "2023-04-06T15:44:56Z"
            },
            {
              "originalPosition": 78,
              "body": "Is this meant to be `https://www.example.org/livestream/stream123/audio`?",
              "createdAt": "2023-04-06T15:16:26Z",
              "updatedAt": "2023-04-06T15:44:56Z"
            },
            {
              "originalPosition": 84,
              "body": "My issue with this syntax is that it's unclear which part is a prefix and which is a suffix.  How about `https://www.example.org/meetings/meeting123#video`?",
              "createdAt": "2023-04-06T15:18:55Z",
              "updatedAt": "2023-04-06T15:44:56Z"
            },
            {
              "originalPosition": 72,
              "body": "Can we just say that the track prefix identifies the MoQ server to which you have to connect to publish/subscribe a track?",
              "createdAt": "2023-04-06T15:31:33Z",
              "updatedAt": "2023-04-06T15:44:56Z"
            },
            {
              "originalPosition": 12,
              "body": "What is the difference between a MoQ server and a MoQ provider?",
              "createdAt": "2023-04-06T15:32:13Z",
              "updatedAt": "2023-04-06T15:44:56Z"
            },
            {
              "originalPosition": 65,
              "body": "If we decide that we're moving all the catalog stuff into the separate document, this can be just removed (since at least in the current draft, the init objects are in the catalog).",
              "createdAt": "2023-04-06T15:36:06Z",
              "updatedAt": "2023-04-06T15:44:56Z"
            },
            {
              "originalPosition": 63,
              "body": "Could you explain to me what are the consequences of those three requirements?  I.e. this section uses \"MUST\" in every paragraph, but I am not sure who is this a requirement on.",
              "createdAt": "2023-04-06T15:40:34Z",
              "updatedAt": "2023-04-06T15:44:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5R9_Fm",
          "commit": {
            "abbreviatedOid": "2b98ce4"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-06T16:20:55Z",
          "updatedAt": "2023-04-06T16:20:55Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "@vasilvv can you please elaborate on \"e.g. a track can be just metadata\" .. ",
              "createdAt": "2023-04-06T16:20:55Z",
              "updatedAt": "2023-04-06T16:20:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5R9_MU",
          "commit": {
            "abbreviatedOid": "2b98ce4"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-06T16:21:13Z",
          "updatedAt": "2023-04-06T16:21:14Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "ah yes .. that's a typo",
              "createdAt": "2023-04-06T16:21:13Z",
              "updatedAt": "2023-04-06T16:21:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5R9_dd",
          "commit": {
            "abbreviatedOid": "2b98ce4"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-06T16:22:02Z",
          "updatedAt": "2023-04-06T16:22:02Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "good point, will update it",
              "createdAt": "2023-04-06T16:22:02Z",
              "updatedAt": "2023-04-06T16:22:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5R-APY",
          "commit": {
            "abbreviatedOid": "2b98ce4"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-06T16:24:18Z",
          "updatedAt": "2023-04-06T16:24:18Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "The MUST is used to scope the definition of track within the MoQ system. \r\nFor example, the first MUST says if there are 2 different encodings, then they should be treated as 2 different tracks and the same is with security configuration.\r\n\r\nWithout these, i am afraid the definition will be very loose and ambiguous.",
              "createdAt": "2023-04-06T16:24:18Z",
              "updatedAt": "2023-04-06T16:24:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5R-A5l",
          "commit": {
            "abbreviatedOid": "2b98ce4"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-06T16:26:17Z",
          "updatedAt": "2023-04-06T16:26:17Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Provider , as expained, is the authority domain along with the other things captured in the definition\r\n\r\nMoQ Server, IIUC from the latest warp draft as \"The party accepting an incoming Warp session.\" , can be any box that accepts WT connection ? \r\n\r\n",
              "createdAt": "2023-04-06T16:26:17Z",
              "updatedAt": "2023-04-06T16:26:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5R-BH6",
          "commit": {
            "abbreviatedOid": "2b98ce4"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-06T16:26:57Z",
          "updatedAt": "2023-04-06T16:26:58Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "I do see what you mean here .. please see the clarification question on the follow up comment regarding MoQ Server below.",
              "createdAt": "2023-04-06T16:26:57Z",
              "updatedAt": "2023-04-06T16:39:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5R-Bdz",
          "commit": {
            "abbreviatedOid": "2b98ce4"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-06T16:27:59Z",
          "updatedAt": "2023-04-06T16:27:59Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "@vasilvv  May be i need your help to frame it appropriately - Can you explain what is MoQ Server from your understanding , like what are its roles and so on",
              "createdAt": "2023-04-06T16:27:59Z",
              "updatedAt": "2023-04-06T16:38:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5R-CMI",
          "commit": {
            "abbreviatedOid": "2b98ce4"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-06T16:30:06Z",
          "updatedAt": "2023-04-06T16:30:06Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "Agreed on the confusion .. Building on your proposal , should we form the track name as \r\n\r\nTrack Name = Track Prefix + '#' + Track Suffix",
              "createdAt": "2023-04-06T16:30:06Z",
              "updatedAt": "2023-04-06T16:30:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SCN6f",
          "commit": {
            "abbreviatedOid": "dfd25e9"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-07T15:24:37Z",
          "updatedAt": "2023-04-07T15:45:18Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I think I made some unnecessary assumptions, so let me change the question a little bit.  Would it be fair to say that a provider is any entity that accepts publish/subscribe requests?",
              "createdAt": "2023-04-07T15:24:37Z",
              "updatedAt": "2023-04-07T15:45:18Z"
            },
            {
              "originalPosition": 54,
              "body": "I can have a track that just instructs the player to draw some overlay text at some point in time.  A catalog would be another example of a track that's not strictly speaking an encoding of some media.",
              "createdAt": "2023-04-07T15:26:38Z",
              "updatedAt": "2023-04-07T15:45:18Z"
            },
            {
              "originalPosition": 63,
              "body": "I see, let me go point-by-point then.\r\n\r\n> A Track MUST be owned by a single authorized MoQ Entity, such as an Emitter (section 2.1.1 {{MOQ-ARCH}}) or a Catalog Maker (section 2.1.5 {{MOQ-ARCH}}), under a single Provider.\r\n\r\nI'm not entirely sure what \"owned\" means.  Can we just say it's produced by a single entity?\r\n\r\n> Tracks MUST have a single encoding configuration.\r\n\r\nThis might be unnecessarily restrictive, since it's not unreasonable for a track to change configuration in certain scenarios (e.g. in live ingestion, video dimensions can change mid-track in some scenarios).\r\n\r\n> Tracks MUST have a single security configuration, when exists.\r\n\r\nI understand what you're trying to say here, but \"security configuration\" is a bit vague.  Can we just say \"a track is the largest entity to which a client can subscribe or publish\"?   Since we perform authentication when we do subscribe/publish request, that would imply that the track is the unit at which we perform security.",
              "createdAt": "2023-04-07T15:37:42Z",
              "updatedAt": "2023-04-07T15:45:18Z"
            },
            {
              "originalPosition": 71,
              "body": "Since this is a URI, I think you might want to reference RFC 3986, and just say that track suffix is the fragment.",
              "createdAt": "2023-04-07T15:39:24Z",
              "updatedAt": "2023-04-07T15:45:18Z"
            },
            {
              "originalPosition": 72,
              "body": "I guess the question I have is, \"once I have a track name, how do I actually subscribe (or publish) to it?\".  I assume that by default, we would do the following:\r\n\r\n1. Extract track prefix, and establish a QUIC connection (or a WebTransport session) to the host/port/path in it (unless we already have that connection from a previous track).\r\n2. Send SUBSCRIBE_REQUEST / PUBLISH_REQUEST with the track suffix.\r\n\r\nWe can define alternative schemes, but without any other prior knowledge, I assume this is the expected approach.  Does this sound correct?\r\n",
              "createdAt": "2023-04-07T15:43:34Z",
              "updatedAt": "2023-04-07T15:45:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SCVPk",
          "commit": {
            "abbreviatedOid": "dfd25e9"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-07T15:57:06Z",
          "updatedAt": "2023-04-07T16:02:12Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I don't think we should mix the discovery of relays with the subscibe / pub stuff here. How you find what relay to connect to is a sperate issue, but once you do you sub/pub to track names. A track name might be a URL but no real reason it needs to be. Even in HTTP, how you find which server to connect to is pretty separate from what resource you request in a GET",
              "createdAt": "2023-04-07T15:57:06Z",
              "updatedAt": "2023-04-07T16:02:12Z"
            },
            {
              "originalPosition": 53,
              "body": "I would put here \"some tracks are\" and perhaps mention there can be tracks with other types of info such as a catalog. A track is just a set of groups each having a set of objects. ",
              "createdAt": "2023-04-07T15:59:34Z",
              "updatedAt": "2023-04-07T16:02:12Z"
            },
            {
              "originalPosition": 71,
              "body": "Have we agreed a track name needs to be a URL ? I 'm fine with that but thought some people did not want that. ",
              "createdAt": "2023-04-07T16:00:39Z",
              "updatedAt": "2023-04-07T16:02:12Z"
            },
            {
              "originalPosition": 80,
              "body": "We can't use the #audio here - that would be mean something very differnt than /audio. I think we need to rethink this example. ",
              "createdAt": "2023-04-07T16:01:44Z",
              "updatedAt": "2023-04-07T16:02:12Z"
            },
            {
              "originalPosition": 86,
              "body": "again , I think use of # is wrong here. ",
              "createdAt": "2023-04-07T16:02:01Z",
              "updatedAt": "2023-04-07T16:02:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SCV08",
          "commit": {
            "abbreviatedOid": "dfd25e9"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Individual review",
          "createdAt": "2023-04-07T15:59:53Z",
          "updatedAt": "2023-04-07T16:13:49Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Do we want to take a normative dependency on this document right now?",
              "createdAt": "2023-04-07T15:59:54Z",
              "updatedAt": "2023-04-07T16:13:50Z"
            },
            {
              "originalPosition": 51,
              "body": "editorial: subject/verb agreement (Tracks...is)\r\n\r\nPerhaps\r\n\r\n\"*A track* is the central concept....and is made up of *a* sequence of objects...organized into one or more groups\"",
              "createdAt": "2023-04-07T16:02:45Z",
              "updatedAt": "2023-04-07T16:13:50Z"
            },
            {
              "originalPosition": 54,
              "body": "I think there's consensus that a catalog is also a track as well.  Maybe:\r\n\r\n\"A track is a transform of uncompressed media *or metadata*...\"",
              "createdAt": "2023-04-07T16:05:07Z",
              "updatedAt": "2023-04-07T16:13:50Z"
            },
            {
              "originalPosition": 59,
              "body": "I think this is the source of the normative dependency",
              "createdAt": "2023-04-07T16:08:10Z",
              "updatedAt": "2023-04-07T16:13:50Z"
            },
            {
              "originalPosition": 63,
              "body": "I'm also unclear what \"owned\" means.  If we think of this document instructing someone how to build a producer, relay or consumer, what are we trying to convey and can that be expressed normatively (for example, a relay MUST NOT change the contents of a track, or something like that)?",
              "createdAt": "2023-04-07T16:10:20Z",
              "updatedAt": "2023-04-07T16:13:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SCaU7",
          "commit": {
            "abbreviatedOid": "2b98ce4"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-07T16:20:00Z",
          "updatedAt": "2023-04-07T16:20:00Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "How does one setup a QUIC connection is not part of this PR and I can add a TBD as a follow up PR .\r\n\r\nHowever Subscribe/publish must carry the entire Track Name (not just the suffix) as agreed at IETF116",
              "createdAt": "2023-04-07T16:20:00Z",
              "updatedAt": "2023-04-07T16:31:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SCoaq",
          "commit": {
            "abbreviatedOid": "dfd25e9"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-07T17:32:00Z",
          "updatedAt": "2023-04-07T17:38:15Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I'm not entirely sure how you separate those.  If the track name includes a domain name, at some point, we would have to check that the server is allowed to speak on behalf of that domain.  Normally, that requires validating TLS certificate for that domain, which you typically get when you connect to it.  There are some ways to delegate this, of course, but this is what HTTP (and most applications of this kind) do, and what I assume is the base case here.",
              "createdAt": "2023-04-07T17:32:00Z",
              "updatedAt": "2023-04-07T17:38:15Z"
            },
            {
              "originalPosition": 80,
              "body": "Could you explain why `#` does not work here?",
              "createdAt": "2023-04-07T17:33:10Z",
              "updatedAt": "2023-04-07T17:38:15Z"
            },
            {
              "originalPosition": 71,
              "body": "I believe we agreed that the name has to be global, and we would need to rely on DNS for that.  I believe URL follows naturally for that.",
              "createdAt": "2023-04-07T17:37:37Z",
              "updatedAt": "2023-04-07T17:38:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SC_ol",
          "commit": {
            "abbreviatedOid": "dfd25e9"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-07T19:28:52Z",
          "updatedAt": "2023-04-09T20:20:52Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "> Would it be fair to say that a provider is any entity that accepts publish/subscribe requests?\r\n\r\nFurther down there's a section that says a track is owned by a single provider, so I don't think so. It sounds more like an origin.",
              "createdAt": "2023-04-07T19:28:52Z",
              "updatedAt": "2023-04-09T20:20:52Z"
            },
            {
              "originalPosition": 12,
              "body": "What's the purpose of this provider?\r\n\r\nFrom what I can gather, there's a single provider per track identified via a domain name (similar to an origin?). A relay would need some way of asking the provider if each publisher/subscriber is authenticated. I think that's the intent based on previous PRs.",
              "createdAt": "2023-04-07T19:34:31Z",
              "updatedAt": "2023-04-09T20:20:52Z"
            },
            {
              "originalPosition": 59,
              "body": "This line doesn't make sense to me. What does it mean to \"own\" a track? How can this MUST be enforced? What would change if we omitted this line?",
              "createdAt": "2023-04-07T19:36:47Z",
              "updatedAt": "2023-04-09T20:20:52Z"
            },
            {
              "originalPosition": 68,
              "body": "IMO the prefix and suffix is a compression technique to reduce overhead for each OBJECT. I don't think it should be in the object model.\r\n\r\nLet's just keep it simple and say that each track has a URL.",
              "createdAt": "2023-04-07T19:42:48Z",
              "updatedAt": "2023-04-09T20:20:52Z"
            },
            {
              "originalPosition": 71,
              "body": "I don't think we should use URLs with this design.\r\n\r\nFor example, when the client connects to akamai.com, DNS/TLS identifies and authenticates the server based on the URL. But let's say the akamai.com server publishes a track with the prefix webex.com.\r\n\r\nThe client can't actually connect to the track URL. The very point of using a CDN in the first place is to shield the origin. \r\n\r\nWe could use a URL if the hostname is used to verify the authenticity. But that would require that every object is signed using some key derived from a public certificate. It would still be weird to include a protocol though.",
              "createdAt": "2023-04-09T20:00:32Z",
              "updatedAt": "2023-04-09T20:20:52Z"
            },
            {
              "originalPosition": 72,
              "body": "> Can we just say that the track prefix identifies the MoQ server to which you have to connect to publish/subscribe a track?\r\n\r\nIt's not though, because I'm pretty sure @suhasHere wants to serve track URLs from other domains. ex. akamai.com serving webex.com tracks.",
              "createdAt": "2023-04-09T20:18:23Z",
              "updatedAt": "2023-04-09T20:20:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SCb53",
          "commit": {
            "abbreviatedOid": "dfd25e9"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-07T16:27:51Z",
          "updatedAt": "2023-04-09T21:25:21Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "Agree on # as the wrong place. Track Prefix and Track Suffix must come from Catalog and end point clients sould create TrackName out of it. This will keep this simple and extensible",
              "createdAt": "2023-04-07T16:27:51Z",
              "updatedAt": "2023-04-09T21:25:21Z"
            },
            {
              "originalPosition": 54,
              "body": "+1 to @afrind suggestion. I can update it to reflect that",
              "createdAt": "2023-04-07T16:30:33Z",
              "updatedAt": "2023-04-09T21:25:21Z"
            },
            {
              "originalPosition": 63,
              "body": "> I'm not entirely sure what \"owned\" means. Can we just say it's produced by a single entity?\r\n\r\nThat sounds fine to me. how about this \"it's produced by a single authorized entity under a given provider\"?",
              "createdAt": "2023-04-07T16:37:20Z",
              "updatedAt": "2023-04-09T21:25:21Z"
            },
            {
              "originalPosition": 63,
              "body": "> This might be unnecessarily restrictive, since it's not unreasonable for a track to change configuration in certain scenarios (e.g. in live ingestion, video dimensions can change mid-track in some scenarios)\r\n\r\nAh ! agree , i imagine that is still a single encoding configuration.  I will remove the requirement text on this",
              "createdAt": "2023-04-07T16:41:59Z",
              "updatedAt": "2023-04-09T21:25:21Z"
            },
            {
              "originalPosition": 63,
              "body": "> I understand what you're trying to say here, but \"security configuration\" is a bit vague. Can we just say \"a track is the largest entity to which a client can subscribe or publish\"? Since we perform authentication when we do subscribe/publish request, that would imply that the track is the unit at which we perform security.\r\n\r\nAgree and happy to reword on your suggestion",
              "createdAt": "2023-04-07T16:42:34Z",
              "updatedAt": "2023-04-09T21:25:21Z"
            },
            {
              "originalPosition": 4,
              "body": "@afrind what is right or wrong with normatively depending on the arch document ? May be I don't see to grasp the intent of your question here ?",
              "createdAt": "2023-04-08T22:46:28Z",
              "updatedAt": "2023-04-09T21:25:21Z"
            },
            {
              "originalPosition": 72,
              "body": "I see 2 layers of things here . \r\n1. moq protocol that deals with pub/sub on track names\r\n2. a connection protocol (WT or native QUIC) that is needed to connect based on some business logic\r\n\r\nIn some use-cases there is overlap between 1 and 2 and that's fine.  Keeping these 2 things apart will make the MoQ protocol be defined in terms of tracks and how things around tracks work to get the objects/groups delivered. \r\n\r\n",
              "createdAt": "2023-04-09T21:24:27Z",
              "updatedAt": "2023-04-09T21:25:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SErUb",
          "commit": {
            "abbreviatedOid": "dfd25e9"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T21:27:21Z",
          "updatedAt": "2023-04-09T21:27:22Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "yeah, that's right. Tracks are part of an authorization scope and how it is verified is very application dependent.\r\n\r\n",
              "createdAt": "2023-04-09T21:27:21Z",
              "updatedAt": "2023-04-09T21:27:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SErbi",
          "commit": {
            "abbreviatedOid": "dfd25e9"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T21:34:52Z",
          "updatedAt": "2023-04-09T21:34:52Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "I think we are mixing connection and moq tracks in the same space.\r\n\r\nAgree when the connect happens to a relay , it happens to the akamai.com and the connection authentication happens the way it is done today.\r\n\r\nThe track names identify media objects belonging to an application under a domain trusted by the relay.  The subscribes/publish should carry necessary authz information proving that a given moq client is authorized for those tracks.\r\n\r\nIt is beneficial if we keep the relay discovery, connection separate from MoQ protocol concepts.",
              "createdAt": "2023-04-09T21:34:52Z",
              "updatedAt": "2023-04-09T21:36:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SEtN3",
          "commit": {
            "abbreviatedOid": "dfd25e9"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T23:16:08Z",
          "updatedAt": "2023-04-09T23:16:09Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "Yeah I agree. These are technically not URLs since they don't locate a resource (ie. can't be used to connect and request the resource).\r\n\r\nURI is probably the correct term here although warp-03 used URN. The application would be responsible for determining the scheme.",
              "createdAt": "2023-04-09T23:16:09Z",
              "updatedAt": "2023-04-09T23:21:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SGbm-",
          "commit": {
            "abbreviatedOid": "dfd25e9"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T11:26:23Z",
          "updatedAt": "2023-04-10T12:20:34Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "> It's not though, because I'm pretty sure @suhasHere wants to serve track URLs from other domains. ex. akamai.com serving webex.com tracks.\r\n\r\nSure, you can *serve* any domain from anywhere, that is true in HTTP too.  The question I am asking is, as a client, how would I know that I should connect to a given CDN, and (more importantly) how should I know that I should trust it to speak on behalf of some other domain?\r\n\r\n> I see 2 layers of things here .\r\n> \r\n> 1. moq protocol that deals with pub/sub on track names\r\n> 2. a connection protocol (WT or native QUIC) that is needed to connect based on some business logic\r\n> \r\n> In some use-cases there is overlap between 1 and 2 and that's fine. Keeping these 2 things apart will make the MoQ protocol be defined in terms of tracks and how things around tracks work to get the objects/groups delivered.\r\n\r\nI would not assume that (2) would always exist.  It's a reasonable assumption for video conferencing, but in some cases (e.g. live video delivery) a client would act based on a single URL.",
              "createdAt": "2023-04-10T11:26:23Z",
              "updatedAt": "2023-04-10T12:20:34Z"
            },
            {
              "originalPosition": 71,
              "body": "> It is beneficial if we keep the relay discovery, connection separate from MoQ protocol concepts.\r\n\r\nThere are definitely a lot of use cases in which one would need to have a URL to tell the client the exact way it's supposed to fetch a specific track.  I'm not sure it's possible to keep discovery and naming separate, those are very tightly coupled problems.\r\n\r\n> We could use a URL if the hostname is used to verify the authenticity. But that would require that every object is signed using some key derived from a public certificate. It would still be weird to include a protocol though.\r\n\r\nWell, there are multiple ways to solve this problem, I can think of at least four (three of which have been discussed for HTTP before):\r\n1. Require the CDN certificate be valid for the origin's hostname ([HTTP pooling](https://datatracker.ietf.org/doc/html/rfc9113#name-connection-reuse) / [Alt-Svc approach](https://datatracker.ietf.org/doc/html/rfc7838#section-2.1))\r\n2. Authenticate the individual connection as valid for the origin ([secondary certificates approach](https://datatracker.ietf.org/doc/draft-ietf-httpbis-http2-secondary-certs/))\r\n3. Have the origin sign off on every PUBLISH_REPLY for the origin it does not directly have a certificate for.\r\n4. Sign individual objects ([signed exchanges approach](https://datatracker.ietf.org/doc/draft-yasskin-http-origin-signed-responses/))",
              "createdAt": "2023-04-10T12:05:12Z",
              "updatedAt": "2023-04-10T12:20:34Z"
            },
            {
              "originalPosition": 63,
              "body": "> how about this \"it's produced by a single authorized entity under a given provider\"?\r\n\r\nThis SGTM, though I am not entirely sure what does \"under a given provider\" means.",
              "createdAt": "2023-04-10T12:10:14Z",
              "updatedAt": "2023-04-10T12:20:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SHmnG",
          "commit": {
            "abbreviatedOid": "5227028"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T15:50:25Z",
          "updatedAt": "2023-04-10T15:50:26Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "I do see prefix, suffix and track name as part of the catalog. They all can be strings and it is left to application to define its length, encoding. A suffix need not be a compression technique as it is very application dependent naming.\r\n\r\nThe compression technique comes from TrackId that gets setup as part of pub/sub control exchange ( #122\r\n)\r\n",
              "createdAt": "2023-04-10T15:50:25Z",
              "updatedAt": "2023-04-10T15:50:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SH7HA",
          "commit": {
            "abbreviatedOid": "2b98ce4"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T16:41:09Z",
          "updatedAt": "2023-04-10T16:41:09Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "Yeah, I do think the ability to configure a client via a single URL is a requirement.\r\n\r\nIf we're going to decouple the connection URL from track URLs, then we'll need a way of bundling all of the information that the client needs into a single resource (ex. composition).",
              "createdAt": "2023-04-10T16:41:09Z",
              "updatedAt": "2023-04-10T16:41:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SH7sI",
          "commit": {
            "abbreviatedOid": "2b98ce4"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T16:43:11Z",
          "updatedAt": "2023-04-10T16:43:12Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "If it's application dependent, why is it in this text? What would change if the relay was not aware of the concept of \"provider\"?",
              "createdAt": "2023-04-10T16:43:11Z",
              "updatedAt": "2023-04-10T16:43:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SH-JN",
          "commit": {
            "abbreviatedOid": "2b98ce4"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T16:51:10Z",
          "updatedAt": "2023-04-10T16:51:11Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "The word \"provider\" confuses me too, especially because I would consider a relay a provider (ie. \"to supply or make available\"). I'm not sure how a provider differs from a producer?",
              "createdAt": "2023-04-10T16:51:11Z",
              "updatedAt": "2023-04-10T16:51:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SIBmY",
          "commit": {
            "abbreviatedOid": "dfd25e9"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T17:02:53Z",
          "updatedAt": "2023-04-10T17:02:54Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "I think 1&2 require all tracks to be sourced from the same origin. The CDN would also have to know what resources the client is going to request during the TLS handshake.\r\n\r\nI don't think 3 is quite good enough. The objects themselves could be modified without 4. A middle ground is using asymmetric crypto to sign a symmetric key in the PUBLISH / SUBSCRIBE_REPLY.",
              "createdAt": "2023-04-10T17:02:54Z",
              "updatedAt": "2023-04-10T17:02:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SICJt",
          "commit": {
            "abbreviatedOid": "5227028"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T17:04:44Z",
          "updatedAt": "2023-04-10T17:07:30Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "What is an \"authorized MoQ Entity\"? \r\n\r\nI would remove this line and the references to MOQ-ARCH.",
              "createdAt": "2023-04-10T17:04:45Z",
              "updatedAt": "2023-04-10T17:07:30Z"
            },
            {
              "originalPosition": 56,
              "body": "> transform of a uncompresss media\r\n\r\ntypo\r\n\r\nI would say \"a track is an encoded bitstream\".",
              "createdAt": "2023-04-10T17:06:25Z",
              "updatedAt": "2023-04-10T17:07:30Z"
            },
            {
              "originalPosition": 68,
              "body": "Sure, let's punt that to the catalog format then.",
              "createdAt": "2023-04-10T17:06:52Z",
              "updatedAt": "2023-04-10T17:07:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SILVP",
          "commit": {
            "abbreviatedOid": "5227028"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T17:36:21Z",
          "updatedAt": "2023-04-10T17:36:22Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "how would you reframe it instead ?   We don't want anyone to produce tracks isn't it ? ",
              "createdAt": "2023-04-10T17:36:22Z",
              "updatedAt": "2023-04-10T17:36:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SIMFj",
          "commit": {
            "abbreviatedOid": "2b98ce4"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T17:39:05Z",
          "updatedAt": "2023-04-10T17:39:05Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I don't understand the question here.  Relays need to know what providers they trust (via some business relationship or something) ",
              "createdAt": "2023-04-10T17:39:05Z",
              "updatedAt": "2023-04-10T17:39:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SIMZN",
          "commit": {
            "abbreviatedOid": "2b98ce4"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T17:40:10Z",
          "updatedAt": "2023-04-10T17:40:10Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "I don't see the current proposal prohibits from doing the single URL. It does duplicates few extra bytes. \r\nRelay discovery is outside of MoQ Transport protocol and there are multiple ways it can be done. There is no point in enforcing that in this spec.",
              "createdAt": "2023-04-10T17:40:10Z",
              "updatedAt": "2023-04-10T17:40:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SINEQ",
          "commit": {
            "abbreviatedOid": "2b98ce4"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T17:42:43Z",
          "updatedAt": "2023-04-10T17:42:43Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Sadly these comments are not helping me atleast .\r\n\r\nI can share the intent here and suggest me something that works\r\n\r\nThe provider is currently defined as\r\nEntity capable of hosting media application session based on the MOQ Transport protocol. It is responsible for authorizing the publishers/subscribers, managing the names used for Tracks and is scoped under a domain for a specific application. In certain deployments, a provider is also responsible for establishing trust between clients and relays for delivering media.\r\n\r\nIt can be called origin, but it is overloaded .. Please suggest what should we call this thing ",
              "createdAt": "2023-04-10T17:42:43Z",
              "updatedAt": "2023-04-10T17:43:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SPHe-",
          "commit": {
            "abbreviatedOid": "dfd25e9"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-11T16:40:57Z",
          "updatedAt": "2023-04-11T16:40:57Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "yes we can punt it to the Catalog, but the transport spec must specify following properties about track names\r\n\r\nGiven a track name in the Subscribe/Publish the relay must be able to \r\n- verifying if the relay is authorized to serve the given provider\r\n- validate the requesting endpoint is authorized for the track requested\r\n\r\nThis requires provider to be identified by some for a DNS name or equivalent  and latter can be done by carrying track authz info \r\n\r\n",
              "createdAt": "2023-04-11T16:40:57Z",
              "updatedAt": "2023-04-11T16:40:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SP7Kl",
          "commit": {
            "abbreviatedOid": "5227028"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-11T19:04:03Z",
          "updatedAt": "2023-04-11T19:14:34Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I'm suggesting that we could drop the concept of \"provider\". It's non-normative and we barely understand what a \"provider\" is supposed to be (is it webex.com or a participant?).\r\n\r\nIt's pretty clear that SOMETHING created the track. We don't need to give it a name until there's some tangible reason to identify it. For example, if a relay had to connect to the \"provider\" to authorize each subscription (which I do not recommend).",
              "createdAt": "2023-04-11T19:04:03Z",
              "updatedAt": "2023-04-11T19:14:34Z"
            },
            {
              "originalPosition": 58,
              "body": "Any entity could produce a track. In fact, we must assume that a relay could produce tracks (aka. a mixer).\r\n\r\nI would even like the relay to be able to produce a track with the estimated bandwidth, so a subscriber could use this information to make better ABR decisions. I don't see how that fits into this definition, or what this definition is even trying to accomplish.",
              "createdAt": "2023-04-11T19:08:04Z",
              "updatedAt": "2023-04-11T19:14:34Z"
            },
            {
              "originalPosition": 68,
              "body": "If that logic is up to the application, then it should be encoded into the URL (opaque blob to the relay). For example, the first part of the path could be the \"provider\" domain.\r\n\r\nIf that logic must be enforced by the relay, then it needs to be more explicit than a prefix/suffix. The track halves would have more semantic meaning and draft would have some text indicating how to perform authorization (ex. based on the prefix). For example, a broadcast/bundle URL (track prefix) and relative paths (track suffix).",
              "createdAt": "2023-04-11T19:11:51Z",
              "updatedAt": "2023-04-11T19:14:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SQL2f",
          "commit": {
            "abbreviatedOid": "5227028"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-11T19:57:09Z",
          "updatedAt": "2023-04-11T19:57:09Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Relays don't have access to media info",
              "createdAt": "2023-04-11T19:57:09Z",
              "updatedAt": "2023-04-11T19:57:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SXwdo",
          "commit": {
            "abbreviatedOid": "5227028"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-12T19:21:57Z",
          "updatedAt": "2023-04-12T19:21:57Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "It doesn't matter if the relay can decode the media; any entity should still be able to add/remove tracks. \r\n\r\nExamples:\r\n- An edge relay could create an advertisement track (unique per viewer). It would contain signals when the user should request an advertisement and with what payload.\r\n- A relay could insert a timed metadata, such chat messages on Twitch so they get rendered at the same time.\r\n- An edge relay could create an estimated bitrate track (unique per hop). It would contain periodic bitrate estimates so the player can perform better ABR.\r\n- An edge relay could create a CMCD track. This is a superset of the estimated bitrate, and contains a lot of statistics about the session.\r\n- The viewer could also create a CMCD track. In fact this is required if we want granular statistics about rebuffering.\r\n\r\nThere's a whole slew of possible use cases. I don't see any benefit to locking down the possible use-cases of tracks, which is what you're attempting to do by requiring globally unique track URLs authorized by an origin.",
              "createdAt": "2023-04-12T19:21:57Z",
              "updatedAt": "2023-04-12T19:23:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SXwjn",
          "commit": {
            "abbreviatedOid": "5227028"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-12T19:22:16Z",
          "updatedAt": "2023-04-12T19:22:16Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "@wilaw you might have some opinions here.",
              "createdAt": "2023-04-12T19:22:16Z",
              "updatedAt": "2023-04-12T19:22:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SYJmX",
          "commit": {
            "abbreviatedOid": "5227028"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-12T20:23:18Z",
          "updatedAt": "2023-04-12T20:23:19Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Let me ask few questions for clarification\r\n\r\n\r\n> * An edge relay could create an advertisement track (unique per viewer). It would contain signals when the user should request an advertisement and with what payload.\r\n\r\nCan i have an example of who is this track authorized to ? how is it advertised ?  is the relay generating track on it own accord ? if so , who authrozied the relay to do so ? \r\n\r\n> * A relay could insert a timed metadata, such chat messages on Twitch so they get rendered at the same time.\r\n\r\nis this inserting into media stream ? if so, relays can't do that ? If not, can you please eloborate of how it is done and how such a timed metadata identified ?\r\n\r\n\r\n\r\n> * An edge relay could create an estimated bitrate track (unique per hop). It would contain periodic bitrate estimates so the player can perform better ABR.\r\n\r\nSame question as earlier ? if the edge is controlled by akamai running twitch application, how would this track look like, who authorizes this track or the edge node ?\r\n\r\n\r\n\r\n> * An edge relay could create a CMCD track. This is a superset of the estimated bitrate, and contains a lot of statistics about the session.\r\n\r\nhow is this track announced and what domain does this track belong to ? in the akamai + twich exmaple, is it part of akamai's auth scope or twitch's?\r\n\r\n> There's a whole slew of possible use cases. I don't see any benefit to locking down the possible use-cases of tracks, which is what you're attempting to do by requiring globally unique track URLs authorized by an origin.\r\n\r\nThe  track name need to know under what domain it is served and where the authorization happens depends on how the business relationship is set between the domain and the CDN. Many of the cases , i suspect it happens at the edge. I don't see how it is blocking/locking possible track use-cases.",
              "createdAt": "2023-04-12T20:23:19Z",
              "updatedAt": "2023-04-12T20:24:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Sy72S",
          "commit": {
            "abbreviatedOid": "dfd25e9"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-17T23:51:47Z",
          "updatedAt": "2023-04-17T23:51:47Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "@suhasHere : my personal philosophy is to have dependencies as minimal as possible, and I didn't see this dependency as being required at this point in the process.  That architecture document hasn't had as much scrutiny yet as this document, and with a normative dependency, would we need to adopt them both?  I'd prefer we pull the specific definitions we need from there into here for now if they are required.",
              "createdAt": "2023-04-17T23:51:47Z",
              "updatedAt": "2023-04-17T23:51:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TG3EF",
          "commit": {
            "abbreviatedOid": "64fda25"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Individual Review",
          "createdAt": "2023-04-20T15:52:27Z",
          "updatedAt": "2023-04-20T15:58:25Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "I think you mean moq://acme.meetings.com/meeting123/audio",
              "createdAt": "2023-04-20T15:52:27Z",
              "updatedAt": "2023-04-20T15:58:25Z"
            },
            {
              "originalPosition": 56,
              "body": "There's still a typo uncompress -> uncompressed",
              "createdAt": "2023-04-20T15:53:47Z",
              "updatedAt": "2023-04-20T15:58:25Z"
            },
            {
              "originalPosition": 18,
              "body": "I still think this MUST implies somehow that implementers have a choice (eg: somehow they could make an object that isn't in a group, and that would be an error).  Instead you can instead simply state \"all objects belong to a group\", and make Group a required parameter in the OBJECT header.",
              "createdAt": "2023-04-20T15:56:21Z",
              "updatedAt": "2023-04-20T15:58:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TG9kZ",
          "commit": {
            "abbreviatedOid": "64fda25"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-20T16:07:26Z",
          "updatedAt": "2023-04-20T16:07:27Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "ah ! you are right. I will fix them",
              "createdAt": "2023-04-20T16:07:26Z",
              "updatedAt": "2023-04-20T16:07:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TG9qU",
          "commit": {
            "abbreviatedOid": "64fda25"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-20T16:07:41Z",
          "updatedAt": "2023-04-20T16:07:41Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "@afrind this PR doesn't change the text for object and groups. It just updated the section reference to the group and rest of the text is unchanged.\r\n\r\nRegardless,I agree your suggestion makes sense and we should update it so.",
              "createdAt": "2023-04-20T16:07:41Z",
              "updatedAt": "2023-04-20T16:07:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5THRp7",
          "commit": {
            "abbreviatedOid": "e1ffc74"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks for the updates - these address all my feedback.",
          "createdAt": "2023-04-20T16:56:15Z",
          "updatedAt": "2023-04-20T16:56:15Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5TIyNh",
          "commit": {
            "abbreviatedOid": "e1ffc74"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-20T21:51:48Z",
          "updatedAt": "2023-04-20T22:39:07Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Did we actually decide to make this a URI?\r\n\r\nMy impression was that we wanted to go with URIs for connect targets, but keep track names being just names since to emphasize the fact that they don't tell you where to connect.  I'd just call this \"full track name\" and leave out the scheme for now.",
              "createdAt": "2023-04-20T21:51:49Z",
              "updatedAt": "2023-04-20T22:39:07Z"
            },
            {
              "originalPosition": 48,
              "body": "I am a bit concerned about this MUST, since we don't actually enforce it on the protocol level.  We should also specify who is the target audience of the MUST.  How about something like:\r\n\r\n\"This document does not define the exact mechanism of naming track namespaces. Applications building on top of MoQ MUST ensure that the mechanism used guarantees global uniqueness; for instance, an application could use domain names as track namespaces.\"",
              "createdAt": "2023-04-20T22:26:01Z",
              "updatedAt": "2023-04-20T22:39:07Z"
            },
            {
              "originalPosition": 60,
              "body": "Please switch both examples to use example names from RFC 2606.",
              "createdAt": "2023-04-20T22:27:36Z",
              "updatedAt": "2023-04-20T22:39:07Z"
            },
            {
              "originalPosition": 70,
              "body": "I believe we want to allow more than one connection URLs, for redundancy and multi-CDN support.  How about \"have one or more associated connection URLs specifying network hosts through which a track may be accessed\"?",
              "createdAt": "2023-04-20T22:37:17Z",
              "updatedAt": "2023-04-20T22:39:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TJpfd",
          "commit": {
            "abbreviatedOid": "e1ffc74"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-21T04:29:07Z",
          "updatedAt": "2023-04-21T04:29:07Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "I can remove moq:// scheme",
              "createdAt": "2023-04-21T04:29:07Z",
              "updatedAt": "2023-04-21T04:30:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TJykP",
          "commit": {
            "abbreviatedOid": "665d643"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-21T05:30:56Z",
          "updatedAt": "2023-04-21T05:30:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 122,
      "id": "PR_kwDOG2Ho4M5NrcUD",
      "title": "IETF 116:  Update Subscribe Messages",
      "url": "https://github.com/moq-wg/moq-transport/pull/122",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR depends on #121 and has the following changes  to capture IETF 116 decisions \r\n\r\n1. Rename subscribe message to subscribe request \r\n2. Include track names and authorization in the subscribe request\r\n3. Add  basic support for subscribe reply providing the results of subscription\r\n4. Add support for short compression identifiers as Track Id (varint) to be used in the object header messages\r\n\r\nCurrently the subscribe granularity is per track and a future PR can be modified to support multiple tracks if needed.",
      "createdAt": "2023-04-05T13:49:34Z",
      "updatedAt": "2023-04-21T18:52:07Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "116-track",
      "baseRefOid": "ede0c5948ee69c2f91b217433272ef7f3700814c",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "116-subscribe",
      "headRefOid": "21ea08cf1e85c3591597741fd9d1eb1822afabaf",
      "closedAt": "2023-04-21T18:52:06Z",
      "mergedAt": "2023-04-21T18:52:06Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "7d497f6554be955d59c9234e2737c1450372131d"
      },
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@afrind \r\n\r\nGood points Alan on the comments. I will respond and update text to reflect these by early next week.",
          "createdAt": "2023-04-07T16:54:24Z",
          "updatedAt": "2023-04-07T16:54:24Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@afrind pushed few changes to address your review feedback. please let me know thanks",
          "createdAt": "2023-04-10T16:47:12Z",
          "updatedAt": "2023-04-10T16:47:12Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@fluffy @kixelated @vasilvv @afrind please give it another read and let me know . thanks",
          "createdAt": "2023-04-10T23:50:56Z",
          "updatedAt": "2023-04-10T23:50:56Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@vasilvv @afrind the last few commits should address your feedback. please let me know . Thanks",
          "createdAt": "2023-04-21T05:40:12Z",
          "updatedAt": "2023-04-21T05:40:12Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5SCbuK",
          "commit": {
            "abbreviatedOid": "bbe4286"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "This seems about right. ",
          "createdAt": "2023-04-07T16:26:55Z",
          "updatedAt": "2023-04-07T16:26:55Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5SCZYs",
          "commit": {
            "abbreviatedOid": "bbe4286"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Individual review",
          "createdAt": "2023-04-07T16:15:59Z",
          "updatedAt": "2023-04-07T16:41:23Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "I think it would be good to explain Track Name vs Track ID with some expository text where tracks are defined (maybe in #121).\r\n\r\nThen here perhaps you can say \"Track ID: unique identifier for this track within the current (session? connection?)\"",
              "createdAt": "2023-04-07T16:15:59Z",
              "updatedAt": "2023-04-07T16:41:23Z"
            },
            {
              "originalPosition": 53,
              "body": "Did you mean SUBSCRIBE_REQUEST?  SUBSCRIBE is no longer defined?",
              "createdAt": "2023-04-07T16:16:57Z",
              "updatedAt": "2023-04-07T16:41:23Z"
            },
            {
              "originalPosition": 89,
              "body": "Does it always have to be fully qualified, or can that vary by \"Streaming format\" or another profile.  My understanding is that some use cases would like to only send the suffix here, and combine it with a prefix communicated elsewhere.  Is that possible?",
              "createdAt": "2023-04-07T16:24:13Z",
              "updatedAt": "2023-04-07T16:41:23Z"
            },
            {
              "originalPosition": 91,
              "body": "Is it better to have the publisher assign the track ID in the SUBSCRIBE_REPLY or the subscriber in the SUBSCRIBE_REQUEST?  Are there any tradeoffs?",
              "createdAt": "2023-04-07T16:24:56Z",
              "updatedAt": "2023-04-07T16:41:23Z"
            },
            {
              "originalPosition": 100,
              "body": "I don't think the layout can have both Group and Object sequence be optional -- if there's only one varint present in the message it's implicitly a Group Sequence, right?  \r\n\r\nI read your intent to support these three cases:\r\n\r\n1. No group/object info - send all groups/objects starting from beginning of most recent group, object 0\r\n2. Group sequence - send from this specific group, starting from object 0\r\n3. Group sequence and Object sequence - send only this specific object from this specific group\r\n\r\nIs that right?",
              "createdAt": "2023-04-07T16:28:00Z",
              "updatedAt": "2023-04-07T16:41:23Z"
            },
            {
              "originalPosition": 114,
              "body": "If we want automatic unsubscribe, then I think SETUP or SUBSCRIBE_REPLY needs to exchange information about the publisher's required refresh period.\r\n\r\nI also think we want an explicit UNSUBSCRIBE message, in case the publishers refresh interval is much longer than the receiver wants to continue getting this track. ",
              "createdAt": "2023-04-07T16:33:22Z",
              "updatedAt": "2023-04-07T16:41:23Z"
            },
            {
              "originalPosition": 135,
              "body": "Is TRACK RESPONSE going to be reused elsewhere (maybe PUBLISH_REQUEST/RESPONSE)?  If not, just merge the fields there into SUBSCRIBE_REPLY?",
              "createdAt": "2023-04-07T16:34:16Z",
              "updatedAt": "2023-04-07T16:41:23Z"
            },
            {
              "originalPosition": 141,
              "body": "It's too early to bikeshed error codes, but I'm curious if you called out Expired here separately from Fail so that a publisher can send a SUBSCRIBE_REPLY once the track expires?  Eg, are you envisioning a sequence like:\r\n\r\nConsumer -> Publisher: SUBSCRIBE_REQUEST\r\nP -> C: SUBSCRIBE_REPLY\r\nP -> C: OBJECT*\r\n...\r\nP -> C: SUBSCRIBE_REPLY (Expired)",
              "createdAt": "2023-04-07T16:37:11Z",
              "updatedAt": "2023-04-07T16:41:24Z"
            },
            {
              "originalPosition": 165,
              "body": "If the publisher has full control over the ID space I think I would recommend against letting the client ask for particular IDs.  Do you have a use case in mind or would publisher-assigned work?",
              "createdAt": "2023-04-07T16:38:30Z",
              "updatedAt": "2023-04-07T16:41:24Z"
            },
            {
              "originalPosition": 162,
              "body": "I think shall is a normative verb, since it's optional, you can use MAY or can.  Also maybe say \"subscription request\" rather than \"transaction\".",
              "createdAt": "2023-04-07T16:40:17Z",
              "updatedAt": "2023-04-07T16:41:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SCfQy",
          "commit": {
            "abbreviatedOid": "bbe4286"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-07T16:44:53Z",
          "updatedAt": "2023-04-07T16:44:53Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "good catch, will update",
              "createdAt": "2023-04-07T16:44:53Z",
              "updatedAt": "2023-04-07T16:44:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SCgiQ",
          "commit": {
            "abbreviatedOid": "bbe4286"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-07T16:51:25Z",
          "updatedAt": "2023-04-07T16:51:26Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "We discussed this topic in length at the IETF116 in the context of WT and Native QUIC and why having full name will work for both cases uniformly and also for inter distribution network flows.\r\n\r\nWe concluded that  tracks are central component and they are self identifying and are carry that way in subscribes/publishes.\r\n ",
              "createdAt": "2023-04-07T16:51:26Z",
              "updatedAt": "2023-04-07T16:51:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SCiYS",
          "commit": {
            "abbreviatedOid": "bbe4286"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-07T17:00:36Z",
          "updatedAt": "2023-04-07T17:00:37Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": ". #121  explains what Track Name is, #122  explains what is TrackId .. would that work ?",
              "createdAt": "2023-04-07T17:00:36Z",
              "updatedAt": "2023-04-07T17:00:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SCyAM",
          "commit": {
            "abbreviatedOid": "bbe4286"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-07T18:23:10Z",
          "updatedAt": "2023-04-07T18:23:11Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "@vasilvv @kixelated will this meet your use cases?  My understanding of Mo's proposal on the mailing list was specifically so that suffix only *could* be specified here -- both suffix only or fully qualified are OK. ",
              "createdAt": "2023-04-07T18:23:10Z",
              "updatedAt": "2023-04-07T18:23:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SCyOT",
          "commit": {
            "abbreviatedOid": "bbe4286"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-07T18:24:28Z",
          "updatedAt": "2023-04-07T18:24:29Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "I'm not necessarily hung up on which PR defines it - only the name vs id concept deserves top level mention earlier in the document.",
              "createdAt": "2023-04-07T18:24:28Z",
              "updatedAt": "2023-04-07T18:24:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SETgm",
          "commit": {
            "abbreviatedOid": "bbe4286"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T05:37:33Z",
          "updatedAt": "2023-04-09T05:37:34Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "yes it is used across Publish and Subscribe message .. same with Track Info too",
              "createdAt": "2023-04-09T05:37:33Z",
              "updatedAt": "2023-04-09T05:37:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SHnBc",
          "commit": {
            "abbreviatedOid": "bbe4286"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T15:51:52Z",
          "updatedAt": "2023-04-10T15:51:52Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "@afrind  thanks .. I will add TrackId to top level terminology in this PR.",
              "createdAt": "2023-04-10T15:51:52Z",
              "updatedAt": "2023-04-10T15:51:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SHoFV",
          "commit": {
            "abbreviatedOid": "bbe4286"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T15:55:33Z",
          "updatedAt": "2023-04-10T15:55:33Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "I think we did have a discussion at the mic on this aspect and we agreed to keep the behavior of subscribe and publish unifirm across all the nodes, it is best to keep the track as self identifying without tying it to the connection context.  Since this will allow 2 things\r\n1.  Work in the same way across WT and native QUIC. For WT there is extra bytes of duplication which is not concerning\r\n2. Nodes processing subscribe/publish can be uniformly defined without needing to explcitly specify the cases where one option would work vs the other. \r\n3. Tracks are authorized and one can define security properties in a common way across applications and distribution networks",
              "createdAt": "2023-04-10T15:55:33Z",
              "updatedAt": "2023-04-10T15:55:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SHpTp",
          "commit": {
            "abbreviatedOid": "bbe4286"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T15:58:32Z",
          "updatedAt": "2023-04-10T15:58:33Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "Good question @afrind \r\n\r\nIn the current model, the publisher has the final say on the trackId to be used. \r\n\r\nThe benefit of Subscriber Request proposing the TrackId is it will lead to a design where one can minimize the rewrites of the object headers per hop if there is no conflict. \r\n\r\nAgain the publisher is the one that can decide the trackId and it will do so in the SUBSCRIBE_REPLY.",
              "createdAt": "2023-04-10T15:58:32Z",
              "updatedAt": "2023-04-10T15:58:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SHsWC",
          "commit": {
            "abbreviatedOid": "bbe4286"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T16:01:49Z",
          "updatedAt": "2023-04-10T16:01:50Z",
          "comments": [
            {
              "originalPosition": 100,
              "body": "Yes , the cases you have listed are right. I would phrase the case 3 as\r\nGroup sequence and Object sequence - send starting only this specific object from this specific group\r\n\r\nI believe for the simplicity of this PR, we can omit both the Group Sequence and Object Sequence and we put in a statement saying,\r\n\"starts from the most recent group , object 0\"\r\n\r\nI will do a separate PR on controlling the start point \r\n\r\nwould that sound fine ? ",
              "createdAt": "2023-04-10T16:01:49Z",
              "updatedAt": "2023-04-10T16:01:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SHtQk",
          "commit": {
            "abbreviatedOid": "bbe4286"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T16:02:43Z",
          "updatedAt": "2023-04-10T16:02:43Z",
          "comments": [
            {
              "originalPosition": 114,
              "body": "@afrind  great points. I agree on both the points. I will add issues to cover those.",
              "createdAt": "2023-04-10T16:02:43Z",
              "updatedAt": "2023-04-10T16:02:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SHuRI",
          "commit": {
            "abbreviatedOid": "bbe4286"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T16:03:50Z",
          "updatedAt": "2023-04-10T16:03:50Z",
          "comments": [
            {
              "originalPosition": 162,
              "body": "+1 .. will update",
              "createdAt": "2023-04-10T16:03:50Z",
              "updatedAt": "2023-04-10T16:03:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SH47J",
          "commit": {
            "abbreviatedOid": "bbe4286"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T16:33:36Z",
          "updatedAt": "2023-04-10T16:33:36Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "the only benefit is minimize object header rewrites. May be very are optimizing too early. i am fine with making it publisher controlled id space.\r\n\r\n",
              "createdAt": "2023-04-10T16:33:36Z",
              "updatedAt": "2023-04-10T16:33:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SH8qf",
          "commit": {
            "abbreviatedOid": "bbe4286"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T16:46:15Z",
          "updatedAt": "2023-04-10T16:46:17Z",
          "comments": [
            {
              "originalPosition": 114,
              "body": "#133 , #132  created these issues ",
              "createdAt": "2023-04-10T16:46:16Z",
              "updatedAt": "2023-04-10T16:46:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SH8zT",
          "commit": {
            "abbreviatedOid": "bbe4286"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T16:46:41Z",
          "updatedAt": "2023-04-10T16:46:41Z",
          "comments": [
            {
              "originalPosition": 141,
              "body": "Removed expired for now. We can revisit later if its needed.",
              "createdAt": "2023-04-10T16:46:41Z",
              "updatedAt": "2023-04-10T16:46:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SIDI7",
          "commit": {
            "abbreviatedOid": "482287d"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T17:08:10Z",
          "updatedAt": "2023-04-10T17:29:26Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I don't think this should be in the definitions. I think Alan was asking for a section on how name/URL maps to ID.",
              "createdAt": "2023-04-10T17:08:10Z",
              "updatedAt": "2023-04-10T17:29:26Z"
            },
            {
              "originalPosition": 89,
              "body": "The intent of the compromise was that `track prefix == bundle URL`.  We have to remove bundle to support tracks as top-level in the object model (absolute track URLs), so prefix/suffix doesn't work as a compromise any longer.\r\n\r\nJust have every track name be fully qualified for now. I'll argue why this doesn't work when we want to support pooling.",
              "createdAt": "2023-04-10T17:14:24Z",
              "updatedAt": "2023-04-10T17:29:26Z"
            },
            {
              "originalPosition": 112,
              "body": "This is a hard no from me as discussed in #102 .\r\n\r\nI would be okay with the server indicating a subscription expiration in the SUBSCRIBE_REPLY message. That way the consumer (nit: not client) would resubscribe based on the policy set by the publisher. \r\n\r\nI would still want to talk about the use-case though; what problem are you solving?",
              "createdAt": "2023-04-10T17:17:57Z",
              "updatedAt": "2023-04-10T17:29:26Z"
            },
            {
              "originalPosition": 109,
              "body": "The group wouldn't start at 0 when joining a live stream. The relay should not rewrite object headers either, as it will break any form of history (ex. catalog that indicates group 45 = timestamp 12:34)",
              "createdAt": "2023-04-10T17:18:49Z",
              "updatedAt": "2023-04-10T17:29:26Z"
            },
            {
              "originalPosition": 114,
              "body": "I would encode an \"expires\" in the SUBSCRIBE_REPLY. It would be a duration (not a timestamp) so the consumer would need to refresh the subscription a little early.",
              "createdAt": "2023-04-10T17:21:42Z",
              "updatedAt": "2023-04-10T17:29:26Z"
            },
            {
              "originalPosition": 146,
              "body": "I've mentioned this in a few PRs, but these optionals are not possible to encode. ",
              "createdAt": "2023-04-10T17:23:55Z",
              "updatedAt": "2023-04-10T17:29:26Z"
            },
            {
              "originalPosition": 145,
              "body": "varint?",
              "createdAt": "2023-04-10T17:24:37Z",
              "updatedAt": "2023-04-10T17:29:26Z"
            },
            {
              "originalPosition": 159,
              "body": "The phrase would be a human readable string, not a code.",
              "createdAt": "2023-04-10T17:25:11Z",
              "updatedAt": "2023-04-10T17:29:26Z"
            },
            {
              "originalPosition": 146,
              "body": "And why is this optional in the first place?",
              "createdAt": "2023-04-10T17:26:48Z",
              "updatedAt": "2023-04-10T17:29:26Z"
            },
            {
              "originalPosition": 162,
              "body": "I think the consumer should choose the track ID in the SUBSCRIBE message.\r\n\r\nOtherwise, there's a race condition where the SUBSCRIBE_REPLY could be delayed, while the consumer receives objects with an unknown track ID. It's a whole lot simpler if the consumer chooses the ID in the SUBSCRIBE message.",
              "createdAt": "2023-04-10T17:29:18Z",
              "updatedAt": "2023-04-10T17:29:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SIOsw",
          "commit": {
            "abbreviatedOid": "482287d"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T17:48:13Z",
          "updatedAt": "2023-04-10T17:48:13Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I see .. I did have it as part of the messages section. May be @afrind  can you see the message section changes and see if it still works.",
              "createdAt": "2023-04-10T17:48:13Z",
              "updatedAt": "2023-04-10T17:48:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SIPHf",
          "commit": {
            "abbreviatedOid": "482287d"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T17:49:39Z",
          "updatedAt": "2023-04-10T17:49:39Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "I don't think I mentioned group starting at 0 .. I meant object starting at 0 form the most recent group",
              "createdAt": "2023-04-10T17:49:39Z",
              "updatedAt": "2023-04-10T17:49:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SIPbZ",
          "commit": {
            "abbreviatedOid": "482287d"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T17:50:33Z",
          "updatedAt": "2023-04-10T17:50:34Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "A failed subscription doesn't need a track Id .. Options are very common QUIC encoding. Can you explain what are the challenges you see ?",
              "createdAt": "2023-04-10T17:50:33Z",
              "updatedAt": "2023-04-10T17:50:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SIPlW",
          "commit": {
            "abbreviatedOid": "482287d"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T17:51:00Z",
          "updatedAt": "2023-04-10T17:51:00Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "+1 .. will upadte",
              "createdAt": "2023-04-10T17:51:00Z",
              "updatedAt": "2023-04-10T17:51:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SI2_S",
          "commit": {
            "abbreviatedOid": "482287d"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T19:58:24Z",
          "updatedAt": "2023-04-10T19:58:24Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I called this \"Subscription ID\" in a previous PR. It might be less confusing since it's decoupled from track.",
              "createdAt": "2023-04-10T19:58:24Z",
              "updatedAt": "2023-04-10T19:58:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SI3ee",
          "commit": {
            "abbreviatedOid": "482287d"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T20:00:07Z",
          "updatedAt": "2023-04-10T20:00:07Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "I missed the `i.e` when reading this, which should be `ex.` anyway...\r\n\r\nI think the example is fine just make up a number like 53.",
              "createdAt": "2023-04-10T20:00:07Z",
              "updatedAt": "2023-04-10T20:00:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SI4dS",
          "commit": {
            "abbreviatedOid": "482287d"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T20:03:33Z",
          "updatedAt": "2023-04-10T20:03:34Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "So I think I understand what you're trying to do in this instance, but you need more text. There's no magic way to make a field optional in QUIC encoding.\r\n\r\nHow about:\r\n> The track ID field MUST ONLY be present if the result is Ok. The reason and length MUST ONLY be present if the result is not Ok.\r\n\r\nI would just make a separate messages honestly: SUBSCRIBE_OK and SUBSCRIBE_ERROR. If we want to consolidate them in the future, we can add a flag for the type (like how QUIC frames work).",
              "createdAt": "2023-04-10T20:03:34Z",
              "updatedAt": "2023-04-10T20:03:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SJWBg",
          "commit": {
            "abbreviatedOid": "482287d"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T21:55:47Z",
          "updatedAt": "2023-04-10T21:55:47Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I did call it \"Subscription ID\" in #96  and there was some push backs on that term IIRC . This is just naming, I am fine with either of the names. We need to pick one and move on",
              "createdAt": "2023-04-10T21:55:47Z",
              "updatedAt": "2023-04-10T21:55:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SJmk3",
          "commit": {
            "abbreviatedOid": "482287d"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T23:30:55Z",
          "updatedAt": "2023-04-10T23:30:56Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I don't see any push-back in that PR around the name. There was a LOT of other stuff in that PR. \r\n\r\nAnd yeah I called it \"Subscribe ID\" in #43. I think \"Subscription ID\" is better.",
              "createdAt": "2023-04-10T23:30:56Z",
              "updatedAt": "2023-04-10T23:30:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SJmzG",
          "commit": {
            "abbreviatedOid": "482287d"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T23:32:23Z",
          "updatedAt": "2023-04-10T23:32:23Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "i will remove it from this PR and we can discuss in #102 ",
              "createdAt": "2023-04-10T23:32:23Z",
              "updatedAt": "2023-04-10T23:32:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SJm6U",
          "commit": {
            "abbreviatedOid": "482287d"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T23:33:08Z",
          "updatedAt": "2023-04-10T23:33:08Z",
          "comments": [
            {
              "originalPosition": 162,
              "body": "i will revert some of these for a fresh discussion",
              "createdAt": "2023-04-10T23:33:08Z",
              "updatedAt": "2023-04-10T23:33:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5S5FaL",
          "commit": {
            "abbreviatedOid": "b18193c"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Individual Review",
          "createdAt": "2023-04-18T18:20:43Z",
          "updatedAt": "2023-04-18T18:44:18Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "I think this discussion is captured in #121 for now and we can update based on whatever the outcome is there.",
              "createdAt": "2023-04-18T18:20:43Z",
              "updatedAt": "2023-04-18T18:44:18Z"
            },
            {
              "originalPosition": 92,
              "body": "Editorial comments:\r\n\r\nI don't think you need to say proposal:\r\n\r\n> An session specific identifier used in OBJECT ... message headers for the requested track.\r\n\r\n\"provides the necessary mapping between\" -> maps\r\n\r\n> ... the Track ID maps the \"Track Name\" ...\r\n\r\nRestating the compression bit more succinctly:\r\n\r\n> Track IDs are generally shorter than Track Names and thus reduce the overhead in OBJECT messages.",
              "createdAt": "2023-04-18T18:27:06Z",
              "updatedAt": "2023-04-18T18:44:18Z"
            },
            {
              "originalPosition": 92,
              "body": "Architectural Comment:\r\n\r\nI'd prefer to just let the server pick the IDs rather than giving the client an option to ask for a specific one.  If we remove that functionality from this PR we can move this forward and have a separate PR to discuss the pros and cons of client hinting track IDs there.",
              "createdAt": "2023-04-18T18:33:49Z",
              "updatedAt": "2023-04-18T18:44:18Z"
            },
            {
              "originalPosition": 102,
              "body": "Maybe remove \"typically in the form of a token\", since \"the specifics of ... authorization information is out of scope\".",
              "createdAt": "2023-04-18T18:35:13Z",
              "updatedAt": "2023-04-18T18:44:18Z"
            },
            {
              "originalPosition": 114,
              "body": "I recommend you add \"expires\" in SUBSCRIBE_REPLY as @kixelated suggests, and rewrite this bit to say \"the subscription is active until it expires, or the underlying transport is disconnected\".  Once UNSUBSCRIBE is added, then you can add the bit here about \"client policy\".",
              "createdAt": "2023-04-18T18:38:54Z",
              "updatedAt": "2023-04-18T18:44:18Z"
            },
            {
              "originalPosition": 145,
              "body": "What do you want to varint here?",
              "createdAt": "2023-04-18T18:39:47Z",
              "updatedAt": "2023-04-18T18:44:18Z"
            },
            {
              "originalPosition": 146,
              "body": "The QUIC wg likes to use different message types for this kind of thing -- along the lines of Luke's second suggestion, but we can also move forward now with just some extra text explaining when the ID will be there and when it will not.",
              "createdAt": "2023-04-18T18:41:07Z",
              "updatedAt": "2023-04-18T18:44:18Z"
            },
            {
              "originalPosition": 163,
              "body": "> the `Track ID` value provided in the request or the one chosen by client processing the request\r\n\r\nDo you mean \"chosen by the *server* processing the request\" ?",
              "createdAt": "2023-04-18T18:42:38Z",
              "updatedAt": "2023-04-18T18:44:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TAQ26",
          "commit": {
            "abbreviatedOid": "b18193c"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-19T17:35:14Z",
          "updatedAt": "2023-04-19T17:35:15Z",
          "comments": [
            {
              "originalPosition": 163,
              "body": "i will reword it as \"chosen by the peer processing the request\"",
              "createdAt": "2023-04-19T17:35:15Z",
              "updatedAt": "2023-04-19T17:35:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TAoIv",
          "commit": {
            "abbreviatedOid": "b18193c"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-19T18:35:48Z",
          "updatedAt": "2023-04-19T19:34:01Z",
          "comments": [
            {
              "originalPosition": 92,
              "body": "Not sure what you mean by client/server in this context.\r\n\r\nI think the endpoint sending the SUBSCRIBE request (receiver) should choose the ID. Otherwise, there's a race condition where the SUBSCRIBE REPLY arrives after OBJECT messages (due to packet loss), and the mapping of ID to URI will be missing.",
              "createdAt": "2023-04-19T18:35:48Z",
              "updatedAt": "2023-04-19T19:34:01Z"
            },
            {
              "originalPosition": 92,
              "body": "The proposed PUBLISH message involves a similar race. \r\n\r\nFrankly, QPACK would fix both of these. You can only use a mapping from ID -> URI in an OBJECT header after there's been an explicit QPACK acknowledgement.",
              "createdAt": "2023-04-19T18:39:25Z",
              "updatedAt": "2023-04-19T19:34:01Z"
            },
            {
              "originalPosition": 145,
              "body": "You can infer that this is the `Track Result` enum as a varint. Would be nice if it was explicit `(i)`. You should also remove the word `Response`.",
              "createdAt": "2023-04-19T18:43:22Z",
              "updatedAt": "2023-04-19T19:34:01Z"
            },
            {
              "originalPosition": 143,
              "body": "Why does the sender echo back the track name in the SUBSCRIBE REPLY? What happens when it's different from the track name in the SUBSCRIBE?",
              "createdAt": "2023-04-19T18:46:18Z",
              "updatedAt": "2023-04-19T19:34:01Z"
            },
            {
              "originalPosition": 146,
              "body": "Here's what I would propose:\r\n\r\n```\r\nSUBSCIRBE {\r\n  Subscribe ID (i)\r\n  Track Name Length (i)\r\n  Track Name (...)\r\n  Auth Payload Length (i)\r\n  Auth Payload (...)\r\n}\r\n\r\nSUBSCRIBE_OK {\r\n  Subscribe ID (i)\r\n  Subscribe Expires (i)\r\n}\r\n\r\nSUBSCRIBE_RESET {\r\n  Subscribe ID (i)\r\n  Error Code (i)\r\n  Error Phrase Length (i)\r\n  Error Phrase (...)\r\n}\r\n```\r\n\r\nI like separate messages instead of optional fields. Especially because we need to put more stuff in the SUBSCRIBE_OK, like the starting group number. SUBSCRIBE_RESET because it could be sent after a SUBSCRIBE_OK to signal that the subscription has ended.\r\n\r\nHere's the last piece of the puzzle:\r\n```\r\nSUBSCRIBE_STOP {\r\n  Subscribe ID (i)\r\n  Error Code (i)\r\n  Error Phrase Length (i)\r\n  Error Phrase (...)\r\n}\r\n```\r\n\r\nThat's unsubscribe, but with a name closer to QUIC nomenclature. These messages are a weird mix between RESET_STREAM, STOP_SENDING, and CONNECTION_CLOSE (because of the phrase).",
              "createdAt": "2023-04-19T18:56:18Z",
              "updatedAt": "2023-04-19T19:34:01Z"
            },
            {
              "originalPosition": 163,
              "body": "`client` versus `server` is very confusing, because it has a very specific meaning in QUIC.\r\n\r\nI call the two endpoints either the `sender` and `receiver` based on the flow of media. The role can change depending on the track though, if both sides negotiate a bidirectional ROLE in the SETUP message.",
              "createdAt": "2023-04-19T18:59:31Z",
              "updatedAt": "2023-04-19T19:34:01Z"
            },
            {
              "originalPosition": 75,
              "body": "Could you merge `TRACK INFO` with `SUBSCRIBE` for now? I know you're trying to deduplicate this information for the other `PUBLISH` PR, but not all of these fields don't quite make sense in that role.",
              "createdAt": "2023-04-19T19:01:56Z",
              "updatedAt": "2023-04-19T19:34:01Z"
            },
            {
              "originalPosition": 95,
              "body": "> the publisher MUST deliver the objects from the most recent group.\r\n\r\nThis is too heavy handed.\r\n\r\nThe intent of this field when present is to say \"please don't deliver anything before sequence X\". That makes sense when the receiver already has the data and doesn't want it to be retransmitted.\r\n\r\nWhen this field is omitted, the receiver is saying \"deliver whatever you want\". The relay must still obey send order so the newest group is sent first based on availability. However the relay should still deliver older groups especially for higher latency use-cases.\r\n\r\nFor example, let's suppose the relay only has a single keyframe in the cache for the newest group. We should always deliver the newest object, but if we follow this MUST and don't deliver older objects, then a client with a 2s jitter buffer it going to sit there with a spinner for 2s.\r\n\r\nI would leave this behavior undefined for now. In the future, we could indicate a max age when subscribing to avoid transmitting useless old media.",
              "createdAt": "2023-04-19T19:21:22Z",
              "updatedAt": "2023-04-19T19:34:01Z"
            },
            {
              "originalPosition": 81,
              "body": "Add some text indicating how these are optional. In the current PR, it's only possible to tell if a field is present based on the message length. This is not how QUIC, HTTP/3, QPACK, TLS, etc encodes optional fields so it needs to be very explicit.\r\n\r\nOr make them required and reserve 0. I think we should start with that.",
              "createdAt": "2023-04-19T19:26:43Z",
              "updatedAt": "2023-04-19T19:34:01Z"
            },
            {
              "originalPosition": 99,
              "body": "Need to clarify if the SUBSCRIBE lasts for the single group requested or continues for future groups, starting at object sequence 0 for those groups. I could see both as valid interpretations.",
              "createdAt": "2023-04-19T19:31:46Z",
              "updatedAt": "2023-04-19T19:34:01Z"
            },
            {
              "originalPosition": 99,
              "body": "But can we remove this for now? I don't want to implement it, and I think the usefulness is nebulous at best.",
              "createdAt": "2023-04-19T19:32:51Z",
              "updatedAt": "2023-04-19T19:34:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TCojP",
          "commit": {
            "abbreviatedOid": "b18193c"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-20T04:47:05Z",
          "updatedAt": "2023-04-20T04:47:06Z",
          "comments": [
            {
              "originalPosition": 143,
              "body": "It correlates the track in the request, since there can be multiple in flight.\r\nwe can add further text for handling edge cases or error flows in the follow up PRs.",
              "createdAt": "2023-04-20T04:47:05Z",
              "updatedAt": "2023-04-20T04:47:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TG6tS",
          "commit": {
            "abbreviatedOid": "2ce30b2"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Individual review",
          "createdAt": "2023-04-20T16:00:42Z",
          "updatedAt": "2023-04-20T16:10:53Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "I see these IDs are defined below -- can you add a reference to that section.",
              "createdAt": "2023-04-20T16:00:42Z",
              "updatedAt": "2023-04-20T16:10:53Z"
            },
            {
              "originalPosition": 165,
              "body": "I recommend replacing `SHOULD verify` with `MUST close the connection` if there are duplicates.",
              "createdAt": "2023-04-20T16:04:40Z",
              "updatedAt": "2023-04-20T16:10:53Z"
            },
            {
              "originalPosition": 169,
              "body": "In the case where the publisher is a cache and the media is no longer live, does this mean start from the last group?",
              "createdAt": "2023-04-20T16:05:36Z",
              "updatedAt": "2023-04-20T16:10:53Z"
            },
            {
              "originalPosition": 175,
              "body": "If it's mandatory, do you want a MUST in here?  Aren't there applications where authorization isn't required at the track level (either public broadcast, or perhaps authorized at webtransport level for that mapping) - so maybe it shouldn't be mandatory?",
              "createdAt": "2023-04-20T16:07:55Z",
              "updatedAt": "2023-04-20T16:10:53Z"
            },
            {
              "originalPosition": 98,
              "body": "I recommend removing Track ID from SUBSCRIBE REQUEST and leave it only in SUBSCRIBE OK.",
              "createdAt": "2023-04-20T16:10:10Z",
              "updatedAt": "2023-04-20T16:10:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5THALC",
          "commit": {
            "abbreviatedOid": "2ce30b2"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-20T16:13:44Z",
          "updatedAt": "2023-04-20T16:13:44Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "Yes, If it is omitted, its start from the beginning of the most recent group.",
              "createdAt": "2023-04-20T16:13:44Z",
              "updatedAt": "2023-04-20T16:13:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5THCN7",
          "commit": {
            "abbreviatedOid": "2ce30b2"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-20T16:18:59Z",
          "updatedAt": "2023-04-20T16:19:00Z",
          "comments": [
            {
              "originalPosition": 175,
              "body": "@afrind makes sense. how about this rephrasing\r\n\r\n\"AUTHORIZATION INFO parameter (key 0x02) identifies track's authorization information. This parameter is populated for cases where the authorization is required at the track level\"",
              "createdAt": "2023-04-20T16:18:59Z",
              "updatedAt": "2023-04-20T16:19:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5THD-O",
          "commit": {
            "abbreviatedOid": "2ce30b2"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-20T16:23:31Z",
          "updatedAt": "2023-04-20T16:23:32Z",
          "comments": [
            {
              "originalPosition": 175,
              "body": "Sounds good to me",
              "createdAt": "2023-04-20T16:23:31Z",
              "updatedAt": "2023-04-20T16:23:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TJNbq",
          "commit": {
            "abbreviatedOid": "2ce30b2"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-21T00:53:33Z",
          "updatedAt": "2023-04-21T01:57:24Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "I would call those \"subscribe request parameters\", since those are properties of the request, and not of the track.",
              "createdAt": "2023-04-21T00:53:33Z",
              "updatedAt": "2023-04-21T01:57:24Z"
            },
            {
              "originalPosition": 117,
              "body": "Do we always need `Expires`?  Do we want to have key/value pairs in the OK message, making `Expires` one of those?",
              "createdAt": "2023-04-21T01:56:00Z",
              "updatedAt": "2023-04-21T01:57:24Z"
            },
            {
              "originalPosition": 140,
              "body": "Do we want to also add a machine-readable error code?",
              "createdAt": "2023-04-21T01:56:31Z",
              "updatedAt": "2023-04-21T01:57:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TJs8h",
          "commit": {
            "abbreviatedOid": "2ce30b2"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-21T04:52:41Z",
          "updatedAt": "2023-04-21T04:52:41Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "@vasilvv since @afrind suggested we might want to reuse these parameters for Publish Request as well, how about I call it as 'Track Request Parameters'",
              "createdAt": "2023-04-21T04:52:41Z",
              "updatedAt": "2023-04-21T04:52:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TNTYd",
          "commit": {
            "abbreviatedOid": "7c356a3"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you for the updates.",
          "createdAt": "2023-04-21T15:36:02Z",
          "updatedAt": "2023-04-21T15:38:14Z",
          "comments": [
            {
              "originalPosition": 180,
              "body": "+Subscribe Error codes",
              "createdAt": "2023-04-21T15:36:02Z",
              "updatedAt": "2023-04-21T15:38:14Z"
            },
            {
              "originalPosition": 169,
              "body": "I can imagine this tripping some people, who would expect that the default is the beginning and not the end.  I suppose it makes sense given the dominant use cases are live.",
              "createdAt": "2023-04-21T15:37:24Z",
              "updatedAt": "2023-04-21T15:38:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TNeEU",
          "commit": {
            "abbreviatedOid": "7c356a3"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-21T16:08:05Z",
          "updatedAt": "2023-04-21T16:08:06Z",
          "comments": [
            {
              "originalPosition": 180,
              "body": "done .. thanks",
              "createdAt": "2023-04-21T16:08:05Z",
              "updatedAt": "2023-04-21T16:08:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TN8UT",
          "commit": {
            "abbreviatedOid": "21ea08c"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-21T17:30:02Z",
          "updatedAt": "2023-04-21T18:25:35Z",
          "comments": [
            {
              "originalPosition": 110,
              "body": "This should be chosen by the subscriber to avoid a race, since OBJECTS will be in flight at the same time.\r\n\r\nThe SUBSCRIBE OK and SUBSCRIBE ERROR messages would then echo back the track ID, not the full track name.",
              "createdAt": "2023-04-21T17:30:02Z",
              "updatedAt": "2023-04-21T18:25:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TOOG9",
          "commit": {
            "abbreviatedOid": "21ea08c"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2023-04-21T18:29:37Z",
          "updatedAt": "2023-04-21T18:29:37Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5TOOtS",
          "commit": {
            "abbreviatedOid": "21ea08c"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "My issues:\r\n\r\n1. We should have parameters in SUBSCRIBE_OK, since currently it has no extensibility.\r\n2. Expiry needs more thought.\r\n\r\nI'll file issues for those, but for now, LGTM.",
          "createdAt": "2023-04-21T18:32:02Z",
          "updatedAt": "2023-04-21T18:32:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 123,
      "id": "PR_kwDOG2Ho4M5NreYS",
      "title": "IETF116:  Announce messages",
      "url": "https://github.com/moq-wg/moq-transport/pull/123",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR depends on #121 and #122  and captures discussions at the IETF 116 to carryout publishes on tracks\r\n\r\nSpecifically this PR adds support for the following\r\n1. Publish Request message (similar to Subscribe Request) for track authorization\r\n2. Publish Reply message (similar to Subscribe Reply) for providing the result of publish request.\r\n\r\nThe core data structures are shared between subscribe and the publish messages.\r\n\r\nAs with PR #122, the scope of a publish request message is one track and can be extended to support multiple tracks in a separate PR, if needed.\r\n",
      "createdAt": "2023-04-05T13:55:15Z",
      "updatedAt": "2023-05-16T17:59:41Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "4135555f0abe0d5b132924ef3779ad1ff8b929b9",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "116-publish",
      "headRefOid": "1da489189f56d9bfd8f9bf0ba31093176a41f5fe",
      "closedAt": "2023-05-16T17:59:36Z",
      "mergedAt": "2023-05-16T17:59:36Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "14d81ba41e837e375d2e2455bfaf9801393ae41f"
      },
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I talked to Alan on slack, and maybe there's a misunderstanding on my part. I think we've been simultaneously talking about two different PUBLISH messages, which I'm going to label 0-RTT and 1-RTT. The primary difference between the two is when OBJECT messages are sent.\r\n\r\n**0-RTT PUBLISH:**\r\n```\r\n-> PUBLISH       track_id=5 track_name=/video\r\n-> OBJECT        track_id=5 object_id=0\r\n<- PUBLISH_REPLY track_id=5 status=ok\r\n```\r\n\r\n**1-RTT PUBLISH:**\r\n```\r\n-> PUBLISH       track_id=5 track_name=/video\r\n<- PUBLISH_REPLY track_id=5 status=ok\r\n-> OBJECT        track_id=5 object_id=0\r\n```\r\n\r\n\r\nThe 0-RTT publish is problematic because there's a race. If the PUBLISH message is lost, then the receiver will receive (and have to buffer) objects for unknown track IDs. It's an optimization when both endpoints have pre-negotiated subscriptions, which is why I liken it to HTTP push.\r\n\r\nThe 1-RTT publish has a lot of overlap with the current CATALOG message since it announces available track URIs. However, the difference is that the track is described solely based on it's name instead of a detailed media descriptor. Additionally, sending a PUBLISH per track is racey, which is why I combined all tracks into a single message.",
          "createdAt": "2023-04-20T02:10:28Z",
          "updatedAt": "2023-04-20T02:27:28Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "If the goal is 0-RTT PUBLISH, then it's a little early to optimize for RTTs. Additionally, if both endpoints can pre-negotiate track names to push, then they can also just pre-negotiate track IDs to push, and skip the problematic PUBLISH message altogether.\r\n\r\nIf the goal is 1-RTT PUBLISH, then I want to see a media catalog that describes the available tracks rather than an opaque URI. There should be some mechanism for the receiver to know the properties of the track before it agrees to subscribe to it (via a PUBLISH REPLY).",
          "createdAt": "2023-04-20T02:21:09Z",
          "updatedAt": "2023-04-20T02:29:00Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> There should be some mechanism for the receiver to know the properties of the track before it agrees to subscribe to it (via a PUBLISH REPLY).\r\n\r\nRelays will not have access to catalog.  So a publish request going from client endpoint to a relay serves as authz enforcement for the track being advertised by the cliend endpoint as the publisher.",
          "createdAt": "2023-04-20T04:44:47Z",
          "updatedAt": "2023-04-20T04:44:47Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> > There should be some mechanism for the receiver to know the properties of the track before it agrees to subscribe to it (via a PUBLISH REPLY).\r\n> \r\n> Relays will not have access to catalog. So a publish request going from client endpoint to a relay serves as authz enforcement for the track being advertised by the cliend endpoint as the publisher.\r\n\r\n\r\n\r\n> > There should be some mechanism for the receiver to know the properties of the track before it agrees to subscribe to it (via a PUBLISH REPLY).\r\n> \r\n> Relays will not have access to catalog. So a publish request going from client endpoint to a relay serves as authz enforcement for the track being advertised by the cliend endpoint as the publisher.\r\n\r\nOkay, that makes sense. Is it fair to say that the purpose of the PUBLISH message is primarily for authentication?",
          "createdAt": "2023-04-20T04:57:17Z",
          "updatedAt": "2023-04-20T04:58:22Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@afrind  latest commits should address the feedback provided. Please let me know .. thanks",
          "createdAt": "2023-04-21T05:57:50Z",
          "updatedAt": "2023-04-21T05:57:50Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n@afrind @kixelated @vasilvv @fluffy does the note added is good to proceed with this PR ?\r\n\r\n",
          "createdAt": "2023-04-21T21:29:01Z",
          "updatedAt": "2023-04-21T21:29:01Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Did you intend to remove the bit about \"active discussion and will be revised\" in d2c791b? ",
          "createdAt": "2023-04-21T21:44:29Z",
          "updatedAt": "2023-04-21T21:44:29Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I opened #143 to track the discussion",
          "createdAt": "2023-04-21T22:02:07Z",
          "updatedAt": "2023-04-21T22:02:07Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@afrind that was not the intent . updated now. Thanks\r\n",
          "createdAt": "2023-04-21T22:33:44Z",
          "updatedAt": "2023-04-21T22:33:44Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the update.",
          "createdAt": "2023-04-21T23:06:04Z",
          "updatedAt": "2023-04-21T23:06:04Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So the the 0-RTT vs 1-RTT is not so much an issue with this PR but is a separate issue of if the relay gets to override the ID or not. I think we should deal with that as a separate issue.  ",
          "createdAt": "2023-04-22T17:08:46Z",
          "updatedAt": "2023-04-22T17:08:46Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Apologies for missing last weeks editors call where this was debated.  My concerns with this approach are several: \r\n\r\n1. The ANNOUNCE message, with its enumeration of track names, is an exact duplicate of data already contained in the proposed CATALOG. See https://wilaw.github.io/MoQ/wilaw-patch-1/draft-law-moq-warpmedia.html#name-catalog-objects. Why do we need two mechanisms for conveying the same data? We can easily add an AUTH field to the  track change descriptors if that is what is required to avoid duplication?\r\n2. An ingest server that is authorizing what a connected publisher may publish is not acting as a relay. It is acting as an end-point and would therefore be able to parse the catalog. \r\n3. If we follow a publish-after-subscribe workflow (which I strongly believe we should), then an edge relay sitting on the contribution side will not have content coming to it that it didn't previously issue a subscribe request for. It will only issue subscriptions that come to it from upstream. Those subscriptions must have originated at an endpoint - either an origin or a end-client. That endpoint will have an access token to authorize the subscription. So the conferencing system can control the output of the publishing entities by controlling the access tokens that are used to pull content from them. \r\n4. For auth, we get to a situation where either the connection (WT or QUIC) specifies what can be subscribed to , or each object carries a token and the relay evaluates that token before routing. We would use an alias scheme for these tokens, like we do for object name, to reduce bits-on-the-wire and to reduce CPU effort in validating tokens. \r\n\r\nI'd love to whiteboard out the flow around subscription. Reconstructing a virtual workflow from PR comments and issue threads is difficult and leads to confusion. ",
          "createdAt": "2023-05-04T23:16:01Z",
          "updatedAt": "2023-05-04T23:16:01Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Auth is for the publisher and Announce will be needed for on path relays to trust the publisher and also to be able to find the publisher with in the relay network when a subscribe happens\r\n\r\n\r\nI am still fine to call it as publish_request/response, if it helps as the semantics are more clearer\r\n\r\n",
          "createdAt": "2023-05-05T00:49:10Z",
          "updatedAt": "2023-05-05T00:50:37Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't see this as the same as the catalog. The catalog has a bunch of information all the tracks. All this has is the authorization token that allows you to publish to a given track. I think I have outlined in other issues why we need this but I hope we can discuss in person today. We also have the issue of the relays can not read the catolog. ",
          "createdAt": "2023-05-05T16:05:17Z",
          "updatedAt": "2023-05-05T16:05:17Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Clarification\r\n\r\n> If we follow a publish-after-subscribe workflow\r\n\r\nAnnounce isn't intended to change the publish-after-subscribe workflow.  It's a mechanism for authorizing individual tracks, dynamically building routing tables in relays that can't parse the catalog, and offers relays a chance to pre-subscribe to content if desired.\r\n\r\nAs I read it now, it's also optional: a receiver can issue a subscribe for a track without having seen the announce for it (publishers gotta handle subscribes for non-existent tracks anyways), and the receiver can reply ANNOUNCE_OK to any ANNOUNCE it sees without taking any further action.",
          "createdAt": "2023-05-05T16:40:55Z",
          "updatedAt": "2023-05-05T16:40:55Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would support merging this PR along with a DISCUSS statement similar to the following:\r\n\r\nWe need discuss and have consensus around how bi-directional routing is going to work with dynamic publishers. CDN's of today have a mechanism for handling ingest from multiple publishers. Can that mechanism be extended to MoQ? Or is a new mechanism, along the lines of ANNOUNCE, required to meet the pub/sub routing demands of applications such as real-time conferencing?",
          "createdAt": "2023-05-05T20:12:20Z",
          "updatedAt": "2023-05-05T20:12:20Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5SCb9y",
          "commit": {
            "abbreviatedOid": "25dbbc9"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-07T16:28:09Z",
          "updatedAt": "2023-04-07T16:28:09Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5SCfB3",
          "commit": {
            "abbreviatedOid": "25dbbc9"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-07T16:43:36Z",
          "updatedAt": "2023-04-07T16:44:39Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "PUBLISH_REQUEST",
              "createdAt": "2023-04-07T16:43:36Z",
              "updatedAt": "2023-04-07T16:44:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SChXh",
          "commit": {
            "abbreviatedOid": "25dbbc9"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-07T16:55:40Z",
          "updatedAt": "2023-04-07T16:55:41Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Thanks for cathcing it . Will fix it",
              "createdAt": "2023-04-07T16:55:41Z",
              "updatedAt": "2023-04-07T16:55:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SJFWn",
          "commit": {
            "abbreviatedOid": "25dbbc9"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T20:47:13Z",
          "updatedAt": "2023-04-10T20:47:14Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "This needs to contain a track ID.",
              "createdAt": "2023-04-10T20:47:13Z",
              "updatedAt": "2023-04-10T20:47:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SJiFG",
          "commit": {
            "abbreviatedOid": "25dbbc9"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T23:01:58Z",
          "updatedAt": "2023-04-10T23:01:59Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Actually, can you be explicit and list the fields here? I'd rather be explicit even if it means more duplication. Case and point, it's not obvious at first glance that there's no track ID.",
              "createdAt": "2023-04-10T23:01:58Z",
              "updatedAt": "2023-04-10T23:02:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SPL0X",
          "commit": {
            "abbreviatedOid": "25dbbc9"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-11T16:51:59Z",
          "updatedAt": "2023-04-11T16:51:59Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "the PR #122  defines these structures .. would it help If i merge these 2 in a single PR ?",
              "createdAt": "2023-04-11T16:51:59Z",
              "updatedAt": "2023-04-11T16:51:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TBA0u",
          "commit": {
            "abbreviatedOid": "25dbbc9"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "DISMISSED",
          "body": "Going to -1 this until we talk more about the publish use-case. This feels like PUSH_PROMISE.\r\n\r\nThe ability to publish is intended to remove a round-trip when the sender already knows the intent of the receiver. There has to be some form of coordination out of the scope of this specification, which automatically rules out generic clients.\r\n\r\nIf this coordination of intent already exists, then receiver could just SUBSCRIBE immediately. I don't actually think it introduces an RTT because of SETUP currently works, and now is not the time to be nit-picking over startup RTTs anyway.\r\n\r\nThe cost of PUBLISH is complexity and race conditions. OBJECTs arrive before they were requested, requiring some form of buffering and identification. We also need a way of saying \"pls no\" if the endpoints actually did not coordinate.",
          "createdAt": "2023-04-19T19:47:05Z",
          "updatedAt": "2023-05-15T14:08:44Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5TG_xo",
          "commit": {
            "abbreviatedOid": "6691e44"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Individual review",
          "createdAt": "2023-04-20T16:12:44Z",
          "updatedAt": "2023-04-20T16:14:22Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Why are the track parameters generic for subscribe but specific for publish?  Can we make them the same?",
              "createdAt": "2023-04-20T16:12:44Z",
              "updatedAt": "2023-04-20T16:14:22Z"
            },
            {
              "originalPosition": 47,
              "body": "Same comment as subscribe",
              "createdAt": "2023-04-20T16:13:00Z",
              "updatedAt": "2023-04-20T16:14:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5THDhe",
          "commit": {
            "abbreviatedOid": "6691e44"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-20T16:22:19Z",
          "updatedAt": "2023-04-20T16:22:19Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "@afrind I wasn't too sure if anything other than authz parameter made sense for publish. may be they do, I am not thinking clearly ?\r\n",
              "createdAt": "2023-04-20T16:22:19Z",
              "updatedAt": "2023-04-20T16:22:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5THDtA",
          "commit": {
            "abbreviatedOid": "6691e44"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-20T16:22:47Z",
          "updatedAt": "2023-04-20T16:22:48Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "yes, I can do that change.",
              "createdAt": "2023-04-20T16:22:47Z",
              "updatedAt": "2023-04-20T16:22:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5THF90",
          "commit": {
            "abbreviatedOid": "6691e44"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-20T16:26:13Z",
          "updatedAt": "2023-04-20T16:26:13Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "@suhasHere OBJECT and GROUP may not make sense for PUBLISH_REQUEST, but these params provide a nice extension point for additional params that may be needed in the future.  The tradeoff is that params that only make sense for SUBSCRIBE or PUBLISH will need to state that explicitly.\r\n\r\nAlso, are there cases where publish need not be authorized at the track level, in which case this might be omitted?",
              "createdAt": "2023-04-20T16:26:13Z",
              "updatedAt": "2023-04-20T16:26:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5THPpO",
          "commit": {
            "abbreviatedOid": "6691e44"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-20T16:50:34Z",
          "updatedAt": "2023-04-20T16:50:34Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "\r\n\r\n\r\n\r\n\r\n\r\n\r\nWill be needed for native QUIC usages and inter-relay use-cases where there might not be 1:1 mapping between all the WT session or QUIC connections.\r\n\r\n\r\nIts also needed in all the cases where session level \r\nauthentication doesn't cover the authz for the tracks and Relays need a way to know if a publisher is fine to use a given track.\r\n\r\nAgain, this is used as driven by the application requirements",
              "createdAt": "2023-04-20T16:50:34Z",
              "updatedAt": "2023-04-20T16:50:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5THQ1U",
          "commit": {
            "abbreviatedOid": "6691e44"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-20T16:53:53Z",
          "updatedAt": "2023-04-20T16:53:54Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "@suhasHere : agree there are many cases where it's required -- only pointing out that because there are some that are not, we might not want to make it a mandatory field.  Any application that requires auth and detects the auth info is missing can return an error.",
              "createdAt": "2023-04-20T16:53:53Z",
              "updatedAt": "2023-04-20T16:53:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TNVjj",
          "commit": {
            "abbreviatedOid": "7ab7ce0"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks for the updates.",
          "createdAt": "2023-04-21T15:42:24Z",
          "updatedAt": "2023-04-21T15:42:46Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "editorial: If OBJECT_SEQUENCE and GROUP_SEQUENCE are not valid in publish, I recommend making that clear in the param definitions in the Track Request Parameters {#track-req-params} section, then you can just reference that section here.  Alternately, subscribe can identify the parameters that are valid above.",
              "createdAt": "2023-04-21T15:42:24Z",
              "updatedAt": "2023-04-21T15:42:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TNf4F",
          "commit": {
            "abbreviatedOid": "7ab7ce0"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-21T16:11:32Z",
          "updatedAt": "2023-04-21T16:11:32Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "OBJECT_SEQUENCE and GROUP_SEQUENCE is  still valid. At this point in time, there is a clear use for Authz Info and thus the text reflected it. It may be good to deal on how group/object sequences can be used for publish in its own PR and thus keeping this PR focussed for the time being ?\r\n\r\n\r\nI do see as we add more parameters, we will have some that are specific to one request vs the others.\r\n\r\n",
              "createdAt": "2023-04-21T16:11:32Z",
              "updatedAt": "2023-04-21T16:11:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TQOD8",
          "commit": {
            "abbreviatedOid": "3004060"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I think this looks like a fine starting point to #143 and we should merge it ",
          "createdAt": "2023-04-22T17:04:37Z",
          "updatedAt": "2023-04-22T17:04:37Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5UWBKJ",
          "commit": {
            "abbreviatedOid": "f0e2f4f"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Individual/Editorial Review",
          "createdAt": "2023-05-05T15:59:53Z",
          "updatedAt": "2023-05-05T16:01:22Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "successful appears twice.  Maybe: \r\n\r\nAn `ANNOUNCE OK` control message indicates the authorization was successful. ",
              "createdAt": "2023-05-05T15:59:53Z",
              "updatedAt": "2023-05-05T16:01:22Z"
            },
            {
              "originalPosition": 135,
              "body": "Maybe Subscribe/Announce error codes.  Unsure if they ought to share a space or be separate, but can punt for now.",
              "createdAt": "2023-05-05T16:01:01Z",
              "updatedAt": "2023-05-05T16:01:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5UWJxr",
          "commit": {
            "abbreviatedOid": "f0e2f4f"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-05T16:24:43Z",
          "updatedAt": "2023-05-05T16:24:43Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "good point Alan . I will update it",
              "createdAt": "2023-05-05T16:24:43Z",
              "updatedAt": "2023-05-05T16:24:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5UWREZ",
          "commit": {
            "abbreviatedOid": "f0e2f4f"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-05T16:46:49Z",
          "updatedAt": "2023-05-05T16:46:49Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5UXwIU",
          "commit": {
            "abbreviatedOid": "f0e2f4f"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-05T22:15:46Z",
          "updatedAt": "2023-05-05T22:24:07Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "Do we need to authorize each track individually? I can't imagine a world where you would send a different authorization token for catalog/audio/video (same goes for subscribe). Duplicating that token for each track just seems wasteful. ",
              "createdAt": "2023-05-05T22:15:46Z",
              "updatedAt": "2023-05-05T22:24:07Z"
            },
            {
              "originalPosition": 35,
              "body": "> The `ANNOUNCE` message sets up authorization for tracks that the publisher intends to publish media with.\r\n\r\nAuthentication is a secondary purpose, especially since it's optional. ANNOUNCE is primarily for discovery, and possibly routing.",
              "createdAt": "2023-05-05T22:18:52Z",
              "updatedAt": "2023-05-05T22:24:07Z"
            },
            {
              "originalPosition": 66,
              "body": "I don't think this is conferencing or even contribution specific. It's just a way of announcing what tracks are available, so a subscriber (viewer, relay, or ingest edge) could follow up with a subscription.",
              "createdAt": "2023-05-05T22:21:06Z",
              "updatedAt": "2023-05-05T22:24:07Z"
            },
            {
              "originalPosition": 94,
              "body": "Bleh, I don't like listing which tracks succeeded and which ones failed. Can we treat them as an all-or-nothing? Would a publisher even be able to recover if one or more tracks were rejected?",
              "createdAt": "2023-05-05T22:22:42Z",
              "updatedAt": "2023-05-05T22:24:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Ud6cR",
          "commit": {
            "abbreviatedOid": "f0e2f4f"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-08T16:34:21Z",
          "updatedAt": "2023-05-08T16:34:22Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "One of the outcomes at IETF 116 was to define MoQ as delivering tracks, thus authz is tied around tracks.\r\n\r\nI think we should make tge Authorization Info as mandatory parameter. However if a given AuthZ info applies to one track or array of tracks can be restructured in our message design \r\n\r\nwould something like this work \r\nANNOUNCE {\r\n  <Array of track full names>,\r\n  AuthzInfo\r\n}\r\n\r\n```\r\n",
              "createdAt": "2023-05-08T16:34:21Z",
              "updatedAt": "2023-05-08T16:34:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Ud-In",
          "commit": {
            "abbreviatedOid": "f0e2f4f"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-08T16:45:34Z",
          "updatedAt": "2023-05-08T16:45:35Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "> One of the outcomes at IETF 116 was to define MoQ as delivering tracks, thus authz is tied around tracks.\r\n> \r\n> I think we should make tge Authorization Info as mandatory parameter. However if a given AuthZ info applies to one track or array of tracks can be restructured in our message design\r\n> \r\n> would something like this work ANNOUNCE { , AuthzInfo }\r\n\r\nWe agreed to add an optional auth field. The application can choose:\r\n1. authenticate when establishing the connection (CONNECT URL)\r\n2. authenticate on each subscription (SUBSCRIBE field)\r\n3. or both",
              "createdAt": "2023-05-08T16:45:34Z",
              "updatedAt": "2023-05-08T16:45:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5UeV2v",
          "commit": {
            "abbreviatedOid": "f0e2f4f"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-08T17:51:26Z",
          "updatedAt": "2023-05-08T17:51:26Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Authorization is also primary purpose to ensure only authorized publishers can send media to the relay. I will update the text as\r\n\r\n\"The ANNOUNCE message provides for the relays to discover tracks being published, enable appropriate routing for serving subscriptions and set up authorization for tracks that the publisher intends to publish media with\"\r\n\r\ndoes this work ?",
              "createdAt": "2023-05-08T17:51:26Z",
              "updatedAt": "2023-05-08T17:51:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5UeXNo",
          "commit": {
            "abbreviatedOid": "f0e2f4f"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-08T17:53:51Z",
          "updatedAt": "2023-05-08T17:53:52Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "The current text talks about both conferences and streaming scenarios.\r\n\r\nhow about following rewording\r\n\r\n\"`ANNOUNCE` message enables flows where publisher advertises the tracks to its peer and the peer lacks sufficient informatio  to issue subscriptions. \"",
              "createdAt": "2023-05-08T17:53:51Z",
              "updatedAt": "2023-05-08T17:55:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5UeXc8",
          "commit": {
            "abbreviatedOid": "f0e2f4f"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-08T17:54:28Z",
          "updatedAt": "2023-05-08T17:54:29Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "> Would a publisher even be able to recover if one or more tracks were rejected?\r\n\r\nIt depends on the application and at the transport layer we are just providing building blocks. ",
              "createdAt": "2023-05-08T17:54:28Z",
              "updatedAt": "2023-05-08T23:03:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Ug4Y2",
          "commit": {
            "abbreviatedOid": "7fd4a8d"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-09T05:38:18Z",
          "updatedAt": "2023-05-09T05:38:19Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "If we allow individual tracks to succeed or fail, is there any particular reason to put multiple tracks into a single ANNOUNCE message?",
              "createdAt": "2023-05-09T05:38:18Z",
              "updatedAt": "2023-05-09T05:38:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Uj7Iv",
          "commit": {
            "abbreviatedOid": "7fd4a8d"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-09T13:56:56Z",
          "updatedAt": "2023-05-09T13:56:56Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "I understand the concern. How about something like this \n\nAnnounce Request {\n  [array of track names]\n   Auth Info\n}\n\nAnnounce Reply {\n  Response \n}\n\n\n",
              "createdAt": "2023-05-09T13:56:56Z",
              "updatedAt": "2023-05-09T13:57:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5UlLLJ",
          "commit": {
            "abbreviatedOid": "7fd4a8d"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Individual review",
          "createdAt": "2023-05-09T16:29:41Z",
          "updatedAt": "2023-05-09T16:35:11Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "successful still appears twice in this sentence.",
              "createdAt": "2023-05-09T16:29:41Z",
              "updatedAt": "2023-05-09T16:35:11Z"
            },
            {
              "originalPosition": 41,
              "body": "I'm wondering if we want a params struct here also to convey meta-data about the group-of-tracks being annouced.",
              "createdAt": "2023-05-09T16:31:48Z",
              "updatedAt": "2023-05-09T16:35:11Z"
            },
            {
              "originalPosition": 94,
              "body": "I prefer Announce / Announce Reply, where Reply has the success/failure of each track in the Announce. ",
              "createdAt": "2023-05-09T16:34:34Z",
              "updatedAt": "2023-05-09T16:35:11Z"
            },
            {
              "originalPosition": 135,
              "body": "Add Announce error codes to this list somewhere?",
              "createdAt": "2023-05-09T16:35:05Z",
              "updatedAt": "2023-05-09T16:35:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5UlYa_",
          "commit": {
            "abbreviatedOid": "f0e2f4f"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-09T17:00:42Z",
          "updatedAt": "2023-05-09T17:00:42Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "I am worried about the cardinality across the distribution system of announcing each individual track. Given that the stated purpose of announce is to identify the source of the tracks, then we need to announce only the minimum information necessary to meet that goal and enable system-wide routing. \r\n\r\nConsider an individual publisher wanting to publish (i.e be the authoritative source for) 4 tracks, with the following full track names\r\n\r\nwebex.com/customerABC/4k5jh64k5jh6/video\r\nwebex.com/customerABC/4k5jh64k5jh6/audio\r\nwebex.com/customerABC/4k5jh64k5jh6/desktop\r\nwebex.com/customerABC/4k5jh64k5jh6/chat\r\n\r\nThe ANNOUNCE message could then be for the smallest common prefix \r\n\r\nANNOUNCE { webex.com/customerABC/4k5jh64k5jh6/ }\r\n\r\nThe relay network can then build a routing table that directs any incoming subscription request matching that prefix to the announced connection. Bloom filters can also be used to quickly tell if the content is available within the network. ",
              "createdAt": "2023-05-09T17:00:42Z",
              "updatedAt": "2023-05-09T17:00:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5UtX1x",
          "commit": {
            "abbreviatedOid": "f0e2f4f"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-10T18:27:36Z",
          "updatedAt": "2023-05-10T18:27:36Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "@wilaw  that would work and would require defining further about track naming in the draft.\r\n\r\nIF we have full track name defined as \r\n```\r\nFull Track Name = Track Namespace + \"/\" + Emitter Id + \"/\" + Track Name\r\n```\r\nwhere emitter id is as per https://datatracker.ietf.org/doc/html/draft-nandakumar-moq-arch-00#section-2.1.1\r\n\r\n, then we can define announce as\r\n```\r\nAnnouce {\r\n   Track Reference,\r\n   Params\r\n}\r\n```\r\n\r\nwhere Track Reference is\r\n```\r\nTrack Reference = Track Namespace + \"/\" + Emitter Id\r\nor \r\nTrack Reference = Full Track Name\r\n```\r\n\r\nDoes this work ?",
              "createdAt": "2023-05-10T18:27:36Z",
              "updatedAt": "2023-05-12T04:33:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5UtbvO",
          "commit": {
            "abbreviatedOid": "f0e2f4f"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-10T18:39:55Z",
          "updatedAt": "2023-05-10T18:39:56Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "Created #154 to discuss this further",
              "createdAt": "2023-05-10T18:39:56Z",
              "updatedAt": "2023-05-10T18:39:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5UtjbT",
          "commit": {
            "abbreviatedOid": "f0e2f4f"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-10T19:04:19Z",
          "updatedAt": "2023-05-10T19:04:20Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "> Does this work ?\r\n\r\nLGTM. We should DISCUSS the details and consequences, but I think it provides an efficient mechanism for publisher registration and discovery in highly distributed networks and is worth exploring further under #154.",
              "createdAt": "2023-05-10T19:04:19Z",
              "updatedAt": "2023-05-10T19:04:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5U1CdE",
          "commit": {
            "abbreviatedOid": "f9374b4"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I put thumbs up on several comments I agree with. This definitely looks close enough to merge to me and we can refine some of the details after that. ",
          "createdAt": "2023-05-11T18:22:38Z",
          "updatedAt": "2023-05-11T18:22:38Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5U1V1m",
          "commit": {
            "abbreviatedOid": "f9374b4"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-11T19:10:52Z",
          "updatedAt": "2023-05-11T20:46:45Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "I don't think we should be listing parameters here, since we will eventually add more for both ANNOUNCE and SUBSCRIBE, and the list will be incomplete.  Instead I would propose to mention where the parameters are supposed to appear whenever we define a parameter.",
              "createdAt": "2023-05-11T19:10:52Z",
              "updatedAt": "2023-05-11T20:46:45Z"
            },
            {
              "originalPosition": 94,
              "body": "Thinking more about this, I think a sender should be able to announce a bunch of tracks atomically (meaning all get accepted or rejected).\r\n\r\nTwo reasons for this:\r\n\r\n1. If a client announces three tracks, let's say a catalog, an audio, and a video, and the server accepts the catalog, but denies an audio or a video track, this leaves the system in a state where there is a catalog for a bunch of unavailable tracks.\r\n2. If the client announces a catalog before video or audio, there is a race condition in which someone could subscribe to the catalog and subscribe to the video before the server processes the ANNOUNCE for the video.\r\n\r\nYou can get around number 2 (and partially number 1, if you're willing to wait an extra RTT) by announcing the video track before the catalog, but this feels like a thing that's really easy to get wrong.\r\n\r\nBoth announcing multiple tracks, and announcing a prefix, should be fine, but we should probably pick one.",
              "createdAt": "2023-05-11T20:46:43Z",
              "updatedAt": "2023-05-11T20:46:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5U3N48",
          "commit": {
            "abbreviatedOid": "f0e2f4f"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-12T04:38:08Z",
          "updatedAt": "2023-05-12T04:38:09Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "@vasilvv agree with the thinking there.  I want to be able to support use-cases like\r\n  - applications where catalog is not needed, say, security cameras broadcasting a static hardcoded set of track qualities\r\n  - applications where catalog is exchanged out of band\r\n\r\nCatalog as a track is a good option to have in the transport, but I don't think we can mandate at the transport level as there may not be catalog tracks for all classes of applications.\r\n\r\nHaving said that, I am also open to allowing announce with multiple tracks  as a scoped set which is either completely accepted or rejected. I would prefer prefix approach better though especially when the track cardinality is huge. This is common for realtime media applications \r\n\r\nI think  #154  address both classes of applications. Also the same idea can be extended for Subscriptions too.\r\n\r\nwondering if we it is worthwhile to consider it as starting point for discussions/adoption\r\n\r\n\r\n",
              "createdAt": "2023-05-12T04:38:08Z",
              "updatedAt": "2023-05-12T04:42:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5U3PA4",
          "commit": {
            "abbreviatedOid": "f9374b4"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-12T04:45:57Z",
          "updatedAt": "2023-05-12T04:45:58Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "@vasilvv good point, will update in the next set of commits",
              "createdAt": "2023-05-12T04:45:58Z",
              "updatedAt": "2023-05-12T04:45:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5U7Fno",
          "commit": {
            "abbreviatedOid": "f9374b4"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-12T15:55:21Z",
          "updatedAt": "2023-05-12T15:55:21Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "We may need to clarify:\r\n\r\nIs either ANNOUNCE or transmitting a catalog in band mandatory in all media formats?  If a publisher and receiver have out-of-band mechanisms for exchanging track names, can a receiver do a \"blind\" SUBSCRIBE?",
              "createdAt": "2023-05-12T15:55:21Z",
              "updatedAt": "2023-05-12T15:55:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5U7IwU",
          "commit": {
            "abbreviatedOid": "f0e2f4f"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-12T16:04:00Z",
          "updatedAt": "2023-05-12T16:04:00Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "IMO the catalog should be mandatory, for interop. Clients should always be able to depend upon it. We may want to use it to signal EOS and/or advertising etc. However, if a receiver has out of band info, they are welcome to do an \"accelerated\" subscription before they receive the catalog. The two are not exclusive and can co-exist. ",
              "createdAt": "2023-05-12T16:04:00Z",
              "updatedAt": "2023-05-12T16:04:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5U7QT4",
          "commit": {
            "abbreviatedOid": "f9374b4"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-12T16:21:46Z",
          "updatedAt": "2023-05-12T16:21:46Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "Having a assigned catalog track needs to be specified but that it always needs to be populated cannot be done at this level. \n\nI agree WMF can mandate it further as well",
              "createdAt": "2023-05-12T16:21:46Z",
              "updatedAt": "2023-05-12T16:21:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5U7Qkx",
          "commit": {
            "abbreviatedOid": "f9374b4"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-12T16:22:35Z",
          "updatedAt": "2023-05-12T16:22:35Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "Also agree that both can coexist. Since at the base transport we can't say one way or the other",
              "createdAt": "2023-05-12T16:22:35Z",
              "updatedAt": "2023-05-12T16:22:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5U7TJe",
          "commit": {
            "abbreviatedOid": "f9374b4"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-12T16:30:35Z",
          "updatedAt": "2023-05-12T17:52:09Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Can you add a note that this message is optional? It may be used for any of the stated reasons, but I would personally not recommend it for any of them actually.",
              "createdAt": "2023-05-12T16:30:35Z",
              "updatedAt": "2023-05-12T17:52:09Z"
            },
            {
              "originalPosition": 74,
              "body": "> CDN's of today have a mechanism for handling ingest from multiple publishers.\r\n\r\nI think this DISCUSS misses the point. There's no standard, so every CDN handles routing and authentication separately (ex. different configuration, different URL schemes). The discuss should be: do we create a standard, or do we leave it up to CDNs?",
              "createdAt": "2023-05-12T16:41:00Z",
              "updatedAt": "2023-05-12T17:52:09Z"
            },
            {
              "originalPosition": 94,
              "body": "ANNOUNCE should be optional and used solely for discovery. If an application handles negotiates track names and any authentication out-of-band, it should be able to SUBSCRIBE immediately.\r\n\r\nIn that case, why couldn't you just announce the catalog track? The catalog itself contains the names of the other tracks, and only an entity capable of parsing the catalog will be able to decide if it should SUBSCRIBE to a track.",
              "createdAt": "2023-05-12T16:48:53Z",
              "updatedAt": "2023-05-12T17:52:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5U-na8",
          "commit": {
            "abbreviatedOid": "fe0b28e"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-15T02:57:41Z",
          "updatedAt": "2023-05-15T03:16:15Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Is there any reason that this one has a `/` at the end of the track namespace, but the two examples above don't?",
              "createdAt": "2023-05-15T02:57:41Z",
              "updatedAt": "2023-05-15T03:16:15Z"
            },
            {
              "originalPosition": 126,
              "body": "s/subscription/announcement/",
              "createdAt": "2023-05-15T03:15:33Z",
              "updatedAt": "2023-05-15T03:16:15Z"
            },
            {
              "originalPosition": 129,
              "body": "s/subscription/announcement/",
              "createdAt": "2023-05-15T03:15:47Z",
              "updatedAt": "2023-05-15T03:16:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5U-t5P",
          "commit": {
            "abbreviatedOid": "fe0b28e"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-15T03:45:04Z",
          "updatedAt": "2023-05-15T03:45:05Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "that was my typo. I will fix it .",
              "createdAt": "2023-05-15T03:45:04Z",
              "updatedAt": "2023-05-15T03:45:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5VE7q8",
          "commit": {
            "abbreviatedOid": "fce5ed6"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Individual/editorial review",
          "createdAt": "2023-05-15T20:56:03Z",
          "updatedAt": "2023-05-15T21:03:38Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "> The receiver can then SUBSCRIBE to the advertised tracks.\r\n\r\nCan a receiver issue a SUBSCRIBE for a namespace, or does it have to be a fully-qualified track.  If it's the latter then maybe this sentence needs rewording?",
              "createdAt": "2023-05-15T20:56:03Z",
              "updatedAt": "2023-05-15T21:03:38Z"
            },
            {
              "originalPosition": 85,
              "body": "> serving subscriptions for tracks whose track full name shares common prefix with the announced namepace\r\n\r\nI'm concerned about the `common prefix` bit, since longest prefix match algorithms might be problematic: can one publisher announce `example.org/steven' and another announce 'example.org/steve'?  Also there's a typo in namespace.\r\n\r\nCan you change it to something like:\r\n\r\n> serving subscriptions for tracks whose track full name matches the announced namespace\r\n\r\nWe can refine what it means to match in a later PR if needed, or possibly delegate to implementations?",
              "createdAt": "2023-05-15T21:01:33Z",
              "updatedAt": "2023-05-15T21:03:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5VFoQQ",
          "commit": {
            "abbreviatedOid": "fce5ed6"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-16T00:46:25Z",
          "updatedAt": "2023-05-16T00:46:26Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "It is indeed a prefix , since track namespace is only first part of the full track name.  For the typo scenario above, the authz will fail for the announce. ",
              "createdAt": "2023-05-16T00:46:25Z",
              "updatedAt": "2023-05-16T00:46:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5VGFob",
          "commit": {
            "abbreviatedOid": "fce5ed6"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-16T03:37:13Z",
          "updatedAt": "2023-05-16T03:37:13Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "@suhasHere : Sorry I think I confused things.  \r\n\r\n1) Your PR just misspelled the word \"namespace\" as \"namepace\". \r\n\r\n2) I meant to show that example.org/steve and example.org/steven are both valid and authorized namespaces in my application.\r\n\r\nAs I mentioned in the other PR, how about: \r\n\r\n> serving subscriptions for tracks whose Track Namespace matches the announced namespace\r\n\r\nDoes that work for you?",
              "createdAt": "2023-05-16T03:37:13Z",
              "updatedAt": "2023-05-16T03:37:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5VLdL6",
          "commit": {
            "abbreviatedOid": "fce5ed6"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Let's merge this.\r\n\r\nI do want to add my piece that ANNOUNCE is half-baked. It's not useful when track identification and authentication is pre-negotiated, and it's not comprehensive enough otherwise. We need to have more discussions as a working group.",
          "createdAt": "2023-05-16T17:26:28Z",
          "updatedAt": "2023-05-16T17:36:38Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "Not relay specific, and should probably go into a separate section anyway.",
              "createdAt": "2023-05-16T17:26:28Z",
              "updatedAt": "2023-05-16T17:36:38Z"
            },
            {
              "originalPosition": 134,
              "body": "Editorial: We should remove this section. It's confusing to lump ANNOUNCE and SUBSCRIBE parameters and then add a sentence at the end of each paragraph indicating the parameter only applies to one of them.\r\n\r\nI would be verbose with how messages are defined even if it involves some copy-pasting. We can consolidate when the parameters are more stable.",
              "createdAt": "2023-05-16T17:32:21Z",
              "updatedAt": "2023-05-16T17:36:38Z"
            }
          ]
        }
      ]
    },
    {
      "number": 124,
      "id": "PR_kwDOG2Ho4M5Nrfur",
      "title": "IETF116: Relay behavior Support",
      "url": "https://github.com/moq-wg/moq-transport/pull/124",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR depends on #121 , #122 and #123  and adds starter text to describe protocol behavior for dealing with publishes and subscribes.\r\n\r\nFuture PR will add details on congestion response in general and for relays in particular.",
      "createdAt": "2023-04-05T13:58:19Z",
      "updatedAt": "2023-04-06T17:34:56Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "116-publish",
      "baseRefOid": "25dbbc9e0030c93570155c3103a2753ef6fbda9c",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "116-relay",
      "headRefOid": "2009b3507dd6c8a3ec3d3c21b8796c0e5a7fb5d6",
      "closedAt": "2023-04-06T17:34:56Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this PR and splitting it in multiple small PRs to keep change on thing at a time",
          "createdAt": "2023-04-06T17:34:56Z",
          "updatedAt": "2023-04-06T17:34:56Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 125,
      "id": "PR_kwDOG2Ho4M5NyW-W",
      "title": "IETF116 - Relay behavior Section Template",
      "url": "https://github.com/moq-wg/moq-transport/pull/125",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR introduces Relays section but leaves most of the subsections under it as TODo. The idea is keep the PR sizes small and focus on one change at a time.\r\n\r\nIf we can agree on the general shape of the relay section,  I will work on individual PRs for each of the TODOs\r\n",
      "createdAt": "2023-04-06T17:08:49Z",
      "updatedAt": "2023-04-13T15:46:38Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "c286f2f86af090f9d291c5c2d7d86af44bb462b7",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "116-relay-tmpl",
      "headRefOid": "87a7db42ad9477d3b6f6e3ae548a6b614578c974",
      "closedAt": "2023-04-13T15:46:38Z",
      "mergedAt": "2023-04-13T15:46:38Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "1c67df978089f0413c6b51889254e45454a1fec7"
      },
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes that's yen idea.",
          "createdAt": "2023-04-07T18:50:12Z",
          "updatedAt": "2023-04-07T18:50:12Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@vasilvv Can we merge this structural PR .. since this was the parent PR on #129 which was recently approved",
          "createdAt": "2023-04-10T16:51:49Z",
          "updatedAt": "2023-04-10T16:51:49Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@vasilvv  please let me know so that I can update the PR or reword to address the feedback responses",
          "createdAt": "2023-04-12T20:35:48Z",
          "updatedAt": "2023-04-12T20:35:48Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "> @vasilvv please let me know so that I can update the PR or reword to address the feedback responses\r\n\r\nIf you remove the bullet points from the intro, and rebase the PR, this should be good to go.",
          "createdAt": "2023-04-13T00:39:37Z",
          "updatedAt": "2023-04-13T00:39:37Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@vasilvv I updated the PR to reflect your feedback. does it look about right ?",
          "createdAt": "2023-04-13T15:40:12Z",
          "updatedAt": "2023-04-13T15:40:12Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5SCcNx",
          "commit": {
            "abbreviatedOid": "b56ffe7"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "This is more or less empty template to add later PR to ?",
          "createdAt": "2023-04-07T16:29:25Z",
          "updatedAt": "2023-04-07T16:29:25Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5SVver",
          "commit": {
            "abbreviatedOid": "ac488c2"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-12T14:17:31Z",
          "updatedAt": "2023-04-12T14:44:35Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "I assume this (and most of the changes from the above) are from the other PR?",
              "createdAt": "2023-04-12T14:17:31Z",
              "updatedAt": "2023-04-12T14:44:35Z"
            },
            {
              "originalPosition": 70,
              "body": "I think this paragraph should be more clear on what relays do, namely that they (1) forward objects, (2) cache objects, (3) don't know what's inside objects.",
              "createdAt": "2023-04-12T14:40:35Z",
              "updatedAt": "2023-04-12T14:44:35Z"
            },
            {
              "originalPosition": 80,
              "body": "So, I'm trying to understand the purpose of this paragraph. Is the goal here to set design requirements for the protocol?  If yes, those requirements are not entirely clear.  If no, I'm not sure we need this much text, since it does not affect the implementations directly.",
              "createdAt": "2023-04-12T14:44:26Z",
              "updatedAt": "2023-04-12T14:44:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SYM87",
          "commit": {
            "abbreviatedOid": "ac488c2"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-12T20:33:57Z",
          "updatedAt": "2023-04-12T20:33:58Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "yes",
              "createdAt": "2023-04-12T20:33:57Z",
              "updatedAt": "2023-04-12T20:33:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SYNIb",
          "commit": {
            "abbreviatedOid": "ac488c2"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-12T20:34:34Z",
          "updatedAt": "2023-04-12T20:34:35Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "@vasilvv yes the individdual TODO sections cover the specifcs .. this is intro section",
              "createdAt": "2023-04-12T20:34:34Z",
              "updatedAt": "2023-04-12T20:34:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SYNWo",
          "commit": {
            "abbreviatedOid": "ac488c2"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-12T20:35:15Z",
          "updatedAt": "2023-04-12T20:35:15Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "I understand the concern. This was just part of introduction section. I can remove if this is not useful",
              "createdAt": "2023-04-12T20:35:15Z",
              "updatedAt": "2023-04-12T20:35:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SZMbS",
          "commit": {
            "abbreviatedOid": "ac488c2"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-13T00:38:21Z",
          "updatedAt": "2023-04-13T00:38:22Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "Let's remove this for now then.",
              "createdAt": "2023-04-13T00:38:21Z",
              "updatedAt": "2023-04-13T00:38:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Sefua",
          "commit": {
            "abbreviatedOid": "87a7db4"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-13T15:44:47Z",
          "updatedAt": "2023-04-13T15:44:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 126,
      "id": "PR_kwDOG2Ho4M5NyaVw",
      "title": "IETF116: Fill in Relay Subscribe Interaction Sub-Section",
      "url": "https://github.com/moq-wg/moq-transport/pull/126",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR depends on #122 and #125 \r\n\r\nThe scope of this PR is to add Relay Subscribe interactions. This is expected to be a starter text and we can add further clarification and details in a separate PR as we develop further.",
      "createdAt": "2023-04-06T17:21:25Z",
      "updatedAt": "2023-05-16T20:31:03Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "14d81ba41e837e375d2e2455bfaf9801393ae41f",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "116-relay-subscribes",
      "headRefOid": "b2ceef6fdb193348cce78055861861052e805ee3",
      "closedAt": "2023-05-16T20:31:02Z",
      "mergedAt": "2023-05-16T20:31:02Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "41c947f3e3ead6856491d00d42c50c7e1c112203"
      },
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@vasilvv @kixelated @afrind @fluffy could you please review the latest updates. Thanks",
          "createdAt": "2023-05-10T01:00:55Z",
          "updatedAt": "2023-05-10T01:00:55Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@kixelated @vasilvv thoughts on the current text ?",
          "createdAt": "2023-05-16T18:01:29Z",
          "updatedAt": "2023-05-16T18:01:29Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5SCcg0",
          "commit": {
            "abbreviatedOid": "efaf37c"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-07T16:30:53Z",
          "updatedAt": "2023-04-07T16:31:56Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Think we might want to add a bit more detail here",
              "createdAt": "2023-04-07T16:30:53Z",
              "updatedAt": "2023-04-07T16:31:56Z"
            },
            {
              "originalPosition": 16,
              "body": "Should we discuss when the subscribe goes away ? or how state is cleaned up if connection closes ?",
              "createdAt": "2023-04-07T16:31:45Z",
              "updatedAt": "2023-04-07T16:31:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5UWDpu",
          "commit": {
            "abbreviatedOid": "035ae92"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Is it possible to rebase this PR on main so that it's only showing the deltas from main?  It's currently showing all the deltas in main that are unrelated and it makes it difficult to see what the proposed change is here.",
          "createdAt": "2023-05-05T16:06:58Z",
          "updatedAt": "2023-05-05T16:06:58Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5UWE5T",
          "commit": {
            "abbreviatedOid": "035ae92"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Individual review",
          "createdAt": "2023-05-05T16:10:35Z",
          "updatedAt": "2023-05-05T16:14:11Z",
          "comments": [
            {
              "originalPosition": 382,
              "body": "> forward all the future publishes\r\n\r\nfuture OBJECTs related to the subscription?",
              "createdAt": "2023-05-05T16:10:35Z",
              "updatedAt": "2023-05-05T16:14:11Z"
            },
            {
              "originalPosition": 382,
              "body": "> the end-point client making the subscribe request is notified of the result of the subscription\r\n\r\n> Relay proceeds to save the subscription information by maintaining mapping from the track information to the list of subscribers\r\n\r\n> A given susbcription ceases to exist because its expired or the publisher of the track stops producing media.\r\n\r\nThese bits seems the same for all publishers, not just relays, right? I think the group agreed to focus the relay section on behaviors that are specific/different for relays.",
              "createdAt": "2023-05-05T16:11:36Z",
              "updatedAt": "2023-05-05T16:14:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5UWFky",
          "commit": {
            "abbreviatedOid": "035ae92"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-05-05T16:12:01Z",
          "updatedAt": "2023-05-05T16:21:04Z",
          "comments": [
            {
              "originalPosition": 263,
              "body": "We will need to define the moq URL somewhere for this to all make sense but depending on what we mean by userinfo, not sure it can not be empty. May need some slight tweaking of words here. For now i might sugest just remove mention of userinfo ",
              "createdAt": "2023-05-05T16:12:01Z",
              "updatedAt": "2023-05-05T16:21:04Z"
            },
            {
              "originalPosition": 270,
              "body": "I would rather not have how we find the relays in this PR and instead just make a sperate section of the draft about a client decides what to connect to ",
              "createdAt": "2023-05-05T16:13:47Z",
              "updatedAt": "2023-05-05T16:21:04Z"
            },
            {
              "originalPosition": 272,
              "body": "where is the path paramter ? Is that in the SUB message ? If thinking the connect message then seems like it should not be here. ",
              "createdAt": "2023-05-05T16:15:21Z",
              "updatedAt": "2023-05-05T16:21:05Z"
            },
            {
              "originalPosition": 273,
              "body": "again, this seems like it should be the stuff stuff where the client forms a connection to the server ( regadless of it the server is a relay or not ) and not in this PR ",
              "createdAt": "2023-05-05T16:15:55Z",
              "updatedAt": "2023-05-05T16:21:05Z"
            },
            {
              "originalPosition": 319,
              "body": "I think thisw should just say do it the same way as client as specified in that section. Also not clear this should be in sub PR ",
              "createdAt": "2023-05-05T16:17:09Z",
              "updatedAt": "2023-05-05T16:21:05Z"
            },
            {
              "originalPosition": 580,
              "body": "I'd rather just seem this be the same regardless of what the transport is. ",
              "createdAt": "2023-05-05T16:20:20Z",
              "updatedAt": "2023-05-05T16:21:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5UWLmm",
          "commit": {
            "abbreviatedOid": "035ae92"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Sorry - prev review had included stuff from PR not rebased to latest. ",
          "createdAt": "2023-05-05T16:30:32Z",
          "updatedAt": "2023-05-05T16:30:32Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5UXXwz",
          "commit": {
            "abbreviatedOid": "035ae92"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "DISMISSED",
          "body": "1. I'd like to see some text on how subscriptions are coalesced/cached, since it is actually specific to relays.\r\n2. Authentication is currently out of scope, so some of the MUSTs surrounding authentication don't make any sense.\r\n3. Most of this applies to generic endpoints. You could say `subscriptions MAY require authorization` and leave it at that.",
          "createdAt": "2023-05-05T20:20:22Z",
          "updatedAt": "2023-05-16T18:00:47Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "> Relays MUST be willing to act on behalf of the subscriptions before they can forward the media, which implies that the subscriptions MUST be authorized and it is done as follows:\r\n\r\nThe MUST's here are confusing and incorrect.\r\n\r\nA relay will receive a SUBSCRIBE and forward it upstream. If it performs authentication at each hop is optional. In fact the relay could forward any authentication token to the upstream, rather than validating it.\r\n\r\nThe one time a relay MUST terminate authentication is if it plans to coalesce subscriptions. This occurs when N downstream subscriptions turn into 1 upstream subscription. \r\n\r\nThough authentication is out of scope though so there's not much to really say. ",
              "createdAt": "2023-05-05T20:20:22Z",
              "updatedAt": "2023-05-05T22:11:33Z"
            },
            {
              "originalPosition": 8,
              "body": "> Subscriptions MUST carry enough authorization information proving the subscriber has access to the requested track.\r\n\r\nThe session itself may be authorized, or the track may not require authentication. An auth token in a SUBSCRIBE is optional.",
              "createdAt": "2023-05-05T20:21:02Z",
              "updatedAt": "2023-05-05T20:34:04Z"
            },
            {
              "originalPosition": 10,
              "body": "This is true for generic endpoints.",
              "createdAt": "2023-05-05T20:21:42Z",
              "updatedAt": "2023-05-05T20:34:04Z"
            },
            {
              "originalPosition": 8,
              "body": "And this entire paragraph applies to generic endpoints, not a relay specifically.",
              "createdAt": "2023-05-05T20:23:24Z",
              "updatedAt": "2023-05-05T20:34:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5UXvVF",
          "commit": {
            "abbreviatedOid": "035ae92"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-05T22:13:40Z",
          "updatedAt": "2023-05-05T22:13:40Z",
          "comments": [
            {
              "originalPosition": 382,
              "body": "Yeah, I think this text is still useful, but it should explain how the pub/sub messages work in general (not specific to relays).",
              "createdAt": "2023-05-05T22:13:40Z",
              "updatedAt": "2023-05-05T22:13:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5UeZCw",
          "commit": {
            "abbreviatedOid": "035ae92"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-08T17:59:00Z",
          "updatedAt": "2023-05-08T17:59:00Z",
          "comments": [
            {
              "originalPosition": 382,
              "body": "As agreed on the authors call, I went ahead and created a new issue to refactor generic protocol flow - https://github.com/kixelated/warp-draft/issues/153\r\n\r\nFor this PR, we agreed to merge it if the text looks alright . I will try to incorporate the comments on text content and leave all refactor to #153  which can be done as part of new PR addressing #153 ",
              "createdAt": "2023-05-08T17:59:00Z",
              "updatedAt": "2023-05-08T17:59:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5U7ZRI",
          "commit": {
            "abbreviatedOid": "c7cc956"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-12T16:50:35Z",
          "updatedAt": "2023-05-12T17:03:55Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Can you remove the mention of `Origin`? Just say authentication is up to the application.",
              "createdAt": "2023-05-12T16:50:36Z",
              "updatedAt": "2023-05-12T17:03:55Z"
            },
            {
              "originalPosition": 10,
              "body": "> end-point client\r\n\r\nCan you replace that with `endpoint`? Both the client and server are allowed to subscribe.",
              "createdAt": "2023-05-12T16:51:13Z",
              "updatedAt": "2023-05-12T17:03:55Z"
            },
            {
              "originalPosition": 12,
              "body": "> For successful subscriptions, relays proceed to save the subscription information by maintaining mapping from the track information to the list of subscriber.\r\n\r\nI don't understand this sentence.\r\n\r\nHere's what I would say: A relay will have a list of frontend subscriptions (aka downstream) and a list of backend subscriptions (aka upstream). The relay maintains a map from each frontend subscription to a backend subscription, which it uses to forward received OBJECT messages from the backend. \r\n\r\n> This will enable relays to forward on-going publishes (live or from cache) to the subscribers, if available, and also forward all the future publishes, until the subscriptions cases to exist\r\n\r\nI don't understand the difference between \"on-going publishes\" and \"future publishes\", or what a \"publish\" is in the first place.\r\n\r\n> A given susbcription ceases to exist because its expired or the publisher of the track stops producing media.\r\n\r\nTypo. And there could be any number of reasons why a subscription ends, as signaled in the SUBSCRIBE ERROR message. A relay SHOULD forward that error messages to consumers.\r\n\r\n> Relays MAY perform subscription aggregations, wherein only the unique subscriptions per \"Full Track Name\" are forwarded upstream for further processing.\r\n\r\nDeduplicatation gets dangerous when authentication is performed in SUBSCRIBE. I would be very careful about \"forwarding\" subscriptions, and make it clear that any authentication information either needs to identical (ex. same token) or validated and stripped in order to deduplicate subscriptions.",
              "createdAt": "2023-05-12T16:54:13Z",
              "updatedAt": "2023-05-12T17:07:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5U7dj6",
          "commit": {
            "abbreviatedOid": "c7cc956"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-12T17:03:39Z",
          "updatedAt": "2023-05-12T17:07:49Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Is this necessarily a relay-specific property?  I imagine any entity receiving a subscribe request would want to check if the sender is authorized to subscribe.",
              "createdAt": "2023-05-12T17:03:39Z",
              "updatedAt": "2023-05-12T17:07:49Z"
            },
            {
              "originalPosition": 12,
              "body": "> Relays MAY perform subscription aggregations, wherein only the unique subscriptions per \"Full Track Name\" are forwarded upstream for further processing.\r\n\r\nI am not entirely sure what this means -- could you elaborate on what \"aggregation\" means here?",
              "createdAt": "2023-05-12T17:07:44Z",
              "updatedAt": "2023-05-12T17:07:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5U9yjm",
          "commit": {
            "abbreviatedOid": "c7cc956"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-14T04:00:56Z",
          "updatedAt": "2023-05-14T04:00:56Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "> Here's what I would say: A relay will have a list of frontend subscriptions (aka downstream) and a list of backend subscriptions (aka upstream). The relay maintains a map from each frontend subscription to a backend subscription, which it uses to forward received OBJECT messages from the backend.\r\n\r\nI don't think we need to go in that detail. The current statement indicates there will be subscribers list per track requested in Subscribe Request. ",
              "createdAt": "2023-05-14T04:00:56Z",
              "updatedAt": "2023-05-14T04:00:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5U9yll",
          "commit": {
            "abbreviatedOid": "c7cc956"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-14T04:02:26Z",
          "updatedAt": "2023-05-14T04:02:26Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "> I don't understand the difference between \"on-going publishes\" and \"future publishes\", or what a \"publish\" is in the first place.\r\n\r\non-going publishes will happen when a subscriber asks for a track for which there is already media being published.\r\n\r\nfuture-publishes indicates, as long as subscription is active and sender is producing media for the track of interest, the subscribers will receive the media",
              "createdAt": "2023-05-14T04:02:26Z",
              "updatedAt": "2023-05-14T04:02:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5U-SNc",
          "commit": {
            "abbreviatedOid": "c7cc956"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-14T22:42:05Z",
          "updatedAt": "2023-05-14T22:42:05Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "yes and no. Agree that every entity should verify if the sender of subscribe is allowed to access the content. I do feel, how it is done is more nuanced at relays than endpoint client",
              "createdAt": "2023-05-14T22:42:05Z",
              "updatedAt": "2023-05-14T22:42:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5VLjXu",
          "commit": {
            "abbreviatedOid": "4a6b776"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "it's fine as a first draft",
          "createdAt": "2023-05-16T17:41:08Z",
          "updatedAt": "2023-05-16T18:08:24Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "> This is done by\r\n\r\neditorial: it's strange to have a single bullet point.",
              "createdAt": "2023-05-16T17:41:08Z",
              "updatedAt": "2023-05-16T18:08:24Z"
            },
            {
              "originalPosition": 8,
              "body": "> Relays MUST ensure subscribers are authorized for the tracks. This is done by\r\n>\r\n> Verifying that the subscriber is authorized to access the content associated with the \"Full Track Name\". The authorization information can be part of subscriptions themselves or part of the encompassing session. Specifics of where the authorization happens, either at the relays or forwarded for further processing, depends on the way the relay is managed and is application specific (typically based on prior business agreement).\r\n\r\nEditorial: this is a lot of words to say authorization is out of scope. It's okay to have recommendations, but the language here is a little strong (some MUSTs) for something undefined. Let the application figure out how to perform authentication; ex. a token in the CONNECT URL, a token in the SUBSCRIBE message, a token in the track name (!), a challenge in the ANNOUNCE and answer in the SUBSCRIBE (!), etc.\r\n\r\n> If forwarded, the authorization information from the original subscribe request MUST be identical.\r\n\r\nRemove this constraint. It's both unenforceable and rules out legitimate use-cases, like nested authorization. For example, the relay's auth token could wrap the subscriber's auth token, like an envelope, so they can both be authenticated upstream.",
              "createdAt": "2023-05-16T17:50:12Z",
              "updatedAt": "2023-05-16T18:08:24Z"
            },
            {
              "originalPosition": 12,
              "body": "> and also forward all the future publishes for the requested track\r\n\r\nI don't know what this means.",
              "createdAt": "2023-05-16T17:57:31Z",
              "updatedAt": "2023-05-16T18:08:24Z"
            },
            {
              "originalPosition": 12,
              "body": "> Subscriptions stay active until it is expired or the publisher of the track stops producing media or other reasons that result in error (see {{message-subscribe-error}}).\r\n\r\nI think the examples are fine, but a relay shouldn't care why the subscription ended. I would add a note that the relay SHOULD forward any received SUBSCRIBE ERROR message to downstream subscribers.",
              "createdAt": "2023-05-16T18:00:03Z",
              "updatedAt": "2023-05-16T18:08:24Z"
            },
            {
              "originalPosition": 14,
              "body": "> Subscriptions aggregation allows relays to forward only the unique subscriptions per track for futher processing, say to setup routing for delivering media, rather than forwarding all the subscriptions received.\r\n\r\nI don't understand. Subscription aggregation is done to share a cache.\r\n\r\n> When the authorization information is carried in the subscribes, the relay needs to verify the authorization information in the subscribe request, in order to deduplicate the subscriptions.\r\n\r\nA relay MUST authorize a subscription prior to serving it from cache.",
              "createdAt": "2023-05-16T18:04:50Z",
              "updatedAt": "2023-05-16T18:08:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5VMNCL",
          "commit": {
            "abbreviatedOid": "4a6b776"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-16T19:24:43Z",
          "updatedAt": "2023-05-16T19:24:43Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "this is already said in the previous paragraph",
              "createdAt": "2023-05-16T19:24:43Z",
              "updatedAt": "2023-05-16T19:24:43Z"
            }
          ]
        }
      ]
    },
    {
      "number": 127,
      "id": "PR_kwDOG2Ho4M5Nybw0",
      "title": "IETF116: Fill in Relay Publish Interaction Sub-Section",
      "url": "https://github.com/moq-wg/moq-transport/pull/127",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR depends on #123 and #125 \r\n\r\nThe scope of this PR is to add Relay Publish interactions. This is expected to be a starter text and we can add further clarification and details in a separate PR as we develop further.",
      "createdAt": "2023-04-06T17:26:45Z",
      "updatedAt": "2023-05-16T22:27:35Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "116-relay-subscribes",
      "baseRefOid": "b2ceef6fdb193348cce78055861861052e805ee3",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "116-relay-publish",
      "headRefOid": "196c1e400b258f8105806db93e007f0d706f2d85",
      "closedAt": "2023-05-16T22:27:35Z",
      "mergedAt": "2023-05-16T22:27:35Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "38f2730013e1d1a509a6e7c3f9a30cab421631c5"
      },
      "comments": [
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we still need to deal with the issue of who creates the TrackID but seems that can be a separate PR. \r\n",
          "createdAt": "2023-05-05T16:35:56Z",
          "updatedAt": "2023-05-05T16:35:56Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@kixelated  I did try to respond to your comments. I do agree in general with refactoring suggestions, however, I feel it can done as part of #153 ",
          "createdAt": "2023-05-16T20:53:16Z",
          "updatedAt": "2023-05-16T20:53:16Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5SCdBd",
          "commit": {
            "abbreviatedOid": "39e40a4"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-07T16:33:12Z",
          "updatedAt": "2023-04-07T16:34:08Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "I would say they act like clients in deciding what to send next and reference the priority section. ( which we need to add ) ",
              "createdAt": "2023-04-07T16:33:12Z",
              "updatedAt": "2023-04-07T16:34:08Z"
            },
            {
              "originalPosition": 8,
              "body": "Need more detail on how they are authorized ",
              "createdAt": "2023-04-07T16:33:31Z",
              "updatedAt": "2023-04-07T16:34:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5UWHm6",
          "commit": {
            "abbreviatedOid": "3103240"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Same rebase comment here - it's hard to view the changes in this PR",
          "createdAt": "2023-05-05T16:18:09Z",
          "updatedAt": "2023-05-05T16:18:09Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5UWNAf",
          "commit": {
            "abbreviatedOid": "3103240"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-05-05T16:35:08Z",
          "updatedAt": "2023-05-05T16:35:18Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I think we could get clearer text on \"Relays MUST match the track id in the OBJECT message header against the active subscribers for a given track.\" part. Perhaps \"Relays match the trackID in the object header agains the  trackID created in the Annouce transaction to know which track the object is for.\" ",
              "createdAt": "2023-05-05T16:35:08Z",
              "updatedAt": "2023-05-05T16:35:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5UXbzw",
          "commit": {
            "abbreviatedOid": "3103240"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-05-05T20:36:13Z",
          "updatedAt": "2023-05-05T21:38:32Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "> Publishers MAY be configured to publish the objects to a Relays based on the application configuration and topology.\r\n\r\nAn endpoint is not allowed to send objects without a subscription from the remote. I don't think you're trying to despite this because of the 2nd sentence, but the word choice could be better to avoid confusion.",
              "createdAt": "2023-05-05T20:36:13Z",
              "updatedAt": "2023-05-05T22:04:32Z"
            },
            {
              "originalPosition": 10,
              "body": "`Relays MUST <do something out-of-scope>`\r\n\r\nThis is an unenforceable MUST, and doesn't need to authenticate ANNOUNCE messages either. It could forward the ANNOUNCE upstream or not require authentication (ex. within a CDN). Likewise this applies to all endpoints, not just relays.\r\n\r\nI would say:\r\n```\r\nA consumer MAY require authorization for the announced tracks.\r\n```",
              "createdAt": "2023-05-05T20:39:15Z",
              "updatedAt": "2023-05-05T22:08:30Z"
            },
            {
              "originalPosition": 12,
              "body": "Do we need these messages?\r\n\r\n- If the consumer wants a track, it will issue a SUBSCRIBE. No need for ANNOUNCE OK.\r\n- If the consumer doesn't want (or understand) a track, it will not issue a SUBSCRIBE. No need for ANNOUNCE OK.\r\n- If the consumer refuses a track (unauthenticated), it can close the connection. Do we need a special error message; would the connection be able to recover from this state?",
              "createdAt": "2023-05-05T20:51:25Z",
              "updatedAt": "2023-05-05T21:38:32Z"
            },
            {
              "originalPosition": 14,
              "body": "> Relays MUST match the track id in the OBJECT message header against the active subscribers for a given track.\r\n\r\n`track ID` is a actually hop-by-hop property (should be renamed to `subscription ID`). Each downstream subscription may use different subscription IDs, which may not match the upstream subscription ID either, so it's not quite as simple as matching them. \r\n\r\nAnd again these are strange MUSTs. What happens if a relay... doesn't do this? In fact I would want relays to be able to rewrite track names, so it's not clear how that would even work with this assertive yet unenforceable statement.",
              "createdAt": "2023-05-05T21:02:32Z",
              "updatedAt": "2023-05-05T22:09:44Z"
            },
            {
              "originalPosition": 8,
              "body": "Are multiple ANNOUNCE messages allowed? What happens when authentication needs to be renewed? Can an endpoint UNANNOUNCE tracks...? What happens if another endpoint ANNOUNCEs the same track (ex. reconnection)?",
              "createdAt": "2023-05-05T21:25:32Z",
              "updatedAt": "2023-05-05T21:38:32Z"
            },
            {
              "originalPosition": 8,
              "body": "Those minor details don't really matter, but the big thing missing is how does the receiver identify tracks? \r\n\r\nIn order to support ingestion from generic clients (like OBS), we need some way of identifying the catalog; it can't be negotiated out-of-band. I included the track format in my proposal to this end. \r\n\r\n@vasilvv suggested ending the track name with a `/` if it's a catalog, which is kind of neat since a catalog is like a directory listing. I think ending with `/catalog` is more future proof, although I would like to see a registry rather than encoding behavior into the track name.",
              "createdAt": "2023-05-05T21:25:45Z",
              "updatedAt": "2023-05-05T22:06:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5UX1p1",
          "commit": {
            "abbreviatedOid": "3103240"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-05T22:33:03Z",
          "updatedAt": "2023-05-05T22:33:04Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "edit: I do think we need these messages primarily to add an `expires` field in ANNOUNCE OK similar to SUBSCRIBE OK. I would really like to combine authentication in both though.",
              "createdAt": "2023-05-05T22:33:04Z",
              "updatedAt": "2023-05-05T22:33:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5U7Kvj",
          "commit": {
            "abbreviatedOid": "0a7822a"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-12T16:09:14Z",
          "updatedAt": "2023-05-12T16:09:14Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Individual/Editorial comment\r\n\r\n> Relays MUST use the `Track Id` in the incoming OBJECT messages to find active subscribers with track information matching the `Track Id`.\r\n\r\nThis MUST reads a little prescriptive to me.  Maybe rewrite the sentence without the MUST and make it informative rather than normative, like:\r\n\r\n`Relays use the `Track ID` of an incoming OBJECT message to identify its track and find the active subscribers for that track`",
              "createdAt": "2023-05-12T16:09:14Z",
              "updatedAt": "2023-05-12T16:09:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5U-TEs",
          "commit": {
            "abbreviatedOid": "3103240"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-14T23:11:16Z",
          "updatedAt": "2023-05-14T23:11:16Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "i do think we need to answer/clarify on some of these , but it's not in the scope of this PR.",
              "createdAt": "2023-05-14T23:11:16Z",
              "updatedAt": "2023-05-14T23:11:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5VFAyB",
          "commit": {
            "abbreviatedOid": "7d946bb"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Individual review",
          "createdAt": "2023-05-15T21:13:36Z",
          "updatedAt": "2023-05-15T21:14:12Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Same concern about common prefix -- can we say \"Full Track Name matches the announced namespace\"?",
              "createdAt": "2023-05-15T21:13:36Z",
              "updatedAt": "2023-05-15T21:14:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5VFVew",
          "commit": {
            "abbreviatedOid": "7d946bb"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-15T22:40:59Z",
          "updatedAt": "2023-05-15T22:40:59Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Full Track Name includes both Track Namespace and Track Name, so here the match should happen only on the namespace part. I wonder if the suggestion is saying namespace is the full track name",
              "createdAt": "2023-05-15T22:40:59Z",
              "updatedAt": "2023-05-15T22:40:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5VFV-4",
          "commit": {
            "abbreviatedOid": "7d946bb"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-15T22:44:02Z",
          "updatedAt": "2023-05-15T22:44:02Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Hmm, yeah I agree that could be a reading of it which I didn't intend. Maybe:\r\n\r\n> set of tracks whose Track Namespace matches the announced namespace",
              "createdAt": "2023-05-15T22:44:02Z",
              "updatedAt": "2023-05-15T22:44:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5U7eX7",
          "commit": {
            "abbreviatedOid": "7d946bb"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I don't think this section is publisher specific. It really should focus on what a relay should do when it receives an ANNOUNCE, and not cover what it should do with subscriptions.",
          "createdAt": "2023-05-12T17:06:24Z",
          "updatedAt": "2023-05-16T18:34:23Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "> Publishing through the relay starts with publisher sending \"ANNOUNCE\" control message for the set of tracks\r\n\r\nThis is optional.\r\n\r\n> Relays MUST ensure that publishers are authorized by:\r\n\r\nAlso optional.",
              "createdAt": "2023-05-12T17:06:24Z",
              "updatedAt": "2023-05-16T18:34:23Z"
            },
            {
              "originalPosition": 8,
              "body": "> Specifics of the authorization process depends on the way the relay is managed and is typically based on prior business agreement with the Origin, for example.\r\n\r\nSame feedback: Can you remove the mention of Origin? Just say authentication is up to the application.",
              "createdAt": "2023-05-12T17:08:25Z",
              "updatedAt": "2023-05-16T18:34:23Z"
            },
            {
              "originalPosition": 10,
              "body": "Replace the word \"Relays\" with \"subscriber\" or \"consumer\" or something else.",
              "createdAt": "2023-05-12T17:10:06Z",
              "updatedAt": "2023-05-16T18:34:23Z"
            },
            {
              "originalPosition": 12,
              "body": "What does ANNOUNCE have to do with forwarding objects? This section is very similar to the subscribe section. ",
              "createdAt": "2023-05-12T17:14:12Z",
              "updatedAt": "2023-05-16T18:34:23Z"
            },
            {
              "originalPosition": 10,
              "body": "This text is duplicated in both the ANNOUNCE and SUBSCRIBE section... but is slightly different. Can you move it to it's own \"authorization\" sub-second?",
              "createdAt": "2023-05-16T18:09:39Z",
              "updatedAt": "2023-05-16T18:34:23Z"
            },
            {
              "originalPosition": 14,
              "body": "> OBJECT message header carry short hop-by-hop Track Id that maps to the Full Track Name (see {{message-subscribe-ok}}). Relays use the Track ID of an incoming OBJECT message to identify its track and find the active subscribers for that track.\r\n\r\nWhat does this have to do with publishing? This whole paragraph should be in the subscription section... it even mentions subscribers.\r\n\r\n> Unless determined by congestion response, Relays MUST forward the OBJECT message to the matching subscribers.\r\n\r\nIf it's not enforceable, then it's a SHOULD and not a MUST. We should also have a discussion about if a transmuxer / transcoder is a \"relay\".",
              "createdAt": "2023-05-16T18:21:17Z",
              "updatedAt": "2023-05-16T18:34:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5VMebZ",
          "commit": {
            "abbreviatedOid": "7d946bb"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-16T20:13:40Z",
          "updatedAt": "2023-05-16T20:13:40Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "> We should also have a discussion about if a transmuxer / transcoder is a \"relay\".\r\n\r\nI think we have had this discussion, right?  A relay doesn't have access to the raw media / e2e encryption keys so a transmuxer / transcoder is not a relay, it's a subscriber and publisher glued together.",
              "createdAt": "2023-05-16T20:13:40Z",
              "updatedAt": "2023-05-16T20:13:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5VMlPo",
          "commit": {
            "abbreviatedOid": "7d946bb"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-16T20:33:55Z",
          "updatedAt": "2023-05-16T20:33:56Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "i was defining transcoder as https://datatracker.ietf.org/doc/html/draft-nandakumar-moq-arch-00#section-2.2\r\n\r\nit has following security roles publisher, subscriber, emitter and receiver \r\n",
              "createdAt": "2023-05-16T20:33:55Z",
              "updatedAt": "2023-05-16T20:33:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5VMlet",
          "commit": {
            "abbreviatedOid": "7d946bb"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-16T20:34:37Z",
          "updatedAt": "2023-05-16T20:34:37Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "> What does this have to do with publishing? This whole paragraph should be in the subscription section... it even mentions subscribers.\r\n\r\nthis is needed to tell what is relay doing when a publish happens",
              "createdAt": "2023-05-16T20:34:37Z",
              "updatedAt": "2023-05-16T20:34:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5VMl3R",
          "commit": {
            "abbreviatedOid": "7d946bb"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-16T20:35:27Z",
          "updatedAt": "2023-05-16T20:35:28Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "once we refactor to have common sender/receiver section , it would be more clearer to move things around inside the relay section. I know its duplicate, but would prefer to fix in a separate PR though",
              "createdAt": "2023-05-16T20:35:28Z",
              "updatedAt": "2023-05-16T20:35:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5VMolJ",
          "commit": {
            "abbreviatedOid": "7d946bb"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-16T20:43:18Z",
          "updatedAt": "2023-05-16T20:43:18Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "@suhasHere : do you agree with matching namespaces rather than matching prefixes?",
              "createdAt": "2023-05-16T20:43:18Z",
              "updatedAt": "2023-05-16T20:43:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5VMpL8",
          "commit": {
            "abbreviatedOid": "0a7822a"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-16T20:45:13Z",
          "updatedAt": "2023-05-16T20:45:14Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "This section is about Relays and using relays goes along with previous page. I think the above change can be part of #153 ",
              "createdAt": "2023-05-16T20:45:13Z",
              "updatedAt": "2023-05-16T20:45:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5VM9uE",
          "commit": {
            "abbreviatedOid": "7d946bb"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-16T21:26:44Z",
          "updatedAt": "2023-05-16T21:26:44Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "yes @afrind ",
              "createdAt": "2023-05-16T21:26:44Z",
              "updatedAt": "2023-05-16T21:26:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5VNLfn",
          "commit": {
            "abbreviatedOid": "196c1e4"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "it's fine, we can do an editorial pass later to consolidate the publisher/subscriber/authentication/relay text",
          "createdAt": "2023-05-16T22:22:12Z",
          "updatedAt": "2023-05-16T22:22:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 128,
      "id": "PR_kwDOG2Ho4M5Nydfa",
      "title": "IETF116: Fill in Relay sub-sections on discovery and connection restoration",
      "url": "https://github.com/moq-wg/moq-transport/pull/128",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR depends on #125 \r\n",
      "createdAt": "2023-04-06T17:34:23Z",
      "updatedAt": "2023-05-14T23:07:30Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "4135555f0abe0d5b132924ef3779ad1ff8b929b9",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "116-relay-rest",
      "headRefOid": "1b4d0731434e693bf77d2e84fadab5192cb10380",
      "closedAt": "2023-05-14T23:07:29Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Since we agreed to table connection restoration until after adoption, should we close this PR for now?",
          "createdAt": "2023-05-12T15:46:56Z",
          "updatedAt": "2023-05-12T15:46:56Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "closing and will reopen once draft is adopted",
          "createdAt": "2023-05-14T23:07:29Z",
          "updatedAt": "2023-05-14T23:07:29Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5SCdgQ",
          "commit": {
            "abbreviatedOid": "962dddc"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-07T16:35:48Z",
          "updatedAt": "2023-04-07T16:37:18Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "My preference would be to add a TBD here of open issue on relay discovery. ",
              "createdAt": "2023-04-07T16:35:48Z",
              "updatedAt": "2023-04-07T16:37:18Z"
            },
            {
              "originalPosition": 14,
              "body": "Rephrase in terms of requirements and possible behavior we could want. ",
              "createdAt": "2023-04-07T16:37:12Z",
              "updatedAt": "2023-04-07T16:37:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5UWINn",
          "commit": {
            "abbreviatedOid": "1b4d073"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Individual review.\r\n\r\nRebase for readability.\r\n\r\nI'm not sure what's different about restoring a connection through a relay vs direct-to-publisher - most of the text here doesn't seem relay specific.\r\n",
          "createdAt": "2023-05-05T16:19:49Z",
          "updatedAt": "2023-05-05T16:25:49Z",
          "comments": [
            {
              "originalPosition": 401,
              "body": "Do we need to define the message for accomplishing this?",
              "createdAt": "2023-05-05T16:19:49Z",
              "updatedAt": "2023-05-05T16:25:49Z"
            },
            {
              "originalPosition": 401,
              "body": "I assume that closing the connection will implicitly unsubscribe, so explicitly unsubscribing seems redundant.",
              "createdAt": "2023-05-05T16:20:42Z",
              "updatedAt": "2023-05-05T16:25:49Z"
            },
            {
              "originalPosition": 408,
              "body": "This bit seems opposed to the above text \"Client moves to the new relay with all of its Subscriptions\" - maybe needs to be reworded into a single section that explains the nuance of migration?",
              "createdAt": "2023-05-05T16:22:24Z",
              "updatedAt": "2023-05-05T16:25:49Z"
            },
            {
              "originalPosition": 410,
              "body": "I think it would be useful to how how groups can be used during migration.  Since the transport protocol is not currently aware of timestamps, I have a preference to rely on groups, at least for now, and let applications or streaming formats handle the group/timestamp mappings?",
              "createdAt": "2023-05-05T16:24:00Z",
              "updatedAt": "2023-05-05T16:25:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5UXqKZ",
          "commit": {
            "abbreviatedOid": "1b4d073"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "The reconnect stuff is biting off a MUCH bigger issue that needs very careful consideration.",
          "createdAt": "2023-05-05T21:44:02Z",
          "updatedAt": "2023-05-05T22:03:54Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "Duplicate of #126 ",
              "createdAt": "2023-05-05T21:44:02Z",
              "updatedAt": "2023-05-05T22:03:54Z"
            },
            {
              "originalPosition": 15,
              "body": "Duplicate of #127 ",
              "createdAt": "2023-05-05T21:44:36Z",
              "updatedAt": "2023-05-05T22:03:54Z"
            },
            {
              "originalPosition": 33,
              "body": "There's actually a GOAWAY message already in the draft.\r\n\r\nYou should file an issue to talk about what happens to subscriptions after a GOAWAY. I would say that the client MAY resubscribe to the same tracks. It certainly shouldn't be automatic, and those subscriptions may fail.\r\n\r\nAnd this doesn't seem relay specific.",
              "createdAt": "2023-05-05T21:47:30Z",
              "updatedAt": "2023-05-05T22:03:54Z"
            },
            {
              "originalPosition": 38,
              "body": "Again, not relay specific. In fact, clients will be subject to disconnections more often.\r\n\r\nWe should talk about what a client should do after a disconnect. One of the problems with groups is that the receiver doesn't know the final group size, so it doesn't know if it should request the remainder of it.\r\n\r\n```\r\nOBJECT group=5 sequence=53\r\nOBJECT group=6 sequence=42\r\nOBJECT group=6 sequence=43\r\n<disconnect>\r\n<time passes>\r\nCONNECT\r\nSUBSCRIBE ???\r\n```\r\n\r\nWhat should the receiver do?\r\n\r\nOption A:\r\n```\r\nSUBSCRIBE group=latest\r\n```\r\n\r\nOption B:\r\n```\r\nSUBSCRIBE group=6 sequence=44\r\n```\r\n\r\nOption C:\r\n```\r\nSUBSCRIBE group=5 sequence=53\r\nSUBSCRIBE group=6 sequence=44\r\n```\r\n\r\n\r\nOption C is invalid for multiple reasons, but is technically the most correct if the receiver is recording a VOD and wants to download all media that was encoded during the disconnect. In order to support this use-case, the receiver needs to know the final size though.\r\n\r\nIMO let's make an section about reconnections. I feel like we need to discuss the right behavior in an issue first though.",
              "createdAt": "2023-05-05T21:57:22Z",
              "updatedAt": "2023-05-05T22:03:54Z"
            },
            {
              "originalPosition": 40,
              "body": "I think this is where ANNOUNCE gets into the most trouble. The dynamic routing table is changed mid-session but there's no clear transition point. For example, `group=5` may be served from the old origin while `group=6` may be served from the new origin. It's just a mess to handle this sort of instantaneous rerouting in a distributed system, since every node will have it's own cache. ",
              "createdAt": "2023-05-05T21:59:27Z",
              "updatedAt": "2023-05-05T22:03:54Z"
            }
          ]
        }
      ]
    },
    {
      "number": 129,
      "id": "PR_kwDOG2Ho4M5N0BiB",
      "title": "IETF116 : Add a placeholder section on prioritization and congestion response",
      "url": "https://github.com/moq-wg/moq-transport/pull/129",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR adds a placeholder section for inserting details on various congestion response and prioritization proposals being discussed.  At IETF116 , it was very clear that there are couple of ways this can be address and having its own section would help along as we go further.",
      "createdAt": "2023-04-07T02:56:49Z",
      "updatedAt": "2023-04-10T16:48:50Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "116-relay-tmpl",
      "baseRefOid": "b56ffe758ef49c3a2b4432ed6e97dff01908ae5a",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "116-priority-template",
      "headRefOid": "e6957d035c6ae0c71e5846d5c532182b47765057",
      "closedAt": "2023-04-10T16:48:49Z",
      "mergedAt": "2023-04-10T16:48:49Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "ac488c2946b7b8e2ea441a01f266cdd82e639e14"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5SCeIU",
          "commit": {
            "abbreviatedOid": "e6957d0"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I think merging something like this now will make it much easier to have PR that don't all depend on each other and and allow the priority stuff to get discussed in one section. ",
          "createdAt": "2023-04-07T16:39:06Z",
          "updatedAt": "2023-04-07T16:39:06Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5SCuW7",
          "commit": {
            "abbreviatedOid": "e6957d0"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-07T18:04:20Z",
          "updatedAt": "2023-04-07T18:04:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 130,
      "id": "PR_kwDOG2Ho4M5N0Kvs",
      "title": "IETF116: Move Transport Usages to its own section",
      "url": "https://github.com/moq-wg/moq-transport/pull/130",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR adds a starter text for moving WT and Native QUIC usage to its own section.\r\n\r\nFollow up PRs should focus on how to concentrate transport specific things to this section and transport independent usages (control stream, data streams, data model mapping to the streams) should be covered in its own PR\r\n\r\n",
      "createdAt": "2023-04-07T04:17:21Z",
      "updatedAt": "2023-04-09T21:38:43Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "19c8e1ca846960e68ff0be11bd2e101433370603",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "trasport-usage",
      "headRefOid": "0913e7b3f5f95c4557da9aef2a014806c5c3f160",
      "closedAt": "2023-04-09T21:38:43Z",
      "mergedAt": "2023-04-09T21:38:43Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "c286f2f86af090f9d291c5c2d7d86af44bb462b7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5SCfAU",
          "commit": {
            "abbreviatedOid": "fdd00db"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-07T16:43:29Z",
          "updatedAt": "2023-04-07T16:45:03Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Might add that nearly all parts of the protocol are the same regardless of if MoQ is running on WebTrasnport or raw QUIC. \r\n",
              "createdAt": "2023-04-07T16:43:29Z",
              "updatedAt": "2023-04-07T16:45:03Z"
            },
            {
              "originalPosition": 53,
              "body": "Did you intent to move this section ? Not sure I following reason for move here. ",
              "createdAt": "2023-04-07T16:44:55Z",
              "updatedAt": "2023-04-07T16:45:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SChMc",
          "commit": {
            "abbreviatedOid": "fdd00db"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-07T16:54:45Z",
          "updatedAt": "2023-04-07T16:54:45Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "good point, will do ",
              "createdAt": "2023-04-07T16:54:45Z",
              "updatedAt": "2023-04-07T16:54:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SChRI",
          "commit": {
            "abbreviatedOid": "fdd00db"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-07T16:55:09Z",
          "updatedAt": "2023-04-07T16:55:09Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Hmm .. that was no the intent. Let me fix it in the next update. Thanks for catching it.",
              "createdAt": "2023-04-07T16:55:09Z",
              "updatedAt": "2023-04-07T16:55:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SCuRB",
          "commit": {
            "abbreviatedOid": "fdd00db"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-07T18:03:51Z",
          "updatedAt": "2023-04-07T18:03:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 134,
      "id": "PR_kwDOG2Ho4M5N-ckT",
      "title": "Generic transport draft.",
      "url": "https://github.com/moq-wg/moq-transport/pull/134",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The plan is to split the draft into two parts: one for generic transport and one for media the media mapping (catalog).\r\n\r\nThere's still a lot of references to media that need to be cleaned up. I tried to limit the changes by primarily deleting sections, only changing the text if there was a reference that no longer worked.\r\n\r\nA follow-up PR will address any lingering media references. I'll deal with the inevitable merge conflicts.",
      "createdAt": "2023-04-10T23:54:59Z",
      "updatedAt": "2023-04-11T20:12:18Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "c286f2f86af090f9d291c5c2d7d86af44bb462b7",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "transport-only",
      "headRefOid": "27f2bcd8bacf6efa6566259c57434b7fd158a662",
      "closedAt": "2023-04-11T20:12:17Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "i wonder if we should rename the protocol as well to avoid confusions with Warp media format work that @wilaw started?",
          "createdAt": "2023-04-11T00:01:45Z",
          "updatedAt": "2023-04-11T00:01:45Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> i wonder if we should rename the protocol as well to avoid confusions with Warp media format work that @wilaw started?\r\n\r\nYep yep, will do. The plan is `warp-transport` and `warp-media`. I just didn't want to rename the file in this PR so it's easy to review.",
          "createdAt": "2023-04-11T00:55:07Z",
          "updatedAt": "2023-04-11T00:55:35Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> Yep yep, will do. The plan is `warp-transport` and `warp-media`. I just didn't want to rename the file in this PR so it's easy to review.\r\n\r\nmy 2 cents would be to call the base transport protocol as just `moq-transport` or `moq-transport-protocol` or something generic.. warp-media name seems fine to the media spec though ",
          "createdAt": "2023-04-11T16:54:31Z",
          "updatedAt": "2023-04-11T16:54:31Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "@suhasHere We can replace `warp` with `moq` as part of adoption. I just don't feel comfortable claiming that an individual draft represents moq until the working group agrees.",
          "createdAt": "2023-04-11T18:51:51Z",
          "updatedAt": "2023-04-11T18:52:21Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Actually let's close this until the media half is fully ready. \r\n\r\nLet's merge/close the existing PRs to avoid a nightmare of merge conflicts. @suhasHere no new PRs, okay? ",
          "createdAt": "2023-04-11T20:12:17Z",
          "updatedAt": "2023-04-11T20:12:17Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5SPvSG",
          "commit": {
            "abbreviatedOid": "27f2bcd"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-11T18:29:41Z",
          "updatedAt": "2023-04-11T18:29:57Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "I thought we no longer have init objects, since those were in the catalog, and we're moving catalog out of transport?",
              "createdAt": "2023-04-11T18:29:41Z",
              "updatedAt": "2023-04-11T18:29:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SP1JT",
          "commit": {
            "abbreviatedOid": "27f2bcd"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-11T18:47:41Z",
          "updatedAt": "2023-04-11T18:47:42Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "Yeh let me do another pass and remove more media stuff. I was trying to minimize the diff but some things are just wrong.",
              "createdAt": "2023-04-11T18:47:41Z",
              "updatedAt": "2023-04-11T18:49:57Z"
            }
          ]
        }
      ]
    },
    {
      "number": 135,
      "id": "PR_kwDOG2Ho4M5OK-Ns",
      "title": "Define the protocol over raw QUIC",
      "url": "https://github.com/moq-wg/moq-transport/pull/135",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-04-12T21:13:48Z",
      "updatedAt": "2023-04-21T19:22:41Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "3050937d86cf2b032132698c1d788d46c4965afd",
      "headRepository": "vasilvv/warp-draft",
      "headRefName": "raw-quic",
      "headRefOid": "cf03d55f676729919f62bb5bdadee76bfed381cb",
      "closedAt": "2023-04-21T19:22:41Z",
      "mergedAt": "2023-04-21T19:22:40Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "903daa528293df746a96f58bfef7df438a8e617a"
      },
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> just want to make sure that we are moving the path and query parameter to SETTINGS ? since atleast for now, I am not sure how it applies to native QUIC ..\r\n\r\nThe path is in the SETUP message. There's no SETTINGS message for native QUIC and it's transparent anyway to MoQ over WebTransport.\r\n\r\nI was alluding to how the SETUP message performs a similar role to the HTTP/3 SETTINGS message. Both endpoints negotiate functionality, but in the case of native QUIC, also exchange a connection URL.",
          "createdAt": "2023-04-20T01:15:53Z",
          "updatedAt": "2023-04-20T01:19:52Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> > just want to make sure that we are moving the path and query parameter to SETTINGS ? since atleast for now, I am not sure how it applies to native QUIC ..\r\n> \r\n> The path is in the SETUP message. There's no SETTINGS message for native QUIC and it's transparent anyway to MoQ over WebTransport.\r\n> \r\n> I was alluding to how the SETUP message performs a similar role to the HTTP/3 SETTINGS message. Both endpoints negotiate functionality, but in the case of native QUIC, also exchange a connection URL.\r\n\r\n\r\nSorry for the confusion , yes I meant SETUP message. The PR currently specifies PATH and query in the connection URL for native QUIC, which may be reworded under a TODO for now. Other than that, we should be fine ?",
          "createdAt": "2023-04-21T14:13:09Z",
          "updatedAt": "2023-04-21T14:13:09Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5SeSne",
          "commit": {
            "abbreviatedOid": "b172ba8"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-13T15:18:38Z",
          "updatedAt": "2023-04-13T15:18:39Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "for my better understanding on why we need a elaborate URI scheme\r\n- why do we need path ? and how is it set ?\r\n- what is the usecase for query ?\r\n\r\nCan you provide few examples of these ",
              "createdAt": "2023-04-13T15:18:38Z",
              "updatedAt": "2023-04-13T15:19:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SeV_D",
          "commit": {
            "abbreviatedOid": "b172ba8"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-13T15:23:57Z",
          "updatedAt": "2023-04-13T15:23:57Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "Native QUIC would be my inclination to call it out though :-)",
              "createdAt": "2023-04-13T15:23:57Z",
              "updatedAt": "2023-04-13T15:23:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5SfUV1",
          "commit": {
            "abbreviatedOid": "b172ba8"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "The definition of raw QUIC suggests using a \"path\" parameter, but there is no such thing in QUIC itself. The use of the path parameter is largely linked to the discussion of bundling, and that discussion has not yet concluded. Waiting for that, I believed we have agreed to not consider bundling in the version-00 of the transport draft, and to simply let the client subscribe to a bunch of tracks, each with their own URI. Maybe mark the whole \"path\" discussion as \"for further study\"?",
          "createdAt": "2023-04-13T17:52:03Z",
          "updatedAt": "2023-04-13T18:00:15Z",
          "comments": [
            {
              "originalPosition": 152,
              "body": "There is no \"path\" parameter in raw QUIC. If we do want one, we will have to define some kind of \"SETTINGS\" transaction to specialize the QUIC/MoQ connection, but it may be a bit early to define that. I would replace this paragraph by a place-holder for now, something like: \"TODO: define whether the `path` parameter is actually needed for raw QUIC connections, and if it is define how to carry it. Waiting for that, assume that the `path` parameter is empty when using raw QUIC.\"",
              "createdAt": "2023-04-13T17:52:03Z",
              "updatedAt": "2023-04-13T18:00:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Slv_I",
          "commit": {
            "abbreviatedOid": "b172ba8"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-14T14:56:02Z",
          "updatedAt": "2023-04-14T14:58:38Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "Renamed.",
              "createdAt": "2023-04-14T14:56:02Z",
              "updatedAt": "2023-04-14T14:58:38Z"
            },
            {
              "originalPosition": 94,
              "body": "It isn't really elaborate -- I just made it equivalent to what HTTP supports.  We could potentially drop path/query, though that can be a useful routing lever.",
              "createdAt": "2023-04-14T14:57:08Z",
              "updatedAt": "2023-04-14T14:58:38Z"
            },
            {
              "originalPosition": 152,
              "body": "> If we do want one, we will have to define some kind of \"SETTINGS\" transaction to specialize the QUIC/MoQ connection, but it may be a bit early to define that.\r\n\r\nThis document already defines one (and we in fact discussed in #107).",
              "createdAt": "2023-04-14T14:58:33Z",
              "updatedAt": "2023-04-14T14:58:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TAjuO",
          "commit": {
            "abbreviatedOid": "3a4de5a"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2023-04-19T18:24:26Z",
          "updatedAt": "2023-04-19T18:27:12Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "Needs some further explanation.\r\n\r\n> ...in the SETUP message after establishing the QUIC connection.",
              "createdAt": "2023-04-19T18:24:26Z",
              "updatedAt": "2023-04-19T18:27:12Z"
            },
            {
              "originalPosition": 152,
              "body": "Yeah, this `SETUP` message is basically that `SETTINGS` transaction you're talking about @huitema .",
              "createdAt": "2023-04-19T18:26:52Z",
              "updatedAt": "2023-04-20T01:12:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TBdgc",
          "commit": {
            "abbreviatedOid": "b172ba8"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-19T21:13:51Z",
          "updatedAt": "2023-04-19T21:13:52Z",
          "comments": [
            {
              "originalPosition": 152,
              "body": "Yes, that would work. I am a bit worried about the setting mechanism itself -- \"the first bidir stream from the client\" seems like a bit underspecified, given that the order in which the stream opening order is not guaranteed the same as client and server. But assuming we fix that, yes, sending \"role\", \"path\", and probably \"version\" on a setup stream makes sense. In raw QUIC, I would assume that the setup could be sent in 0-RTT.",
              "createdAt": "2023-04-19T21:13:51Z",
              "updatedAt": "2023-04-19T21:13:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TCF2U",
          "commit": {
            "abbreviatedOid": "3a4de5a"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "just want to make sure that we are moving the path and query parameter to SETTINGS ? since atleast for now, I am not sure how it applies to native QUIC ..",
          "createdAt": "2023-04-20T00:51:40Z",
          "updatedAt": "2023-04-20T00:51:40Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5TCyhb",
          "commit": {
            "abbreviatedOid": "b172ba8"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-20T05:42:58Z",
          "updatedAt": "2023-04-20T05:42:58Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "I really wonder what the point of QUERY parameters would be, if we have an explicit SETUP process. That would mean two option for specifying parameters: as SETUP type/value, or as query items. Leading to potential conflicts, etc.\r\n\r\nWe had discussions in previous meetings of using the Path parameter to specify some kind of \"bundle\", maybe a common origin for the tracks. But that too would be better handled by a specific SETUP type/value.\r\n\r\nThat means we could also simplify the HTTP specification, and explain that the only purpose of the path-abempty would be to distinguish MoQ from other webtransport services implemented on the server -- pretty much the equivalent of the ALPN.\r\n",
              "createdAt": "2023-04-20T05:42:58Z",
              "updatedAt": "2023-04-20T05:42:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TOYQq",
          "commit": {
            "abbreviatedOid": "fc41458"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-21T19:04:40Z",
          "updatedAt": "2023-04-21T19:04:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 141,
      "id": "PR_kwDOG2Ho4M5O4pcN",
      "title": "116 track + subscribe approved changes",
      "url": "https://github.com/moq-wg/moq-transport/pull/141",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR is just a merge of 2 approved PRs (121, 122) . Need need to get a +1 to merge them. @vasilvv ",
      "createdAt": "2023-04-21T18:53:31Z",
      "updatedAt": "2023-04-21T19:02:58Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "b2cae1f06562bba1dece98d0d3d061efc1f73417",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "116-track",
      "headRefOid": "7d497f6554be955d59c9234e2737c1450372131d",
      "closedAt": "2023-04-21T19:02:58Z",
      "mergedAt": "2023-04-21T19:02:58Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "3050937d86cf2b032132698c1d788d46c4965afd"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5TOXuX",
          "commit": {
            "abbreviatedOid": "7d497f6"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-21T19:02:37Z",
          "updatedAt": "2023-04-21T19:02:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 147,
      "id": "PR_kwDOG2Ho4M5POlFm",
      "title": "Resolve group DISCUSS in object model",
      "url": "https://github.com/moq-wg/moq-transport/pull/147",
      "state": "MERGED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It was quite difficult to get the wording correct and I'm open to suggestions.\r\n\r\nThe main difficult is that groups are not truly independent, particularly for audio decoding. In Yokohama I learned I was mistaken in the assumption that audio consists of independent \"frames\"; technically it self-corrects any errors. This was extra apparent in my sample code as reseting the decoder at each group caused noticeable blips (we can remove this anecdote from the text if it's not useful). Video works the same way when using intra-refresh so we need to clearly spell it out.",
      "createdAt": "2023-04-26T18:53:48Z",
      "updatedAt": "2023-05-05T17:22:32Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "c57d17cba99a0a76f76ac52ff2265a6fba53a20a",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "group-model",
      "headRefOid": "6fe74a6afa7a134785910d25a31615a25b10136f",
      "closedAt": "2023-05-05T17:22:29Z",
      "mergedAt": "2023-05-05T17:22:29Z",
      "mergedBy": "kixelated",
      "mergeCommit": {
        "oid": "4135555f0abe0d5b132924ef3779ad1ff8b929b9"
      },
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Replaces #90.",
          "createdAt": "2023-04-26T18:54:04Z",
          "updatedAt": "2023-04-26T18:54:04Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> * Groups are consumption points for enabling functions like joins, rewinds and replays\r\n> * Groups are checkpoints for nodes implementing relay functionality to implement appropriate congestion responses\r\n\r\nI'm having trouble explaining WHY groups can be used as sync points or checkpoints. What are the concrete properties of groups that enable these use-cases?",
          "createdAt": "2023-04-28T03:09:26Z",
          "updatedAt": "2023-04-28T03:09:26Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> > * Groups are consumption points for enabling functions like joins, rewinds and replays\r\n> > * Groups are checkpoints for nodes implementing relay functionality to implement appropriate congestion responses\r\n> \r\n> I'm having trouble explaining WHY groups can be used as sync points or checkpoints. What are the concrete properties of groups that enable these use-cases?\r\n\r\nConsumption points - subscriber joins, rewind and replays\r\nCheckpoints - For relays to apply congestion response at group boundaries\r\n",
          "createdAt": "2023-04-28T04:03:54Z",
          "updatedAt": "2023-04-28T04:03:54Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5TnCUC",
          "commit": {
            "abbreviatedOid": "2e44c22"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Individual review, mostly editorial comments.",
          "createdAt": "2023-04-26T20:14:10Z",
          "updatedAt": "2023-04-26T20:20:03Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "'receiving' doesn't strike me as the right verb.  'consuming' as in the previous text was probably ok, or using/decoding/processing?",
              "createdAt": "2023-04-26T20:14:10Z",
              "updatedAt": "2023-04-26T20:20:03Z"
            },
            {
              "originalPosition": 5,
              "body": "'prior progress' reads awkwardly to me.  Something similar to the previous text might work \"without access to any other groups\"",
              "createdAt": "2023-04-26T20:14:32Z",
              "updatedAt": "2023-04-26T20:20:03Z"
            },
            {
              "originalPosition": 9,
              "body": "I don't think you need \"This implies that\".",
              "createdAt": "2023-04-26T20:15:09Z",
              "updatedAt": "2023-04-26T20:20:03Z"
            },
            {
              "originalPosition": 14,
              "body": "I'm a bit confused by this part.  Maybe leave it out for now since it doesn't seem purely object model related - the priority stuff can go in the priority section?",
              "createdAt": "2023-04-26T20:16:35Z",
              "updatedAt": "2023-04-26T20:20:03Z"
            },
            {
              "originalPosition": 16,
              "body": "I'm trying to reconcile \"MUST NOT depend\" with \"MAY use\".  It sounds like there's some encoding schemes that have \"weak\" rather than strict dependencies.  I would maybe put this MAY up near line 220/221 at least.",
              "createdAt": "2023-04-26T20:19:01Z",
              "updatedAt": "2023-04-26T20:20:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TokPe",
          "commit": {
            "abbreviatedOid": "2e44c22"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for the PR and few high level comments\r\n\r\nAt a higher level, it might be useful to capture group properties as\r\n- Groups are consumption points for enabling functions like joins, rewinds and replays\r\n- Groups are checkpoints for nodes implementing relay functionality to implement appropriate congestion responses\r\n- Some text about object dependencies within a group",
          "createdAt": "2023-04-27T04:18:14Z",
          "updatedAt": "2023-04-27T04:41:55Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "+1 to @afrind  suggestion. This doesn't seem to fit in the data model section and the SHOULD here is probably  making it a suggestion.",
              "createdAt": "2023-04-27T04:18:14Z",
              "updatedAt": "2023-04-27T04:41:55Z"
            },
            {
              "originalPosition": 16,
              "body": "I don't see how this helps with the data model and also may be we should replace the decoder here with \"application\" to be generic",
              "createdAt": "2023-04-27T04:19:14Z",
              "updatedAt": "2023-04-27T04:41:55Z"
            },
            {
              "originalPosition": 32,
              "body": "I think we still need \" is starts at 0 at the original media publisher\".  A subscriber joining mid-way through a call will be delivered object message with group_sequence > 0.",
              "createdAt": "2023-04-27T04:22:04Z",
              "updatedAt": "2023-04-27T04:41:55Z"
            },
            {
              "originalPosition": 8,
              "body": "I don't think \"MUST be decodable after the delivery of all prior objects\" is true. Decoders can decode a p-frame even if its proir p-frame is missing, but the experience for the user will not be great. \r\n\r\nMay be somethign on these lines ?\r\n\r\n1) Objects within a group express dependency relationship and in certain application settings an object MAY NOT be decodable until all the prior objects are delivered.\r\n\r\n2) \"Also, the first object within a group MUST NOT depend on other objects within a group\"",
              "createdAt": "2023-04-27T04:34:19Z",
              "updatedAt": "2023-04-27T04:41:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TtAVN",
          "commit": {
            "abbreviatedOid": "2e44c22"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Individual/Editorial comments",
          "createdAt": "2023-04-27T15:09:23Z",
          "updatedAt": "2023-04-27T15:12:29Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "> I don't think \"MUST be decodable after the delivery of all prior objects\" is true. Decoders can decode a p-frame even if its proir p-frame is missing, but the experience for the user will not be great.\r\n\r\nAs I read it, the text doesn't say that object N is unusable without 1 .. N - 1, it says N must be usable without any information other than 1 .. N - 1.  I think the MUST and MAY NOT are expressing the same concept?",
              "createdAt": "2023-04-27T15:09:23Z",
              "updatedAt": "2023-04-27T15:12:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TtfuS",
          "commit": {
            "abbreviatedOid": "2e44c22"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-27T16:13:52Z",
          "updatedAt": "2023-04-27T16:13:53Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "my concern is the requirement of delivery .. MAY NOT was suggested to say that it is true in some cases not all the cases.",
              "createdAt": "2023-04-27T16:13:53Z",
              "updatedAt": "2023-04-27T16:13:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TthxJ",
          "commit": {
            "abbreviatedOid": "2e44c22"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-27T16:19:04Z",
          "updatedAt": "2023-04-27T16:19:05Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "All we need to say is , its some form of sync point and since the text mentions they are independent, i think the latter statement might not be needed",
              "createdAt": "2023-04-27T16:19:04Z",
              "updatedAt": "2023-04-27T16:19:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TtkYU",
          "commit": {
            "abbreviatedOid": "2e44c22"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-27T16:25:50Z",
          "updatedAt": "2023-04-27T16:25:51Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I think we're all saying the same thing.  Maybe it's easier to read this normative requirement if it were in the active rather than passive voice:\r\n\r\nAn endpoint MUST NOT add an object to a group if that object strictly depends on an object in another group, or another object in the same group with a higher sequence number.\r\n\r\n?",
              "createdAt": "2023-04-27T16:25:50Z",
              "updatedAt": "2023-04-27T16:25:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TvgM2",
          "commit": {
            "abbreviatedOid": "2e44c22"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-27T21:54:01Z",
          "updatedAt": "2023-04-27T21:54:01Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "that is not true entirely .. when there are B frames, there will be dependency in both directions .. \r\n\r\nThese details are very specific to media encoding and these might totally change when a new codec come.\r\n\r\nI would rather keep it at an higher level and suggest something on the lines of \" objects within a group express dependency relationship and the first object must be the independent object.\"\r\n\r\nWe can then add few example for video coding , but those are just examples and not normative requirements.\r\n",
              "createdAt": "2023-04-27T21:54:01Z",
              "updatedAt": "2023-04-27T21:54:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Tvlxq",
          "commit": {
            "abbreviatedOid": "2e44c22"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-27T22:17:14Z",
          "updatedAt": "2023-04-27T22:17:15Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Good point about B frames - let me make sure I understand:\r\n\r\nThe dependency graph is like this:  P1 <- B -> P2 (and also maybe P1 <- P2?)\r\n\r\nAnd an app might want to put B and P2 in the same group, but transmit B first because it's available first, right?\r\n\r\nI was thinking that making stricter normative guarantees about group properties would make publisher, relay and receiver operation easier, but with graphs like these maybe there isn't anything we can definitively say.\r\n\r\nWhen an encoder spits out a B frame, does it know how many subsequent frames it's going to depend on?  If so, the publisher could send P1(seq=0), B(seq=2), P2(seq=1), but maybe that opens up another can of worms.",
              "createdAt": "2023-04-27T22:17:14Z",
              "updatedAt": "2023-04-27T22:17:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TwLSB",
          "commit": {
            "abbreviatedOid": "2e44c22"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-28T02:18:11Z",
          "updatedAt": "2023-04-28T02:18:12Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "An application knows exactly based on the encoding scheme its dependency structure and it can use techniques to order the objects that satisfy the relationship. I feel we should probably not define more about these specifics in this spec ",
              "createdAt": "2023-04-28T02:18:11Z",
              "updatedAt": "2023-04-28T02:18:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TwPeC",
          "commit": {
            "abbreviatedOid": "2e44c22"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-28T02:45:23Z",
          "updatedAt": "2023-04-28T02:45:24Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "@suhasHere media should always* be transmitted in decode order (DTS), not presentation order (PTS).\r\n\r\nThe object sequence is basically the same thing as DTS but sequential. A B-frame would have a higher object sequence than any frames it references.\r\n\r\nI think the sequential nature is useful because a relay can detect gaps. A relay can guarantee that an object is decodable if all prior sequences have been delivered, without access to the underlying frame references.",
              "createdAt": "2023-04-28T02:45:24Z",
              "updatedAt": "2023-04-28T02:45:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TwQ2_",
          "commit": {
            "abbreviatedOid": "2e44c22"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-28T02:56:46Z",
          "updatedAt": "2023-04-28T02:56:47Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I think this mostly points out a flaw with the concept of groups. They can't actually provide hard dependency guarantees.\r\n\r\nPersonally, I think we should position groups as the addressable units, while objects are merely chunks within a group. So long as objects are transmitted in a specific order, we could punt any mention of dependencies to the application.",
              "createdAt": "2023-04-28T02:56:47Z",
              "updatedAt": "2023-04-28T02:57:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TwRmk",
          "commit": {
            "abbreviatedOid": "2e44c22"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-28T03:02:29Z",
          "updatedAt": "2023-04-28T03:02:29Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "I see what you mean. Is there a better way to phrase \"at the original media publisher\"? Could we just remove this sentence altogether?",
              "createdAt": "2023-04-28T03:02:29Z",
              "updatedAt": "2023-04-28T03:02:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TwXv5",
          "commit": {
            "abbreviatedOid": "2e44c22"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-28T03:54:36Z",
          "updatedAt": "2023-04-28T03:54:36Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Objects are sequenced when inserted into the group, the delivery can have gaps (due to drops) or out of sequence .. But the application knows to put them in order. \r\n\r\nMay be we need to say \"Nodes SHOULD always attempt to deliver objects within the group as defined by its object sequence, wherever possible\"\r\n\r\n",
              "createdAt": "2023-04-28T03:54:36Z",
              "updatedAt": "2023-04-28T03:54:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TwowJ",
          "commit": {
            "abbreviatedOid": "2e44c22"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-28T05:44:16Z",
          "updatedAt": "2023-04-28T05:44:16Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "may be say it as \"group sequence start at 0 however subscribers should be able to consume objects starting at any group sequence\" ??",
              "createdAt": "2023-04-28T05:44:16Z",
              "updatedAt": "2023-04-28T05:44:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5T0pEH",
          "commit": {
            "abbreviatedOid": "2e44c22"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-28T17:02:26Z",
          "updatedAt": "2023-04-28T17:02:26Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "> I don't think \"MUST be decodable after the delivery of all prior objects\" is true. Decoders can decode a p-frame even if its proir p-frame is missing, but the experience for the user will not be great.\r\n\r\nIf all prior frames have been delivered, then yeah, the P-frame MUST be decodable. But like Alan said, I was careful to not say anything about the opposite case. I agree that we can't say that \"an object MUST NOT be decodable without all prior frames\".",
              "createdAt": "2023-04-28T17:02:26Z",
              "updatedAt": "2023-04-28T17:02:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5T02Zr",
          "commit": {
            "abbreviatedOid": "2988510"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-28T17:46:50Z",
          "updatedAt": "2023-04-28T17:46:51Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I think we should just remove lines 225 to 226 and move to the section on how senders decide what to send next. ",
              "createdAt": "2023-04-28T17:46:50Z",
              "updatedAt": "2023-04-28T17:46:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5T03LG",
          "commit": {
            "abbreviatedOid": "2988510"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-28T17:49:21Z",
          "updatedAt": "2023-04-28T17:49:22Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I propose we resolve this by removing the word \"prior\"",
              "createdAt": "2023-04-28T17:49:22Z",
              "updatedAt": "2023-04-28T17:49:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5UWMEq",
          "commit": {
            "abbreviatedOid": "ba3c4ca"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-05T16:32:07Z",
          "updatedAt": "2023-05-05T16:32:08Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "i think the latest commit didn't fix this yet ?",
              "createdAt": "2023-05-05T16:32:08Z",
              "updatedAt": "2023-05-05T16:32:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5UWMOV",
          "commit": {
            "abbreviatedOid": "ba3c4ca"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-05T16:32:38Z",
          "updatedAt": "2023-05-05T16:32:39Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I am inclining that we just skip this sentence altogether ?",
              "createdAt": "2023-05-05T16:32:38Z",
              "updatedAt": "2023-05-05T16:32:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5UWMdh",
          "commit": {
            "abbreviatedOid": "ba3c4ca"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-05T16:33:25Z",
          "updatedAt": "2023-05-05T16:33:26Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "May be also add a point for relays to make congestion response decisions.",
              "createdAt": "2023-05-05T16:33:25Z",
              "updatedAt": "2023-05-05T16:33:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5UWQcK",
          "commit": {
            "abbreviatedOid": "ba3c4ca"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-05T16:44:40Z",
          "updatedAt": "2023-05-05T16:44:47Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "I would be happy to see this merged either way. ",
              "createdAt": "2023-05-05T16:44:40Z",
              "updatedAt": "2023-05-05T16:44:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5UWXJQ",
          "commit": {
            "abbreviatedOid": "ba3c4ca"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-05T17:05:56Z",
          "updatedAt": "2023-05-05T17:05:56Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Oh yeah I forgot about this section.",
              "createdAt": "2023-05-05T17:05:56Z",
              "updatedAt": "2023-05-05T17:05:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5UWbM5",
          "commit": {
            "abbreviatedOid": "6fe74a6"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-05T17:15:14Z",
          "updatedAt": "2023-05-05T17:15:14Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5UWbRm",
          "commit": {
            "abbreviatedOid": "6fe74a6"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-05T17:15:22Z",
          "updatedAt": "2023-05-05T17:15:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 148,
      "id": "PR_kwDOG2Ho4M5POmlK",
      "title": "Resolve object DISCUSS in object model",
      "url": "https://github.com/moq-wg/moq-transport/pull/148",
      "state": "MERGED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Removes a discuss in the object model, going with option 1.\r\n\r\nI do think we should add an atomic/incremental flag to OBJECT, so the relay can know when dropping an object early will cause an object to be full undecodable. But that's a separate discussion.",
      "createdAt": "2023-04-26T18:58:14Z",
      "updatedAt": "2023-05-05T17:06:17Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "c57d17cba99a0a76f76ac52ff2265a6fba53a20a",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "object-model",
      "headRefOid": "6c7e72da045a4b54de8b8068ae29218136af7228",
      "closedAt": "2023-05-05T17:06:12Z",
      "mergedAt": "2023-05-05T17:06:12Z",
      "mergedBy": "kixelated",
      "mergeCommit": {
        "oid": "a52c36ce5693e68822aaf6295e2d6b14a2f96cb0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5Tm9aY",
          "commit": {
            "abbreviatedOid": "8fa0c93"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Editorial suggestions",
          "createdAt": "2023-04-26T20:01:34Z",
          "updatedAt": "2023-04-26T20:07:16Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Maybe 'decode a partially received object' ?",
              "createdAt": "2023-04-26T20:01:34Z",
              "updatedAt": "2023-04-26T20:07:16Z"
            },
            {
              "originalPosition": 20,
              "body": "A sender SHOULD transmit partial object data as soon as possible to avoid incurring additional latency.",
              "createdAt": "2023-04-26T20:04:16Z",
              "updatedAt": "2023-04-26T20:07:16Z"
            },
            {
              "originalPosition": 21,
              "body": "The meaning of 'remainder' is unclear - remainder after what?  Maybe:\r\n\r\nA sender MAY drop or deprioritize object data during congestion, potentially rendering an object undecodable in favor of a higher priority object.",
              "createdAt": "2023-04-26T20:06:29Z",
              "updatedAt": "2023-04-26T20:07:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TnAtI",
          "commit": {
            "abbreviatedOid": "8fa0c93"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-26T20:08:57Z",
          "updatedAt": "2023-04-26T20:08:57Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "We lost the statement 'All objects belong to a group' - which I think was providing some value.  Maybe put it first like:\r\n\r\nAll objects belong to a group.  An object MAY depend on other objects in the same group.",
              "createdAt": "2023-04-26T20:08:57Z",
              "updatedAt": "2023-04-26T20:08:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Toh0Y",
          "commit": {
            "abbreviatedOid": "8fa0c93"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-04-27T04:01:05Z",
          "updatedAt": "2023-04-27T04:13:41Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "+1 to @afrind  suggestion on ``` All objects belong to a group. An object MAY depend on other objects in the same group.```\r\n\r\nAlso , I think we still need it to be cacheable unit too,  since it will give Relays unit of caching as objects and can support object queries to be served from cache",
              "createdAt": "2023-04-27T04:01:05Z",
              "updatedAt": "2023-04-27T04:13:42Z"
            },
            {
              "originalPosition": 15,
              "body": "+1 on \"MUST NOT combine, split, or otherwise modify object payloads\"",
              "createdAt": "2023-04-27T04:02:16Z",
              "updatedAt": "2023-04-27T04:13:41Z"
            },
            {
              "originalPosition": 19,
              "body": "per our 1:1 chat at IETF116, we agreed to not mention anything about partially decodable property. I would prefer removing this line altogether. I think it is application way to define object granularity ( GOP vs single frame, for example) and they know if they are partially decodable or not.",
              "createdAt": "2023-04-27T04:04:22Z",
              "updatedAt": "2023-04-27T04:13:41Z"
            },
            {
              "originalPosition": 20,
              "body": "Again, I will remove this sentence and not useful for the data model section and also \"partial\" is not well defined.  \r\n\r\nHow about we have something on these lines \r\n\"Latency sensitive applications using moq-transport MAY choose not to wait for the object to be fully constructed before transmitting. The mechanisms of how the parts of the objects are identified at the receiver is defined by the application\" ",
              "createdAt": "2023-04-27T04:12:03Z",
              "updatedAt": "2023-04-27T04:13:41Z"
            },
            {
              "originalPosition": 21,
              "body": "I am not sure this level of detail is needed in data model section",
              "createdAt": "2023-04-27T04:13:10Z",
              "updatedAt": "2023-04-27T04:13:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Ts3lx",
          "commit": {
            "abbreviatedOid": "8fa0c93"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Individual review/editorial",
          "createdAt": "2023-04-27T14:52:16Z",
          "updatedAt": "2023-04-27T15:00:44Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I suppose it's fine to remove.  There is nothing that prevents the receiver from doing whatever they want with the bits they receive, so this MAY is implicit.",
              "createdAt": "2023-04-27T14:52:16Z",
              "updatedAt": "2023-04-27T15:00:44Z"
            },
            {
              "originalPosition": 20,
              "body": "> Latency sensitive applications using moq-transport MAY choose not to wait for the object to be fully constructed before transmitting.\r\n\r\nThis would work for me too, although the statement is largely aimed at relays, rather than endpoints.  I'm guessing Luke was trying to be generic with \"sender\" but maybe spelling out the relay bit is also useful, like \r\n\r\n\"A relay does not have to wait to receive a full object before forwarding object data.  A relay SHOULD forward any received object data as soon as possible\"\r\n\r\nThen again, we could save that for the relay section.",
              "createdAt": "2023-04-27T14:56:21Z",
              "updatedAt": "2023-04-27T15:00:44Z"
            },
            {
              "originalPosition": 21,
              "body": "+1 @suhasHere - we can defer this to the priority section.",
              "createdAt": "2023-04-27T14:58:23Z",
              "updatedAt": "2023-04-27T15:00:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TtY7P",
          "commit": {
            "abbreviatedOid": "8fa0c93"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-27T15:58:11Z",
          "updatedAt": "2023-04-27T15:58:12Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "yeah and we can't know at the transport layer anyways .. All we know is object has a address and it carries some properties to help relays reacting to congestion and optionally can be cached and retrieved by their address.\r\n",
              "createdAt": "2023-04-27T15:58:11Z",
              "updatedAt": "2023-04-27T15:58:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TtZ-A",
          "commit": {
            "abbreviatedOid": "8fa0c93"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-27T16:00:27Z",
          "updatedAt": "2023-04-27T16:00:27Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "in my intent above, i was thinking of just the end-points and hence used the word Applications.  I agree we can add a section on relays above too.",
              "createdAt": "2023-04-27T16:00:27Z",
              "updatedAt": "2023-04-27T16:00:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TveWg",
          "commit": {
            "abbreviatedOid": "8fa0c93"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-27T21:50:44Z",
          "updatedAt": "2023-04-27T22:55:13Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "> We lost the statement 'All objects belong to a group' - which I think was providing some value. Maybe put it first like:\r\n> \r\n> All objects belong to a group. An object MAY depend on other objects in the same group.\r\n\r\nI'm good starting with \"All objects belong to a group\".\r\n\r\nThe group dependency stuff is tougher. \"An object MAY depend on other objects in the same group\" is so weak that it means nothing. I think we remove it and link to the group section of the object model.",
              "createdAt": "2023-04-27T21:50:44Z",
              "updatedAt": "2023-04-27T22:55:13Z"
            },
            {
              "originalPosition": 19,
              "body": "I'm fine removing this mention. There should be some mention that objects should be streamed and can be truncated, but it can go elsewhere.",
              "createdAt": "2023-04-27T21:52:57Z",
              "updatedAt": "2023-04-27T22:55:13Z"
            },
            {
              "originalPosition": 20,
              "body": "> This would work for me too, although the statement is largely aimed at relays, rather than endpoints. I'm guessing Luke was trying to be generic with \"sender\" but maybe spelling out the relay bit is also useful, like\r\n\r\nI want to make sure that MoQ libraries support streaming objects too. The intention is to signal that generic libraries and endpoints should not buffer objects.\r\n\r\nbad: `send_object(id: int, payload: bytes)`\r\ngood: `start_object(id: int); write(chunk: bytes); write(chunk: bytes)`\r\n\r\n> in my intent above, i was thinking of just the end-points and hence used the word Applications.\r\n\r\nI only think of the \"application\" as the first and last hop. A generic relay has no idea that an application is \"latency sensitive\", and can't change its behavior in response.\r\n\r\n\r\n> I will remove this sentence and not useful for the data model section and also \"partial\" is not well defined.\r\n\r\nI want OBJECTs to behave like QUIC streams, where they could be used for both incremental (partially buffered) and atomic (fully buffered) purposes. I think it's important to clarify that somehow. ",
              "createdAt": "2023-04-27T22:09:27Z",
              "updatedAt": "2023-04-27T22:55:13Z"
            },
            {
              "originalPosition": 21,
              "body": "I think it's important to mention that an object might not be delivered, without going into detail. Although we can remove stuff about partial objects because those fall into the same \"might not be (fully) delivered\" bucket.",
              "createdAt": "2023-04-27T22:12:57Z",
              "updatedAt": "2023-04-27T22:55:13Z"
            },
            {
              "originalPosition": 8,
              "body": "> Also , I think we still need it to be cacheable unit too, since it will give Relays unit of caching as objects and can support object queries to be served from cache\r\n\r\nI just don't know what \"cacheable\" means. I think it's fair to say that an object is addressable and that TTL is an example property. But otherwise, I don't think anything is being added by including that word.",
              "createdAt": "2023-04-27T22:38:24Z",
              "updatedAt": "2023-04-27T22:55:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5T0rZZ",
          "commit": {
            "abbreviatedOid": "962308e"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-28T17:10:07Z",
          "updatedAt": "2023-04-28T17:10:07Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "or *be* dropped",
              "createdAt": "2023-04-28T17:10:07Z",
              "updatedAt": "2023-04-28T17:10:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5UR2Fj",
          "commit": {
            "abbreviatedOid": "6c7e72d"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-04T21:43:40Z",
          "updatedAt": "2023-05-04T21:43:40Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5UWO-2",
          "commit": {
            "abbreviatedOid": "6c7e72d"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-05T16:41:27Z",
          "updatedAt": "2023-05-05T16:41:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 149,
      "id": "PR_kwDOG2Ho4M5PU8fH",
      "title": "Text expressing the lack of consensus for send order and priorities.",
      "url": "https://github.com/moq-wg/moq-transport/pull/149",
      "state": "MERGED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "During the last editors meeting, we decided to not try to resolve the discussions on congestion and priorities\r\nbefore draft adoption, and I was asked to propose text to that effect. This PR adds text expressing our lack of consensus on send order versus priorities.\r\n\r\n",
      "createdAt": "2023-04-27T19:17:41Z",
      "updatedAt": "2023-04-28T17:06:08Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "c57d17cba99a0a76f76ac52ff2265a6fba53a20a",
      "headRepository": null,
      "headRefName": "order-or-priorities",
      "headRefOid": "1b4457f3a403d237c06d38408cd620ef1fee28a9",
      "closedAt": "2023-04-28T17:06:08Z",
      "mergedAt": "2023-04-28T17:06:08Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "cbba324c0654d9d40f5106440af805e50df56278"
      },
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@suhasHere I tried to keep the PR minimal -- minimal text so the draft can be adopted without waiting for a consensus on handling of congestion.  I think that we can worry about moving sections around after the draft is adopted.",
          "createdAt": "2023-04-28T04:34:10Z",
          "updatedAt": "2023-04-28T04:34:10Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5TvSPL",
          "commit": {
            "abbreviatedOid": "1dc00e7"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-27T21:25:58Z",
          "updatedAt": "2023-04-27T21:25:58Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5Tvdog",
          "commit": {
            "abbreviatedOid": "1dc00e7"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "this looks like a good start on this topic and we should merge it.\r\n\r\none small nit, should we move sendOrder and priorities under Section 7 ?",
          "createdAt": "2023-04-27T21:49:18Z",
          "updatedAt": "2023-04-27T21:49:18Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5Tvnsb",
          "commit": {
            "abbreviatedOid": "1dc00e7"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-27T22:27:03Z",
          "updatedAt": "2023-04-27T22:29:24Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "an explicit",
              "createdAt": "2023-04-27T22:27:03Z",
              "updatedAt": "2023-04-27T22:29:24Z"
            },
            {
              "originalPosition": 41,
              "body": "always sent",
              "createdAt": "2023-04-27T22:28:55Z",
              "updatedAt": "2023-04-27T22:29:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TwcBE",
          "commit": {
            "abbreviatedOid": "1dc00e7"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-28T04:28:19Z",
          "updatedAt": "2023-04-28T04:28:19Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Fixed.",
              "createdAt": "2023-04-28T04:28:19Z",
              "updatedAt": "2023-04-28T04:28:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5TwcCp",
          "commit": {
            "abbreviatedOid": "1dc00e7"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-28T04:28:30Z",
          "updatedAt": "2023-04-28T04:28:30Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Fixed.",
              "createdAt": "2023-04-28T04:28:30Z",
              "updatedAt": "2023-04-28T04:28:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5T0pmG",
          "commit": {
            "abbreviatedOid": "1b4457f"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-28T17:04:13Z",
          "updatedAt": "2023-04-28T17:04:50Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Remove this TODO?",
              "createdAt": "2023-04-28T17:04:13Z",
              "updatedAt": "2023-04-28T17:04:50Z"
            }
          ]
        }
      ]
    },
    {
      "number": 155,
      "id": "PR_kwDOG2Ho4M5QqNTj",
      "title": "116 relay subscribes + Publishes - Rebased",
      "url": "https://github.com/moq-wg/moq-transport/pull/155",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-16T23:09:25Z",
      "updatedAt": "2023-05-17T02:22:08Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "41c947f3e3ead6856491d00d42c50c7e1c112203",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "116-relay-subscribes",
      "headRefOid": "bf00ff85ce5dc6db6c524aa62502a896e42a83c9",
      "closedAt": "2023-05-17T02:21:22Z",
      "mergedAt": "2023-05-17T02:21:22Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "37b20a8b0a9a1f88025a33370ed28c493d4866a5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5VNdcw",
          "commit": {
            "abbreviatedOid": "38f2730"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-16T23:53:48Z",
          "updatedAt": "2023-05-16T23:53:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 156,
      "id": "PR_kwDOG2Ho4M5Qws1I",
      "title": "Remove any references to media.",
      "url": "https://github.com/moq-wg/moq-transport/pull/156",
      "state": "MERGED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Going to be moved to another draft that uses tracks.\r\nWill rename the file to `draft-moq-transport` after this gets merged.",
      "createdAt": "2023-05-17T23:10:47Z",
      "updatedAt": "2023-05-21T23:37:29Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "37b20a8b0a9a1f88025a33370ed28c493d4866a5",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "transport-base",
      "headRefOid": "8d37f03f25aabfc9c26cd59267db01ff43e3be54",
      "closedAt": "2023-05-21T23:37:25Z",
      "mergedAt": "2023-05-21T23:37:25Z",
      "mergedBy": "kixelated",
      "mergeCommit": {
        "oid": "5d0d4a5e23274a15b58956572031138217c71653"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5VV2sT",
          "commit": {
            "abbreviatedOid": "3e9742b"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-17T23:21:56Z",
          "updatedAt": "2023-05-17T23:27:44Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "I'm not sure this is necessarily true -- you can have multiple WT sessions on a QUIC connection, for instance.  Was there anything wrong specifically with the old transport session definition?",
              "createdAt": "2023-05-17T23:21:56Z",
              "updatedAt": "2023-05-17T23:27:44Z"
            },
            {
              "originalPosition": 110,
              "body": "\"Publisher is an endpoint that publishes\" -- that is a bit of a circular definition.  Maybe, since we always require subscribing, we could use something along the lines of \"publisher is an endpoint that fulfills the subscription requests and sends objects?\"",
              "createdAt": "2023-05-17T23:24:52Z",
              "updatedAt": "2023-05-17T23:27:44Z"
            },
            {
              "originalPosition": 148,
              "body": "I feel like \"a live stream\" is ambiguous.  A sequence of objects?  A stream of objects?  A feed of objects?",
              "createdAt": "2023-05-17T23:26:52Z",
              "updatedAt": "2023-05-17T23:27:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5VV35j",
          "commit": {
            "abbreviatedOid": "3e9742b"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for the PR .. Few nits on terminology and suggestions on some.",
          "createdAt": "2023-05-17T23:30:19Z",
          "updatedAt": "2023-05-17T23:44:13Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "I would either refer to the terminology defined in https://datatracker.ietf.org/doc/html/draft-nandakumar-moq-arch-00#section-2 or copy over some the roles driven terminology.\r\n\r\nSince there is security role played by each entity within the protocol and it will be good to define along those lines.",
              "createdAt": "2023-05-17T23:30:19Z",
              "updatedAt": "2023-05-17T23:45:17Z"
            },
            {
              "originalPosition": 158,
              "body": "group/object -> prefer add a reference to the model section",
              "createdAt": "2023-05-17T23:31:00Z",
              "updatedAt": "2023-05-17T23:44:13Z"
            },
            {
              "originalPosition": 181,
              "body": "i don't think the last statement is needed.",
              "createdAt": "2023-05-17T23:35:25Z",
              "updatedAt": "2023-05-17T23:44:14Z"
            },
            {
              "originalPosition": 208,
              "body": "Let's please add the examples back.",
              "createdAt": "2023-05-17T23:35:49Z",
              "updatedAt": "2023-05-17T23:44:14Z"
            },
            {
              "originalPosition": 253,
              "body": "s/live protocol/moq-transport protocol\r\n\r\nLive protocol seems bit ambigouos or partly defined.",
              "createdAt": "2023-05-17T23:37:16Z",
              "updatedAt": "2023-05-17T23:44:14Z"
            },
            {
              "originalPosition": 263,
              "body": "s/live media protocol/moq-transport protocol",
              "createdAt": "2023-05-17T23:37:39Z",
              "updatedAt": "2023-05-17T23:44:14Z"
            },
            {
              "originalPosition": 300,
              "body": "I feel by remove the term media, we are loosing clarity here.\r\nto scale a \"to scale a live media protocol \" is still fine. Media doesn't have to me audio or video. Or may be reword it as \"to scale a live content delivery transport\"\r\n",
              "createdAt": "2023-05-17T23:39:38Z",
              "updatedAt": "2023-05-17T23:44:14Z"
            },
            {
              "originalPosition": 516,
              "body": "A OBJECT message contains a byte slice or A OBJECT message contains chunk of application content ?",
              "createdAt": "2023-05-17T23:42:19Z",
              "updatedAt": "2023-05-17T23:48:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5VV8h1",
          "commit": {
            "abbreviatedOid": "3e9742b"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-17T23:46:57Z",
          "updatedAt": "2023-05-17T23:46:57Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Pleas rename WARP to MoQTransport .\r\n\r\ns/Warp - Live Transport over QUIC/MoQTransport - Live  Content Transport Protocol over QUIC",
              "createdAt": "2023-05-17T23:46:57Z",
              "updatedAt": "2023-05-17T23:46:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5VV3It",
          "commit": {
            "abbreviatedOid": "3e9742b"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Individual/editorial review",
          "createdAt": "2023-05-17T23:24:41Z",
          "updatedAt": "2023-05-18T01:23:21Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "> QUIC is used to objects over streams\r\n\r\nParse error",
              "createdAt": "2023-05-17T23:24:41Z",
              "updatedAt": "2023-05-18T01:23:21Z"
            },
            {
              "originalPosition": 4,
              "body": "I think the plan was to do that in the next PR, hence \"Will rename the file to draft-moq-transport after this gets merged.\"",
              "createdAt": "2023-05-18T00:55:00Z",
              "updatedAt": "2023-05-18T01:23:21Z"
            },
            {
              "originalPosition": 122,
              "body": "I prefer to bring in any definitions required rather than reference another document at this time.",
              "createdAt": "2023-05-18T00:56:59Z",
              "updatedAt": "2023-05-18T01:23:21Z"
            },
            {
              "originalPosition": 253,
              "body": "Since this is about motivation, I don't think using moq-transport-protocol here is necessary.  Maybe just\r\n\r\n`The speed at which the system can detect and respond...?`",
              "createdAt": "2023-05-18T01:05:13Z",
              "updatedAt": "2023-05-18T01:23:21Z"
            },
            {
              "originalPosition": 263,
              "body": "I think `live media protocol ecosystem` is correct here, or maybe just `media protocol ecosystem`",
              "createdAt": "2023-05-18T01:06:02Z",
              "updatedAt": "2023-05-18T01:23:21Z"
            },
            {
              "originalPosition": 280,
              "body": "This is not a sentence.",
              "createdAt": "2023-05-18T01:07:00Z",
              "updatedAt": "2023-05-18T01:23:21Z"
            },
            {
              "originalPosition": 289,
              "body": "s/base live transport/base transport protocol/ ?",
              "createdAt": "2023-05-18T01:10:49Z",
              "updatedAt": "2023-05-18T01:23:21Z"
            },
            {
              "originalPosition": 430,
              "body": "terminate the session.",
              "createdAt": "2023-05-18T01:15:24Z",
              "updatedAt": "2023-05-18T01:23:21Z"
            },
            {
              "originalPosition": 516,
              "body": "Byte slice came out of nowhere.  Maybe \r\n\r\n`An OBJECT message contains a range of contiguous bytes from a track, ...`\r\n\r\nThough this now begs the questions about whether Object metadata should also carry the offset into the track (maybe?, optionally?), and whether data from multiple OBJECTs can overlap (hopefully not).",
              "createdAt": "2023-05-18T01:21:10Z",
              "updatedAt": "2023-05-18T01:23:21Z"
            },
            {
              "originalPosition": 651,
              "body": "objects",
              "createdAt": "2023-05-18T01:22:36Z",
              "updatedAt": "2023-05-18T01:23:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5VWT0L",
          "commit": {
            "abbreviatedOid": "3e9742b"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-18T02:22:17Z",
          "updatedAt": "2023-05-18T02:22:18Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "The comment indicates file name rename .. May be my confusion?",
              "createdAt": "2023-05-18T02:22:17Z",
              "updatedAt": "2023-05-18T02:22:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Va5RF",
          "commit": {
            "abbreviatedOid": "3e9742b"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-18T17:16:43Z",
          "updatedAt": "2023-05-18T17:16:43Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "that would be fine too and also bringing something as informational reference shouldn't be bad either",
              "createdAt": "2023-05-18T17:16:43Z",
              "updatedAt": "2023-05-18T17:16:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Va5cf",
          "commit": {
            "abbreviatedOid": "3e9742b"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-18T17:17:14Z",
          "updatedAt": "2023-05-18T17:17:14Z",
          "comments": [
            {
              "originalPosition": 110,
              "body": "This is what is currently defined in the arch spec\r\n\"Entities with Publisher role publish MoQ Objects belonging to a given track using the MoQ Transport Protocol.\"\r\n\r\n\r\nSince MoQ Relays play role of Publisher/Subscriber where as send-recv endpoints play role of Publisher/ Subscriber/Emitter/Receiver.\r\n\r\n\r\n",
              "createdAt": "2023-05-18T17:17:14Z",
              "updatedAt": "2023-05-18T17:18:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Va7KE",
          "commit": {
            "abbreviatedOid": "3e9742b"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-18T17:22:09Z",
          "updatedAt": "2023-05-18T17:22:10Z",
          "comments": [
            {
              "originalPosition": 110,
              "body": "May be we can do it in its own PR. Created an issue to discuss the same here: https://github.com/kixelated/warp-draft/issues/157",
              "createdAt": "2023-05-18T17:22:09Z",
              "updatedAt": "2023-05-18T17:22:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5VjyRJ",
          "commit": {
            "abbreviatedOid": "3e9742b"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-20T20:29:30Z",
          "updatedAt": "2023-05-20T20:29:31Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "+1 one on getting all the definitions this draft needs into this draft. ",
              "createdAt": "2023-05-20T20:29:30Z",
              "updatedAt": "2023-05-20T20:29:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5VjyUg",
          "commit": {
            "abbreviatedOid": "3e9742b"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-20T20:32:57Z",
          "updatedAt": "2023-05-20T20:32:58Z",
          "comments": [
            {
              "originalPosition": 148,
              "body": "To help the reader understand, I think it would be useful to give and an example along lines of \"a track would often be used to represent a single stream of video, or audio\". Something that ties it back to media and helps the reader understand what this might be. ",
              "createdAt": "2023-05-20T20:32:57Z",
              "updatedAt": "2023-05-20T20:32:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5VjyVW",
          "commit": {
            "abbreviatedOid": "3e9742b"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-20T20:33:49Z",
          "updatedAt": "2023-05-20T20:33:50Z",
          "comments": [
            {
              "originalPosition": 154,
              "body": "Might be good to add in that a group is part of a single track. ",
              "createdAt": "2023-05-20T20:33:49Z",
              "updatedAt": "2023-05-20T20:33:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Vjyac",
          "commit": {
            "abbreviatedOid": "3e9742b"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-20T20:38:49Z",
          "updatedAt": "2023-05-20T20:38:49Z",
          "comments": [
            {
              "originalPosition": 226,
              "body": "FWIW ... in this section, I think it would be fine to talk about media instead of content but I am fine with it either way ",
              "createdAt": "2023-05-20T20:38:49Z",
              "updatedAt": "2023-05-20T20:38:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5VjztY",
          "commit": {
            "abbreviatedOid": "3e9742b"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-20T21:52:55Z",
          "updatedAt": "2023-05-20T21:52:56Z",
          "comments": [
            {
              "originalPosition": 414,
              "body": "I might rephrase this as something like .... \"Bufferbloat occurs when routers queue packets for too long instead of dropping the packet which can add significant latency.\"  ",
              "createdAt": "2023-05-20T21:52:55Z",
              "updatedAt": "2023-05-20T21:52:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5Vjzxh",
          "commit": {
            "abbreviatedOid": "3e9742b"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": " I added some small comments which can be incorporated or ignored as you see fit. I think this does a good job of the the main goal of moving th media part to  the other draft. ",
          "createdAt": "2023-05-20T21:57:40Z",
          "updatedAt": "2023-05-20T21:57:40Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5Vj0Iv",
          "commit": {
            "abbreviatedOid": "3e9742b"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-20T22:22:57Z",
          "updatedAt": "2023-05-20T22:30:04Z",
          "comments": [
            {
              "originalPosition": 226,
              "body": "I'd like to move this motivation section to an overview or requirements document, and yeah make it media-specific.",
              "createdAt": "2023-05-20T22:22:57Z",
              "updatedAt": "2023-05-20T22:30:04Z"
            },
            {
              "originalPosition": 208,
              "body": "Sorry, I got carried away.",
              "createdAt": "2023-05-20T22:24:16Z",
              "updatedAt": "2023-05-20T22:30:04Z"
            },
            {
              "originalPosition": 208,
              "body": "FYI the examples could be shorter.\r\n\r\n```\r\n/Users/kixelated/work/warp-draft/draft-lcurley-warp.xml(182): Warning: Artwork too wide, reducing indentation from 3 to 0\r\n/Users/kixelated/work/warp-draft/draft-lcurley-warp.xml(170): Warning: Section too wide, reducing indentation from 0 to 0\r\n/Users/kixelated/work/warp-draft/draft-lcurley-warp.xml(165): Warning: Section too wide, reducing indentation from 0 to 0\r\n/Users/kixelated/work/warp-draft/draft-lcurley-warp.xml(140): Warning: Section too wide, reducing indentation from 0 to 0\r\n/Users/kixelated/work/warp-draft/draft-lcurley-warp.xml(66): Warning: Middle too wide, reducing indentation from 0 to 0\r\ns/Users/kixelated/work/warp-draft/draft-lcurley-warp.xml(182): Warning: Too long line found (L286), 8 characters longer than 72 characters:\r\nTrack Namespace = videoconferencing.example.com/meetings/m123/participants/alice\r\n/Users/kixelated/work/warp-draft/draft-lcurley-warp.xml(182): Warning: Too long line found (L288), 14 characters longer than 72 characters:\r\nFull Track Name = videoconferencing.example.com/meetings/m123/participants/alice/audio\r\n```",
              "createdAt": "2023-05-20T22:29:31Z",
              "updatedAt": "2023-05-20T22:30:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5VkAis",
          "commit": {
            "abbreviatedOid": "3e9742b"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-21T09:32:53Z",
          "updatedAt": "2023-05-21T09:32:54Z",
          "comments": [
            {
              "originalPosition": 110,
              "body": "I agree, but I removed any changes to the definitions.",
              "createdAt": "2023-05-21T09:32:54Z",
              "updatedAt": "2023-05-21T09:33:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5VkA4l",
          "commit": {
            "abbreviatedOid": "3e9742b"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-21T09:43:52Z",
          "updatedAt": "2023-05-21T09:43:52Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "I removed any changes to the definitions because it was out of place.\r\n\r\noff-topic: I wouldn't define the producer as the entity with encryption keys, especially because that's optional. The producer's main role is to package live content into tracks/groups/objects. There should definitely be a note saying the producer SHOULD be the only entity with encryption keys, but that access does not define it.",
              "createdAt": "2023-05-21T09:43:52Z",
              "updatedAt": "2023-05-21T09:43:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5VkA6w",
          "commit": {
            "abbreviatedOid": "3e9742b"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-21T09:45:07Z",
          "updatedAt": "2023-05-21T09:45:07Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I made a separate PR to do the rename (#161), and it looks like Github can show the diff correctly.",
              "createdAt": "2023-05-21T09:45:07Z",
              "updatedAt": "2023-05-21T09:45:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5VkTr0",
          "commit": {
            "abbreviatedOid": "4cedeca"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-21T19:14:56Z",
          "updatedAt": "2023-05-21T19:14:56Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "As agreed on the authors call, lets keep the word \"media\" here",
              "createdAt": "2023-05-21T19:14:56Z",
              "updatedAt": "2023-05-21T19:14:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5VkTsT",
          "commit": {
            "abbreviatedOid": "4cedeca"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-21T19:15:20Z",
          "updatedAt": "2023-05-21T19:15:20Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "As agreed on the authors call, lets keep the word \"media\" here",
              "createdAt": "2023-05-21T19:15:20Z",
              "updatedAt": "2023-05-21T19:15:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5VkTtO",
          "commit": {
            "abbreviatedOid": "4cedeca"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-21T19:15:59Z",
          "updatedAt": "2023-05-21T19:16:00Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "As agreed on the authors call, lets keep the word \"media\" here",
              "createdAt": "2023-05-21T19:16:00Z",
              "updatedAt": "2023-05-21T19:16:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5VkTtu",
          "commit": {
            "abbreviatedOid": "4cedeca"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-21T19:16:20Z",
          "updatedAt": "2023-05-21T19:16:20Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "s/data/application content/",
              "createdAt": "2023-05-21T19:16:20Z",
              "updatedAt": "2023-05-21T19:16:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5VkTt7",
          "commit": {
            "abbreviatedOid": "4cedeca"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-21T19:16:31Z",
          "updatedAt": "2023-05-21T19:16:31Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "s/data/application content",
              "createdAt": "2023-05-21T19:16:31Z",
              "updatedAt": "2023-05-21T19:16:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5VkWD0",
          "commit": {
            "abbreviatedOid": "4cedeca"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-21T20:57:36Z",
          "updatedAt": "2023-05-21T20:57:37Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "duplicate text",
              "createdAt": "2023-05-21T20:57:36Z",
              "updatedAt": "2023-05-21T20:57:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5VkaKG",
          "commit": {
            "abbreviatedOid": "e480003"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-21T23:13:49Z",
          "updatedAt": "2023-05-21T23:13:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 161,
      "id": "PR_kwDOG2Ho4M5Q8-CL",
      "title": "Rename to MoQTransport",
      "url": "https://github.com/moq-wg/moq-transport/pull/161",
      "state": "MERGED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I'm not a fan of the capitalization, but it's better than the alternatives.",
      "createdAt": "2023-05-21T09:30:53Z",
      "updatedAt": "2023-05-21T23:36:30Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "transport-base",
      "baseRefOid": "e4800036454b6244f88a4057ccbf7cf187f796bc",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "transport-rename",
      "headRefOid": "ce857b517b92ad0864cfdf8fd509d1d216f32bd1",
      "closedAt": "2023-05-21T23:36:25Z",
      "mergedAt": "2023-05-21T23:36:25Z",
      "mergedBy": "kixelated",
      "mergeCommit": {
        "oid": "8d37f03f25aabfc9c26cd59267db01ff43e3be54"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5VkJKw",
          "commit": {
            "abbreviatedOid": "e1bf749"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2023-05-21T13:26:51Z",
          "updatedAt": "2023-05-21T13:26:51Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5VkR_M",
          "commit": {
            "abbreviatedOid": "e1bf749"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-21T18:08:36Z",
          "updatedAt": "2023-05-21T18:08:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 162,
      "id": "PR_kwDOG2Ho4M5RL_jM",
      "title": "Update the section on track naming",
      "url": "https://github.com/moq-wg/moq-transport/pull/162",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Introduce the notion of MoQ scope.\r\nRequire that the full track name is the sole name for the track.\r\n\r\nCloses #160",
      "createdAt": "2023-05-23T21:58:25Z",
      "updatedAt": "2023-05-24T19:05:46Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "5d0d4a5e23274a15b58956572031138217c71653",
      "headRepository": "vasilvv/warp-draft",
      "headRefName": "track-name-scope",
      "headRefOid": "4279e5b2ec5872bd8d71e55ce39afb6c115e61c9",
      "closedAt": "2023-05-24T19:05:45Z",
      "mergedAt": "2023-05-24T19:05:45Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "f6c3449cb8a23fb7f1ed174af4db63806107fbd8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5V3zEv",
          "commit": {
            "abbreviatedOid": "9fd04e6"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Please coordinate with Will to minimize merge hassle with the forthcoming editorial PR(s).",
          "createdAt": "2023-05-23T23:17:45Z",
          "updatedAt": "2023-05-23T23:22:53Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "To clarify, all MoQ servers with the same connection URI share a single scope.  Some MoQ servers with different connection URIs MAY share the same scope. Is that right?  Can a MoQ server with a single connection URI belong to more than one scope?",
              "createdAt": "2023-05-23T23:17:46Z",
              "updatedAt": "2023-05-23T23:22:54Z"
            },
            {
              "originalPosition": 28,
              "body": "have to have -> MUST have ?",
              "createdAt": "2023-05-23T23:18:41Z",
              "updatedAt": "2023-05-23T23:22:54Z"
            },
            {
              "originalPosition": 9,
              "body": "ANNOUNCE only announces a namespace (though is that a problem?  Can you announce a single track?), therefore I don't understand what it means that tracks to have to be announced atomically -- that's the only way to do it, right?",
              "createdAt": "2023-05-23T23:21:46Z",
              "updatedAt": "2023-05-23T23:22:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5V3_-T",
          "commit": {
            "abbreviatedOid": "9fd04e6"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-23T23:48:40Z",
          "updatedAt": "2023-05-23T23:48:40Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "I don't think we even need to say the above.  How about\r\n\r\nThe full track name is the only piece of information that is used to identify the track within a given scope and  used as  a key for caching. ",
              "createdAt": "2023-05-23T23:48:40Z",
              "updatedAt": "2023-05-23T23:48:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5V4A-7",
          "commit": {
            "abbreviatedOid": "9fd04e6"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-23T23:55:03Z",
          "updatedAt": "2023-05-23T23:55:04Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "i don't think we need to mention about ANNOUNCE in the object model section ?",
              "createdAt": "2023-05-23T23:55:03Z",
              "updatedAt": "2023-05-23T23:55:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5V4CRi",
          "commit": {
            "abbreviatedOid": "9fd04e6"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks Victor for the PR. I have few suggestions and happy to discuss live if needed. please let me know . ",
          "createdAt": "2023-05-24T00:04:03Z",
          "updatedAt": "2023-05-24T00:04:59Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "my interpretation of moq-scope was   **\"Set of application servers and relays for which there is uniqueness guarantee for a  given full track name.\"**\r\n\r\nThen, the following also holds (has some slight modifications from the PR )\r\n\r\n\"Within a moq-scoppe, subscribing to the same full track name would result in the subscriber receiving media for the same track. It is up to the application building on top of MoQ to define how broad or narrow the scope has to be. An application that deals with connections between devices on a local network may limit the scope to a single connection (identified via the connection url); by contrast, an application that uses multiple CDNs to serve media may require the scope to include all of those CDNs.\r\n\r\n",
              "createdAt": "2023-05-24T00:04:03Z",
              "updatedAt": "2023-05-24T00:04:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5V4htt",
          "commit": {
            "abbreviatedOid": "9fd04e6"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T03:31:50Z",
          "updatedAt": "2023-05-24T03:31:50Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "editoria , s/scope/moq-scope",
              "createdAt": "2023-05-24T03:31:50Z",
              "updatedAt": "2023-05-24T03:31:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5V-uIo",
          "commit": {
            "abbreviatedOid": "9fd04e6"
          },
          "author": "kpugin",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T18:17:41Z",
          "updatedAt": "2023-05-24T18:17:41Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "'full track name' here means namespace + track name?",
              "createdAt": "2023-05-24T18:17:41Z",
              "updatedAt": "2023-05-24T18:17:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5V-ueu",
          "commit": {
            "abbreviatedOid": "9fd04e6"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T18:18:43Z",
          "updatedAt": "2023-05-24T18:18:50Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": " I would rather remove the \"/\" and just have Track Namespace and Track Name be binary blogs that are concatenated. ",
              "createdAt": "2023-05-24T18:18:43Z",
              "updatedAt": "2023-05-24T18:18:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5V-2WE",
          "commit": {
            "abbreviatedOid": "9fd04e6"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T18:40:06Z",
          "updatedAt": "2023-05-24T18:40:06Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Changed sentence to discuss uniqueness guarantee.",
              "createdAt": "2023-05-24T18:40:06Z",
              "updatedAt": "2023-05-24T18:40:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5V-2aR",
          "commit": {
            "abbreviatedOid": "9fd04e6"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T18:40:17Z",
          "updatedAt": "2023-05-24T18:40:17Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Removed this sentence.",
              "createdAt": "2023-05-24T18:40:17Z",
              "updatedAt": "2023-05-24T18:40:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5V-2vS",
          "commit": {
            "abbreviatedOid": "9fd04e6"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T18:41:17Z",
          "updatedAt": "2023-05-24T18:41:17Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Yes, see the sentence above (\"A tuple of a track name and a track namespace together is known as *a full track name*\")",
              "createdAt": "2023-05-24T18:41:17Z",
              "updatedAt": "2023-05-24T18:41:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5V-3K6",
          "commit": {
            "abbreviatedOid": "9fd04e6"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T18:42:37Z",
          "updatedAt": "2023-05-24T18:42:37Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I agree, but I feel like we should address this as a separate PR (I have some other thoughts about syntax for this).",
              "createdAt": "2023-05-24T18:42:37Z",
              "updatedAt": "2023-05-24T18:42:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5V-4hi",
          "commit": {
            "abbreviatedOid": "9fd04e6"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T18:46:30Z",
          "updatedAt": "2023-05-24T18:46:31Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "I agree that we don't need it, but I feel like this might be easier to understand what this requirement means if we explain it in terms of what we are not going to do.",
              "createdAt": "2023-05-24T18:46:30Z",
              "updatedAt": "2023-05-24T18:46:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5V-4jn",
          "commit": {
            "abbreviatedOid": "041f207"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "looks gud",
          "createdAt": "2023-05-24T18:46:36Z",
          "updatedAt": "2023-05-24T18:46:36Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5V-9VP",
          "commit": {
            "abbreviatedOid": "73cdbe2"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-24T18:59:32Z",
          "updatedAt": "2023-05-24T18:59:32Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5V-9fw",
          "commit": {
            "abbreviatedOid": "9eac066"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-24T18:59:51Z",
          "updatedAt": "2023-05-24T18:59:51Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5V-_ne",
          "commit": {
            "abbreviatedOid": "4279e5b"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-24T19:05:42Z",
          "updatedAt": "2023-05-24T19:05:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 163,
      "id": "PR_kwDOG2Ho4M5RNdQM",
      "title": "Editorial changes",
      "url": "https://github.com/moq-wg/moq-transport/pull/163",
      "state": "CLOSED",
      "author": "wilaw",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The purpose of this PR is to improve the readability, language and structure of the current draft, and to incorporate editorial  changes suggested by https://docs.google.com/document/d/1MAWoSJq7YM7AZ6y6TJqNGRcKwlhWlVOOfHxt8R5jwzQ . ",
      "createdAt": "2023-05-24T06:42:21Z",
      "updatedAt": "2023-05-26T18:20:52Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "8285147cf345eaa2cb1211a66a63c2dde6c11e6b",
      "headRepository": null,
      "headRefName": "patch-1",
      "headRefOid": "2fc770d3a80fc6f01c808d6dd6afe5f136807da5",
      "closedAt": "2023-05-26T18:20:51Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I pushed Will's latest changes on top of Victor's section moves into my repo and the non-moving deltas can be viewed here: https://github.com/kixelated/warp-draft/commit/3d5854c980e4a86ef37b1d162b08d997d5ac8b8f\r\n\r\nIf folks want me to create a PR for that I can.",
          "createdAt": "2023-05-25T02:52:00Z",
          "updatedAt": "2023-05-25T02:52:00Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "This was a great reference . Thanks for being here",
          "createdAt": "2023-05-26T18:20:51Z",
          "updatedAt": "2023-05-26T18:20:51Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5V8lzN",
          "commit": {
            "abbreviatedOid": "f054fdb"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T13:56:06Z",
          "updatedAt": "2023-05-24T13:56:07Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "s/MoQ/Transport/MoQTransport(moqt)",
              "createdAt": "2023-05-24T13:56:07Z",
              "updatedAt": "2023-05-24T13:56:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5V8mQC",
          "commit": {
            "abbreviatedOid": "f054fdb"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T13:56:29Z",
          "updatedAt": "2023-05-24T13:56:29Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "nit, prefer moqt over MoQT :-) ",
              "createdAt": "2023-05-24T13:56:29Z",
              "updatedAt": "2023-05-24T13:56:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5V8noD",
          "commit": {
            "abbreviatedOid": "f054fdb"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T13:57:27Z",
          "updatedAt": "2023-05-24T13:57:28Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "nit , QUIC network protocol --> QUIC Transport",
              "createdAt": "2023-05-24T13:57:27Z",
              "updatedAt": "2023-05-24T13:57:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5V9I5O",
          "commit": {
            "abbreviatedOid": "f054fdb"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T14:45:28Z",
          "updatedAt": "2023-05-24T14:45:29Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "probably just add ref to group section in the model ",
              "createdAt": "2023-05-24T14:45:28Z",
              "updatedAt": "2023-05-24T14:45:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5V9I9-",
          "commit": {
            "abbreviatedOid": "f054fdb"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "DISMISSED",
          "body": "Thanks Will for the PR. This is looking good\r\nI have few nits and some minor feedback on non-editorial changes. I think this seems pretty close. ",
          "createdAt": "2023-05-24T14:45:36Z",
          "updatedAt": "2023-05-25T03:24:20Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "probably just add ref to group section in the model ",
              "createdAt": "2023-05-24T14:45:36Z",
              "updatedAt": "2023-05-24T15:08:30Z"
            },
            {
              "originalPosition": 95,
              "body": "how about we just say this\r\n\"A native QUIC connection, or a WebTransport session\"",
              "createdAt": "2023-05-24T14:46:18Z",
              "updatedAt": "2023-05-24T15:08:30Z"
            },
            {
              "originalPosition": 119,
              "body": "I understand the text context here. But if end to end encryption is not available, then the object is also visible to the relays. Original text did address that fact, but not sure what is the best way though. \r\n\r\nSo i am fine with the changes too",
              "createdAt": "2023-05-24T14:48:25Z",
              "updatedAt": "2023-05-24T15:08:30Z"
            },
            {
              "originalPosition": 129,
              "body": "s/may/MAY",
              "createdAt": "2023-05-24T14:48:58Z",
              "updatedAt": "2023-05-24T15:08:30Z"
            },
            {
              "originalPosition": 145,
              "body": "I wonder, if we should revisit changes in this section to reflect Victor's PR #162  \r\nTwo options\r\n1. Revert the changes in this section, merge this PR and then PR #162 is done over it\r\n2. Get PR #162 in this PR\r\n\r\nJust to avoid dependency loop, my preference will be 1 though",
              "createdAt": "2023-05-24T14:53:26Z",
              "updatedAt": "2023-05-24T15:08:30Z"
            },
            {
              "originalPosition": 168,
              "body": "wondering, Why was connection url section deleted . Suggest revering this change",
              "createdAt": "2023-05-24T14:54:40Z",
              "updatedAt": "2023-05-24T16:51:14Z"
            },
            {
              "originalPosition": 279,
              "body": "PR #162  address this and namespace cannot be empty",
              "createdAt": "2023-05-24T14:55:15Z",
              "updatedAt": "2023-05-24T15:08:30Z"
            },
            {
              "originalPosition": 290,
              "body": "I think i understand the context behind his example, but this example is somewhat confusing. May be consider removing it ?",
              "createdAt": "2023-05-24T14:56:00Z",
              "updatedAt": "2023-05-24T16:07:11Z"
            },
            {
              "originalPosition": 483,
              "body": "Suggest: Proposal Send Order",
              "createdAt": "2023-05-24T15:01:59Z",
              "updatedAt": "2023-05-24T15:08:30Z"
            },
            {
              "originalPosition": 504,
              "body": "suggest Proposal Order by Priorities",
              "createdAt": "2023-05-24T15:02:20Z",
              "updatedAt": "2023-05-24T15:08:30Z"
            },
            {
              "originalPosition": 569,
              "body": "s/send order/ send order/priority",
              "createdAt": "2023-05-24T15:03:09Z",
              "updatedAt": "2023-05-24T15:08:30Z"
            },
            {
              "originalPosition": 568,
              "body": "s/send order/priority",
              "createdAt": "2023-05-24T15:03:23Z",
              "updatedAt": "2023-05-24T15:08:30Z"
            },
            {
              "originalPosition": 563,
              "body": "May be we should just add this reorg section into the above section as another sub-section. Since they both bring in values.\r\n\r\n",
              "createdAt": "2023-05-24T15:04:55Z",
              "updatedAt": "2023-05-24T15:08:30Z"
            },
            {
              "originalPosition": 721,
              "body": "typo ANNOUNCE",
              "createdAt": "2023-05-24T15:06:39Z",
              "updatedAt": "2023-05-24T15:08:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5V9Ugi",
          "commit": {
            "abbreviatedOid": "f054fdb"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks, this is a huge improvement in the flow of the document.\r\n\r\nLeft some editorial comments/questions.",
          "createdAt": "2023-05-24T15:03:52Z",
          "updatedAt": "2023-05-24T15:59:44Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "mapped",
              "createdAt": "2023-05-24T15:03:53Z",
              "updatedAt": "2023-05-24T15:59:44Z"
            },
            {
              "originalPosition": 67,
              "body": "I think sometimes we use endpoint to refer to either end of a QUIC connection -- transmission chain implies this means either the producer or consumer - is that right?",
              "createdAt": "2023-05-24T15:10:16Z",
              "updatedAt": "2023-05-24T15:59:45Z"
            },
            {
              "originalPosition": 71,
              "body": "Maybe a forward reference is ok, but I think that's not very common.  A short summary definition should appear here, maybe delete the third sentence.",
              "createdAt": "2023-05-24T15:11:53Z",
              "updatedAt": "2023-05-24T15:59:45Z"
            },
            {
              "originalPosition": 118,
              "body": "Did we keep this normative somewhere?  I think it's important.",
              "createdAt": "2023-05-24T15:14:15Z",
              "updatedAt": "2023-05-24T15:59:45Z"
            },
            {
              "originalPosition": 129,
              "body": "non-normative may not and may.\r\n\r\nmight not/can?",
              "createdAt": "2023-05-24T15:15:32Z",
              "updatedAt": "2023-05-24T15:59:45Z"
            },
            {
              "originalPosition": 140,
              "body": "nit: With groups I sometimes like \"one or more\" to indicate it's valid to have only a single group span a track.",
              "createdAt": "2023-05-24T15:42:05Z",
              "updatedAt": "2023-05-24T15:59:45Z"
            },
            {
              "originalPosition": 308,
              "body": "These are new normative requirements.  Should we take these to an issue first?",
              "createdAt": "2023-05-24T15:45:55Z",
              "updatedAt": "2023-05-24T15:59:45Z"
            },
            {
              "originalPosition": 389,
              "body": "This section describes stream cancellation rather than session cancellation, not sure where it belongs.",
              "createdAt": "2023-05-24T15:47:46Z",
              "updatedAt": "2023-05-24T15:59:45Z"
            },
            {
              "originalPosition": 447,
              "body": "Can we delete the \"having its own section\" bit?",
              "createdAt": "2023-05-24T15:49:23Z",
              "updatedAt": "2023-05-24T15:59:45Z"
            },
            {
              "originalPosition": 494,
              "body": "normative SHOULD?",
              "createdAt": "2023-05-24T15:51:29Z",
              "updatedAt": "2023-05-24T15:59:45Z"
            },
            {
              "originalPosition": 563,
              "body": "Maybe title the section \"Relay Object Handling\"?",
              "createdAt": "2023-05-24T15:54:32Z",
              "updatedAt": "2023-05-24T15:59:45Z"
            },
            {
              "originalPosition": 720,
              "body": "ANNOUNCE message",
              "createdAt": "2023-05-24T15:56:57Z",
              "updatedAt": "2023-05-24T15:59:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5V_Pk5",
          "commit": {
            "abbreviatedOid": "f054fdb"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T19:51:11Z",
          "updatedAt": "2023-05-24T19:51:11Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "For this draft, I am keeping the name consistent as MoQTransport , with an abbreviation of MoQT. Deviations from those two variants are bugs and should be highlighted. We can bikeshed the names post adoption. ",
              "createdAt": "2023-05-24T19:51:11Z",
              "updatedAt": "2023-05-24T19:51:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5V_Q0N",
          "commit": {
            "abbreviatedOid": "f054fdb"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T19:53:49Z",
          "updatedAt": "2023-05-24T19:53:49Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Keeping MoQT for consistency. We can change later. Updating QUIC network protocol --> QUIC Transport",
              "createdAt": "2023-05-24T19:53:49Z",
              "updatedAt": "2023-05-24T19:53:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5V_S8o",
          "commit": {
            "abbreviatedOid": "f054fdb"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T19:56:32Z",
          "updatedAt": "2023-05-24T19:56:32Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "Added ref to Object model section. ",
              "createdAt": "2023-05-24T19:56:32Z",
              "updatedAt": "2023-05-24T19:56:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5V_Tmt",
          "commit": {
            "abbreviatedOid": "f054fdb"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T19:57:40Z",
          "updatedAt": "2023-05-24T19:57:41Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "Change made. ",
              "createdAt": "2023-05-24T19:57:40Z",
              "updatedAt": "2023-05-24T19:57:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5V_123",
          "commit": {
            "abbreviatedOid": "f054fdb"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T21:50:50Z",
          "updatedAt": "2023-05-24T21:50:50Z",
          "comments": [
            {
              "originalPosition": 119,
              "body": "Updated text to reference that payload is not visible to relays if it is encrypted. ",
              "createdAt": "2023-05-24T21:50:50Z",
              "updatedAt": "2023-05-24T21:50:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5V_2SG",
          "commit": {
            "abbreviatedOid": "f054fdb"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T21:52:41Z",
          "updatedAt": "2023-05-24T21:52:41Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "Changed to non-normative language - might/can.",
              "createdAt": "2023-05-24T21:52:41Z",
              "updatedAt": "2023-05-24T21:52:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5V_39O",
          "commit": {
            "abbreviatedOid": "f054fdb"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T22:00:06Z",
          "updatedAt": "2023-05-24T22:00:06Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "Deleted third sentence, as this is just a summary of object characteristics. ",
              "createdAt": "2023-05-24T22:00:06Z",
              "updatedAt": "2023-05-24T22:00:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WAKQj",
          "commit": {
            "abbreviatedOid": "f054fdb"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T23:35:10Z",
          "updatedAt": "2023-05-24T23:35:10Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "Since PR#162 got merged after this comment was made, I am going to add Victor's text directly to #163. ",
              "createdAt": "2023-05-24T23:35:10Z",
              "updatedAt": "2023-05-24T23:35:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WAMl5",
          "commit": {
            "abbreviatedOid": "f054fdb"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T23:45:31Z",
          "updatedAt": "2023-05-24T23:45:31Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "Change reverted.",
              "createdAt": "2023-05-24T23:45:31Z",
              "updatedAt": "2023-05-24T23:45:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WAMzM",
          "commit": {
            "abbreviatedOid": "f054fdb"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T23:46:15Z",
          "updatedAt": "2023-05-24T23:46:15Z",
          "comments": [
            {
              "originalPosition": 279,
              "body": "Removing this example. We can add more examples back later. ",
              "createdAt": "2023-05-24T23:46:15Z",
              "updatedAt": "2023-05-24T23:46:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WAM2C",
          "commit": {
            "abbreviatedOid": "f054fdb"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T23:46:36Z",
          "updatedAt": "2023-05-24T23:46:37Z",
          "comments": [
            {
              "originalPosition": 290,
              "body": "Removing. Can add back later. ",
              "createdAt": "2023-05-24T23:46:36Z",
              "updatedAt": "2023-05-24T23:46:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WANHd",
          "commit": {
            "abbreviatedOid": "f054fdb"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T23:48:35Z",
          "updatedAt": "2023-05-24T23:48:35Z",
          "comments": [
            {
              "originalPosition": 483,
              "body": "Changed to \"Proposal - Send Order\"",
              "createdAt": "2023-05-24T23:48:35Z",
              "updatedAt": "2023-05-24T23:48:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WANav",
          "commit": {
            "abbreviatedOid": "f054fdb"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T23:50:33Z",
          "updatedAt": "2023-05-24T23:50:33Z",
          "comments": [
            {
              "originalPosition": 504,
              "body": "Changed to \"Proposal - Order by Priorities\"",
              "createdAt": "2023-05-24T23:50:33Z",
              "updatedAt": "2023-05-24T23:50:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WAOKp",
          "commit": {
            "abbreviatedOid": "f054fdb"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T23:56:02Z",
          "updatedAt": "2023-05-24T23:56:02Z",
          "comments": [
            {
              "originalPosition": 569,
              "body": "What change are you asking for here? ",
              "createdAt": "2023-05-24T23:56:02Z",
              "updatedAt": "2023-05-24T23:56:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WAOv4",
          "commit": {
            "abbreviatedOid": "f054fdb"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-24T23:59:57Z",
          "updatedAt": "2023-05-24T23:59:57Z",
          "comments": [
            {
              "originalPosition": 569,
              "body": "I think the ask might be to have the language generic for either priority proposal?",
              "createdAt": "2023-05-24T23:59:57Z",
              "updatedAt": "2023-05-24T23:59:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WAPj_",
          "commit": {
            "abbreviatedOid": "f054fdb"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-25T00:05:20Z",
          "updatedAt": "2023-05-25T00:05:20Z",
          "comments": [
            {
              "originalPosition": 563,
              "body": "Victor has generated a separate MOVE PR since this comment was made. Moving would disturb that.  So I'll leave for now and we can re-org later. ",
              "createdAt": "2023-05-25T00:05:20Z",
              "updatedAt": "2023-05-25T00:05:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WAQ3g",
          "commit": {
            "abbreviatedOid": "f054fdb"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-25T00:14:50Z",
          "updatedAt": "2023-05-25T00:14:50Z",
          "comments": [
            {
              "originalPosition": 569,
              "body": "Based on side chat, changed text to \"send order/priority\".",
              "createdAt": "2023-05-25T00:14:50Z",
              "updatedAt": "2023-05-25T00:14:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WASNe",
          "commit": {
            "abbreviatedOid": "f054fdb"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-25T00:24:50Z",
          "updatedAt": "2023-05-25T00:24:50Z",
          "comments": [
            {
              "originalPosition": 721,
              "body": "Fixed",
              "createdAt": "2023-05-25T00:24:50Z",
              "updatedAt": "2023-05-25T00:24:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WAST6",
          "commit": {
            "abbreviatedOid": "f054fdb"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-25T00:25:36Z",
          "updatedAt": "2023-05-25T00:25:36Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Fixed",
              "createdAt": "2023-05-25T00:25:36Z",
              "updatedAt": "2023-05-25T00:25:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WAS4I",
          "commit": {
            "abbreviatedOid": "f054fdb"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-25T00:30:05Z",
          "updatedAt": "2023-05-25T00:30:05Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "This language comes from the terminology document. I agree there is ambiguity and will add a TODO to refine the text with a consensus definition post adoption. ",
              "createdAt": "2023-05-25T00:30:05Z",
              "updatedAt": "2023-05-25T00:30:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WATqB",
          "commit": {
            "abbreviatedOid": "f054fdb"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-25T00:36:21Z",
          "updatedAt": "2023-05-25T00:36:21Z",
          "comments": [
            {
              "originalPosition": 118,
              "body": "It seemed out of place in the object model section, as it's a normative relay requirement. Anyhow, I have added it back and we can reassign it to relay section post adoption. ",
              "createdAt": "2023-05-25T00:36:21Z",
              "updatedAt": "2023-05-25T00:36:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WAT1B",
          "commit": {
            "abbreviatedOid": "f054fdb"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-25T00:37:46Z",
          "updatedAt": "2023-05-25T00:37:47Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "Replaced with \"A new subscriber might not want to receive the entire track, and can instead opt to receive only the latest group(s).\"",
              "createdAt": "2023-05-25T00:37:46Z",
              "updatedAt": "2023-05-25T00:37:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WAUFX",
          "commit": {
            "abbreviatedOid": "f054fdb"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-25T00:39:29Z",
          "updatedAt": "2023-05-25T00:39:29Z",
          "comments": [
            {
              "originalPosition": 140,
              "body": "Added \"one or more\".",
              "createdAt": "2023-05-25T00:39:29Z",
              "updatedAt": "2023-05-25T00:39:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WAWf3",
          "commit": {
            "abbreviatedOid": "f054fdb"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-25T00:58:31Z",
          "updatedAt": "2023-05-25T00:58:32Z",
          "comments": [
            {
              "originalPosition": 308,
              "body": "yes, I have deleted this text. I will open up an issue to ask for normative catalog requirements. \r\n",
              "createdAt": "2023-05-25T00:58:32Z",
              "updatedAt": "2023-05-25T00:58:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WAXFw",
          "commit": {
            "abbreviatedOid": "f054fdb"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-25T01:02:48Z",
          "updatedAt": "2023-05-25T01:02:48Z",
          "comments": [
            {
              "originalPosition": 389,
              "body": "We need a new section on the mechanics (or workflow) of sending data between nodes. I think this text should go there. But rather than deleting it, I am leaving it where it is and we can add the new section and then move it later. I added a TODO to this effect. ",
              "createdAt": "2023-05-25T01:02:48Z",
              "updatedAt": "2023-05-25T01:02:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WAXVu",
          "commit": {
            "abbreviatedOid": "f054fdb"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-25T01:04:25Z",
          "updatedAt": "2023-05-25T01:04:26Z",
          "comments": [
            {
              "originalPosition": 447,
              "body": "Yes",
              "createdAt": "2023-05-25T01:04:26Z",
              "updatedAt": "2023-05-25T01:04:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WAYI_",
          "commit": {
            "abbreviatedOid": "f054fdb"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-25T01:09:11Z",
          "updatedAt": "2023-05-25T01:09:11Z",
          "comments": [
            {
              "originalPosition": 494,
              "body": "Yes",
              "createdAt": "2023-05-25T01:09:11Z",
              "updatedAt": "2023-05-25T01:09:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WAY49",
          "commit": {
            "abbreviatedOid": "f054fdb"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-25T01:14:09Z",
          "updatedAt": "2023-05-25T01:14:10Z",
          "comments": [
            {
              "originalPosition": 563,
              "body": "Change made. ",
              "createdAt": "2023-05-25T01:14:10Z",
              "updatedAt": "2023-05-25T01:14:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WAY9N",
          "commit": {
            "abbreviatedOid": "f054fdb"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-25T01:14:37Z",
          "updatedAt": "2023-05-25T01:14:37Z",
          "comments": [
            {
              "originalPosition": 720,
              "body": "Already fixed after Suhas comment. ",
              "createdAt": "2023-05-25T01:14:37Z",
              "updatedAt": "2023-05-25T01:14:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WArda",
          "commit": {
            "abbreviatedOid": "597c046"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "The new changes does address the comments i had. \r\nI wonder if we can replace MoqT to moqt or use MoQTransport instead of MoqT.",
          "createdAt": "2023-05-25T03:23:58Z",
          "updatedAt": "2023-05-25T03:23:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 164,
      "id": "PR_kwDOG2Ho4M5RSQrx",
      "title": "Move-only parts of #163",
      "url": "https://github.com/moq-wg/moq-transport/pull/164",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR only contains:\r\n\r\n- Pure moves\r\n- Updating header depth (i.e. changing the number of `#`s)\r\n\r\nHopefully this would make review of #163 easier.",
      "createdAt": "2023-05-24T20:27:39Z",
      "updatedAt": "2023-05-26T17:15:03Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "f6c3449cb8a23fb7f1ed174af4db63806107fbd8",
      "headRepository": "vasilvv/warp-draft",
      "headRefName": "editorial-moves",
      "headRefOid": "2d3b2a2d4fcd2148ebb868e0037f94bb9789b7b7",
      "closedAt": "2023-05-26T17:15:03Z",
      "mergedAt": "2023-05-26T17:15:03Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "2d3b2a2d4fcd2148ebb868e0037f94bb9789b7b7"
      },
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "(I am not saying I found all of the moves, but this has the four ones that were detected with the tooling I have)",
          "createdAt": "2023-05-24T20:28:20Z",
          "updatedAt": "2023-05-24T20:28:20Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is a big help. Before we start reviewing this, let me try and construct a set of PR that fully recreate exactly the changes in 163 - should have done sometime late tonight ",
          "createdAt": "2023-05-24T21:50:12Z",
          "updatedAt": "2023-05-24T21:50:12Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Suhas created #167 to replace this so I can base my PR against that and everyone can easily find them. \r\n\r\nSo perhaps close this PR ",
          "createdAt": "2023-05-25T05:12:44Z",
          "updatedAt": "2023-05-25T05:12:44Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 165,
      "id": "PR_kwDOG2Ho4M5RSRlx",
      "title": "Move motivation to introduction",
      "url": "https://github.com/moq-wg/moq-transport/pull/165",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR moves the motivation related text into introduction section",
      "createdAt": "2023-05-24T20:31:27Z",
      "updatedAt": "2023-05-24T20:42:47Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "f6c3449cb8a23fb7f1ed174af4db63806107fbd8",
      "headRepository": "fluffy/warp-draft",
      "headRefName": "big-move",
      "headRefOid": "f7d81b8e7f152f674e72214212dd91812b064956",
      "closedAt": "2023-05-24T20:42:47Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 166,
      "id": "PR_kwDOG2Ho4M5RTR-_",
      "title": "Add Christian Huitema back",
      "url": "https://github.com/moq-wg/moq-transport/pull/166",
      "state": "MERGED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-25T02:48:00Z",
      "updatedAt": "2023-05-25T04:23:53Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "f6c3449cb8a23fb7f1ed174af4db63806107fbd8",
      "headRepository": "fluffy/warp-draft",
      "headRefName": "contrib",
      "headRefOid": "764410d13155676412ad90cdd36c28b2508492ef",
      "closedAt": "2023-05-25T04:23:53Z",
      "mergedAt": "2023-05-25T04:23:53Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "8285147cf345eaa2cb1211a66a63c2dde6c11e6b"
      },
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Since this change doesn't conflict with any ongoing PRs, I will merge it in.",
          "createdAt": "2023-05-25T04:23:48Z",
          "updatedAt": "2023-05-25T04:23:48Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5WAqzz",
          "commit": {
            "abbreviatedOid": "764410d"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-25T03:19:02Z",
          "updatedAt": "2023-05-25T03:19:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 167,
      "id": "PR_kwDOG2Ho4M5RToOF",
      "title": "Editorial moves",
      "url": "https://github.com/moq-wg/moq-transport/pull/167",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is just the same as Victors PR but on Luke's repo instead of Victor's repo to make it easy for review.",
      "createdAt": "2023-05-25T05:09:52Z",
      "updatedAt": "2023-05-26T17:08:16Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "8285147cf345eaa2cb1211a66a63c2dde6c11e6b",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "editorial-moves",
      "headRefOid": "2d3b2a2d4fcd2148ebb868e0037f94bb9789b7b7",
      "closedAt": "2023-05-26T17:08:16Z",
      "mergedAt": "2023-05-26T17:08:16Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "b846c6846e121d6de98123e8bd05e0c778b01ec4"
      },
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "lgtm - I assume Suhas' comments will be reflecting in some other PR - since the goal here is \"move only, no text changes\"",
          "createdAt": "2023-05-26T15:27:58Z",
          "updatedAt": "2023-05-26T15:27:58Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5WBAyz",
          "commit": {
            "abbreviatedOid": "2d3b2a2"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-25T05:27:06Z",
          "updatedAt": "2023-05-25T05:27:07Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "Delete the above TODO",
              "createdAt": "2023-05-25T05:27:06Z",
              "updatedAt": "2023-05-25T05:27:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WBA3d",
          "commit": {
            "abbreviatedOid": "2d3b2a2"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-25T05:27:28Z",
          "updatedAt": "2023-05-25T05:27:29Z",
          "comments": [
            {
              "originalPosition": 217,
              "body": "s/emitters/producers",
              "createdAt": "2023-05-25T05:27:28Z",
              "updatedAt": "2023-05-25T05:27:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WBA7R",
          "commit": {
            "abbreviatedOid": "2d3b2a2"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-25T05:27:46Z",
          "updatedAt": "2023-05-25T05:27:47Z",
          "comments": [
            {
              "originalPosition": 227,
              "body": "Delete this line. We don't have any consensus on this",
              "createdAt": "2023-05-25T05:27:47Z",
              "updatedAt": "2023-05-25T05:27:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WOfA3",
          "commit": {
            "abbreviatedOid": "2d3b2a2"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-26T17:07:54Z",
          "updatedAt": "2023-05-26T17:07:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 168,
      "id": "PR_kwDOG2Ho4M5RTp0_",
      "title": "rewrite abstract",
      "url": "https://github.com/moq-wg/moq-transport/pull/168",
      "state": "MERGED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-25T05:17:59Z",
      "updatedAt": "2023-05-26T17:15:00Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "b846c6846e121d6de98123e8bd05e0c778b01ec4",
      "headRepository": "fluffy/warp-draft",
      "headRefName": "edit-a",
      "headRefOid": "7aa561e91ff05205496be892e88e8a5e344a7cf3",
      "closedAt": "2023-05-26T17:15:00Z",
      "mergedAt": "2023-05-26T17:15:00Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "1026997397801b55a483be1f3a96644e3a3901b4"
      },
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@kixelated I went ahead and pushed a commit fixing parts of abstract. Happy to revert if this doesn't capture the intent. Please let me know. Thanks",
          "createdAt": "2023-05-26T16:06:42Z",
          "updatedAt": "2023-05-26T16:06:42Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@kixelated  done and also removed the last sentence",
          "createdAt": "2023-05-26T17:06:17Z",
          "updatedAt": "2023-05-26T17:06:17Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5WBBya",
          "commit": {
            "abbreviatedOid": "a96ab92"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-25T05:32:03Z",
          "updatedAt": "2023-05-25T05:32:03Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WE0mF",
          "commit": {
            "abbreviatedOid": "a96ab92"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "The new text is super vague but that's fine for an abstract.",
          "createdAt": "2023-05-25T15:01:57Z",
          "updatedAt": "2023-05-25T15:03:34Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "> The core subscribable entities are tracks, consisting of a sequence of objects organized into groups.\r\n\r\nI wouldn't introduce terminology in the abstract. This sentence doesn't add anything or make me think \"boy I want to read more\". I think the PR is good if you remove this sentence.",
              "createdAt": "2023-05-25T15:01:57Z",
              "updatedAt": "2023-05-25T15:04:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WN4p3",
          "commit": {
            "abbreviatedOid": "a96ab92"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T15:29:16Z",
          "updatedAt": "2023-05-26T15:29:16Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "@kixelated do you need that line removed now or can you stamp?",
              "createdAt": "2023-05-26T15:29:16Z",
              "updatedAt": "2023-05-26T15:29:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WOdTu",
          "commit": {
            "abbreviatedOid": "66bd7c6"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "DISMISSED",
          "body": "Could you revert your changes Suhas? The previous commit was nice, I just wanted a sentence removed.",
          "createdAt": "2023-05-26T17:04:05Z",
          "updatedAt": "2023-05-26T17:10:49Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WOf2C",
          "commit": {
            "abbreviatedOid": "7aa561e"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-26T17:10:44Z",
          "updatedAt": "2023-05-26T17:13:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 169,
      "id": "PR_kwDOG2Ho4M5RTqBz",
      "title": "rewrite introduction",
      "url": "https://github.com/moq-wg/moq-transport/pull/169",
      "state": "MERGED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-25T05:19:12Z",
      "updatedAt": "2023-05-26T17:21:38Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "1026997397801b55a483be1f3a96644e3a3901b4",
      "headRepository": "fluffy/warp-draft",
      "headRefName": "edit-b",
      "headRefOid": "fcaf61f0d967c5f0a98efbaa8934df29683e7283",
      "closedAt": "2023-05-26T17:21:37Z",
      "mergedAt": "2023-05-26T17:21:37Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "d66eb85dcc682c2c1bd6b9c2753b172d5a9a3477"
      },
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@kixelated does the latest commit address your feedback? thanks",
          "createdAt": "2023-05-26T05:18:17Z",
          "updatedAt": "2023-05-26T05:18:17Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5WBB6A",
          "commit": {
            "abbreviatedOid": "d3fc53c"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks fine . It would be nice if editorial nits are addressed as you see appropriate",
          "createdAt": "2023-05-25T05:32:37Z",
          "updatedAt": "2023-05-25T05:33:38Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "s/MoQT/moqt/g",
              "createdAt": "2023-05-25T05:32:37Z",
              "updatedAt": "2023-05-25T05:33:38Z"
            },
            {
              "originalPosition": 13,
              "body": "live, interactive, as well as near-live ....",
              "createdAt": "2023-05-25T05:33:04Z",
              "updatedAt": "2023-05-25T05:33:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WE3FE",
          "commit": {
            "abbreviatedOid": "d3fc53c"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-05-25T15:07:00Z",
          "updatedAt": "2023-05-25T15:17:11Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "VOD is out of scope, as per the charter.",
              "createdAt": "2023-05-25T15:07:00Z",
              "updatedAt": "2023-05-25T15:17:11Z"
            },
            {
              "originalPosition": 16,
              "body": "Live mode?",
              "createdAt": "2023-05-25T15:07:44Z",
              "updatedAt": "2023-05-25T15:17:11Z"
            },
            {
              "originalPosition": 22,
              "body": "> congestion response\r\n\r\nThis draft is what relays implement, so I want congestion response to be in scope.",
              "createdAt": "2023-05-25T15:17:06Z",
              "updatedAt": "2023-05-25T15:17:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WF_UF",
          "commit": {
            "abbreviatedOid": "d3fc53c"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-25T18:03:28Z",
          "updatedAt": "2023-05-25T18:03:28Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "+1 ",
              "createdAt": "2023-05-25T18:03:28Z",
              "updatedAt": "2023-05-25T18:03:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WF_pk",
          "commit": {
            "abbreviatedOid": "d3fc53c"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-25T18:04:25Z",
          "updatedAt": "2023-05-25T18:04:26Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I would suggest we edit it as\r\n\r\n MoQT\r\nsupports live, interactive use-cases.\r\n\r\nI don;t understand near-live though ",
              "createdAt": "2023-05-25T18:04:26Z",
              "updatedAt": "2023-05-25T18:04:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WHvVJ",
          "commit": {
            "abbreviatedOid": "d3fc53c"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T02:03:30Z",
          "updatedAt": "2023-05-26T02:03:30Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I missed this, I agree we should pick some word other than \"live mode\"",
              "createdAt": "2023-05-26T02:03:30Z",
              "updatedAt": "2023-05-26T02:03:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WNO8M",
          "commit": {
            "abbreviatedOid": "8c16877"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "LGTM",
          "createdAt": "2023-05-26T14:05:34Z",
          "updatedAt": "2023-05-26T14:05:34Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WN5Ft",
          "commit": {
            "abbreviatedOid": "8c16877"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "lgtm modulo addressing Luke's comment.",
          "createdAt": "2023-05-26T15:30:12Z",
          "updatedAt": "2023-05-26T15:33:26Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I think all naming changes are deferred until the editorial bits land.",
              "createdAt": "2023-05-26T15:30:12Z",
              "updatedAt": "2023-05-26T15:33:26Z"
            },
            {
              "originalPosition": 22,
              "body": "Streaming formats might specify strategies for setting priorities, or for producer congestion response - the sentence says \"policies for...\"  What's the right finessing here?",
              "createdAt": "2023-05-26T15:32:09Z",
              "updatedAt": "2023-05-26T15:33:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WOkEN",
          "commit": {
            "abbreviatedOid": "fcaf61f"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-26T17:21:16Z",
          "updatedAt": "2023-05-26T17:21:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 170,
      "id": "PR_kwDOG2Ho4M5RTqDw",
      "title": "rewrite motivation",
      "url": "https://github.com/moq-wg/moq-transport/pull/170",
      "state": "MERGED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-25T05:19:22Z",
      "updatedAt": "2023-05-26T17:32:17Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "d66eb85dcc682c2c1bd6b9c2753b172d5a9a3477",
      "headRepository": "fluffy/warp-draft",
      "headRefName": "edit-c",
      "headRefOid": "1c1dae244cf7f1b1358abefd4e6c70e6bd34eea9",
      "closedAt": "2023-05-26T17:32:17Z",
      "mergedAt": "2023-05-26T17:32:17Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "f62adc1a606955df47fa6736c151d2d24f25d98b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5WBCcp",
          "commit": {
            "abbreviatedOid": "913ddc5"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Have a clarification question on HTTP/3 , but rest looks fine",
          "createdAt": "2023-05-25T05:35:12Z",
          "updatedAt": "2023-05-25T05:35:55Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "This is not entirely true , isn't it. Each GET/POST is its own QUIC Stream or am I understanding it incorrectly ?",
              "createdAt": "2023-05-25T05:35:12Z",
              "updatedAt": "2023-05-25T05:35:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WBE_N",
          "commit": {
            "abbreviatedOid": "913ddc5"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I really like the new text ",
          "createdAt": "2023-05-25T05:47:14Z",
          "updatedAt": "2023-05-25T05:50:18Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "s/rate/time/",
              "createdAt": "2023-05-25T05:47:14Z",
              "updatedAt": "2023-05-25T05:50:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WE9Ht",
          "commit": {
            "abbreviatedOid": "913ddc5"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I'm biased but I thought the old motivation section was pretty good.",
          "createdAt": "2023-05-25T15:19:29Z",
          "updatedAt": "2023-05-25T15:36:31Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "It's a big paragraph that summarizes some difficult concepts. You should split it up into smaller parts so it's digestible.",
              "createdAt": "2023-05-25T15:19:29Z",
              "updatedAt": "2023-05-25T15:36:02Z"
            },
            {
              "originalPosition": 66,
              "body": "I like \"Universal\" more. There's a multitude of benefits for consolidating standards, workflow efficiency being one of them.",
              "createdAt": "2023-05-25T15:23:26Z",
              "updatedAt": "2023-05-25T15:36:02Z"
            },
            {
              "originalPosition": 59,
              "body": "The implicit assumption is that HLS/DASH do not issue concurrent HTTP requests, so they can't fully benefit from QUIC.",
              "createdAt": "2023-05-25T15:26:31Z",
              "updatedAt": "2023-05-25T15:36:02Z"
            },
            {
              "originalPosition": 55,
              "body": "I understand the point trying to be made, but it's a bit convoluted and not particularly compelling.\r\n\r\nI would focus on _why_ we want to use QUIC, instead of focusing on how we use QUIC better than HLS/DASH. We can build a thin layer on top of the QUIC ecosystem and API, leveraging the full feature set.",
              "createdAt": "2023-05-25T15:30:37Z",
              "updatedAt": "2023-05-25T15:36:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WGAIj",
          "commit": {
            "abbreviatedOid": "913ddc5"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-25T18:05:52Z",
          "updatedAt": "2023-05-25T18:05:53Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "that makes sense. But that might change in the future  and adding it here is  bit misleading.\r\n\r\nMay be , how about we say\r\n\r\n\"As it stands today, applying {{QUIC}} to HAS via HTTP/3 does not yield generalized .....\"\r\n",
              "createdAt": "2023-05-25T18:05:53Z",
              "updatedAt": "2023-05-25T18:05:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WGAZu",
          "commit": {
            "abbreviatedOid": "913ddc5"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-25T18:06:38Z",
          "updatedAt": "2023-05-25T18:06:38Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "I think I am with Luke on this .. Universal or Unified works for me ",
              "createdAt": "2023-05-25T18:06:38Z",
              "updatedAt": "2023-05-25T18:06:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WN7DR",
          "commit": {
            "abbreviatedOid": "913ddc5"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "lgtm with the small tweaks to H3 and section heading requested by Luke/Suhas",
          "createdAt": "2023-05-26T15:35:01Z",
          "updatedAt": "2023-05-26T15:37:38Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "I think rate was intended here - there's an acknowledgement that e2e latency and encoding delays are baked in.",
              "createdAt": "2023-05-26T15:35:01Z",
              "updatedAt": "2023-05-26T15:37:38Z"
            },
            {
              "originalPosition": 59,
              "body": "s/does not yield/has not yet yielded/ ?",
              "createdAt": "2023-05-26T15:36:34Z",
              "updatedAt": "2023-05-26T15:37:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WOnYF",
          "commit": {
            "abbreviatedOid": "1c1dae2"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-26T17:31:51Z",
          "updatedAt": "2023-05-26T17:31:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 171,
      "id": "PR_kwDOG2Ho4M5RTqFO",
      "title": "add new terminology",
      "url": "https://github.com/moq-wg/moq-transport/pull/171",
      "state": "MERGED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-25T05:19:32Z",
      "updatedAt": "2023-05-26T17:37:35Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "f62adc1a606955df47fa6736c151d2d24f25d98b",
      "headRepository": "fluffy/warp-draft",
      "headRefName": "edit-d",
      "headRefOid": "cab83e1f09917ab01504a89fb56c47779d765441",
      "closedAt": "2023-05-26T17:37:35Z",
      "mergedAt": "2023-05-26T17:37:35Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "ef4373a3b3e06187273ea2f2fcac5d8ffe94fa04"
      },
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@kixelated does the updated text with OPEN ISSUE looks about right to you. I personally feel we should revisit all the terms and get to a common understaning across the documents. For -05 an OPEN ISSUE seems like OK. thoughts ?",
          "createdAt": "2023-05-26T04:59:24Z",
          "updatedAt": "2023-05-26T04:59:24Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "LGTM ",
          "createdAt": "2023-05-26T14:04:33Z",
          "updatedAt": "2023-05-26T14:04:33Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5WBDXK",
          "commit": {
            "abbreviatedOid": "96a3ee7"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-25T05:39:25Z",
          "updatedAt": "2023-05-25T05:40:09Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Suggest split this into 2 terms\r\n\r\nProducer : The original producer of the media.\r\nConsumer: the final consumer of the media.",
              "createdAt": "2023-05-25T05:39:25Z",
              "updatedAt": "2023-05-25T05:40:09Z"
            },
            {
              "originalPosition": 11,
              "body": "remove last sentence and add reference to the group ?",
              "createdAt": "2023-05-25T05:39:56Z",
              "updatedAt": "2023-05-25T05:40:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WBF9l",
          "commit": {
            "abbreviatedOid": "96a3ee7"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-25T05:51:55Z",
          "updatedAt": "2023-05-25T05:52:41Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I thought we had come to \"SHOULD NOT\" depend. ",
              "createdAt": "2023-05-25T05:51:55Z",
              "updatedAt": "2023-05-25T05:52:42Z"
            },
            {
              "originalPosition": 10,
              "body": "I have a slight preference for \"join point\" instead of \"subscription point\" ",
              "createdAt": "2023-05-25T05:52:31Z",
              "updatedAt": "2023-05-25T05:52:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WFIWK",
          "commit": {
            "abbreviatedOid": "96a3ee7"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-05-25T15:39:44Z",
          "updatedAt": "2023-05-25T15:43:39Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "This is does not match my understand of \"endpoint\". A QUIC endpoint is a client or a server.",
              "createdAt": "2023-05-25T15:39:44Z",
              "updatedAt": "2023-05-25T15:43:39Z"
            },
            {
              "originalPosition": 10,
              "body": "IMO keep this definition simple and link to the section in the object model. No need to describe all properties of a group up here.\r\n\r\n> The media data within the group must not depend on the data in any other groups.\r\n\r\nWe agreed to remove any mention of dependencies when updating the object/group model. Technically, audio groups depend on each other, as do video groups when intra-refresh is used.",
              "createdAt": "2023-05-25T15:43:13Z",
              "updatedAt": "2023-05-25T15:43:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WIcJ4",
          "commit": {
            "abbreviatedOid": "3cdfc41"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T04:52:13Z",
          "updatedAt": "2023-05-26T04:52:14Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Added an OPEN ISSUE on the terminology",
              "createdAt": "2023-05-26T04:52:13Z",
              "updatedAt": "2023-05-26T04:52:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WN-So",
          "commit": {
            "abbreviatedOid": "ba74daf"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T15:43:09Z",
          "updatedAt": "2023-05-26T15:43:09Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I had the same comment as Luke on 163.  Endpoint appears 10 times in the doc though and all the references match Luke's definition (either the QUIC client or the QUIC server for a session) as I read it.\r\n\r\nThe point of the terminology is to help understand the document, so this definition is not accomplishing that.  I'd say either update the definition to match the usage, or remove the definition.  Adding this definition plus a discuss doesn't seem optimal to me.",
              "createdAt": "2023-05-26T15:43:09Z",
              "updatedAt": "2023-05-26T15:43:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WOpHG",
          "commit": {
            "abbreviatedOid": "cab83e1"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-26T17:37:22Z",
          "updatedAt": "2023-05-26T17:37:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 172,
      "id": "PR_kwDOG2Ho4M5RTqI-",
      "title": "rewrite model section",
      "url": "https://github.com/moq-wg/moq-transport/pull/172",
      "state": "MERGED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-25T05:19:54Z",
      "updatedAt": "2023-05-26T17:41:10Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "ef4373a3b3e06187273ea2f2fcac5d8ffe94fa04",
      "headRepository": "fluffy/warp-draft",
      "headRefName": "edit-f",
      "headRefOid": "7046a710a7e9c7a73462cc4316a69be985697e32",
      "closedAt": "2023-05-26T17:41:09Z",
      "mergedAt": "2023-05-26T17:41:09Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "37821c88dae0f7a2c63bf54db353c60f795b4167"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5WBGfU",
          "commit": {
            "abbreviatedOid": "a1dc3ca"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-25T05:54:28Z",
          "updatedAt": "2023-05-25T05:54:57Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "I would rather not loose priority and TTL in metadata here. ",
              "createdAt": "2023-05-25T05:54:28Z",
              "updatedAt": "2023-05-25T05:54:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WHnBZ",
          "commit": {
            "abbreviatedOid": "a1dc3ca"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "We spent a while debating the object/group text so I'd prefer smaller changes.",
          "createdAt": "2023-05-26T01:10:09Z",
          "updatedAt": "2023-05-26T01:12:28Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Could we mention that the application is responsible for any further sub divisions?",
              "createdAt": "2023-05-26T01:10:09Z",
              "updatedAt": "2023-05-26T01:12:28Z"
            },
            {
              "originalPosition": 5,
              "body": "What about working top-down right than bottom up?\r\n\r\nI think it makes more sense to describe tracks first, and then groups, and then objects, and then anything smaller (application).",
              "createdAt": "2023-05-26T01:11:25Z",
              "updatedAt": "2023-05-26T01:12:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WBF-d",
          "commit": {
            "abbreviatedOid": "a1dc3ca"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-25T05:51:58Z",
          "updatedAt": "2023-05-26T02:19:21Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "payload is opaque and possibly encrypted to the relays",
              "createdAt": "2023-05-25T05:51:58Z",
              "updatedAt": "2023-05-26T02:19:21Z"
            },
            {
              "originalPosition": 5,
              "body": "totally agree .. This was my suggestion on google docs too . Its more natural that way. ",
              "createdAt": "2023-05-26T02:15:26Z",
              "updatedAt": "2023-05-26T02:19:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WN_Do",
          "commit": {
            "abbreviatedOid": "ebbee50"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T15:44:53Z",
          "updatedAt": "2023-05-26T15:44:54Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I also had the same suggestion, though I think reading bottom up is still getting the job done.  If we're pressed for time today for -05, I would leave this and revisit it later.",
              "createdAt": "2023-05-26T15:44:53Z",
              "updatedAt": "2023-05-26T15:44:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WOp4w",
          "commit": {
            "abbreviatedOid": "7046a71"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-26T17:40:14Z",
          "updatedAt": "2023-05-26T17:40:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 173,
      "id": "PR_kwDOG2Ho4M5RTqKk",
      "title": "add model intro paragraph",
      "url": "https://github.com/moq-wg/moq-transport/pull/173",
      "state": "MERGED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-25T05:20:03Z",
      "updatedAt": "2023-05-26T17:47:00Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "37821c88dae0f7a2c63bf54db353c60f795b4167",
      "headRepository": "fluffy/warp-draft",
      "headRefName": "edit-g",
      "headRefOid": "a44047186ca82e678837c090d5cda871df04acfd",
      "closedAt": "2023-05-26T17:47:00Z",
      "mergedAt": "2023-05-26T17:47:00Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "b478f04c263699a8528ba88cc312d31fe7bb25b7"
      },
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@kixelated  please check the latest commit . thanks",
          "createdAt": "2023-05-26T05:27:30Z",
          "updatedAt": "2023-05-26T05:27:30Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Something is wrong, this PR appears blank",
          "createdAt": "2023-05-26T15:45:51Z",
          "updatedAt": "2023-05-26T15:45:51Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5WBFdu",
          "commit": {
            "abbreviatedOid": "cc54cfd"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-25T05:49:32Z",
          "updatedAt": "2023-05-25T05:49:33Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "s/MoQT/moqt ?",
              "createdAt": "2023-05-25T05:49:32Z",
              "updatedAt": "2023-05-25T05:49:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WBFi9",
          "commit": {
            "abbreviatedOid": "cc54cfd"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "editorial nit if it can be addressed, otherwise LGTM",
          "createdAt": "2023-05-25T05:49:56Z",
          "updatedAt": "2023-05-25T05:49:56Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WHnxm",
          "commit": {
            "abbreviatedOid": "cc54cfd"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Let's introduce the concept of control streams and data streams in another PR. But those should have nothing to do with the object model.",
          "createdAt": "2023-05-26T01:14:32Z",
          "updatedAt": "2023-05-26T01:21:24Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I like \"MoQ Transport\". If we're going to use initials, it should probably be all uppercase (ex. MOQT)",
              "createdAt": "2023-05-26T01:14:32Z",
              "updatedAt": "2023-05-26T01:21:24Z"
            },
            {
              "originalPosition": 5,
              "body": "In the current draft, OBJECTs are messages. There's no distinction between control streams/messages and data streams/messages.\r\n\r\nIMO the object model is meant to explain the properties of the protocol, while messages are the wire encoding of those properties. We should cover messages in another section and leave this section high level.",
              "createdAt": "2023-05-26T01:20:29Z",
              "updatedAt": "2023-05-26T01:21:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WHuOx",
          "commit": {
            "abbreviatedOid": "cc54cfd"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "+1 other things people want to fix but LGTM ",
          "createdAt": "2023-05-26T01:55:13Z",
          "updatedAt": "2023-05-26T02:00:19Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I'm going to assume that after we merge all these PR we have final ",
              "createdAt": "2023-05-26T01:55:13Z",
              "updatedAt": "2023-05-26T02:00:19Z"
            },
            {
              "originalPosition": 5,
              "body": "I can live with this whatever we do but +1 luke.\r\n\r\nSIP had a class of things that were called Messages and one of them was named MESSAGE and these were sent over the wire as message so you have to sometime talk about the the message MESSAGE Message. Seriously, I can't make this up. Anyways, message is often pretty confusing term in protocols. ",
              "createdAt": "2023-05-26T01:59:58Z",
              "updatedAt": "2023-05-26T02:00:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WOr8B",
          "commit": {
            "abbreviatedOid": "a440471"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-26T17:46:52Z",
          "updatedAt": "2023-05-26T17:46:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 174,
      "id": "PR_kwDOG2Ho4M5RTqXB",
      "title": "add examples",
      "url": "https://github.com/moq-wg/moq-transport/pull/174",
      "state": "CLOSED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-25T05:21:02Z",
      "updatedAt": "2023-05-25T17:51:51Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "editorial-moves",
      "baseRefOid": "2d3b2a2d4fcd2148ebb868e0037f94bb9789b7b7",
      "headRepository": "fluffy/warp-draft",
      "headRefName": "edit-h",
      "headRefOid": "704ab696171938e7eb605bd39509bea6fee3a2ab",
      "closedAt": "2023-05-25T17:51:51Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Reflecting on the authors call and latest changes in #163  , I will go ahead and close this ",
          "createdAt": "2023-05-25T17:51:51Z",
          "updatedAt": "2023-05-25T17:51:51Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5WBGIG",
          "commit": {
            "abbreviatedOid": "704ab69"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-05-25T05:52:42Z",
          "updatedAt": "2023-05-25T05:52:48Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "With the new change to remove \"/\", i think these examples can now go away",
              "createdAt": "2023-05-25T05:52:42Z",
              "updatedAt": "2023-05-25T05:52:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WExA0",
          "commit": {
            "abbreviatedOid": "704ab69"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-25T14:54:59Z",
          "updatedAt": "2023-05-25T14:55:04Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Yeah I would remove all of these examples, not add more. It's not a difficult concept that the full track name is split into two parts.",
              "createdAt": "2023-05-25T14:54:59Z",
              "updatedAt": "2023-05-25T14:55:58Z"
            }
          ]
        }
      ]
    },
    {
      "number": 175,
      "id": "PR_kwDOG2Ho4M5RTqZJ",
      "title": "add new catalog track section",
      "url": "https://github.com/moq-wg/moq-transport/pull/175",
      "state": "CLOSED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-25T05:21:08Z",
      "updatedAt": "2023-05-25T17:50:33Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "editorial-moves",
      "baseRefOid": "2d3b2a2d4fcd2148ebb868e0037f94bb9789b7b7",
      "headRepository": "fluffy/warp-draft",
      "headRefName": "edit-i",
      "headRefOid": "bc8b6dc2d35f099b9ef713fdde7080bd8b695318",
      "closedAt": "2023-05-25T17:50:33Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "hardie",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair hat:\nGiven the desire to get a document out, what will it take to get a\ndisposition on this?  Can this be merged if a \"To be discussed\" is added?\n\nNot chair chat:\n\nThis text:\n\nAll producers of content MUST produce a catalog track which describes\nthe availability of the tracks which they are capable of publishing.\n\nseems like an odd way to deploy the MUST, because \"capable of publishing\"\nseems like it could be divorced from the timing of the act of publication.\nI think you mean \"Producers MUST provide a catalog of the tracks available\nwhen they publish the tracks.\"\n\nProducers MUST update the catalog tracks when new tracks are added or\nexisting tracks deleted.  The payload of the catalog track objects is\ndefined by the MoQStreaming Format being used by the publisher, with the\nexception that the first varint of the payload MUST be unencrypted and\nMUST hold the type of the MoQStreaming Format, as registered in the IANA\nregistration table {{iana}} for MoQtransport Streaming Formats.\n\nI also think the last sentence is quite hard to read. The intent appears to\nbe something like \"The catalog track must begin with an unencrypted\nindication of which MoQStreaming Format is in use; all subsequent objects\nare provided in that format.  The IANA registrations of streaming formats\n{{iana}} will associate a value with each registered format which may be\nused to provide the indicator above.\"\n\n\n\n\nOn Thu, May 25, 2023 at 6:44\u202fAM Cullen Jennings ***@***.***>\nwrote:\n\n> ***@***.**** commented on this pull request.\n>\n> I don't think we should merge this yet\n>\n> \u2014\n> Reply to this email directly, view it on GitHub\n> <https://github.com/kixelated/warp-draft/pull/175#pullrequestreview-1443120768>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAKVXZBZCN25WLCUHVVUCZLXH3WUVANCNFSM6AAAAAAYOJY2I4>\n> .\n> You are receiving this because you are subscribed to this thread.Message\n> ID: ***@***.***>\n>\n",
          "createdAt": "2023-05-25T07:50:42Z",
          "updatedAt": "2023-05-25T07:50:42Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\nWe got a +1 from Will yesterday and this change is not reflected in the latest version of #163 \r\n\r\nClosing this PR per authors call and add at some point later once the draft is adopted\r\n",
          "createdAt": "2023-05-25T17:50:33Z",
          "updatedAt": "2023-05-25T17:50:33Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5WBEaA",
          "commit": {
            "abbreviatedOid": "bc8b6dc"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I don't think we should merge this yet",
          "createdAt": "2023-05-25T05:44:31Z",
          "updatedAt": "2023-05-25T05:44:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 176,
      "id": "PR_kwDOG2Ho4M5RTqbA",
      "title": "remove connection URL section",
      "url": "https://github.com/moq-wg/moq-transport/pull/176",
      "state": "CLOSED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-25T05:21:14Z",
      "updatedAt": "2023-05-25T18:48:52Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "editorial-moves",
      "baseRefOid": "2d3b2a2d4fcd2148ebb868e0037f94bb9789b7b7",
      "headRepository": "fluffy/warp-draft",
      "headRefName": "edit-j",
      "headRefOid": "906898c2c6f5473a4b4931900e886624495ac0c0",
      "closedAt": "2023-05-25T18:48:52Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "We agreed to put this section back in the Author's call today. May be we don't need this change",
          "createdAt": "2023-05-25T05:46:23Z",
          "updatedAt": "2023-05-25T05:46:23Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5WBE8v",
          "commit": {
            "abbreviatedOid": "906898c"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Close this PR, per authors call outcome ",
          "createdAt": "2023-05-25T05:47:04Z",
          "updatedAt": "2023-05-25T05:47:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 177,
      "id": "PR_kwDOG2Ho4M5RTqcq",
      "title": "remove session and objects",
      "url": "https://github.com/moq-wg/moq-transport/pull/177",
      "state": "MERGED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-25T05:21:19Z",
      "updatedAt": "2023-05-26T17:48:39Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "b478f04c263699a8528ba88cc312d31fe7bb25b7",
      "headRepository": "fluffy/warp-draft",
      "headRefName": "edit-k",
      "headRefOid": "a5b8295566c3ffcd35e296a893079692651fffcc",
      "closedAt": "2023-05-26T17:48:38Z",
      "mergedAt": "2023-05-26T17:48:38Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "9f3a21aebd55711ec5932e04273dad1a348d8e7c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5WBDl1",
          "commit": {
            "abbreviatedOid": "a5b8295"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-25T05:40:35Z",
          "updatedAt": "2023-05-26T17:48:12Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WBHis",
          "commit": {
            "abbreviatedOid": "bd1adc5"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I do think we should remove all this for now but wanted to at least flag it for reiview. \r\n",
          "createdAt": "2023-05-25T05:59:02Z",
          "updatedAt": "2023-05-25T05:59:02Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WHpy-",
          "commit": {
            "abbreviatedOid": "bd1adc5"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I don't understand this change.",
          "createdAt": "2023-05-26T01:23:12Z",
          "updatedAt": "2023-05-26T01:23:25Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "What is a session? Why does this section start with a DISCUSS object priorities? What does this even have to do with sessions...?",
              "createdAt": "2023-05-26T01:23:12Z",
              "updatedAt": "2023-05-26T01:23:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WHtxx",
          "commit": {
            "abbreviatedOid": "bd1adc5"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T01:51:45Z",
          "updatedAt": "2023-05-26T01:51:45Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Two things happened here. First was we kept the Session and moved it to a top level session ( the ## to # ).  And 2nd things was to remove all the stuff on the left. I think the further text that was left here on Order Priorities and such get moved/removed in a different PR about priorities. It confusing to see here but it will be killed later ",
              "createdAt": "2023-05-26T01:51:45Z",
              "updatedAt": "2023-05-26T01:51:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WOAKV",
          "commit": {
            "abbreviatedOid": "bd1adc5"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This PR by itself doesn't make a lot of sense but I'm ok rolling with it if it's part of the grand plan",
          "createdAt": "2023-05-26T15:48:06Z",
          "updatedAt": "2023-05-26T15:48:06Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WOsVg",
          "commit": {
            "abbreviatedOid": "a5b8295"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-26T17:48:00Z",
          "updatedAt": "2023-05-26T17:48:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 178,
      "id": "PR_kwDOG2Ho4M5RTqfC",
      "title": "remove groups",
      "url": "https://github.com/moq-wg/moq-transport/pull/178",
      "state": "MERGED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-25T05:21:25Z",
      "updatedAt": "2023-05-26T17:49:14Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "9f3a21aebd55711ec5932e04273dad1a348d8e7c",
      "headRepository": "fluffy/warp-draft",
      "headRefName": "edit-l",
      "headRefOid": "0c2003b19b22e1e88f694835cf1e18d03a340f10",
      "closedAt": "2023-05-26T17:49:14Z",
      "mergedAt": "2023-05-26T17:49:14Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "ec007899e0ff76fd4195ac1255eab8474ba19138"
      },
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "@huitema I think you added this TODO but it got removed in the editorial pass, are you good with that?",
          "createdAt": "2023-05-26T15:49:00Z",
          "updatedAt": "2023-05-26T15:49:00Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5WBGOV",
          "commit": {
            "abbreviatedOid": "0c2003b"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-25T05:53:11Z",
          "updatedAt": "2023-05-26T17:49:08Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WHp6O",
          "commit": {
            "abbreviatedOid": "0c2003b"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-26T01:24:07Z",
          "updatedAt": "2023-05-26T17:49:08Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WHtI4",
          "commit": {
            "abbreviatedOid": "cf3c515"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "LGTM",
          "createdAt": "2023-05-26T01:46:52Z",
          "updatedAt": "2023-05-26T01:46:52Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WOJqU",
          "commit": {
            "abbreviatedOid": "cf3c515"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Yes, we can remove this. We will certainly revisit the issue later, because this is a thorny subject. For example, we assume that \"objects MUST not depend from objects in the group that have a higher priority code or a higher object ID\" -- object at P2 does not depend on another object at P3, object number 1000 cannot depend on object number 2001. That much has consensus, but it is a negative statement.",
          "createdAt": "2023-05-26T16:12:09Z",
          "updatedAt": "2023-05-26T16:12:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 179,
      "id": "PR_kwDOG2Ho4M5RTqgs",
      "title": "rewrite stream initialization",
      "url": "https://github.com/moq-wg/moq-transport/pull/179",
      "state": "MERGED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-25T05:21:31Z",
      "updatedAt": "2023-05-26T17:49:47Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "ec007899e0ff76fd4195ac1255eab8474ba19138",
      "headRepository": "fluffy/warp-draft",
      "headRefName": "edit-m",
      "headRefOid": "559cac4e87eeac1e555c1ec12a9c05577e5ee06c",
      "closedAt": "2023-05-26T17:49:46Z",
      "mergedAt": "2023-05-26T17:49:46Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "07e38b92e064277221e076d4b2bf3978a1c14e97"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5WHKWE",
          "commit": {
            "abbreviatedOid": "559cac4"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-25T22:08:22Z",
          "updatedAt": "2023-05-26T17:49:36Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WHqOq",
          "commit": {
            "abbreviatedOid": "559cac4"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks gud. I would like to see #138 eventually because it's unclear when an endpoint is allowed to create \"subsequent streams\".",
          "createdAt": "2023-05-26T01:26:15Z",
          "updatedAt": "2023-05-26T17:49:36Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WHsHM",
          "commit": {
            "abbreviatedOid": "b88f564"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "LGTM",
          "createdAt": "2023-05-26T01:40:20Z",
          "updatedAt": "2023-05-26T01:40:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 180,
      "id": "PR_kwDOG2Ho4M5RTqio",
      "title": "rewrite relays",
      "url": "https://github.com/moq-wg/moq-transport/pull/180",
      "state": "MERGED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-25T05:21:37Z",
      "updatedAt": "2023-05-26T17:50:11Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "07e38b92e064277221e076d4b2bf3978a1c14e97",
      "headRepository": "fluffy/warp-draft",
      "headRefName": "edit-p",
      "headRefOid": "bb9f4309e6cef3560ab3a012f4eca46ec6980db3",
      "closedAt": "2023-05-26T17:50:11Z",
      "mergedAt": "2023-05-26T17:50:11Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "3b9fc6d5161b68e940e1ad5d3b61d78841b7f385"
      },
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM",
          "createdAt": "2023-05-26T15:50:37Z",
          "updatedAt": "2023-05-26T15:50:37Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5WBGUd",
          "commit": {
            "abbreviatedOid": "337e8ee"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-25T05:53:40Z",
          "updatedAt": "2023-05-25T05:53:40Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WGJpc",
          "commit": {
            "abbreviatedOid": "bb9f430"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-25T18:34:41Z",
          "updatedAt": "2023-05-26T17:50:06Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WHr3f",
          "commit": {
            "abbreviatedOid": "81349f4"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "LGTM",
          "createdAt": "2023-05-26T01:38:24Z",
          "updatedAt": "2023-05-26T01:38:24Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WOXWb",
          "commit": {
            "abbreviatedOid": "bb9f430"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-26T16:47:37Z",
          "updatedAt": "2023-05-26T17:50:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 181,
      "id": "PR_kwDOG2Ho4M5RTqlE",
      "title": "Edit Subscribe Interactions",
      "url": "https://github.com/moq-wg/moq-transport/pull/181",
      "state": "MERGED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-25T05:21:47Z",
      "updatedAt": "2023-05-26T17:56:35Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "3b9fc6d5161b68e940e1ad5d3b61d78841b7f385",
      "headRepository": "fluffy/warp-draft",
      "headRefName": "edit-q",
      "headRefOid": "a1b96ed7b52b0558f283427a9d2f6cd71be7d55c",
      "closedAt": "2023-05-26T17:56:35Z",
      "mergedAt": "2023-05-26T17:56:35Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "dd489cb7f9df39fb2b6595ebd756a062b2448ee9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5WBGb6",
          "commit": {
            "abbreviatedOid": "9a85077"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-25T05:54:12Z",
          "updatedAt": "2023-05-26T17:46:13Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WHrqO",
          "commit": {
            "abbreviatedOid": "f91236a"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "LGTM",
          "createdAt": "2023-05-26T01:36:46Z",
          "updatedAt": "2023-05-26T01:36:46Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WOCVz",
          "commit": {
            "abbreviatedOid": "f91236a"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "LGTM",
          "createdAt": "2023-05-26T15:53:08Z",
          "updatedAt": "2023-05-26T15:53:18Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "super minor nit: we have \"a subscription remains active until A or B or C\", but I prefer \"A, B or C\".  Don't bother updating this PR just for that though, if nothing else the RFC editor will fix it.",
              "createdAt": "2023-05-26T15:53:08Z",
              "updatedAt": "2023-05-26T15:53:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WOX0B",
          "commit": {
            "abbreviatedOid": "f91236a"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I think this section could use some more text improvements.",
          "createdAt": "2023-05-26T16:49:13Z",
          "updatedAt": "2023-05-26T17:05:20Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "> Relays MUST ensure subscribers are authorized to subscribe to the requested tracks. This is done by verifying that the subscriber is authorized to access the content associated with the \"Full Track Name\".\r\n\r\nsuggested replacement:\r\n\r\n> Relays MUST ensure subscribers are authorized to access the content associated with the \"Full Track Name\".",
              "createdAt": "2023-05-26T16:49:13Z",
              "updatedAt": "2023-05-26T17:05:20Z"
            },
            {
              "originalPosition": 8,
              "body": "> The endpoint making the subscribe request\r\n\r\nsuggested replacement:\r\n\r\n> The subscriber",
              "createdAt": "2023-05-26T16:50:07Z",
              "updatedAt": "2023-05-26T17:05:20Z"
            },
            {
              "originalPosition": 11,
              "body": "> For successful subscriptions, the sender maintains a list of subscribers for each full track name.\r\n\r\nsuggested replacement:\r\n\r\n> The publisher maintains a list of successful subscriptions for each full track name.",
              "createdAt": "2023-05-26T16:51:08Z",
              "updatedAt": "2023-05-26T17:05:20Z"
            },
            {
              "originalPosition": 11,
              "body": "> Each new OBJECT belonging to the track MUST be forwarded to each active subscriber, unless determined by congestion response.\r\n\r\nThis MUST is a bait and switch, since the statement after the comma makes it conditional.",
              "createdAt": "2023-05-26T16:56:09Z",
              "updatedAt": "2023-05-26T17:05:20Z"
            },
            {
              "originalPosition": 11,
              "body": "> A subscription remains active until it expires, or until the publisher of the track stops producing objects or there is a subscription error\r\n\r\nsuggested replacement:\r\n\r\n> A subscription remains active until the publisher sends a SUBSCRIBE ERROR message.\r\n\r\nWe could add some examples but I think it's fine without them.",
              "createdAt": "2023-05-26T17:00:17Z",
              "updatedAt": "2023-05-26T17:05:20Z"
            }
          ]
        }
      ]
    },
    {
      "number": 182,
      "id": "PR_kwDOG2Ho4M5RTq5Q",
      "title": "add new text for security and iana sections",
      "url": "https://github.com/moq-wg/moq-transport/pull/182",
      "state": "MERGED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-25T05:23:50Z",
      "updatedAt": "2023-05-26T17:57:04Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "dd489cb7f9df39fb2b6595ebd756a062b2448ee9",
      "headRepository": "fluffy/warp-draft",
      "headRefName": "edit-r",
      "headRefOid": "03d5988f769c02b0d2abef4899f90afde7571c70",
      "closedAt": "2023-05-26T17:57:04Z",
      "mergedAt": "2023-05-26T17:57:04Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "c0e1a7ee0933074253665f9dfcf7dda7fe318231"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5WBGqH",
          "commit": {
            "abbreviatedOid": "03d5988"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-25T05:55:15Z",
          "updatedAt": "2023-05-26T17:56:59Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WBJUG",
          "commit": {
            "abbreviatedOid": "3415704"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I think it makes sense to include this. ",
          "createdAt": "2023-05-25T06:06:10Z",
          "updatedAt": "2023-05-25T06:06:15Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "It would sense to have an informational  reference the other media draft here as that would be in the table. ",
              "createdAt": "2023-05-25T06:06:10Z",
              "updatedAt": "2023-05-25T06:06:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WOCvG",
          "commit": {
            "abbreviatedOid": "3415704"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "LGTM",
          "createdAt": "2023-05-26T15:54:18Z",
          "updatedAt": "2023-05-26T15:54:18Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WOeaR",
          "commit": {
            "abbreviatedOid": "03d5988"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-26T17:06:28Z",
          "updatedAt": "2023-05-26T17:56:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 183,
      "id": "PR_kwDOG2Ho4M5RTrDM",
      "title": "IMPORTANT remove, move, edit of priority",
      "url": "https://github.com/moq-wg/moq-transport/pull/183",
      "state": "MERGED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-25T05:24:24Z",
      "updatedAt": "2023-05-26T17:58:32Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "c0e1a7ee0933074253665f9dfcf7dda7fe318231",
      "headRepository": "fluffy/warp-draft",
      "headRefName": "edit-s",
      "headRefOid": "282b2c982b3ac2a4e611a5a0deed1141f71f6cea",
      "closedAt": "2023-05-26T17:58:31Z",
      "mergedAt": "2023-05-26T17:58:31Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "5cc0893effe77cbf66467e0c2075c09073b44197"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5WBHht",
          "commit": {
            "abbreviatedOid": "282b2c9"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-25T05:58:59Z",
          "updatedAt": "2023-05-26T17:58:26Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WBHw2",
          "commit": {
            "abbreviatedOid": "bb4625a"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-25T05:59:58Z",
          "updatedAt": "2023-05-25T05:59:58Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "most of the text in this section seems non normative and just stating the fact. Seems fine to remove",
              "createdAt": "2023-05-25T05:59:58Z",
              "updatedAt": "2023-05-25T05:59:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WOEPE",
          "commit": {
            "abbreviatedOid": "bb4625a"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T15:58:10Z",
          "updatedAt": "2023-05-26T15:58:11Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "I commented on the gdoc that I think there's value in this text, though it's somewhat contradictory (is it BBR or GCC?) and maybe none of it should be normative.  I'm ok with removing it now and perhaps bringing it back under a performance considerations section, or something.  \r\n\r\n@kixelated What's your thought since you wrote this bit",
              "createdAt": "2023-05-26T15:58:10Z",
              "updatedAt": "2023-05-26T15:58:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WOxsV",
          "commit": {
            "abbreviatedOid": "8643bfa"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T17:58:15Z",
          "updatedAt": "2023-05-26T17:58:15Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "agree at authors call to keep it as it is in the PR",
              "createdAt": "2023-05-26T17:58:15Z",
              "updatedAt": "2023-05-26T17:58:15Z"
            }
          ]
        }
      ]
    },
    {
      "number": 184,
      "id": "PR_kwDOG2Ho4M5RTrFL",
      "title": "update section refs and pointer text",
      "url": "https://github.com/moq-wg/moq-transport/pull/184",
      "state": "MERGED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-25T05:24:36Z",
      "updatedAt": "2023-05-26T17:59:04Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "5cc0893effe77cbf66467e0c2075c09073b44197",
      "headRepository": "fluffy/warp-draft",
      "headRefName": "edit-t",
      "headRefOid": "55538f92eeee1f02542fab231640610eee2a7a03",
      "closedAt": "2023-05-26T17:59:04Z",
      "mergedAt": "2023-05-26T17:59:04Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "74d44ed8fe2c58feff17d4979ad4acb202bd1406"
      },
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM",
          "createdAt": "2023-05-26T15:59:01Z",
          "updatedAt": "2023-05-26T15:59:01Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5WBIfV",
          "commit": {
            "abbreviatedOid": "2bee871"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "So more the section tags are probably missing or wrong but at some point once we get the contact fixed we can focus on making it build. ",
          "createdAt": "2023-05-25T06:03:00Z",
          "updatedAt": "2023-05-25T06:03:00Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WHUoG",
          "commit": {
            "abbreviatedOid": "55538f9"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-25T23:06:34Z",
          "updatedAt": "2023-05-26T17:58:58Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WHrDM",
          "commit": {
            "abbreviatedOid": "2bee871"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "LGTM",
          "createdAt": "2023-05-26T01:32:33Z",
          "updatedAt": "2023-05-26T01:32:33Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WOm-O",
          "commit": {
            "abbreviatedOid": "55538f9"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-26T17:30:26Z",
          "updatedAt": "2023-05-26T17:58:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 185,
      "id": "PR_kwDOG2Ho4M5RTrG5",
      "title": "relay requirements",
      "url": "https://github.com/moq-wg/moq-transport/pull/185",
      "state": "MERGED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-25T05:24:46Z",
      "updatedAt": "2023-05-26T18:01:01Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "74d44ed8fe2c58feff17d4979ad4acb202bd1406",
      "headRepository": "fluffy/warp-draft",
      "headRefName": "edit-u",
      "headRefOid": "dad946aad99f15b0aee321ab22eb68ac5fe1cffc",
      "closedAt": "2023-05-26T18:01:01Z",
      "mergedAt": "2023-05-26T18:01:01Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "a8e3bbb2db98328ab6b309530d36918af2e3e369"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5WBIVJ",
          "commit": {
            "abbreviatedOid": "809a92f"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-25T06:02:23Z",
          "updatedAt": "2023-05-25T06:02:23Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WBJul",
          "commit": {
            "abbreviatedOid": "809a92f"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-25T06:07:47Z",
          "updatedAt": "2023-05-25T06:07:47Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "so the last part here seems like something that should not say send order but should point at that section of the draft",
              "createdAt": "2023-05-25T06:07:47Z",
              "updatedAt": "2023-05-25T06:07:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WGC96",
          "commit": {
            "abbreviatedOid": "809a92f"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-25T18:14:19Z",
          "updatedAt": "2023-05-25T18:14:19Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "yes this should send-order/object priorty ({{priority-congestion}}",
              "createdAt": "2023-05-25T18:14:19Z",
              "updatedAt": "2023-05-25T18:14:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WOThh",
          "commit": {
            "abbreviatedOid": "4bf8e93"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "LGTM with Suhas feedback",
          "createdAt": "2023-05-26T16:38:36Z",
          "updatedAt": "2023-05-26T16:38:36Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WOnzX",
          "commit": {
            "abbreviatedOid": "04d4a0c"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-26T17:32:41Z",
          "updatedAt": "2023-05-26T17:43:44Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "These might format strangely. Should use bullet points?",
              "createdAt": "2023-05-26T17:32:41Z",
              "updatedAt": "2023-05-26T17:32:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 186,
      "id": "PR_kwDOG2Ho4M5RTrIr",
      "title": "rewrite and move setup greese",
      "url": "https://github.com/moq-wg/moq-transport/pull/186",
      "state": "MERGED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-25T05:24:56Z",
      "updatedAt": "2023-05-26T18:02:02Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "a8e3bbb2db98328ab6b309530d36918af2e3e369",
      "headRepository": "fluffy/warp-draft",
      "headRefName": "edit-v",
      "headRefOid": "ee4ccdce31be4ca62f9d829db1ff28371635e222",
      "closedAt": "2023-05-26T18:02:02Z",
      "mergedAt": "2023-05-26T18:02:02Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "40eb9985206d1127c692a933b3d58e361768c245"
      },
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM",
          "createdAt": "2023-05-26T16:45:03Z",
          "updatedAt": "2023-05-26T16:45:03Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5WHKQO",
          "commit": {
            "abbreviatedOid": "ee4ccdc"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-25T22:07:56Z",
          "updatedAt": "2023-05-26T18:01:54Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WBKQV",
          "commit": {
            "abbreviatedOid": "4168ca7"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "could use some tweeks but close enough to merge IMHO ",
          "createdAt": "2023-05-25T06:09:51Z",
          "updatedAt": "2023-05-26T01:34:25Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I actually think you also need to be able to set mandator to understand parameters that must not be ignored. but perhaps that is for some other time. ",
              "createdAt": "2023-05-25T06:09:51Z",
              "updatedAt": "2023-05-26T01:34:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WOyrv",
          "commit": {
            "abbreviatedOid": "4168ca7"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T18:01:43Z",
          "updatedAt": "2023-05-26T18:01:44Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "WIll be updated later.",
              "createdAt": "2023-05-26T18:01:43Z",
              "updatedAt": "2023-05-26T18:01:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 187,
      "id": "PR_kwDOG2Ho4M5RXfID",
      "title": "very minor naming update",
      "url": "https://github.com/moq-wg/moq-transport/pull/187",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-25T17:44:07Z",
      "updatedAt": "2023-05-26T18:03:36Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "editorial-moves",
      "baseRefOid": "2d3b2a2d4fcd2148ebb868e0037f94bb9789b7b7",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "cleanup",
      "headRefOid": "265a6c8cf0420f58c1e8b8f55cd141ad28cb201c",
      "closedAt": "2023-05-26T18:03:36Z",
      "mergedAt": "2023-05-26T18:03:36Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "e838dfc09781e06637c01be870275f0d210033fa"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5WHqxA",
          "commit": {
            "abbreviatedOid": "f98f1aa"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM \r\n\r\n(side note for much much later, RFC editor often objects to acronyms in the title - but this is a future problem) ",
          "createdAt": "2023-05-26T01:30:16Z",
          "updatedAt": "2023-05-26T01:30:16Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WOXQq",
          "commit": {
            "abbreviatedOid": "f98f1aa"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "LGTM",
          "createdAt": "2023-05-26T16:47:17Z",
          "updatedAt": "2023-05-26T16:47:17Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WOzLX",
          "commit": {
            "abbreviatedOid": "265a6c8"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-26T18:03:25Z",
          "updatedAt": "2023-05-26T18:03:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 188,
      "id": "PR_kwDOG2Ho4M5RXrbE",
      "title": "Small changes in session section",
      "url": "https://github.com/moq-wg/moq-transport/pull/188",
      "state": "MERGED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-25T18:27:47Z",
      "updatedAt": "2023-05-26T18:06:47Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "40eb9985206d1127c692a933b3d58e361768c245",
      "headRepository": "fluffy/warp-draft",
      "headRefName": "edit-w",
      "headRefOid": "4218b8f4a88c7f1d238b250d020c495bf0d80ce4",
      "closedAt": "2023-05-26T18:06:46Z",
      "mergedAt": "2023-05-26T18:06:46Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "0460b50d89df4eb8bcbd6481a097abc83a9f0f35"
      },
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM",
          "createdAt": "2023-05-26T16:48:00Z",
          "updatedAt": "2023-05-26T16:48:00Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5WHJi1",
          "commit": {
            "abbreviatedOid": "7332b34"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-25T22:04:34Z",
          "updatedAt": "2023-05-26T17:42:47Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WHqjk",
          "commit": {
            "abbreviatedOid": "180b0a2"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "LGTM",
          "createdAt": "2023-05-26T01:28:41Z",
          "updatedAt": "2023-05-26T01:28:41Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WOsvD",
          "commit": {
            "abbreviatedOid": "7332b34"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T17:48:59Z",
          "updatedAt": "2023-05-26T17:49:00Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Is this TODO necessary? ",
              "createdAt": "2023-05-26T17:49:00Z",
              "updatedAt": "2023-05-26T17:49:00Z"
            }
          ]
        }
      ]
    },
    {
      "number": 189,
      "id": "PR_kwDOG2Ho4M5RXvla",
      "title": "Editorial changes for Messages Section",
      "url": "https://github.com/moq-wg/moq-transport/pull/189",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-25T18:42:13Z",
      "updatedAt": "2023-05-26T18:08:47Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "editorial-moves",
      "baseRefOid": "e838dfc09781e06637c01be870275f0d210033fa",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "edit-z",
      "headRefOid": "9558ae258d38ffd02a3d9c48f92bdb9b564a9d77",
      "closedAt": "2023-05-26T18:08:47Z",
      "mergedAt": "2023-05-26T18:08:47Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "3e101f99a47102fb51ab7db6cf40eedbf7e876a1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5WHqXm",
          "commit": {
            "abbreviatedOid": "895b091"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2023-05-26T01:27:15Z",
          "updatedAt": "2023-05-26T01:27:15Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WO0Ws",
          "commit": {
            "abbreviatedOid": "b7f31ce"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T18:06:57Z",
          "updatedAt": "2023-05-26T18:06:58Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "better phrasing?",
              "createdAt": "2023-05-26T18:06:58Z",
              "updatedAt": "2023-05-26T18:06:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WO0ce",
          "commit": {
            "abbreviatedOid": "b7f31ce"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T18:07:18Z",
          "updatedAt": "2023-05-26T18:07:18Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "Do we have an unsubscribe message?",
              "createdAt": "2023-05-26T18:07:18Z",
              "updatedAt": "2023-05-26T18:07:18Z"
            }
          ]
        }
      ]
    },
    {
      "number": 190,
      "id": "PR_kwDOG2Ho4M5RYkBd",
      "title": "update existing terminology",
      "url": "https://github.com/moq-wg/moq-transport/pull/190",
      "state": "MERGED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-25T22:10:46Z",
      "updatedAt": "2023-05-26T18:12:00Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "0460b50d89df4eb8bcbd6481a097abc83a9f0f35",
      "headRepository": "fluffy/warp-draft",
      "headRefName": "edit-e",
      "headRefOid": "7a1d380056c8575d00070595c7795dd2725885c0",
      "closedAt": "2023-05-26T18:12:00Z",
      "mergedAt": "2023-05-26T18:12:00Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "bc17f9f699a17185b47a4e89a054c03ca2d2e2c4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5WHOaR",
          "commit": {
            "abbreviatedOid": "c243032"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-25T22:30:05Z",
          "updatedAt": "2023-05-25T22:30:05Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WHp23",
          "commit": {
            "abbreviatedOid": "c243032"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "LGTM",
          "createdAt": "2023-05-26T01:23:39Z",
          "updatedAt": "2023-05-26T01:23:39Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WHxkk",
          "commit": {
            "abbreviatedOid": "c243032"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "DISMISSED",
          "body": "I might be voting to not update terminology section for -05",
          "createdAt": "2023-05-26T02:20:02Z",
          "updatedAt": "2023-05-26T05:00:02Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WOYCg",
          "commit": {
            "abbreviatedOid": "a959cf3"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "These updates to the terminology seem to be editorial only and improving clarity.\r\n\r\nLGTM",
          "createdAt": "2023-05-26T16:50:06Z",
          "updatedAt": "2023-05-26T16:50:06Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WOxe-",
          "commit": {
            "abbreviatedOid": "a959cf3"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-05-26T17:57:38Z",
          "updatedAt": "2023-05-26T17:57:43Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Wrong definition of endpoint",
              "createdAt": "2023-05-26T17:57:38Z",
              "updatedAt": "2023-05-26T17:57:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WO2Mx",
          "commit": {
            "abbreviatedOid": "7a1d380"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-26T18:11:54Z",
          "updatedAt": "2023-05-26T18:11:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 191,
      "id": "PR_kwDOG2Ho4M5RZb7s",
      "title": "Misc fix ups to match updates to WIlls PR ",
      "url": "https://github.com/moq-wg/moq-transport/pull/191",
      "state": "MERGED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-26T02:46:21Z",
      "updatedAt": "2023-05-26T18:19:31Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "bc17f9f699a17185b47a4e89a054c03ca2d2e2c4",
      "headRepository": "fluffy/warp-draft",
      "headRefName": "edit-x",
      "headRefOid": "d0b0b9f7639c92f751255f1fcfd2ec0bf1d0f517",
      "closedAt": "2023-05-26T18:19:30Z",
      "mergedAt": "2023-05-26T18:19:30Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "3742f86e1c7266faca3733861bc44c5bad37c576"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5WH6VH",
          "commit": {
            "abbreviatedOid": "60a5478"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-26T03:01:50Z",
          "updatedAt": "2023-05-26T17:39:37Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WOYtS",
          "commit": {
            "abbreviatedOid": "321bc37"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "LGTM",
          "createdAt": "2023-05-26T16:52:11Z",
          "updatedAt": "2023-05-26T16:52:30Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "I thought I saw this `.` appear in a different PR too, hopefully no merge conflicts :P ",
              "createdAt": "2023-05-26T16:52:11Z",
              "updatedAt": "2023-05-26T16:52:30Z"
            },
            {
              "originalPosition": 6,
              "body": "minor minor nit: two spaces between `that  is`",
              "createdAt": "2023-05-26T16:52:20Z",
              "updatedAt": "2023-05-26T16:52:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WOyKD",
          "commit": {
            "abbreviatedOid": "60a5478"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T17:59:53Z",
          "updatedAt": "2023-05-26T18:02:15Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "> and that  is used as a key for caching.\r\n\r\nsuggested:\r\n\r\n> and is used as a cache key.",
              "createdAt": "2023-05-26T17:59:53Z",
              "updatedAt": "2023-05-26T18:02:15Z"
            },
            {
              "originalPosition": 35,
              "body": "I'm confused by the old text. Tracks don't \"have connection URLs\".",
              "createdAt": "2023-05-26T18:01:06Z",
              "updatedAt": "2023-05-26T18:02:15Z"
            }
          ]
        }
      ]
    },
    {
      "number": 192,
      "id": "PR_kwDOG2Ho4M5RZfGF",
      "title": "The lost edits at long last ",
      "url": "https://github.com/moq-wg/moq-transport/pull/192",
      "state": "MERGED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "At this point we have PRs for all the stuff that was in the big PR. ",
      "createdAt": "2023-05-26T03:01:15Z",
      "updatedAt": "2023-05-26T18:20:11Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "3742f86e1c7266faca3733861bc44c5bad37c576",
      "headRepository": "fluffy/warp-draft",
      "headRefName": "edit-y",
      "headRefOid": "67bb77a195edb77f2bcb6db2ff6ea8da9c6d0b53",
      "closedAt": "2023-05-26T18:20:11Z",
      "mergedAt": "2023-05-26T18:20:11Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "5c85c97e845b5d6fe59e1842016d969f423fe035"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5WH6ZW",
          "commit": {
            "abbreviatedOid": "67bb77a"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-26T03:02:22Z",
          "updatedAt": "2023-05-26T18:20:04Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WOZGQ",
          "commit": {
            "abbreviatedOid": "ebe048a"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "LGTM",
          "createdAt": "2023-05-26T16:53:18Z",
          "updatedAt": "2023-05-26T16:53:22Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Thought I saw this elsewhere too but now I may just be going blind.",
              "createdAt": "2023-05-26T16:53:18Z",
              "updatedAt": "2023-05-26T16:53:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WO0OR",
          "commit": {
            "abbreviatedOid": "67bb77a"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-26T18:06:27Z",
          "updatedAt": "2023-05-26T18:20:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 193,
      "id": "PR_kwDOG2Ho4M5RZgQe",
      "title": "Fix up object send order definition",
      "url": "https://github.com/moq-wg/moq-transport/pull/193",
      "state": "MERGED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-26T03:06:40Z",
      "updatedAt": "2023-05-26T03:12:09Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "edit-z",
      "baseRefOid": "895b09160f1cdce602a88b66cbde2ae102026fd7",
      "headRepository": "fluffy/warp-draft",
      "headRefName": "edit-z2",
      "headRefOid": "ea6adfbe5cad2a831718eac4955363b9ab80203d",
      "closedAt": "2023-05-26T03:12:09Z",
      "mergedAt": "2023-05-26T03:12:09Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "b7f31ce5cf29039c2178316ac7f8ce61493950b4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5WH7d8",
          "commit": {
            "abbreviatedOid": "ea6adfb"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-26T03:11:06Z",
          "updatedAt": "2023-05-26T03:11:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 194,
      "id": "PR_kwDOG2Ho4M5Rdsb3",
      "title": "fixes section reference",
      "url": "https://github.com/moq-wg/moq-transport/pull/194",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-26T18:25:30Z",
      "updatedAt": "2023-05-26T18:26:13Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "5c85c97e845b5d6fe59e1842016d969f423fe035",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "sections",
      "headRefOid": "158ad5f79b7ae13a35559071949905693f1ccde1",
      "closedAt": "2023-05-26T18:26:13Z",
      "mergedAt": "2023-05-26T18:26:13Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "e78933765e9e199d36bc0deede017d3155ab950d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5WO7aS",
          "commit": {
            "abbreviatedOid": "158ad5f"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-26T18:26:01Z",
          "updatedAt": "2023-05-26T18:26:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 195,
      "id": "PR_kwDOG2Ho4M5RduQ0",
      "title": "Update draft-lcurley-moq-transport.md",
      "url": "https://github.com/moq-wg/moq-transport/pull/195",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-26T18:32:45Z",
      "updatedAt": "2023-05-26T18:37:01Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "e78933765e9e199d36bc0deede017d3155ab950d",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "suhasHere-patch-1",
      "headRefOid": "7ba2a4449b115fa9210d8a54bdc5b041a69d45af",
      "closedAt": "2023-05-26T18:37:01Z",
      "mergedAt": "2023-05-26T18:37:01Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "66c3db81f5b114b6e7151dffc43f076c800fd380"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5WO967",
          "commit": {
            "abbreviatedOid": "7bee760"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-26T18:34:31Z",
          "updatedAt": "2023-05-26T18:34:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 196,
      "id": "PR_kwDOG2Ho4M5Rdxgd",
      "title": "Edit z",
      "url": "https://github.com/moq-wg/moq-transport/pull/196",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-26T18:46:20Z",
      "updatedAt": "2023-05-26T18:49:10Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "66c3db81f5b114b6e7151dffc43f076c800fd380",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "edit-z",
      "headRefOid": "120131911f0fb3636acaea2e71c64b50351903fb",
      "closedAt": "2023-05-26T18:49:10Z",
      "mergedAt": "2023-05-26T18:49:10Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "ee7e6725c87b11afc35ad36ca826ca1d8159c027"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5WPCDB",
          "commit": {
            "abbreviatedOid": "1201319"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-26T18:48:50Z",
          "updatedAt": "2023-05-26T18:48:50Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WPCHW",
          "commit": {
            "abbreviatedOid": "1201319"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-26T18:49:05Z",
          "updatedAt": "2023-05-26T18:49:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 197,
      "id": "PR_kwDOG2Ho4M5Rd6eA",
      "title": "Rename to Media Over QUIC Transport (MOQT)",
      "url": "https://github.com/moq-wg/moq-transport/pull/197",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-26T19:22:45Z",
      "updatedAt": "2023-05-26T22:33:53Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "ee7e6725c87b11afc35ad36ca826ca1d8159c027",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "rename",
      "headRefOid": "89c6bc52fbd23158c55fb5871b8091fcd4b91cbf",
      "closedAt": "2023-05-26T22:33:53Z",
      "mergedAt": "2023-05-26T22:33:53Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "62f7e275bfb08fe679cbdda51a26f160fe41a7b1"
      },
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "But I also don't care; we're going to rename this thing anyway.",
          "createdAt": "2023-05-26T20:03:33Z",
          "updatedAt": "2023-05-26T20:03:33Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@afrind  the latest commit should address your feedback. @kixelated it fixes expansion case",
          "createdAt": "2023-05-26T20:31:04Z",
          "updatedAt": "2023-05-26T20:31:39Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't like MOQT but we can continue to argue about the name forever.",
          "createdAt": "2023-05-26T20:43:18Z",
          "updatedAt": "2023-05-26T20:43:18Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "This LGTM for implementing what we discussed on the call.  Let's consider it a consensus placeholder while we search for that perfect name.",
          "createdAt": "2023-05-26T20:44:55Z",
          "updatedAt": "2023-05-26T20:44:55Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5WPRlF",
          "commit": {
            "abbreviatedOid": "aef4572"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T19:39:51Z",
          "updatedAt": "2023-05-26T19:39:52Z",
          "comments": [
            {
              "originalPosition": 332,
              "body": "The table name should not use the abbreviation. It should be `for MoQTransport Streaming Formats. Each MoQTransport Streaming Format can then register its type in that table. The MoQTransprt Streaming Format type` ..",
              "createdAt": "2023-05-26T19:39:52Z",
              "updatedAt": "2023-05-26T19:39:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WPRn5",
          "commit": {
            "abbreviatedOid": "aef4572"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T19:40:04Z",
          "updatedAt": "2023-05-26T19:40:04Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Needs a space between Transport and (",
              "createdAt": "2023-05-26T19:40:04Z",
              "updatedAt": "2023-05-26T19:40:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WPYNH",
          "commit": {
            "abbreviatedOid": "aef4572"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T20:01:08Z",
          "updatedAt": "2023-05-26T20:01:08Z",
          "comments": [
            {
              "originalPosition": 332,
              "body": "we decided to go with Media Over QUIC Transport or MOQT. I can go with the latter for the above.",
              "createdAt": "2023-05-26T20:01:08Z",
              "updatedAt": "2023-05-26T20:01:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WPT00",
          "commit": {
            "abbreviatedOid": "aef4572"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I think `MOQT` is an ugly acronym.\r\n\r\nMy recommendation:\r\nlong: `Media over QUIC Transport`\r\nshort: `MoQ Transport`\r\n\r\nIt's fine if the short name is more verbose. ",
          "createdAt": "2023-05-26T19:49:35Z",
          "updatedAt": "2023-05-26T20:02:46Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "I prefer a lower-case `o` when fully written out, but don't really care.",
              "createdAt": "2023-05-26T19:49:35Z",
              "updatedAt": "2023-05-26T20:02:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WPWBX",
          "commit": {
            "abbreviatedOid": "aef4572"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T19:57:41Z",
          "updatedAt": "2023-05-26T20:06:31Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "maybe the lowercase \"o\" is ok here?",
              "createdAt": "2023-05-26T19:57:41Z",
              "updatedAt": "2023-05-26T20:06:31Z"
            },
            {
              "originalPosition": 32,
              "body": "little o in over?",
              "createdAt": "2023-05-26T19:58:10Z",
              "updatedAt": "2023-05-26T20:06:31Z"
            },
            {
              "originalPosition": 199,
              "body": "Do we even need MOQT here?",
              "createdAt": "2023-05-26T19:59:38Z",
              "updatedAt": "2023-05-26T20:06:31Z"
            },
            {
              "originalPosition": 332,
              "body": "These are called \"MoQ Streaming Formats\" when referenced earlier, and I'm inclined to keep that in both places.  ",
              "createdAt": "2023-05-26T20:01:06Z",
              "updatedAt": "2023-05-26T20:06:31Z"
            },
            {
              "originalPosition": 146,
              "body": "The below paragraph has 5 uses of \"MoQ\" by itself:\r\n\r\nMoQ scope (3x) -> MOQT Scope\r\nMoQ servers -> just \"servers\"? Or \"MOQT servers\"?\r\n\"on top of MoQ\" -> on top of MOQT / using MOQT",
              "createdAt": "2023-05-26T20:05:59Z",
              "updatedAt": "2023-05-26T20:06:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WPeJa",
          "commit": {
            "abbreviatedOid": "aef4572"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T20:11:50Z",
          "updatedAt": "2023-05-26T20:11:50Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "I'd be fine calling it `MoQ Transport` and leaving stuff like `MoQ Scope` and `MoQ Servers`",
              "createdAt": "2023-05-26T20:11:50Z",
              "updatedAt": "2023-05-26T20:11:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5WPlhv",
          "commit": {
            "abbreviatedOid": "89c6bc5"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-26T20:40:44Z",
          "updatedAt": "2023-05-26T20:40:44Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WP8Vy",
          "commit": {
            "abbreviatedOid": "89c6bc5"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM ",
          "createdAt": "2023-05-26T22:20:54Z",
          "updatedAt": "2023-05-26T22:20:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 198,
      "id": "PR_kwDOG2Ho4M5Rej3n",
      "title": "Use a shorter example to avoid idnits",
      "url": "https://github.com/moq-wg/moq-transport/pull/198",
      "state": "MERGED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-26T22:48:12Z",
      "updatedAt": "2023-05-26T22:58:00Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "62f7e275bfb08fe679cbdda51a26f160fe41a7b1",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "shorter-example",
      "headRefOid": "3b6768bcb3dcb253a03500978f29abce19a0bdc6",
      "closedAt": "2023-05-26T22:57:59Z",
      "mergedAt": "2023-05-26T22:57:59Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "d538f6368d955bfeeaa1628f11af6f55f911641b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5WQA2S",
          "commit": {
            "abbreviatedOid": "3b6768b"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-26T22:57:24Z",
          "updatedAt": "2023-05-26T22:57:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 199,
      "id": "PR_kwDOG2Ho4M5ReoW3",
      "title": "fix up whitespace newlines for some tool and add a period",
      "url": "https://github.com/moq-wg/moq-transport/pull/199",
      "state": "MERGED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-26T23:23:07Z",
      "updatedAt": "2023-05-26T23:27:49Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "d538f6368d955bfeeaa1628f11af6f55f911641b",
      "headRepository": "fluffy/warp-draft",
      "headRefName": "newLines1",
      "headRefOid": "c5908411ee4d7681bf63d973344eb35a28b87cc8",
      "closedAt": "2023-05-26T23:27:31Z",
      "mergedAt": "2023-05-26T23:27:31Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "4d2b36952d5ad01726e0670cf0112b0f8e2b5dd2"
      },
      "comments": [
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No real changes here (other than adding a missing period) but changes newlines for checker tools ",
          "createdAt": "2023-05-26T23:24:53Z",
          "updatedAt": "2023-05-26T23:24:53Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5WQEbU",
          "commit": {
            "abbreviatedOid": "c590841"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM, as it seems to just whitespaces only change.",
          "createdAt": "2023-05-26T23:24:36Z",
          "updatedAt": "2023-05-26T23:27:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 200,
      "id": "PR_kwDOG2Ho4M5Reo3K",
      "title": "remove italics which generates invalid txt files with kramdown",
      "url": "https://github.com/moq-wg/moq-transport/pull/200",
      "state": "MERGED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The stuff we had to italicize the stuff in html is inserting underscores in the .txt file so I just want to remove this until for now until we figure this out. Did not change anything other than making the words not italicized\r\n",
      "createdAt": "2023-05-26T23:29:14Z",
      "updatedAt": "2023-05-26T23:31:22Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "4d2b36952d5ad01726e0670cf0112b0f8e2b5dd2",
      "headRepository": "fluffy/warp-draft",
      "headRefName": "fixFormat1",
      "headRefOid": "16cb678ddc02ea9f5c8f5172b9dc27165110c464",
      "closedAt": "2023-05-26T23:31:22Z",
      "mergedAt": "2023-05-26T23:31:22Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "6b29138d5cdcb5f78b075b684cf45262390f3a2e"
      },
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for catching this , the rendered TXT file looks different for these things. Merging it for now and we can work on figuring out the right markdown syntax. ",
          "createdAt": "2023-05-26T23:31:01Z",
          "updatedAt": "2023-05-26T23:31:01Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5WQFCU",
          "commit": {
            "abbreviatedOid": "16cb678"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-26T23:31:13Z",
          "updatedAt": "2023-05-26T23:31:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 201,
      "id": "PR_kwDOG2Ho4M5Rep9t",
      "title": "reflow document",
      "url": "https://github.com/moq-wg/moq-transport/pull/201",
      "state": "MERGED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I have no idea if people want to merge this or not. This does not change a single character of the draft but does reflow all the markdown. Some people like this, some people hate this. \r\n\r\nI like it because github only really does line by line diffs and this minimizes the stuff on a single line thus makes diffs smaller and easier to deal with and less likely to get a merge conflict..  I think it works well with a github work flow as long as wen you edit stuff, you do not reflow and try and just only change the line you need to change. Over time things get out of wack and eventually you need to have a reflow PR like this. \r\n\r\nIf we are going to do a reflow, now is an ideal time because we do not have a bunch of outstanding PRs. ",
      "createdAt": "2023-05-26T23:43:08Z",
      "updatedAt": "2023-05-26T23:55:58Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "6b29138d5cdcb5f78b075b684cf45262390f3a2e",
      "headRepository": "fluffy/warp-draft",
      "headRefName": "reflow2",
      "headRefOid": "6f9a20ec23636c8b420d99ae3aca56e3f47d4ac3",
      "closedAt": "2023-05-26T23:55:57Z",
      "mergedAt": "2023-05-26T23:55:57Z",
      "mergedBy": "suhasHere",
      "mergeCommit": {
        "oid": "3f07456048f22666316f7c8a4f592d335cdd704f"
      },
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "In general I'm a fan of this - what is the max line length you used?",
          "createdAt": "2023-05-26T23:52:54Z",
          "updatedAt": "2023-05-26T23:52:54Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5WQGIw",
          "commit": {
            "abbreviatedOid": "6f9a20e"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This seems fine to me.  The changes look daunting but they are just moving the text around for wrapping",
          "createdAt": "2023-05-26T23:45:20Z",
          "updatedAt": "2023-05-26T23:45:20Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5WQHEs",
          "commit": {
            "abbreviatedOid": "6f9a20e"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-26T23:55:09Z",
          "updatedAt": "2023-05-26T23:55:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 211,
      "id": "PR_kwDOG2Ho4M5Stlfx",
      "title": "Update link in README",
      "url": "https://github.com/moq-wg/moq-transport/pull/211",
      "state": "MERGED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-06-11T20:58:26Z",
      "updatedAt": "2023-06-14T22:52:35Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "3f07456048f22666316f7c8a4f592d335cdd704f",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "kixelated-patch-1",
      "headRefOid": "6382dab79a45d39064bc5b79a6e5f6d15b41b88f",
      "closedAt": "2023-06-14T22:52:32Z",
      "mergedAt": "2023-06-14T22:52:32Z",
      "mergedBy": "kixelated",
      "mergeCommit": {
        "oid": "d23fcbb4ced6956aa9e7f2bdaba0efd0465d9b92"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5YPTjA",
          "commit": {
            "abbreviatedOid": "6382dab"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-14T22:37:15Z",
          "updatedAt": "2023-06-14T22:37:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 220,
      "id": "PR_kwDOG2Ho4M5UakcT",
      "title": "prepare for ietf version",
      "url": "https://github.com/moq-wg/moq-transport/pull/220",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-07-01T17:00:41Z",
      "updatedAt": "2023-08-01T18:35:10Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "d23fcbb4ced6956aa9e7f2bdaba0efd0465d9b92",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ietf-version",
      "headRefOid": "8a7503ba606a67ada04db307b0efb65c6b6c1fe7",
      "closedAt": "2023-08-01T18:35:10Z",
      "mergedAt": "2023-08-01T18:35:10Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "5486f85b228f5ea025010021adc754b867528396"
      },
      "comments": [
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "can this be closed ?",
          "createdAt": "2023-07-22T03:44:05Z",
          "updatedAt": "2023-07-22T03:44:05Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "This needs to be merged to get the version that is in the data tracker.",
          "createdAt": "2023-07-22T06:54:08Z",
          "updatedAt": "2023-07-22T06:54:08Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@ianswett , this PR needs to be merged since the current version on the main branch doesn't reflect what is submitted to the IETF . ",
          "createdAt": "2023-07-27T17:41:53Z",
          "updatedAt": "2023-07-27T17:41:53Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "```\r\ngit rm draft-lcurley-moq-transport.md\r\ngit commit\r\n```\r\n\r\nOtherwise there will be two copies of the draft in the repo. If you rm in this PR, then the diff will show up on GitHub.",
          "createdAt": "2023-07-30T17:11:45Z",
          "updatedAt": "2023-07-30T17:11:45Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I pushed the delete.",
          "createdAt": "2023-07-30T17:21:26Z",
          "updatedAt": "2023-07-30T17:21:26Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5cmG3O",
          "commit": {
            "abbreviatedOid": "37421a7"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-29T23:03:17Z",
          "updatedAt": "2023-07-29T23:03:17Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5cmwpH",
          "commit": {
            "abbreviatedOid": "37421a7"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "FWIW ... I build, diffed, and looks good to me. ",
          "createdAt": "2023-07-30T16:02:21Z",
          "updatedAt": "2023-07-30T16:02:21Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5cmyo5",
          "commit": {
            "abbreviatedOid": "560f1c0"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-30T17:22:25Z",
          "updatedAt": "2023-07-30T17:26:59Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "art",
              "createdAt": "2023-07-30T17:22:56Z",
              "updatedAt": "2023-07-30T17:26:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5cm2YM",
          "commit": {
            "abbreviatedOid": "560f1c0"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-30T19:52:17Z",
          "updatedAt": "2023-07-30T19:52:17Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5c1jso",
          "commit": {
            "abbreviatedOid": "560f1c0"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-01T18:01:02Z",
          "updatedAt": "2023-08-01T18:01:03Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "```suggestion\r\narea: Applications and Real-Time\r\n```",
              "createdAt": "2023-08-01T18:01:02Z",
              "updatedAt": "2023-08-01T18:01:03Z"
            }
          ]
        }
      ]
    },
    {
      "number": 232,
      "id": "PR_kwDOG2Ho4M5X5is_",
      "title": "Specify draft versions.",
      "url": "https://github.com/moq-wg/moq-transport/pull/232",
      "state": "MERGED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Based on QUIC: https://datatracker.ietf.org/doc/html/draft-ietf-quic-transport-27#name-versions\r\n\r\nFixes #214 ",
      "createdAt": "2023-08-14T16:04:52Z",
      "updatedAt": "2023-09-25T16:46:56Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "361753a0f08d6564de829eb52e7d69856a37d03e",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "versions",
      "headRefOid": "411efdf702d8f2d9309654a39be41df9a1e86eaa",
      "closedAt": "2023-09-25T16:46:56Z",
      "mergedAt": "2023-09-25T16:46:56Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "106f827d30f81d300aa5d8604424fe3906ac21d3"
      },
      "comments": [
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Based on call today, sounds like when running over QUIC we should also use an ALPN of \"moq-13\" for draft 13 \r\n",
          "createdAt": "2023-08-14T16:50:57Z",
          "updatedAt": "2023-08-14T16:50:57Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "When running over web transport, we need to talk to the web transport people to talk about what to do but the ALPN would be H3 (or whatever) so the answer is not ALPN ",
          "createdAt": "2023-08-14T16:54:21Z",
          "updatedAt": "2023-08-14T16:54:21Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "The conclusion was that we should move version negotiation out of the SETUP message and into an ALPN for native QUIC and an unspecified mechanism for WebTransport.\r\n\r\nHowever, I can't think of any replacement for WebTransport that would work today. Query parameters would work for passing the client supported versions but there's no mechanism for replying with the server selected version. The javascript API provides no information about connection establishment (ex. any returned headers), only that it completed. If we moved version negotiation out of SETUP, then it would not be possible to interop until new WebTransport functionality was deployed, assuming W3C agrees in the first place.\r\n\r\nCould we go ahead with this PR until there's an available alternative? I like the direction of utilizing more of the QUIC/WebTransport handshake, but I don't think we should block interop awaiting this marginally better design.",
          "createdAt": "2023-08-17T18:35:09Z",
          "updatedAt": "2023-08-17T18:36:22Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Can we add in the ALPN text as part of this PR and for now say something like \"When QUIC is used, the negotiated alpn MUST match the value in the SETUP message.\"?",
          "createdAt": "2023-08-21T16:14:04Z",
          "updatedAt": "2023-08-21T16:14:04Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5eAo8l",
          "commit": {
            "abbreviatedOid": "411efdf"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-08-14T16:34:19Z",
          "updatedAt": "2023-09-25T16:28:52Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5eAqdJ",
          "commit": {
            "abbreviatedOid": "411efdf"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks fine to me. Sure we might do more complicated stuff later but this seems like good enough for now. ",
          "createdAt": "2023-08-14T16:37:05Z",
          "updatedAt": "2023-09-25T16:28:52Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5eArX0",
          "commit": {
            "abbreviatedOid": "411efdf"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I would want to consider using alpn at some point in time. \r\nWant to keep it open for major.minor version at some point too.\r\n\r\nThis PR is fine to continue the experimentation.",
          "createdAt": "2023-08-14T16:38:40Z",
          "updatedAt": "2023-09-25T16:28:52Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5eAzQR",
          "commit": {
            "abbreviatedOid": "b021130"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Per conversation, the intent is to use ALPN in raw QUIC to negotiate protocol and version.\r\n\r\nie: moq-<draftnum> as the ALPN string.\r\n\r\nThe intent is to work with the WebTransport working group on how to achieve similar functionality in WebTransport.",
          "createdAt": "2023-08-14T16:58:41Z",
          "updatedAt": "2023-08-14T16:58:41Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5h59Mt",
          "commit": {
            "abbreviatedOid": "411efdf"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Per conversation, we've decided to move forward with this and do ALPN as a separate PR.",
          "createdAt": "2023-09-25T16:30:07Z",
          "updatedAt": "2023-09-25T16:30:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 234,
      "id": "PR_kwDOG2Ho4M5YBcvC",
      "title": "Fix Track Request Params section ordering and missing info in announce_ok",
      "url": "https://github.com/moq-wg/moq-transport/pull/234",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR moves track request params to its own section. This was messed up during huge PR merge as part of preparing for IETF117 work. \r\n\r\nAlso it add track namespace length field to Announce_OK message which was omitted.",
      "createdAt": "2023-08-16T03:28:42Z",
      "updatedAt": "2023-08-21T16:58:24Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "5486f85b228f5ea025010021adc754b867528396",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "nit-fix",
      "headRefOid": "16f15d15e61b5355f55652e76f6612cc7ce5417f",
      "closedAt": "2023-08-21T16:58:24Z",
      "mergedAt": "2023-08-21T16:58:24Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "7a756b77b7879f5dee5d96192b5e10720c564446"
      },
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@vasilvv good catch. updated the commit to address your comment. Thanks",
          "createdAt": "2023-08-16T18:10:26Z",
          "updatedAt": "2023-08-16T18:10:26Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5ePJGI",
          "commit": {
            "abbreviatedOid": "ff2937b"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "You may also want to move the actual definition of Track Request Parameter, it's currently in the SUBSCRIBE REQUEST section.",
          "createdAt": "2023-08-16T16:37:51Z",
          "updatedAt": "2023-08-16T16:37:51Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5eXqwM",
          "commit": {
            "abbreviatedOid": "16f15d1"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "It's an improvement so we should merge, but we do need to clean up how parameters are encoded.",
          "createdAt": "2023-08-17T18:47:17Z",
          "updatedAt": "2023-08-17T18:52:40Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "> This parameter is applicable in SUBSCRIBE REQUEST message.\r\n\r\nIt's quite difficult to cross-reference which parameters are valid for which messages. We only have 3 parameters now and 2 messages so it's not a big deal now, but even just scanning these parameter descriptions to determine which parameters are valid in which messages is time consuming. It also produces a poor narrative, as the behavior of SUBSCRIBE REQUEST is described in this section. \r\n\r\nThere should be a single way to encode optional parameters specified in the encoding section which would also be used by SETUP. Then have each message declare the available parameters and their functionality instead of using this shared section. ",
              "createdAt": "2023-08-17T18:47:17Z",
              "updatedAt": "2023-08-17T18:52:40Z"
            },
            {
              "originalPosition": 56,
              "body": "`(..)`\r\n\r\nAlso, I added the `(b)` encoding to avoid the need explicitly put the size in front of each byte slice. We should use it or remove it.\r\n\r\n```\r\nTrack Namespace (b)\r\n```\r\n\r\nIs equivalent to:\r\n```\r\nTrack Namespace Length (i)\r\nTrack Namespace (..)\r\n```",
              "createdAt": "2023-08-17T18:50:56Z",
              "updatedAt": "2023-08-17T18:52:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5eniP2",
          "commit": {
            "abbreviatedOid": "16f15d1"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-21T16:30:35Z",
          "updatedAt": "2023-08-21T16:30:35Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "+1, we should definitely have an encoding to avoid having a length preceding every variable length entry.",
              "createdAt": "2023-08-21T16:30:35Z",
              "updatedAt": "2023-08-21T16:30:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5enjCX",
          "commit": {
            "abbreviatedOid": "16f15d1"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-21T16:32:44Z",
          "updatedAt": "2023-08-21T16:32:44Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "Should this be close the session?  ",
              "createdAt": "2023-08-21T16:32:44Z",
              "updatedAt": "2023-08-21T16:32:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5enjdl",
          "commit": {
            "abbreviatedOid": "16f15d1"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-21T16:33:48Z",
          "updatedAt": "2023-08-21T16:33:48Z",
          "comments": [
            {
              "originalPosition": 74,
              "body": "Can we use 'Type' instead of key, since that's more standard?",
              "createdAt": "2023-08-21T16:33:48Z",
              "updatedAt": "2023-08-21T16:33:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5enjq1",
          "commit": {
            "abbreviatedOid": "16f15d1"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-21T16:34:23Z",
          "updatedAt": "2023-08-21T16:34:23Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "IIRC, Someone from the quic community thought b(...) was confusing and QUIC's defined way is clear enough .. Hence most of this was reverted at some point ..\r\n\r\nI am open to either approach. Let's pick one",
              "createdAt": "2023-08-21T16:34:23Z",
              "updatedAt": "2023-08-21T16:34:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 235,
      "id": "PR_kwDOG2Ho4M5YGamF",
      "title": "Add support for Unsubscribe message",
      "url": "https://github.com/moq-wg/moq-transport/pull/235",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR adds support for subscribers to issue unsubscribe requests to express its interest in not receiving media for a given track. This reflects discussions from #203 \r\n\r\nThe high level call flow is\r\n\r\n```mermaid\r\nsequenceDiagram\r\n  Bob->>Relay: SUBSCRIBE( webex.com/alice/hd-video)\r\n  Bob->>Relay: SUBSCRIBE( webex.com/alice/audio)\r\n  loop media\r\n        Relay-->Bob: Media Exchange (audio, hd-video)\r\n   end\r\n   Note left of Bob: Not interested in hd-video anymore\r\n   Bob->>Relay: UNSUBSCRIBE(webex.com/alice/hd-video)\r\n   Relay->>Bob: UNSUBSCRIBE OK (webex.com/alice/hd-video)\r\n   loop media\r\n        Relay-->Bob: Media Exchange continues unaltered for audio\r\n   end\r\n```\r\n",
      "createdAt": "2023-08-16T21:07:14Z",
      "updatedAt": "2023-09-18T17:11:36Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "57dd3279e06b24031f9082b19d8c524b46b3fe78",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "unsubscribe",
      "headRefOid": "6f3f1530cd60930527ad0e0441a779558f93e9f0",
      "closedAt": "2023-09-18T17:11:36Z",
      "mergedAt": "2023-09-18T17:11:36Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "361753a0f08d6564de829eb52e7d69856a37d03e"
      },
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Thinking about it some more, an error code doesn't seem necessary. \r\n\r\npublisher -> subscriber should have an error code.\r\nsubscriber -> publisher doesn't need an error code.\r\n\r\nEven with an error code, it would get lost in the deduplication process.",
          "createdAt": "2023-09-14T04:27:39Z",
          "updatedAt": "2023-09-14T04:27:39Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5eWgAo",
          "commit": {
            "abbreviatedOid": "b48ab26"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Individual review",
          "createdAt": "2023-08-17T16:00:39Z",
          "updatedAt": "2023-08-17T16:04:25Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Renumbering will cause interop problems, but I agree that by the final rev we should have the messages in some reasonable ordering.  We could\r\n\r\n1) Keep it like this, and assume there's not much interop happening yet, so this is a freebie.\r\n2) keep all the numbers the same for now, add UNSUBSCRIBE and friends at the end, then renumber the messages later when version negotiation is better settled",
              "createdAt": "2023-08-17T16:00:39Z",
              "updatedAt": "2023-08-17T16:04:25Z"
            },
            {
              "originalPosition": 68,
              "body": "You can also do this with the track ID, since you can only unsubscribe things that had an ID.  I might leave FTN in UNSUBSCRIBE_OK/ERROR though.",
              "createdAt": "2023-08-17T16:03:12Z",
              "updatedAt": "2023-08-17T16:04:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5eWxef",
          "commit": {
            "abbreviatedOid": "b48ab26"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-17T16:40:09Z",
          "updatedAt": "2023-08-17T16:40:10Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "@afrind  you are right. The same thought went through my mind too. Then it felt , if we are changing it is good to change before our interop meeting :-) \r\n\r\nI am fine with either options too",
              "createdAt": "2023-08-17T16:40:09Z",
              "updatedAt": "2023-08-17T16:40:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5eW1w9",
          "commit": {
            "abbreviatedOid": "b48ab26"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-08-17T16:51:36Z",
          "updatedAt": "2023-08-17T17:45:08Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Yeah, don't change the ID numbers until there's a significant change.",
              "createdAt": "2023-08-17T16:51:36Z",
              "updatedAt": "2023-08-17T17:45:08Z"
            },
            {
              "originalPosition": 42,
              "body": "I don't think we need this message. Why would an UNSUBSCRIBE fail?\r\n\r\n### The producer already terminated the subscription\r\nThis means the producer already sent a SUBSCRIBE_ERROR/SUBSCRIBE_RESET, so sending an UNSUBSCRIBE_ERROR is just redundant.\r\n\r\n### The subscription does not exist\r\nWhich means the corresponding SUBSCRIBE was not received first. I think this is a protocol error and the connection can be closed instead. \r\n\r\n### Because I said so?\r\nI don't want to support a producer to say: \"no, I'm still going to keep sending this junk\". An UNSUBSCRIBE should always succeed.",
              "createdAt": "2023-08-17T17:12:54Z",
              "updatedAt": "2023-08-17T17:45:08Z"
            },
            {
              "originalPosition": 40,
              "body": "I don't think we need this message. I would have the producer reply with a SUBSCRIBE_RESET instead, mirroring how QUIC streams are reset. \r\n\r\n**SUBSCRIBE_RESET**: The subscription has ended and no further objects will be transmitted above the provided group/object sequence. Mirrors RESET_STREAM.\r\n\r\n**UNSUBSCRIBE**: Please terminate the subscription (at a given group/object sequence?). Implicitly acknowledged by the receipt of a SUBSCRIBE_RESET. Mirrors STOP_SENDING.\r\n\r\nNote: I think SUBSCRIBE_ERROR and SUBSCRIBE_RESET are the same message, but I'm splitting them here for sake of argument.",
              "createdAt": "2023-08-17T17:28:31Z",
              "updatedAt": "2023-08-17T17:45:08Z"
            },
            {
              "originalPosition": 68,
              "body": "Using the track ID isn't great in the current spec because you can't UNSUBSCRIBE prior to receiving a SUBSCRIBE_OK. \r\n\r\nHowever, that's fixed once the subscriber chooses the ID (#145), in which case all SUBSCRIBE messages should reference that ID instead of the full track name. There's no reason to use the full track name unless you're sending these control messages over separate streams, which will introduce a boat-load of race conditions.",
              "createdAt": "2023-08-17T17:41:46Z",
              "updatedAt": "2023-08-17T17:45:08Z"
            },
            {
              "originalPosition": 133,
              "body": "Why do we need auth information in an UNSUBSCRIBE message? This seems like an invalid use-case.",
              "createdAt": "2023-08-17T17:43:46Z",
              "updatedAt": "2023-08-17T17:45:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5gldE_",
          "commit": {
            "abbreviatedOid": "9850ffa"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "We'll need to revisit using track name vs track ID for unsubscribe once we have an answer to #145, but for now, this LGTM.",
          "createdAt": "2023-09-11T16:48:58Z",
          "updatedAt": "2023-09-11T16:48:58Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5goZFr",
          "commit": {
            "abbreviatedOid": "9850ffa"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "It might be useful to have an error code, but I'm not sure. LGTM.",
          "createdAt": "2023-09-12T04:18:53Z",
          "updatedAt": "2023-09-12T04:18:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 236,
      "id": "PR_kwDOG2Ho4M5YHVyc",
      "title": "Add support for un-announcing a track namespace",
      "url": "https://github.com/moq-wg/moq-transport/pull/236",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Following from discussions in #203 , this PR allows a given publishers to un-announce a track namespace to indicate that it is not longer accepting new subscribe requests.\r\n\r\nThe high-level call flow for happy path is as below\r\n\r\n```mermaid\r\nsequenceDiagram\r\n  Alice->>Relay: ANNOUNCE(webex.com/alice/)\r\n  Bob->>Relay: SUBSCRIBE( webex.com/alice/hd-video)\r\n  Relay->>Alice: SUBSCRIBE( webex.com/alice/hd-video)\r\n  loop media\r\n        Alice-->Bob: Media Exchange for hd-video\r\n   end\r\n   Alice->>Relay: UNANNOUNCE(webex.com/alice)\r\n   par Carl to Relay\r\n   Carl ->> Relay: SUBSCRIBE( webex.com/alice/hd-video)\r\n   opt Return error if subscribe cannot be served locally\r\n   Relay ->> Carl: SUBSCRIBE ERROR (...)\r\n   end\r\n   and Relay to Alice\r\n   Relay->> Alice: UNSUBSCRIBE(webex.com/alice/hd-video)\r\n   end\r\n   Relay->>Relay: Clean up publisher state for Alice\r\n```\r\n",
      "createdAt": "2023-08-17T03:35:18Z",
      "updatedAt": "2023-09-18T17:02:56Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "7a756b77b7879f5dee5d96192b5e10720c564446",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "unannounce",
      "headRefOid": "8259f3c6a28c01c708bf081cde3a5b16665656a9",
      "closedAt": "2023-09-18T17:02:55Z",
      "mergedAt": "2023-09-18T17:02:55Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "57dd3279e06b24031f9082b19d8c524b46b3fe78"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5eWiCW",
          "commit": {
            "abbreviatedOid": "10f85f7"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Individual Review",
          "createdAt": "2023-08-17T16:05:26Z",
          "updatedAt": "2023-08-17T16:08:49Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Same question/comment here as in the UNSUB PR regarding code points changing.",
              "createdAt": "2023-08-17T16:05:26Z",
              "updatedAt": "2023-08-17T16:08:49Z"
            },
            {
              "originalPosition": 21,
              "body": "Shouldn't this be \r\n\r\n`Track Namespace(...)` ?",
              "createdAt": "2023-08-17T16:05:45Z",
              "updatedAt": "2023-08-17T16:08:49Z"
            },
            {
              "originalPosition": 39,
              "body": "`(...)`",
              "createdAt": "2023-08-17T16:06:02Z",
              "updatedAt": "2023-08-17T16:08:49Z"
            },
            {
              "originalPosition": 51,
              "body": "We might want to give additional informational guidance that it's totally OK to continue serving existing SUBSCRIBEs too and it is up to the application to decide.",
              "createdAt": "2023-08-17T16:07:07Z",
              "updatedAt": "2023-08-17T16:08:49Z"
            },
            {
              "originalPosition": 64,
              "body": "`(...)`",
              "createdAt": "2023-08-17T16:07:25Z",
              "updatedAt": "2023-08-17T16:08:49Z"
            },
            {
              "originalPosition": 82,
              "body": "The only code I can imagine here is \"I've never heard of that namespace\".  It's not like the peer can say \"tough cookies, I'm going to keep routing SUBSCRIBE to you\".",
              "createdAt": "2023-08-17T16:08:20Z",
              "updatedAt": "2023-08-17T16:08:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5eWx07",
          "commit": {
            "abbreviatedOid": "10f85f7"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-17T16:41:05Z",
          "updatedAt": "2023-08-17T16:41:05Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "yes, my bad .. will fix it",
              "createdAt": "2023-08-17T16:41:05Z",
              "updatedAt": "2023-08-17T16:41:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5eXHfB",
          "commit": {
            "abbreviatedOid": "10f85f7"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-17T17:30:13Z",
          "updatedAt": "2023-08-17T17:30:13Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "@afrind Is this along the lines of your thinking\r\n\r\nThe publisher MAY respond with `SUBSCRIBE ERROR` message ({{message-subscribe-error}}) with an appropriate error for new SUBSCRIBE REQUESTs received for track(s) matching the track namespace after sending the unannounce message. However for existing subscriptions, it is up to the application to either continue to serve media or \r\nterminate serving those subscriptions.",
              "createdAt": "2023-08-17T17:30:13Z",
              "updatedAt": "2023-08-17T17:30:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5eXU4C",
          "commit": {
            "abbreviatedOid": "10f85f7"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-08-17T17:50:22Z",
          "updatedAt": "2023-08-17T18:21:22Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Same comments as #235, why could this fail? We don't need these OK/ERROR messages, even more so because the behavior of ANNOUNCE is so extremely vague right now.",
              "createdAt": "2023-08-17T17:50:22Z",
              "updatedAt": "2023-08-17T18:21:22Z"
            },
            {
              "originalPosition": 51,
              "body": "The text is a bit confusing since it talks about sending individual messages. Just say \"MAY terminate matching subscriptions\".\r\n\r\nHowever, I think this guidance is actually misleading. The publisher is allowed to continue existing subscriptions, but it can also continue to accept new subscriptions. The ANNOUNCE message indicates application \"intent\" but it should not cause relays to change their behavior by rejecting new subscriptions.\r\n\r\nIMO, the ANNOUNCE messages either needs to have zero impact on the SUBSCRIBE state machine (new and existing), or it needs to full impact (ANNOUNCE is the parent of SUBSCRIBE). Adding guidance that UNANNOUNCE might only have impact on new subscriptions is misleading; the behavior is actually undefined.",
              "createdAt": "2023-08-17T18:08:34Z",
              "updatedAt": "2023-08-17T18:21:22Z"
            },
            {
              "originalPosition": 57,
              "body": "> For tracks within the track namespace provided in the unannounce message, the receiver MUST unsubscribe from all the tracks and stop routing new SUBSCRIBE REQUESTs to the publisher.\r\n\r\nWow. I personally like this approach but I thought the group disagreed. [Alan's guidance](https://github.com/moq-wg/moq-transport/pull/236/files#r1297440814) runs contrary to this statement.",
              "createdAt": "2023-08-17T18:20:35Z",
              "updatedAt": "2023-08-17T18:21:22Z"
            },
            {
              "originalPosition": 82,
              "body": "Yeah, IMO it should never be valid to send `UNANNOUNCE_ERROR` otherwise it's just a protocol error.",
              "createdAt": "2023-08-17T18:21:09Z",
              "updatedAt": "2023-08-17T18:21:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5gldDv",
          "commit": {
            "abbreviatedOid": "9aa0d3a"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-11T16:48:55Z",
          "updatedAt": "2023-09-11T16:49:43Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "This collides with UNSUBSCRIBE if merged.\r\n\r\nI would use 0x18 or 0xA",
              "createdAt": "2023-09-11T16:48:55Z",
              "updatedAt": "2023-09-11T16:49:43Z"
            },
            {
              "originalPosition": 82,
              "body": "Can we add the error code back? Maybe the string reason too, if just for initial interop.",
              "createdAt": "2023-09-11T16:49:30Z",
              "updatedAt": "2023-09-11T16:49:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5glgcd",
          "commit": {
            "abbreviatedOid": "9aa0d3a"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-11T16:57:42Z",
          "updatedAt": "2023-09-11T16:59:01Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "Small thing: the RFC 9000 syntax is `(..)`, not `(...)`.",
              "createdAt": "2023-09-11T16:57:42Z",
              "updatedAt": "2023-09-11T16:59:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5glkk6",
          "commit": {
            "abbreviatedOid": "9aa0d3a"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-11T17:08:45Z",
          "updatedAt": "2023-09-11T17:08:45Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "+1",
              "createdAt": "2023-09-11T17:08:45Z",
              "updatedAt": "2023-09-11T17:08:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5g59fb",
          "commit": {
            "abbreviatedOid": "4ae94d3"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-14T04:28:04Z",
          "updatedAt": "2023-09-14T04:28:04Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5hQAXB",
          "commit": {
            "abbreviatedOid": "4ae94d3"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-18T17:00:48Z",
          "updatedAt": "2023-09-18T17:00:48Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "```suggestion\r\n  Track Namespace(..),\r\n```",
              "createdAt": "2023-09-18T17:00:48Z",
              "updatedAt": "2023-09-18T17:00:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5hQAdV",
          "commit": {
            "abbreviatedOid": "fb4fd4a"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-18T17:01:05Z",
          "updatedAt": "2023-09-18T17:01:05Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "```suggestion\r\n  Track Namespace(..),\r\n```",
              "createdAt": "2023-09-18T17:01:05Z",
              "updatedAt": "2023-09-18T17:01:05Z"
            }
          ]
        }
      ]
    },
    {
      "number": 246,
      "id": "PR_kwDOG2Ho4M5Z_GKs",
      "title": " Transport Delivery Mode and Subscription Hints",
      "url": "https://github.com/moq-wg/moq-transport/pull/246",
      "state": "CLOSED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a placeholder PR to support the issues #244 and #245 .  \r\n\r\nAll the discussions have to be done on those above issues listed and the suggestions/outcoms from the discussions are to be reflected in this PR.\r\n\r\n",
      "createdAt": "2023-09-11T07:01:03Z",
      "updatedAt": "2023-10-25T17:16:14Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "7a756b77b7879f5dee5d96192b5e10720c564446",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "experimental",
      "headRefOid": "b17213d383f34e5ebea09434e4b8b82d0caad42b",
      "closedAt": "2023-10-25T17:16:13Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Can we close this now that we have #289 ?",
          "createdAt": "2023-10-18T00:04:08Z",
          "updatedAt": "2023-10-18T00:04:08Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed since Subscription Hints (Locations) landed in -01, and we're still discussing delivery modes.",
          "createdAt": "2023-10-25T17:16:13Z",
          "updatedAt": "2023-10-25T17:16:13Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5iV24w",
          "commit": {
            "abbreviatedOid": "b17213d"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Lots of discussion in #244 and #245. We're not ready for a PR.",
          "createdAt": "2023-09-29T01:27:00Z",
          "updatedAt": "2023-09-29T01:27:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 255,
      "id": "PR_kwDOG2Ho4M5bejHx",
      "title": "Disallow unknown messages",
      "url": "https://github.com/moq-wg/moq-transport/pull/255",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #241 and #248.\r\n\r\nif messages must be known, explicit message lengths are redundanct except for OBJECT and messages with parameters.\r\n\r\nThis also eliminates a whole class of potential errors where the message length does not match the actual parsing of the message. Not checking this -- and not have any message type be potentially zero-length -- greatly simplifies the parser.",
      "createdAt": "2023-09-28T19:26:53Z",
      "updatedAt": "2023-10-09T17:16:16Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "106f827d30f81d300aa5d8604424fe3906ac21d3",
      "headRepository": "martinduke/moq-transport",
      "headRefName": "no-message-length",
      "headRefOid": "f703334b87b7cfc04d745fcd6ab4bc6854a97d33",
      "closedAt": "2023-10-09T16:36:56Z",
      "mergedAt": "2023-10-09T16:36:56Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "d86837dcd319a7f054a374513f74f92e08741eac"
      },
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "And trying to use messages without negotiating an extension/version just won't work for MoQ. We're designing a protocol explicitly for relays so you do need relay cooperation, or at the very least some information on how to forward unknown messages.",
          "createdAt": "2023-09-29T01:29:42Z",
          "updatedAt": "2023-09-29T04:21:57Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Also I love that you're using \"parameter count\" instead of \"parameter size (bytes)\". It makes it much easier to build a streaming encoder/decoder without allocating temporary buffers.",
          "createdAt": "2023-09-29T04:36:31Z",
          "updatedAt": "2023-09-29T04:37:11Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I thought we agreed to allow extensibility by allowing new message types to be created. ",
          "createdAt": "2023-10-03T14:23:49Z",
          "updatedAt": "2023-10-03T14:23:49Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Like to see us agree on a extensibility strategy before deciding what to do on this. \r\n\r\nWe also need to decide if messages can have optional fields",
          "createdAt": "2023-10-03T14:35:09Z",
          "updatedAt": "2023-10-03T14:35:09Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> I thought we agreed to allow extensibility by allowing new message types to be created.\r\n\r\nWe have version negotiation, and presumably we'll have extension negotiation too. What's the use-case for adding new messages without negotiating them? \r\n\r\nThe problem is that we can't relay unknown messages, so all it takes is a single uncooperative relay on the chain to shallow them. I think we need explicit negotiation as a result.",
          "createdAt": "2023-10-03T14:43:06Z",
          "updatedAt": "2023-10-03T14:43:06Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If we have extension negotiation, I agree.  But if our extension negotiation mechanism relies on not getting an error on unknown messages .... \r\n\r\nPR is wrong place to discuss this but I think what I would like to see is a good way to do extension negotiation, and then like you have here, error on any message that is not part of a negotiated extension.  I think I would lean that way if we had an extension negotiation mechanism.\r\n\r\nNote this is the opposite direction of HTTP which is often our model for things. HTTP just skips past unknown headers. ",
          "createdAt": "2023-10-03T15:19:47Z",
          "updatedAt": "2023-10-03T15:19:47Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5iVn-_",
          "commit": {
            "abbreviatedOid": "0be8bd8"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I love it.\r\n\r\nIt also means you can implement streaming encoders. Prefixing each message with the length required a temporary buffer or 2nd pass to compute the length.",
          "createdAt": "2023-09-28T23:31:35Z",
          "updatedAt": "2023-09-28T23:31:35Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5jIaVM",
          "commit": {
            "abbreviatedOid": "f703334"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-08T03:17:29Z",
          "updatedAt": "2023-10-08T03:17:29Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5jPILS",
          "commit": {
            "abbreviatedOid": "f703334"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LG.\r\n\r\nThe agreement at the interim was to follow up with separate frame types for object with and without length, but do that in a separate PR.",
          "createdAt": "2023-10-09T16:28:55Z",
          "updatedAt": "2023-10-09T16:28:55Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5jPKrZ",
          "commit": {
            "abbreviatedOid": "f703334"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2023-10-09T16:36:55Z",
          "updatedAt": "2023-10-09T16:36:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 256,
      "id": "PR_kwDOG2Ho4M5beqvR",
      "title": "Parameter Reform",
      "url": "https://github.com/moq-wg/moq-transport/pull/256",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #247, #251\r\n\r\n- Removes \"mandatory parameters\" from the SETUP message and just puts them in the main part of the message (retaining the notion of parameters as an extension point)\r\n\r\n- Unifies the two parameter namespaces into one (previously known as \"Track Request Parameters\")\r\n\r\n- Resolves the inconsistency about receiver reaction to duplicate parameters as a \"SHOULD\" close, not MUST. (Tracking the appearance of unknown parameter types is relatively resource-intensive)\r\n\r\n- Specifies that parameters that arrive in messages where they don't apply are ignored, without error.",
      "createdAt": "2023-09-28T19:51:03Z",
      "updatedAt": "2023-11-13T22:30:45Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "fbde56a237942020d0b05f26cd10d8775edcb72a",
      "headRepository": "martinduke/moq-transport",
      "headRefName": "parameters",
      "headRefOid": "2987673c765dab48042ccf6b01d5d221e37bc8cb",
      "closedAt": "2023-10-25T17:18:30Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "I generally like the direction of this PR. But would like to discuss this as part of or post interop.",
          "createdAt": "2023-09-29T19:16:44Z",
          "updatedAt": "2023-09-29T19:16:44Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Don't see this as big deal one way another but looks fine to me. ",
          "createdAt": "2023-10-03T14:40:00Z",
          "updatedAt": "2023-10-03T14:40:00Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Check the [transport parameter encoding in QUIC](https://www.rfc-editor.org/rfc/rfc9000.html#name-transport-parameter-encodin):\r\n~~~\r\nTransport Parameter {\r\n  Transport Parameter ID (i),\r\n  Transport Parameter Length (i),\r\n  Transport Parameter Value (..),\r\n}\r\n~~~\r\nI think this is solving the exact same problem as Setup parameters: transport parameters with unknown ID can just be skipped.",
          "createdAt": "2023-10-04T15:06:02Z",
          "updatedAt": "2023-10-04T15:06:02Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Major changes from Boston:\r\n- There are SETUP parameters (which are constant across all versions) and version-specific parameters (which apply to all messages except SETUP-- SUBSCRIBE_REQUEST and ANNOUNCE).\r\n- The LSB of the type indicates if the length is varint-encoded or the length is itself a varint.\r\n- Editorial rearranging.\r\n- Keeps the new rules about duplicate parameters and ignoring inapplicable parameters.",
          "createdAt": "2023-10-04T19:04:18Z",
          "updatedAt": "2023-10-04T19:04:18Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, maybe we just copy QUIC... which is basically the current encoding. I didn't realize that QUIC transport parameters include a redundant size for varints.\r\n\r\nI do like Cullen's and Christian's suggestion that the encoding is specific to the ID. It means we can have other encodings other than string/int, kinda like `preferred_address` in QUIC. The cost is that we waste a byte for each varint and have to validate the redundant size, but whatever.",
          "createdAt": "2023-10-05T17:26:41Z",
          "updatedAt": "2023-10-05T17:31:23Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The proposed syntax looks like early optimization, trying to save a few bytes of encoding by having two classes of identifiers. I would much rather have something like the QUIC transport parameters:\r\n> \r\n> ```\r\n> Parameter {\r\n>    Parameter Type (i),\r\n>    Parameter Length (i),\r\n>    Parameter Value (...)\r\n> }\r\n> ```\r\n> \r\n> My proposal would assume that parameter types are standardized, or at least registered, and that the registration specifies the encoding. That encoding will in many cases be \"integer\" or \"string\", but it does not have to be forever.\r\n\r\nI agree that QUIC does this. It does create the error case where the varint length is different from the parameter length, and it's nice when encodings don't allow these kinds of errors\r\n",
          "createdAt": "2023-10-05T17:34:28Z",
          "updatedAt": "2023-10-05T17:34:28Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Leaving a note for myself. I would love to review this post interim. ",
          "createdAt": "2023-10-05T17:37:59Z",
          "updatedAt": "2023-10-05T17:37:59Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There are a couple of sub-issues where I'm not quite ready to surrender yet: length encoding, and the number of parameter registries/namespaces we're going to have. I sent an email to the list to discuss further.",
          "createdAt": "2023-10-09T18:24:46Z",
          "updatedAt": "2023-10-09T18:24:46Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "My ideal solution would be to keep flexible SETUP parameters for version/extension negotiation, but use fixed encodings for other messages.",
          "createdAt": "2023-10-18T04:41:57Z",
          "updatedAt": "2023-10-18T04:42:06Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Are we planning to rebase this on main for the remaining issues, or should we close it?",
          "createdAt": "2023-10-25T17:17:03Z",
          "updatedAt": "2023-10-25T17:17:03Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this is rapidly becoming OBE, closing.",
          "createdAt": "2023-10-25T17:18:30Z",
          "updatedAt": "2023-10-25T17:18:30Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5iV2rr",
          "commit": {
            "abbreviatedOid": "bf57c81"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "SETUP needs to support arbitrary parameters for version negotiation. Version 00 might require role/path, but other versions might not. These fields would be deprecated pretty quickly and set to 0 much like some TLS headers before the switch was made to generic fields.\r\n\r\nHowever if we used ALPN or equivalent in WebTransport for version negotiation, then I would love to used a fixed encoding. It makes life sooo much easier. I would like to use a fixed encoding in SUBSCRIBE/ANNOUNCE since the version has already been negotiated though.",
          "createdAt": "2023-09-29T01:25:11Z",
          "updatedAt": "2023-09-29T20:41:43Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5i3nF_",
          "commit": {
            "abbreviatedOid": "b72c045"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Individual/Editorial Review",
          "createdAt": "2023-10-05T01:29:00Z",
          "updatedAt": "2023-10-05T01:42:40Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Seems like they could also be represented as an Int param with value=0 or 1.  Is that allowed?",
              "createdAt": "2023-10-05T01:29:01Z",
              "updatedAt": "2023-10-05T01:42:40Z"
            },
            {
              "originalPosition": 98,
              "body": "nit: Would GROUP START SEQUENCE or just GROUP START be a more apt name?  Particularly if we add GROUP END later.",
              "createdAt": "2023-10-05T01:30:58Z",
              "updatedAt": "2023-10-05T01:42:40Z"
            },
            {
              "originalPosition": 101,
              "body": "Editorial: with the `, when this param` reads awkwardly to me.  I think it's better without the comma, or start the sentence with the when clause?",
              "createdAt": "2023-10-05T01:32:39Z",
              "updatedAt": "2023-10-05T01:42:40Z"
            },
            {
              "originalPosition": 108,
              "body": "Did we put AUTH before OBJECT SEQUENCE because we're listing them numerically?  I think keeping GROUP and OBJECT next to each other will read better.",
              "createdAt": "2023-10-05T01:33:37Z",
              "updatedAt": "2023-10-05T01:42:40Z"
            },
            {
              "originalPosition": 111,
              "body": "nit: same name comment as with GROUP SEQUENCE",
              "createdAt": "2023-10-05T01:34:00Z",
              "updatedAt": "2023-10-05T01:42:40Z"
            },
            {
              "originalPosition": 240,
              "body": "Maybe:\r\n\r\nAuthorization Info is applicable to this message, but is not mandatory.\r\n.",
              "createdAt": "2023-10-05T01:38:44Z",
              "updatedAt": "2023-10-05T01:42:40Z"
            },
            {
              "originalPosition": 240,
              "body": "Maybe:\r\n\r\nAuthorization Info is applicable to this message, but is not mandatory.\r\n.",
              "createdAt": "2023-10-05T01:38:54Z",
              "updatedAt": "2023-10-05T01:42:40Z"
            },
            {
              "originalPosition": 221,
              "body": "Maybe this is best captured with a small table like:\r\n\r\n```\r\nParam     | Mandatory / Optional / Invalid\r\n-----------------\r\nGROUP SEQ | Optional\r\nOBJ SEQ   | Optional\r\nAUTH INFO | Optional\r\n```\r\n Similar for other messages with params",
              "createdAt": "2023-10-05T01:41:52Z",
              "updatedAt": "2023-10-05T01:42:40Z"
            },
            {
              "originalPosition": 240,
              "body": "See above comment about a table.",
              "createdAt": "2023-10-05T01:42:10Z",
              "updatedAt": "2023-10-05T01:42:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5i8HLx",
          "commit": {
            "abbreviatedOid": "b72c045"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I'd like to review this in more detail but initial reaction is mostly looks fine to me. ",
          "createdAt": "2023-10-05T13:52:39Z",
          "updatedAt": "2023-10-05T13:55:20Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "I would prefer to see these have an named value or label then an IANA table that mapped that name or label to the value 0x01 ",
              "createdAt": "2023-10-05T13:52:39Z",
              "updatedAt": "2023-10-05T13:55:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5i8miy",
          "commit": {
            "abbreviatedOid": "b72c045"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "The proposed syntax looks like early optimization, trying to save a few bytes of encoding by having two classes of identifiers. I would much rather have something like the QUIC transport parameters:\r\n\r\n~~~\r\nParameter {\r\n   Parameter Type (i),\r\n   Parameter Length (i),\r\n   Parameter Value (...)\r\n}\r\n~~~\r\n\r\nMy proposal would assume that parameter types are standardized, or at least registered, and that the registration specifies the encoding. That encoding will in many cases be \"integer\" or \"string\", but it does not have to be forever.",
          "createdAt": "2023-10-05T14:39:33Z",
          "updatedAt": "2023-10-05T14:39:33Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5i9yhD",
          "commit": {
            "abbreviatedOid": "b72c045"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-05T17:19:45Z",
          "updatedAt": "2023-10-05T17:19:45Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "Well the issue with that is that you to have to extract the length if you don't know the parameter type.",
              "createdAt": "2023-10-05T17:19:45Z",
              "updatedAt": "2023-10-05T17:19:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5jO-TN",
          "commit": {
            "abbreviatedOid": "b72c045"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-09T16:01:28Z",
          "updatedAt": "2023-10-09T16:01:28Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I would rather just say, \"Receiver ignore unrecognized parameters\". ",
              "createdAt": "2023-10-09T16:01:28Z",
              "updatedAt": "2023-10-09T16:01:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5jO_aj",
          "commit": {
            "abbreviatedOid": "b72c045"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-09T16:04:25Z",
          "updatedAt": "2023-10-09T16:04:25Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "what is a namespace constant?",
              "createdAt": "2023-10-09T16:04:25Z",
              "updatedAt": "2023-10-09T16:04:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5jO_qE",
          "commit": {
            "abbreviatedOid": "b72c045"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-09T16:05:06Z",
          "updatedAt": "2023-10-09T16:05:07Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "but unclear on what it means different to other message types. May be more clarification is needed ?",
              "createdAt": "2023-10-09T16:05:06Z",
              "updatedAt": "2023-10-09T16:05:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5jPAST",
          "commit": {
            "abbreviatedOid": "b72c045"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-09T16:06:48Z",
          "updatedAt": "2023-10-09T16:06:48Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "May be this comment is not for this PR. The way it is defined today, will limit the lenghth of the string to 7 bytes. are we ok with that ?",
              "createdAt": "2023-10-09T16:06:48Z",
              "updatedAt": "2023-10-09T16:06:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5jPAgt",
          "commit": {
            "abbreviatedOid": "b72c045"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-09T16:07:25Z",
          "updatedAt": "2023-10-09T16:07:25Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "I would rather define a Bool parameter type than overloading the meaning of the value.",
              "createdAt": "2023-10-09T16:07:25Z",
              "updatedAt": "2023-10-09T16:07:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5jPA-s",
          "commit": {
            "abbreviatedOid": "b72c045"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-09T16:08:45Z",
          "updatedAt": "2023-10-09T16:08:45Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "the role parameter needs to be optional or there should be a default value if not provided.",
              "createdAt": "2023-10-09T16:08:45Z",
              "updatedAt": "2023-10-09T16:08:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5jPCJy",
          "commit": {
            "abbreviatedOid": "b72c045"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-09T16:12:11Z",
          "updatedAt": "2023-10-09T16:12:11Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "Please add reference to to section defining groups",
              "createdAt": "2023-10-09T16:12:11Z",
              "updatedAt": "2023-10-09T16:12:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5jPCXy",
          "commit": {
            "abbreviatedOid": "b72c045"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-09T16:12:48Z",
          "updatedAt": "2023-10-09T16:12:48Z",
          "comments": [
            {
              "originalPosition": 108,
              "body": "@afrind  this comes due to integer/string encoding ;) ",
              "createdAt": "2023-10-09T16:12:48Z",
              "updatedAt": "2023-10-09T16:12:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5jPCd6",
          "commit": {
            "abbreviatedOid": "b72c045"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-09T16:13:04Z",
          "updatedAt": "2023-10-09T16:13:04Z",
          "comments": [
            {
              "originalPosition": 111,
              "body": "please add reference to section defining object sequence",
              "createdAt": "2023-10-09T16:13:04Z",
              "updatedAt": "2023-10-09T16:13:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5jPDoW",
          "commit": {
            "abbreviatedOid": "b72c045"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for the work Martin. I do have few nits and clarification questions. Overall i feel this is looking good. ",
          "createdAt": "2023-10-09T16:16:28Z",
          "updatedAt": "2023-10-09T16:16:28Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5jPCfb",
          "commit": {
            "abbreviatedOid": "b72c045"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-09T16:13:08Z",
          "updatedAt": "2023-10-09T16:39:09Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "I'm not sure I follow. The parameter length is a VarInt with a maximum size of 2^62",
              "createdAt": "2023-10-09T16:13:08Z",
              "updatedAt": "2023-10-09T16:39:09Z"
            },
            {
              "originalPosition": 78,
              "body": "I think role is very useful, but kind of annoying as it is currently defined. The application has to know and specify the intention of the server, which also means there's no possible default. I would like to see the role describe the local endpoint's capability, not the server's intended behavior. See #151 \r\n\r\nBut this is out of scope of the PR.",
              "createdAt": "2023-10-09T16:26:35Z",
              "updatedAt": "2023-10-09T16:39:09Z"
            },
            {
              "originalPosition": 98,
              "body": "+1",
              "createdAt": "2023-10-09T16:26:48Z",
              "updatedAt": "2023-10-09T16:39:09Z"
            },
            {
              "originalPosition": 221,
              "body": "Yeah my concern is that we're going to have a full compatibility matrix when we add more params to more messages. I'd rather just define the parameters for each messages individually, instead of sharing one big parameter namespace.",
              "createdAt": "2023-10-09T16:27:31Z",
              "updatedAt": "2023-10-09T16:39:09Z"
            },
            {
              "originalPosition": 49,
              "body": "Maybe remove this line? I think using both a `string` and `int` are valid ways to encode a boolean, and it's up to the parameter to specify the encoding.\r\n\r\nI'm not sure you want to use a string though. Do you just put arbitrary data if it's a truthy value, zero bytes if it's falsy, and missing if it's undefined?",
              "createdAt": "2023-10-09T16:39:07Z",
              "updatedAt": "2023-10-09T16:39:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5jPZGD",
          "commit": {
            "abbreviatedOid": "b72c045"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-09T17:24:37Z",
          "updatedAt": "2023-10-09T17:24:38Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "The model I had in mind was for extension negotiation, where presence of the parameter was an implied True. I think there's value of setting a norm for how this works. But since this seems to be creating a lot of trouble I'll just delete it.",
              "createdAt": "2023-10-09T17:24:38Z",
              "updatedAt": "2023-10-09T17:24:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5jPZtu",
          "commit": {
            "abbreviatedOid": "b72c045"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-09T17:26:48Z",
          "updatedAt": "2023-10-09T17:26:48Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "Added the reference. I don't mind the name change but I took this from the current draft and would prefer a separate issue/PR for parameter renaming.",
              "createdAt": "2023-10-09T17:26:48Z",
              "updatedAt": "2023-10-09T17:26:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5jPZ98",
          "commit": {
            "abbreviatedOid": "b72c045"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-09T17:27:42Z",
          "updatedAt": "2023-10-09T17:27:42Z",
          "comments": [
            {
              "originalPosition": 108,
              "body": "Yes, it was numerical, but I'll just change it back.",
              "createdAt": "2023-10-09T17:27:42Z",
              "updatedAt": "2023-10-09T17:27:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5jPbw8",
          "commit": {
            "abbreviatedOid": "b72c045"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-09T17:34:12Z",
          "updatedAt": "2023-10-09T17:34:13Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "a namespace THAT IS constant across...",
              "createdAt": "2023-10-09T17:34:12Z",
              "updatedAt": "2023-10-09T17:34:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5jPb8S",
          "commit": {
            "abbreviatedOid": "b72c045"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-09T17:34:53Z",
          "updatedAt": "2023-10-09T17:34:54Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "and for all other message types...",
              "createdAt": "2023-10-09T17:34:53Z",
              "updatedAt": "2023-10-09T17:34:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5jPcG3",
          "commit": {
            "abbreviatedOid": "b72c045"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-09T17:35:30Z",
          "updatedAt": "2023-10-09T17:35:30Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "yes, the limit is 2^62.",
              "createdAt": "2023-10-09T17:35:30Z",
              "updatedAt": "2023-10-09T17:35:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5jPcSM",
          "commit": {
            "abbreviatedOid": "b72c045"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-09T17:36:11Z",
          "updatedAt": "2023-10-09T17:36:11Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "I agree that this is out of scope.  See #250 ",
              "createdAt": "2023-10-09T17:36:11Z",
              "updatedAt": "2023-10-09T17:36:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5jZx6d",
          "commit": {
            "abbreviatedOid": "13ce11d"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T13:16:33Z",
          "updatedAt": "2023-10-10T13:16:33Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "no I did not mean that. I mean that in the text of the draft we in the role section we do not put 0x01, we put a name for that constant like SETUP_PAR_ROLE then later in the document we have an IANA table that defined SETUP_PAR_ROLE  as 0x01. This is only a change in the way the doc is organized, not anything on the wire. I really don't care about this very much but I find it an easy way to make sure that two different places in the doc did not accidentally use 0x01 for when they mean to have different code points.  It also helps with library API because then people end up definiing the constants in the API to match the spec and it makes it easier to figure out what the API does. Again, all way secondary benefits and we can do this way later in the spec development. Do not need to figure this out to merge this PR. \r\n",
              "createdAt": "2023-10-10T13:16:33Z",
              "updatedAt": "2023-10-10T13:16:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5jc4tX",
          "commit": {
            "abbreviatedOid": "b72c045"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T18:02:36Z",
          "updatedAt": "2023-10-10T18:02:36Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "Ah, i see now that I massively misinterpreted your comment. I added a TODO since the IANA considerations section is not ready for this yet.\r\n",
              "createdAt": "2023-10-10T18:02:36Z",
              "updatedAt": "2023-10-10T18:02:36Z"
            }
          ]
        }
      ]
    },
    {
      "number": 257,
      "id": "PR_kwDOG2Ho4M5berF1",
      "title": "Change draft version to 'latest'",
      "url": "https://github.com/moq-wg/moq-transport/pull/257",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #254 ",
      "createdAt": "2023-09-28T19:52:02Z",
      "updatedAt": "2023-10-09T17:40:00Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "106f827d30f81d300aa5d8604424fe3906ac21d3",
      "headRepository": "martinduke/moq-transport",
      "headRefName": "latest",
      "headRefOid": "4d5433a4a3c1db8868df343bacf691185d5490c2",
      "closedAt": "2023-10-09T17:40:00Z",
      "mergedAt": "2023-10-09T17:40:00Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "704dbc80c896d6fd6a04d93b2dadea932183efb6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5iV2JD",
          "commit": {
            "abbreviatedOid": "4d5433a"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "+1 this shouldn't have been checked in. ",
          "createdAt": "2023-09-29T01:20:17Z",
          "updatedAt": "2023-09-29T01:20:17Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5iqobj",
          "commit": {
            "abbreviatedOid": "4d5433a"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-03T14:21:35Z",
          "updatedAt": "2023-10-03T14:21:35Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5jPdlh",
          "commit": {
            "abbreviatedOid": "4d5433a"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-09T17:39:54Z",
          "updatedAt": "2023-10-09T17:39:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 258,
      "id": "PR_kwDOG2Ho4M5bgAMo",
      "title": "Allow the Track Alias to be selected by the publisher",
      "url": "https://github.com/moq-wg/moq-transport/pull/258",
      "state": "MERGED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently SUBSCRIBE_OK and OBJECT will race. If OBJECT wins (>50% chance for multi-threaded QUIC libraries), then the subscriber will receive an unknown OBJECT that needs to be buffered. Moving Track ID to SUBSCRIBE fixes this race, removes the need to buffer OBJECTs in the MoqT library, and simplifies the flow. See #145",
      "createdAt": "2023-09-29T04:17:03Z",
      "updatedAt": "2024-01-10T17:24:34Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "9c6a6a9c74df27e503e982611d9226155a3996a2",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "subscribe-id",
      "headRefOid": "56e420af5ab79f51cd40e0a56266c723f3083172",
      "closedAt": "2024-01-10T17:24:33Z",
      "mergedAt": "2024-01-10T17:24:33Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "4d42a78c12acf6f12389b8faf5edf4b5f9e3f512"
      },
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "@fluffy @suhasHere I think #305 should immediately follow and split Track ID into Subscription ID and Track Alias.",
          "createdAt": "2023-11-04T15:37:48Z",
          "updatedAt": "2023-11-04T15:37:48Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5ibbNL",
          "commit": {
            "abbreviatedOid": "b4a51e6"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-09-29T19:14:47Z",
          "updatedAt": "2023-09-29T19:15:53Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "This is fine as long as we have a way to let server propose a trackId in the SubscribeError or replace the one in here.",
              "createdAt": "2023-09-29T19:14:47Z",
              "updatedAt": "2023-09-29T19:15:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5iblxX",
          "commit": {
            "abbreviatedOid": "b4a51e6"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-29T19:53:21Z",
          "updatedAt": "2023-09-29T19:53:22Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "I've still not seen documentation of a use case in which server-proposed ID is useful.  Can we have an example that we can work through?",
              "createdAt": "2023-09-29T19:53:21Z",
              "updatedAt": "2023-09-29T19:53:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5icDDp",
          "commit": {
            "abbreviatedOid": "b4a51e6"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-29T21:48:15Z",
          "updatedAt": "2023-09-29T21:48:15Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Yeah, I just don't understand the use-case. And just to clarify, the subscriber chooses the ID, not the client.\r\n\r\nYou could still use the same ID within the CDN (ex. hash of the name). The only difference is that the ID is rewritten on egress instead of ingress. There's a tangible difference between the two because of fanout, but we're talking about encoding a VarInt; it will never show up on benchmarks.\r\n\r\nCould you file an issue and really dive into the problem? Maybe we don't understand your setup.",
              "createdAt": "2023-09-29T21:48:15Z",
              "updatedAt": "2023-09-29T21:50:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5mJi_V",
          "commit": {
            "abbreviatedOid": "b4a51e6"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Proposed somethings that I think would allow us to get to consensus on this one. ",
          "createdAt": "2023-11-04T13:50:41Z",
          "updatedAt": "2023-11-04T13:54:36Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "Add an error code for, use differnt track-id and add a field of proposed track-id",
              "createdAt": "2023-11-04T13:51:38Z",
              "updatedAt": "2023-11-04T13:54:36Z"
            },
            {
              "originalPosition": 48,
              "body": "sure simple use case that is given over and over again, eliminate the need to keep track of per hop rewrite information and do the rewrites. ",
              "createdAt": "2023-11-04T13:53:54Z",
              "updatedAt": "2023-11-04T13:54:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5mJsLi",
          "commit": {
            "abbreviatedOid": "a2c2e85"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-04T16:00:35Z",
          "updatedAt": "2023-11-04T16:00:35Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "nit, if possible is redundant",
              "createdAt": "2023-11-04T16:00:35Z",
              "updatedAt": "2023-11-04T16:00:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5mJsMC",
          "commit": {
            "abbreviatedOid": "a2c2e85"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-04T16:00:47Z",
          "updatedAt": "2023-11-04T16:00:47Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5mJsnl",
          "commit": {
            "abbreviatedOid": "a2c2e85"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "This looks good and I really hope we can agree on this compromise. It's not perfect for everyone but I think it is the best we can get to now. ",
          "createdAt": "2023-11-04T16:15:41Z",
          "updatedAt": "2023-11-04T16:15:41Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5mLDYK",
          "commit": {
            "abbreviatedOid": "9c51840"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-06T02:27:05Z",
          "updatedAt": "2023-11-06T02:27:05Z",
          "comments": [
            {
              "originalPosition": 100,
              "body": "@fluffy @suhasHere is this okay with you? There could be a race where:\r\n\r\nsubscriber:\r\n```\r\nsend SUBSCRIBE id=69 name=foo\r\nsend SUBSCRIBE id=420 name=bar\r\n```\r\n\r\npublisher:\r\n```\r\nrecv SUBSCRIBE id=69 name=foo\r\nsend SUBSCRIBE_ERROR id=69 new_id=420 # publisher remap from 69 -> 420\r\nrecv SUBSCRIBE id=420 name=bar\r\nsend SUBSCRIBE_ERROR id=420 new_id=1234 # publisher rename from 420 -> 1234\r\n```\r\n\r\nsubscriber:\r\n```\r\nrecv SUBSCRIBE_ERROR id=69 new_id=420\r\n# invalid: send SUBSCRIBE id=420 name=foo\r\n```\r\n\r\nThe subscriber could wait until it receives the anticipated `SUBSCRIBE_ERROR id=420`. However, I doubt anybody would ever implement this, and you would still need throw an error if you ever receive `SUBSCRIBE_OK id=420`. \r\n\r\nYou can avoid this race by sharding publisher/subscriber IDs. Or the publisher can use an unguessable track ID (ex. hash) and it's virtually impossible to ever encounter this, which I think is gud enough.",
              "createdAt": "2023-11-06T02:27:05Z",
              "updatedAt": "2023-11-06T03:51:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5mLDgf",
          "commit": {
            "abbreviatedOid": "9c51840"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-06T02:28:06Z",
          "updatedAt": "2023-11-06T02:28:07Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "I added this line. Two different tracks can't use the same ID in any scheme, and I think we should share the error code instead of making a new one.",
              "createdAt": "2023-11-06T02:28:06Z",
              "updatedAt": "2023-11-06T02:29:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5mLLZg",
          "commit": {
            "abbreviatedOid": "9c51840"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM on the basis of this being an improvement over the current text in the draft.",
          "createdAt": "2023-11-06T03:14:00Z",
          "updatedAt": "2023-11-06T03:14:00Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5mMnkT",
          "commit": {
            "abbreviatedOid": "9c51840"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-06T09:09:13Z",
          "updatedAt": "2023-11-06T09:09:14Z",
          "comments": [
            {
              "originalPosition": 100,
              "body": "It seems like once we have separate the subscribe-id and track-id, this problem goes away ? Perhaps I misunderstand but agree on if a publisher ever suggests reusing a track-id that is already in use for a different track, that is totally borked and the connection should be closed with an error.  ",
              "createdAt": "2023-11-06T09:09:14Z",
              "updatedAt": "2023-11-06T09:09:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5mU7Ym",
          "commit": {
            "abbreviatedOid": "9c51840"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-07T03:54:07Z",
          "updatedAt": "2023-11-07T03:54:07Z",
          "comments": [
            {
              "originalPosition": 100,
              "body": "I think the problem still exists when subscribe-id and track-id are split.\r\n\r\nThe problem is that there's an RTT chasm between the publisher and subscriber. The publisher may send `SUBSCRIBE_ERROR id=1 new_alias=420`, but there was a whole RTT where the subscriber MAY have decided to `SUBSCRIBE id=2 alias=420` for some completely different track (collision). The subscriber can't send `SUBSCRIBE id=2 alias=420` like the publisher is requesting until the existing `SUBSCRIBE id=1 alias=420` in flight has been rejected. \r\n\r\nI think maybe the subscriber could `UNSUBSCRIBE id=1` and then immediately `SUBSCRIBE id=2 alias=420` though thanks to the split. It would still be absolutely fatal if the subscriber receives `SUBSCRIBE_OK id=1`, even after the unsubscribe was sent, because it would be impossible to disambiguate `OBJECT alias=420`.",
              "createdAt": "2023-11-07T03:54:07Z",
              "updatedAt": "2023-11-07T03:54:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5maJZs",
          "commit": {
            "abbreviatedOid": "9c51840"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-07T16:18:11Z",
          "updatedAt": "2023-11-07T16:18:11Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "I'd like to nuance this.  I think a common implementation will be to hash the full track name to get the track id and what we need to say here is that it is only an error if the track-id is reused *and* it does not refer to the same full track name. So if I had two differnt subscribes both to the same track, they could use the same track-id \r\n\r\n",
              "createdAt": "2023-11-07T16:18:11Z",
              "updatedAt": "2023-11-07T16:18:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5pvyhm",
          "commit": {
            "abbreviatedOid": "79712e7"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-11T00:15:01Z",
          "updatedAt": "2023-12-11T00:15:01Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "```suggestion\r\nthe subscriber MUST specify a Track Alias that is equal to the Subscribe ID.\r\n```",
              "createdAt": "2023-12-11T00:15:01Z",
              "updatedAt": "2023-12-11T00:15:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5p2eAe",
          "commit": {
            "abbreviatedOid": "ca8974b"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-11T18:31:27Z",
          "updatedAt": "2023-12-11T18:31:27Z",
          "comments": [
            {
              "originalPosition": 139,
              "body": "I think you need to change the condition here.  \r\n\r\nC->S: Subscribe (sub-id 1, track alias 1)\r\nS->C: Subscribe Error (sub-id 1, track alias 19, error code=try new id) \r\nC->S: Subscribe (sub-id 2, track alias 19)\r\nS->C: Subscribe Error (sub-id 2, track alias 19, error code=bad auth)  # sub-id != track alias, but server isn't asking for a resubscribe with new id",
              "createdAt": "2023-12-11T18:31:27Z",
              "updatedAt": "2023-12-11T18:31:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5qHidS",
          "commit": {
            "abbreviatedOid": "ca8974b"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-12-13T19:40:38Z",
          "updatedAt": "2023-12-13T19:47:57Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "\"The Track Alias as specified in the SUBSCRIBE message {{message-subscribe-req}}\"",
              "createdAt": "2023-12-13T19:40:39Z",
              "updatedAt": "2023-12-13T19:47:57Z"
            },
            {
              "originalPosition": 85,
              "body": "s/responsds/responds",
              "createdAt": "2023-12-13T19:44:07Z",
              "updatedAt": "2023-12-13T19:47:57Z"
            },
            {
              "originalPosition": 87,
              "body": "I don't see the need for ``` subscriber MUST specify a Track Alias that is equal to the Subscribe ID ```. ",
              "createdAt": "2023-12-13T19:44:55Z",
              "updatedAt": "2023-12-13T19:47:57Z"
            },
            {
              "originalPosition": 87,
              "body": "May be all we need to say is .. \r\n\r\n\"Unless the publisher responds with a different Track Alias in SUBSCRIBE_ERROR for the subscriber to retry the SUBSCRIBE with publisher chosen Track Alias\"",
              "createdAt": "2023-12-13T19:46:31Z",
              "updatedAt": "2023-12-13T19:47:57Z"
            },
            {
              "originalPosition": 139,
              "body": "I am not understanding why a track alias value must match subscribe id. ",
              "createdAt": "2023-12-13T19:47:46Z",
              "updatedAt": "2023-12-13T19:47:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5qQAfW",
          "commit": {
            "abbreviatedOid": "b7eef47"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-14T19:40:15Z",
          "updatedAt": "2023-12-14T19:40:15Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "```suggestion\r\n  that was already in use.\r\n```",
              "createdAt": "2023-12-14T19:40:15Z",
              "updatedAt": "2023-12-14T19:40:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5qQBDt",
          "commit": {
            "abbreviatedOid": "8209047"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-14T19:41:23Z",
          "updatedAt": "2023-12-14T19:41:24Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "```suggestion\r\nUnless the publisher responds with a different Track Alias in SUBSCRIBE_ERROR,\r\n```",
              "createdAt": "2023-12-14T19:41:24Z",
              "updatedAt": "2023-12-14T19:41:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5qRyoe",
          "commit": {
            "abbreviatedOid": "cb260f6"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-15T02:50:06Z",
          "updatedAt": "2023-12-15T02:50:07Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "```suggestion\r\nthe subscriber can specify a Track Alias that is equal to the Subscribe ID.\r\n```",
              "createdAt": "2023-12-15T02:50:06Z",
              "updatedAt": "2023-12-15T02:50:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5qRyxK",
          "commit": {
            "abbreviatedOid": "598dc1e"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-15T02:51:10Z",
          "updatedAt": "2023-12-15T02:51:10Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "I changed it to a 'can' from a MUST",
              "createdAt": "2023-12-15T02:51:10Z",
              "updatedAt": "2023-12-15T02:51:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5qRzDm",
          "commit": {
            "abbreviatedOid": "598dc1e"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-15T02:53:18Z",
          "updatedAt": "2023-12-15T02:53:18Z",
          "comments": [
            {
              "originalPosition": 139,
              "body": "The idea would be to prevent some sort of loop where the server keeps coming back with a new subscribe ID, but the text also assumes the MUST I just removed.",
              "createdAt": "2023-12-15T02:53:18Z",
              "updatedAt": "2023-12-15T02:53:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5rvkuv",
          "commit": {
            "abbreviatedOid": "598dc1e"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-07T00:06:09Z",
          "updatedAt": "2024-01-07T00:06:09Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "SubscribeId and Track Alias are semantically different concepts. Former is per transaction (subscription) and latter is a short name for Full Track Name. we should remove the last sentence above.",
              "createdAt": "2024-01-07T00:06:09Z",
              "updatedAt": "2024-01-07T00:06:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5rvsMj",
          "commit": {
            "abbreviatedOid": "598dc1e"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-07T03:38:56Z",
          "updatedAt": "2024-01-07T03:38:56Z",
          "comments": [
            {
              "originalPosition": 139,
              "body": "> S->C: Subscribe Error (sub-id 2, track alias 19, error code=bad auth) # sub-id != track alias, but server isn't asking for a resubscribe with new id\r\n\r\nI don't see why this is an error. \r\n\r\nI expected the flow to be something like:\r\n\r\n```\r\nC->S: Subscribe (sub-id 1, track alias 1)\r\nS->C: Subscribe Error (sub-id 1, track alias 19, error code=try new track alias)\r\nC->S: Subscribe (sub-id 2, track alias 19)\r\nS->C: Sub Ok \r\n```",
              "createdAt": "2024-01-07T03:38:56Z",
              "updatedAt": "2024-01-07T03:38:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5sGhtv",
          "commit": {
            "abbreviatedOid": "598dc1e"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-10T16:38:05Z",
          "updatedAt": "2024-01-10T16:38:06Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "```suggestion\r\n  SUBSCRIBE message {{message-subscribe-req}}.\r\n```",
              "createdAt": "2024-01-10T16:38:06Z",
              "updatedAt": "2024-01-10T16:38:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5sGxrL",
          "commit": {
            "abbreviatedOid": "b2514be"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM - thanks for getting this so simple ",
          "createdAt": "2024-01-10T17:11:48Z",
          "updatedAt": "2024-01-10T17:11:48Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5sGzp3",
          "commit": {
            "abbreviatedOid": "b2514be"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-10T17:16:30Z",
          "updatedAt": "2024-01-10T17:16:31Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "```suggestion\r\n\r\n```",
              "createdAt": "2024-01-10T17:16:31Z",
              "updatedAt": "2024-01-10T17:16:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5sG0Et",
          "commit": {
            "abbreviatedOid": "7b12291"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-10T17:17:29Z",
          "updatedAt": "2024-01-10T17:17:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 262,
      "id": "PR_kwDOG2Ho4M5b9F-O",
      "title": "Add Subcribe Confirm message",
      "url": "https://github.com/moq-wg/moq-transport/pull/262",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I was tasked with producing a PR that:\r\n\r\n* enables the receiver to chose the Track ID in the Subscribe message\r\n* allows for the publisher to override the receiver's choice if necessary\r\n* solve the race condition that exists if the publisher sets its own Track ID\r\n\r\nThe solution is to add a \"Suggested Track ID\" parameter to the Subscribe message, and rename the Track ID in the Subscribe OK parameter as \"Server Track ID\". The server may set the Server Track ID to the suggested value, in which case there is no race condition, or pick a different value if needed. In that case, the client will send a \"Subscribe Confirm\" message after receiving the \"Subscribe OK\". The server may choose to send Objects before receiving the subscribe confirm, but it should set the Track ID in those objects to the suggested value, so there is no race condition. After receiving the \"Subscribe Confirm\", the server uses the chosen Server Track ID.",
      "createdAt": "2023-10-05T01:34:25Z",
      "updatedAt": "2023-11-14T01:04:50Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "106f827d30f81d300aa5d8604424fe3906ac21d3",
      "headRepository": "huitema/moq-transport",
      "headRefName": "subscribe-race-condition",
      "headRefOid": "543d81eb4aa310d95011d88e2417b164600bb5c8",
      "closedAt": "2023-11-14T01:04:41Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Based on discussions at IETF 118, I think this can be closed?",
          "createdAt": "2023-11-14T00:43:32Z",
          "updatedAt": "2023-11-14T00:43:32Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@afrind yes, it can be closed. This was \"an example of a possible solution\", but the WG has progressed after that.",
          "createdAt": "2023-11-14T01:04:41Z",
          "updatedAt": "2023-11-14T01:04:41Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5i3qmz",
          "commit": {
            "abbreviatedOid": "5a7d817"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Individual Review",
          "createdAt": "2023-10-05T01:50:59Z",
          "updatedAt": "2023-10-05T02:13:24Z",
          "comments": [
            {
              "originalPosition": 140,
              "body": "Why SHOULD and not MUST?  Are there requirements on the receiver to buffer or can  object's using an unconfirmed publisher track ID be discarded by the receiver?",
              "createdAt": "2023-10-05T01:50:59Z",
              "updatedAt": "2023-10-05T02:13:24Z"
            },
            {
              "originalPosition": 85,
              "body": "Publisher Track ID - since clients and servers can both publish.",
              "createdAt": "2023-10-05T01:51:25Z",
              "updatedAt": "2023-10-05T02:13:24Z"
            },
            {
              "originalPosition": 96,
              "body": "How do we prevent race conditions between a receiver coincidentally using the Publisher Track ID in another Subscribe that is racing with this Subscribe Ok?  I think you would need something like odd/even Track IDs.",
              "createdAt": "2023-10-05T01:54:51Z",
              "updatedAt": "2023-10-05T02:13:24Z"
            },
            {
              "originalPosition": 96,
              "body": "How do we prevent race conditions between a receiver coincidentally using the Publisher Track ID in another Subscribe that is racing with this Subscribe Ok?  I think you would need something like odd/even Track IDs.",
              "createdAt": "2023-10-05T01:54:51Z",
              "updatedAt": "2023-10-05T02:13:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5i39n6",
          "commit": {
            "abbreviatedOid": "5a7d817"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-05T03:55:12Z",
          "updatedAt": "2023-10-05T03:55:12Z",
          "comments": [
            {
              "originalPosition": 140,
              "body": "The server MAY also try to solve the race condition by another mean, such as delaying the moment at which it starts sending objects. It could certainly delay until receiving the Subscribe Confirm, and that would work just fine.",
              "createdAt": "2023-10-05T03:55:12Z",
              "updatedAt": "2023-10-05T03:55:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5i39qH",
          "commit": {
            "abbreviatedOid": "5a7d817"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-05T03:55:25Z",
          "updatedAt": "2023-10-05T03:55:26Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "Good catch.",
              "createdAt": "2023-10-05T03:55:26Z",
              "updatedAt": "2023-10-05T03:55:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5i3-H5",
          "commit": {
            "abbreviatedOid": "5a7d817"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-05T03:58:52Z",
          "updatedAt": "2023-10-05T03:58:52Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "Yes, that's a real issue. I suppose that the receiver has the ultimate responsibility that the track ID are unique in the sender to receiver direction, since the receiver is doing the demuxing. I was hesitating, because I don't know whether saying something like \"server chooses even IDs, client chooses odd IDs\" would work. It's an easy fix, and we could get a sense of the room tomorrow.",
              "createdAt": "2023-10-05T03:58:52Z",
              "updatedAt": "2023-10-05T03:58:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5i3-Lc",
          "commit": {
            "abbreviatedOid": "5a7d817"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-05T03:59:16Z",
          "updatedAt": "2023-10-05T03:59:16Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "See previous comment.",
              "createdAt": "2023-10-05T03:59:16Z",
              "updatedAt": "2023-10-05T03:59:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5i3-s-",
          "commit": {
            "abbreviatedOid": "5a7d817"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-05T04:02:52Z",
          "updatedAt": "2023-10-05T04:02:53Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "also to note, the in-flight Subscribe will be returned a server chose Publisher TrackId in that case. I don't see it as a race though since any naive implementation updating the trackId will be behind mutex anyways. Am i missing something here ?",
              "createdAt": "2023-10-05T04:02:52Z",
              "updatedAt": "2023-10-05T04:02:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5i4BtL",
          "commit": {
            "abbreviatedOid": "5a7d817"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-05T04:23:47Z",
          "updatedAt": "2023-10-05T04:23:48Z",
          "comments": [
            {
              "originalPosition": 140,
              "body": "But yes, it is simpler to just say MUST, and avoid the vagaries of heuristics. ",
              "createdAt": "2023-10-05T04:23:48Z",
              "updatedAt": "2023-10-05T04:23:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5i4B13",
          "commit": {
            "abbreviatedOid": "5a7d817"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-05T04:24:42Z",
          "updatedAt": "2023-10-05T04:24:42Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "Not a race. This is the completion of a 3-ways handshake.",
              "createdAt": "2023-10-05T04:24:42Z",
              "updatedAt": "2023-10-05T04:24:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5i4CCL",
          "commit": {
            "abbreviatedOid": "5a7d817"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-05T04:25:54Z",
          "updatedAt": "2023-10-05T04:25:55Z",
          "comments": [
            {
              "originalPosition": 140,
              "body": "I think this is solved in commit \"Feedback from Alan\".",
              "createdAt": "2023-10-05T04:25:55Z",
              "updatedAt": "2023-10-05T04:25:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5i4CEU",
          "commit": {
            "abbreviatedOid": "5a7d817"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-05T04:26:08Z",
          "updatedAt": "2023-10-05T04:26:08Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "This is solved in commit \"Feedback from Alan\".",
              "createdAt": "2023-10-05T04:26:08Z",
              "updatedAt": "2023-10-05T04:26:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5i4CJ4",
          "commit": {
            "abbreviatedOid": "5a7d817"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-05T04:26:43Z",
          "updatedAt": "2023-10-05T04:26:43Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "I think this is solved in commit \"Feedback from Alan\", which introduce an Odd/Even Track-ID split.",
              "createdAt": "2023-10-05T04:26:43Z",
              "updatedAt": "2023-10-05T04:26:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5i4GBw",
          "commit": {
            "abbreviatedOid": "5a7d817"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-05T04:50:28Z",
          "updatedAt": "2023-10-05T04:50:28Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "@suhashere the race is between the \"subscribe OK\" and the first \"Object\" messages. If the server sends Object messages just after receiving the Subscribe request, there is a good chance that these messages will arrive before the client receives the Subscribe OK, and thus before the client can understand the Track ID in the object message. ",
              "createdAt": "2023-10-05T04:50:28Z",
              "updatedAt": "2023-10-05T04:50:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5i4GP_",
          "commit": {
            "abbreviatedOid": "5a7d817"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-05T04:51:48Z",
          "updatedAt": "2023-10-05T04:51:48Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "You're right that the publisher could disambiguate SUBSCRIBE, although it's complicated, has foot guns, and would require a single control stream. However:\r\n\r\n```\r\n--> SUBSCRIBE 4\r\n--> SUBSCRIBE 5\r\n<-- SUBSCRIBE_OK 4:5\r\n<-- SUBSCRIBE_OK 5:6\r\n<-- OBJECT 5\r\n```\r\n\r\nThis would be invalid, since the meaning of 5 is ambiguous until the receipt of `SUBSCRIBE_CONFIRM`. You would have to incur an RTT for the 2nd subscription only.\r\n\r\n```\r\n--> SUBSCRIBE 4\r\n--> SUBSCRIBE 5\r\n<-- SUBSCRIBE_OK 4:5\r\n<-- SUBSCRIBE_OK 5:6\r\n<-- OBJECT 4\r\n--> SUBSCRIBE_CONFIRM 4:5\r\n--> SUBSCRIBE_CONFIRM 5:6\r\n<-- OBJECT 6\r\n```",
              "createdAt": "2023-10-05T04:51:48Z",
              "updatedAt": "2023-10-05T04:52:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5i4LWD",
          "commit": {
            "abbreviatedOid": "5a7d817"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-05T05:20:04Z",
          "updatedAt": "2023-10-05T05:20:04Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "@kixelated the odd/even split in the last commit solves your issue.",
              "createdAt": "2023-10-05T05:20:04Z",
              "updatedAt": "2023-10-05T05:20:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5i61K-",
          "commit": {
            "abbreviatedOid": "543d81e"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Individual review",
          "createdAt": "2023-10-05T11:21:16Z",
          "updatedAt": "2023-10-05T11:35:23Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "Yes, maybe with different track parameters?  One that starts at group X and another that starts at group Y?",
              "createdAt": "2023-10-05T11:21:16Z",
              "updatedAt": "2023-10-05T11:35:23Z"
            },
            {
              "originalPosition": 101,
              "body": "I think you need publisher/receiver in order to allow clients publishing via relays to use the same ID all the way through.  However, since the client and server can both publish and receive on a given connection, doesn't it still have the race?  ",
              "createdAt": "2023-10-05T11:24:16Z",
              "updatedAt": "2023-10-05T11:35:23Z"
            },
            {
              "originalPosition": 137,
              "body": "s/client/receiver/",
              "createdAt": "2023-10-05T11:25:12Z",
              "updatedAt": "2023-10-05T11:35:23Z"
            },
            {
              "originalPosition": 169,
              "body": "s/client/receiver/",
              "createdAt": "2023-10-05T11:27:45Z",
              "updatedAt": "2023-10-05T11:35:23Z"
            },
            {
              "originalPosition": 96,
              "body": "It's not ambiguous - In Luke's example, OBJECT 5 has to be for the receiver's *second* subscription, since neither subscribe OK was confirmed.  The receiver does need to serialize sending SUBSCRIBE CONFIRM vs new SUBSCRIBEs, so either confirm is sent before the second subscribe, in which case the receiver would pick 6 for the the second subscribe, or after, in which case the client would not confirm the 4:5 mapping.\r\n\r\nIt can get itself out of the mess by carefully sending the 5:6 confirm, waiting for an OBJECT with ID 6, then sending the 4:5 confirm.  But that is an awful lot of work, and nothing presently prevents a circular race which can't be resolved.  Using evens and odds prevents this case, but means that client publishes via relays can't use the same track ID all the way through (see long comment in the issue).",
              "createdAt": "2023-10-05T11:34:55Z",
              "updatedAt": "2023-10-05T11:35:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5i7gRV",
          "commit": {
            "abbreviatedOid": "543d81e"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-05T12:44:10Z",
          "updatedAt": "2023-10-05T12:44:10Z",
          "comments": [
            {
              "originalPosition": 101,
              "body": "Yeah exactly, it needs to be subscriber/publisher not client/server.",
              "createdAt": "2023-10-05T12:44:10Z",
              "updatedAt": "2023-10-05T12:44:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5i7rkN",
          "commit": {
            "abbreviatedOid": "5a7d817"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-05T13:04:29Z",
          "updatedAt": "2023-10-05T13:04:29Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "> It's not ambiguous - In Luke's example, OBJECT 5 has to be for the receiver's _second_ subscription, since neither subscribe OK was confirmed. The receiver does need to serialize sending SUBSCRIBE CONFIRM vs new SUBSCRIBEs, so either confirm is sent before the second subscribe, in which case the receiver would pick 6 for the the second subscribe, or after, in which case the client would not confirm the 4:5 mapping.\r\n\r\nSorry it's difficult to diagram these races, especially on my phone while on the subway.\r\n\r\n```\r\nsubscriber\r\nsent SUBSCRIBE 4\r\nsent SUBSCRIBE 5\r\n\r\npublisher \r\nreceived SUBSCRIBE 4\r\nsent SUBSCRIBE_OK 4:5\r\nsent OBJECT 4\r\nreceived SUBSCRIBE 5\r\nsent SUBSCRIBE_OK 5:6\r\nsent OBJECT 5\r\n\r\nsubscriber\r\nreceived SUBSCRIBE_OK 4:5\r\nsent SUBSCRIBE_CONFIRM 4:5\r\nreceived OBJECT 4\r\nreceived OBJECT 5 # ambiguous\r\n```\r\n\r\nI don't know how to fix this other than even/odd IDs.",
              "createdAt": "2023-10-05T13:04:29Z",
              "updatedAt": "2023-10-05T13:06:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5i73iF",
          "commit": {
            "abbreviatedOid": "543d81e"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-05T13:25:33Z",
          "updatedAt": "2023-10-05T13:25:33Z",
          "comments": [
            {
              "originalPosition": 101,
              "body": "The ambiguity condition is really per direction of transfer. To use Luke's notation, we could have:\r\n~~~\r\n<-- OBJECT 4\r\nOBJECT -->4\r\n~~~\r\nand it would not matter, because there are two demuxing tables, one at the client, and one at the server.\r\n\r\nMy concern was will the case when a network of relays wants to use a unique ID for a given Track. So we would have:\r\n\r\n| Client (publisher) | Relay | Relay | Client Receiver |\r\n|--------------------|-------|-------|-----------------|\r\n| Publish(example) |      |    |   |\r\n| Object(5)--->      |      |    |   |\r\n|  | Publish(example) | | |\r\n| | Object(5)  --->      | | |\r\n| | | Publish(example) | | \r\n| |  | Object(5) -->       | | \r\n| | | | Subscribe(example) | \r\n| | |  | Object(5) -->       | \r\n\r\nNot sure how to express that...\r\n         \r\n\r\n\r\n\r\n",
              "createdAt": "2023-10-05T13:25:33Z",
              "updatedAt": "2023-10-05T13:25:33Z"
            }
          ]
        }
      ]
    },
    {
      "number": 264,
      "id": "PR_kwDOG2Ho4M5cH00N",
      "title": "Session migration and GOAWAY encoding",
      "url": "https://github.com/moq-wg/moq-transport/pull/264",
      "state": "MERGED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #213 \r\nFixes #32\r\n\r\nIs this too much? Do we need to prescribe an algorithm or can we rely on clients to figure it out?",
      "createdAt": "2023-10-06T15:18:23Z",
      "updatedAt": "2023-10-19T02:49:04Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "34e542187097a27197859497dbac54010b81e43a",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "goaway-revamp",
      "headRefOid": "7ac67fb3a146d0d41366654abd5f398e14358f72",
      "closedAt": "2023-10-19T02:49:04Z",
      "mergedAt": "2023-10-19T02:49:04Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "60dde69c912f3a3fd8586798f1e84728feec92f9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5jEkNX",
          "commit": {
            "abbreviatedOid": "e9a189c"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-06T15:31:09Z",
          "updatedAt": "2023-10-06T15:31:09Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "IMO I would remove this entire section and the publisher/subscriber subsections. I think we should have this recommended algorithm _somewhere_ so people can build gud clients, but I'm not sure it needs to be in the draft.\r\n\r\nWhat do you think? People seemed excited in the interim so I wanted to at least write down my thoughts.",
              "createdAt": "2023-10-06T15:31:09Z",
              "updatedAt": "2023-10-06T15:31:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5jEuKt",
          "commit": {
            "abbreviatedOid": "e9a189c"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Individual review.\r\n\r\nSome high level questions:\r\n\r\n1. Should we make it clear that OBJECTs on existing subscriptions continue flowing until an UNSUBSCRIBE, the subscription expires, or the session closes (eg: GOAWAY does not change any subscription states from either peer)?\r\n2. If the session closes and the peer is left with a partial OBJECT - do they need to discard it?\r\n3. When can the sender of GOAWAY close the connection gracefully - as soon as all subscriptions and announces have been terminated?\r\n4. Do we need client initiated GOAWAY - to ask the server to UNSUBSCRIBE gracefully, or should the client send the soon to be \"SUBSCRIPTION END\" with a code like \"going away\" instead?\r\n5. Do we need to make explicit that SUBSCRIBE/ANNOUNCE can race with a peer GOAWAY, so the GOAWAY sender should SUBSCRIBE ERROR/ANNOUNCE ERROR with a code like \"going away\"?  There's no implicit cancellation like in HTTP/[2,3].",
          "createdAt": "2023-10-06T15:51:35Z",
          "updatedAt": "2023-10-06T16:22:12Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "While we're here, should we change \"session terminated\" to \"no error\"?  ",
              "createdAt": "2023-10-06T15:51:35Z",
              "updatedAt": "2023-10-06T16:22:12Z"
            },
            {
              "originalPosition": 41,
              "body": "I'm not sure we need this.  GOAWAY is like a warning shot and the recipient is free to ignore it.  The receiver may want to just keep getting as much on their current tracks and wait for the peer to hang up.",
              "createdAt": "2023-10-06T15:55:29Z",
              "updatedAt": "2023-10-06T16:22:12Z"
            },
            {
              "originalPosition": 38,
              "body": "The algorithm is \"suggested\" but contains normative language.  For interoperability, I think the important bit is how do you drain the current session gracefully, and how should you respond to information in the GOAWAY.  The parts about how to seamlessly transition can be a non-normative example?",
              "createdAt": "2023-10-06T15:58:58Z",
              "updatedAt": "2023-10-06T16:22:12Z"
            },
            {
              "originalPosition": 73,
              "body": "Part of this depends on #227, how will the relay (network) handle a duplicate announcements.",
              "createdAt": "2023-10-06T16:01:26Z",
              "updatedAt": "2023-10-06T16:22:12Z"
            },
            {
              "originalPosition": 115,
              "body": "Maybe `New Session URI`",
              "createdAt": "2023-10-06T16:08:19Z",
              "updatedAt": "2023-10-06T16:22:12Z"
            },
            {
              "originalPosition": 97,
              "body": "I'm not sure you need this MUST, probably `the endpoint 'can' discard any redundant objects` is sufficient.",
              "createdAt": "2023-10-06T16:11:06Z",
              "updatedAt": "2023-10-06T16:22:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5jIghs",
          "commit": {
            "abbreviatedOid": "e9a189c"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-08T07:20:16Z",
          "updatedAt": "2023-10-08T07:20:17Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "As a server operator, it would be have to have some insight into how many clients failed due to not supporting GOAWAY. I imagine it will be more common than HTTP because it's more difficult to implement and there will be more client variety (as opposed to 2 browser implementations).\r\n\r\nUpon receiving a GOAWAY, a client would either:\r\n1. Gracefully migrate subscriptions and close the session with error code 0.\r\n2. Ignore the GOAWAY, waiting for the server to terminate the session.\r\n3. Terminate immediately with some error code\r\n\r\nThat 3rd case worries me a little bit. We could eyeball the number of session terminations around when the GOAWAY was sent. However it would be nice if the draft said either don't do that, or use a specific error code if you did.",
              "createdAt": "2023-10-08T07:20:17Z",
              "updatedAt": "2023-10-08T07:20:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5jIgj5",
          "commit": {
            "abbreviatedOid": "e9a189c"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-08T07:21:33Z",
          "updatedAt": "2023-10-08T07:21:33Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Yeah I think we move the recommended algorithm into a Github issue. I mostly wanted to write it down to make sure the mechanisms in MoqT allow for graceful drains (almost), even if we don't document the algorithm itself in the draft.",
              "createdAt": "2023-10-08T07:21:33Z",
              "updatedAt": "2023-10-08T07:21:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5jPmx5",
          "commit": {
            "abbreviatedOid": "858c6e9"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Individual review\r\n\r\nI think we want to say something like you MUST NOT send any new SUBSCRIBE/ANNOUNCE messages after receiving a GOAWAY.  If you receive a SUBSCRIBE/ANNOUNCE after sending GOAWAY, reply with an error like \"DRAINING\" or \"REFUSED\".\r\n\r\nWe should clarify if GOAWAY changes the state of any active subscriptions issued by the sender - eg: does GOAWAY implicitly UNSUBSCRIBE or not?  ",
          "createdAt": "2023-10-09T18:08:23Z",
          "updatedAt": "2023-10-09T18:18:35Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Is the only case for this \"GOAWAY Drain Timeout\" - eg I told you to unsubscribe everything and you didn't do it?  If so, maybe rename.",
              "createdAt": "2023-10-09T18:08:23Z",
              "updatedAt": "2023-10-09T18:18:35Z"
            },
            {
              "originalPosition": 81,
              "body": "Another use case for client initiated GOAWAY is a moq intermediary that acts as both a server and a client.  When it wants to go down for maintenance, it may want to ask its upstream to unsubscribe to cleanly terminate.\r\n\r\nIf you're not sold, maybe we should open an issue to discuss the directionality of GOAWAY.",
              "createdAt": "2023-10-09T18:12:13Z",
              "updatedAt": "2023-10-09T18:18:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kJoz7",
          "commit": {
            "abbreviatedOid": "858c6e9"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Editorial nits, but this LG overall.  I'm inclined to merge this sooner rather than later.",
          "createdAt": "2023-10-16T15:06:06Z",
          "updatedAt": "2023-10-16T15:13:26Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "I don't think we should make not supporting it an explicit option.  Obviously implementations can ignore it, but from the sender's perspective, all they know is the peer didn't GOAWAY in time.",
              "createdAt": "2023-10-16T15:06:06Z",
              "updatedAt": "2023-10-16T15:13:27Z"
            },
            {
              "originalPosition": 57,
              "body": "I think GOAWAY really means to unsubscribe from all subscriptions on this server and if the client wants to establish a new session, it does so.",
              "createdAt": "2023-10-16T15:07:49Z",
              "updatedAt": "2023-10-16T15:13:27Z"
            },
            {
              "originalPosition": 29,
              "body": "I think \"GOAWAY Timeout\" is good personally.",
              "createdAt": "2023-10-16T15:08:30Z",
              "updatedAt": "2023-10-16T15:13:27Z"
            },
            {
              "originalPosition": 81,
              "body": "I opened a new issue, #274, since I think it's worth discussion and understanding the use cases.\r\n\r\nI'd prefer to land only the server to client one in this PR, since we understand that and know we need it.",
              "createdAt": "2023-10-16T15:12:32Z",
              "updatedAt": "2023-10-16T15:13:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kK-tj",
          "commit": {
            "abbreviatedOid": "4b29012"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-16T17:33:13Z",
          "updatedAt": "2023-10-16T17:33:13Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5kLO3s",
          "commit": {
            "abbreviatedOid": "4b29012"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Individual Review",
          "createdAt": "2023-10-16T18:06:28Z",
          "updatedAt": "2023-10-16T18:09:28Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "GOAWAY Timeout",
              "createdAt": "2023-10-16T18:06:28Z",
              "updatedAt": "2023-10-16T18:09:28Z"
            },
            {
              "originalPosition": 57,
              "body": "Agree - GOAWAY is a signal to UNANNOUNCE/UNSUBSCRIBE.",
              "createdAt": "2023-10-16T18:07:18Z",
              "updatedAt": "2023-10-16T18:09:28Z"
            },
            {
              "originalPosition": 77,
              "body": "s/Failure/Timeout/",
              "createdAt": "2023-10-16T18:07:51Z",
              "updatedAt": "2023-10-16T18:09:28Z"
            },
            {
              "originalPosition": 81,
              "body": "Add a sentence about the sender of the GOAWAY also sending UNSUBSCRIBEs?",
              "createdAt": "2023-10-16T18:08:51Z",
              "updatedAt": "2023-10-16T18:09:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kMT_Y",
          "commit": {
            "abbreviatedOid": "4b29012"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-16T20:59:16Z",
          "updatedAt": "2023-10-16T20:59:16Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "I'd like this fixed before merging.",
              "createdAt": "2023-10-16T20:59:16Z",
              "updatedAt": "2023-10-16T20:59:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kN5yD",
          "commit": {
            "abbreviatedOid": "cb240c8"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-17T05:01:52Z",
          "updatedAt": "2023-10-17T05:01:52Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "@ianswett @afrind Does this text address your comments?\r\n\r\nI decided that the subscriber should close subscriptions (via `UNSUBSCRIBE`). This is tricky because the server might be a subscriber, and yet the client is the one who chooses when to terminate the connection. That's why I think a normative SHOULD is needed, otherwise the client might be waiting indefinitely for the server to terminate subscriptions.\r\n\r\nAlternatively, we should switch it such that the client terminates all subscriptions, regardless of if its a publisher or subscriber. This means it sends `UNSUBSCRIBE` and `SUBSCRIBE_RESET` in response to a `GOAWAY`. I don't think this will be as graceful in the contribution scenario; I would rather have the server `UNSUBSCRIBE` than the client `SUBSCRIBE_RESET`.",
              "createdAt": "2023-10-17T05:01:52Z",
              "updatedAt": "2023-10-17T05:02:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kRTwA",
          "commit": {
            "abbreviatedOid": "cb240c8"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-17T12:54:54Z",
          "updatedAt": "2023-10-17T12:54:55Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "I think this works for me, and a SHOULD is fine for now.  One can never enforce GOAWAY behavior anyway.",
              "createdAt": "2023-10-17T12:54:55Z",
              "updatedAt": "2023-10-17T12:54:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kRUuj",
          "commit": {
            "abbreviatedOid": "cb240c8"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "One nit, but LG.",
          "createdAt": "2023-10-17T12:56:06Z",
          "updatedAt": "2023-10-17T12:57:01Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "By terminate, we mean UNSUBSCRIBE, correct?  If so, how about we say that explicitly.",
              "createdAt": "2023-10-17T12:56:06Z",
              "updatedAt": "2023-10-17T12:57:01Z"
            }
          ]
        }
      ]
    },
    {
      "number": 271,
      "id": "PR_kwDOG2Ho4M5cTMSu",
      "title": "Payload to end of stream is a different message type",
      "url": "https://github.com/moq-wg/moq-transport/pull/271",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #206 and #248.\r\n\r\nThere was consensus in Cambridge that removing the special meaning of zero length gets rid of difficult code, removes potental foot guns, saves a byte, and enables actual zero length payloads, which supposedly has use cases.",
      "createdAt": "2023-10-09T21:03:52Z",
      "updatedAt": "2023-10-11T00:55:00Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "704dbc80c896d6fd6a04d93b2dadea932183efb6",
      "headRepository": "martinduke/moq-transport",
      "headRefName": "two-object-types",
      "headRefOid": "18ca83feee02309e13b588335ce538496feb8f89",
      "closedAt": "2023-10-11T00:54:59Z",
      "mergedAt": "2023-10-11T00:54:59Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "fbde56a237942020d0b05f26cd10d8775edcb72a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5jRJwJ",
          "commit": {
            "abbreviatedOid": "9255a8f"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LG, but I think we'd like to avoid changing the existing codepoints.",
          "createdAt": "2023-10-09T22:33:06Z",
          "updatedAt": "2023-10-09T22:34:06Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "We've been trying to avoid renumbering existing messages, so can you give this the next available codepoint?",
              "createdAt": "2023-10-09T22:33:06Z",
              "updatedAt": "2023-10-09T22:34:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5jbi7Y",
          "commit": {
            "abbreviatedOid": "164d2cb"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-10T15:52:53Z",
          "updatedAt": "2023-10-10T15:52:53Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "In the interest in not making changes to existing types, can this be OBJECT with payload length, as it is today?",
              "createdAt": "2023-10-10T15:52:53Z",
              "updatedAt": "2023-10-10T15:52:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5jgokq",
          "commit": {
            "abbreviatedOid": "18ca83f"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-11T00:54:53Z",
          "updatedAt": "2023-10-11T00:54:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 274,
      "id": "PR_kwDOG2Ho4M5c432s",
      "title": "Clarify that SUBSCRIBE and ANNOUNCE generate only one response",
      "url": "https://github.com/moq-wg/moq-transport/pull/274",
      "state": "MERGED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #261 \r\n\r\n",
      "createdAt": "2023-10-16T11:35:45Z",
      "updatedAt": "2023-10-16T17:28:57Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "fbde56a237942020d0b05f26cd10d8775edcb72a",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "one-error1",
      "headRefOid": "d5e835dc151a52f570e5e704c2c8fda3c0b21b17",
      "closedAt": "2023-10-16T17:28:56Z",
      "mergedAt": "2023-10-16T17:28:56Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "12b724c883d4a25721e27bcbe2a3034ebbb31882"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5kJkkK",
          "commit": {
            "abbreviatedOid": "d9784c9"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "LG, but I'd like to make these MUSTs, ie: exactly one response MUST be sent and if more than one is received, it's a protocol violation.",
          "createdAt": "2023-10-16T15:01:28Z",
          "updatedAt": "2023-10-16T15:03:41Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I'd be inclined to make this a MUST and a description of what happens when there are multiple (protocol violation?).\r\n\r\n",
              "createdAt": "2023-10-16T15:01:28Z",
              "updatedAt": "2023-10-16T15:03:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kKpog",
          "commit": {
            "abbreviatedOid": "d9784c9"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-16T16:47:07Z",
          "updatedAt": "2023-10-16T16:47:07Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Yeah `will` is kinda awkward. Also what about reusing track IDs?",
              "createdAt": "2023-10-16T16:47:07Z",
              "updatedAt": "2023-10-16T16:47:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kK42g",
          "commit": {
            "abbreviatedOid": "d9784c9"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-16T17:18:01Z",
          "updatedAt": "2023-10-16T17:18:01Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "agree with both of you. Updated to have that ",
              "createdAt": "2023-10-16T17:18:01Z",
              "updatedAt": "2023-10-16T17:18:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kK8oK",
          "commit": {
            "abbreviatedOid": "d5e835d"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-16T17:28:00Z",
          "updatedAt": "2023-10-16T17:28:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 277,
      "id": "PR_kwDOG2Ho4M5c6wUK",
      "title": "Explicitly specify the namespace",
      "url": "https://github.com/moq-wg/moq-transport/pull/277",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #204 by explicitly specifying the namespace.\r\n\r\nAlso consistently changes to the (b) notation to indicate a variable length sequence of bytes.",
      "createdAt": "2023-10-16T15:43:00Z",
      "updatedAt": "2023-10-31T23:06:34Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "fbde56a237942020d0b05f26cd10d8775edcb72a",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ianswett-separate-namespace",
      "headRefOid": "a5f77433d11c6453c25fc8249123f36e78873410",
      "closedAt": "2023-10-16T20:56:01Z",
      "mergedAt": "2023-10-16T20:56:01Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "db8110b913c19f7f43180a05573ad9f5f94876ba"
      },
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "This PR got lost when merging 289.",
          "createdAt": "2023-10-31T23:06:34Z",
          "updatedAt": "2023-10-31T23:06:34Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5kKMqc",
          "commit": {
            "abbreviatedOid": "ad81a4a"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-16T15:57:04Z",
          "updatedAt": "2023-10-16T15:57:33Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Track Namespace?",
              "createdAt": "2023-10-16T15:57:05Z",
              "updatedAt": "2023-10-16T15:57:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kKpzk",
          "commit": {
            "abbreviatedOid": "a5f7743"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-16T16:47:36Z",
          "updatedAt": "2023-10-16T16:47:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 278,
      "id": "PR_kwDOG2Ho4M5c60WR",
      "title": "Start sending incomplete objects",
      "url": "https://github.com/moq-wg/moq-transport/pull/278",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #205\r\n\r\nAlso, can someone explain what the following paragraph is saying, because I'm having a difficult time parsing it.",
      "createdAt": "2023-10-16T15:49:57Z",
      "updatedAt": "2023-10-16T17:26:14Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "fbde56a237942020d0b05f26cd10d8775edcb72a",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ianswett-send-incomplete",
      "headRefOid": "3e114c198cc4e713661f9d3d8f9ceefd4abca803",
      "closedAt": "2023-10-16T17:26:13Z",
      "mergedAt": "2023-10-16T17:26:13Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "41ee31321cd340c090f04603107e5c4fdef53e54"
      },
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "The next paragraph is trying to say that if you receive HoL blocked stream data at a relay you should try to forward what you have.  The goal is to mitigate accumulating latency at every relay hop.\r\n\r\nI think this makes sense in two cases:\r\n\r\nYou receive data that you know to be within an object you have already seen the header for.  Eg: the object length is 100 and you miss bytes 0-49 but get 50-99, you can forward 50-99, as long as your QUIC library supports out of order reads and writes to a stream (not many presently do).  This also applies when the object has no length and occupies the entire stream.\r\n\r\nYou are missing some object data for object N on a stream, but you receive the header for object N + 1.  This is (potentially) less problematic since the relay might be able to open a new stream to forward it, so out-of-order stream write APIs are not required.\r\n\r\nIn any case, the text probably needs clarification, and perhaps moving from SHOULD (but we know you won't) to MAY is warranted?",
          "createdAt": "2023-10-16T16:06:17Z",
          "updatedAt": "2023-10-16T16:06:17Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5kK4h4",
          "commit": {
            "abbreviatedOid": "3e114c1"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "sooner is better\r\n\r\nI do think this might be interpreted by some people in an over zealous sort of way ( like turning off nagle type things ). I do wonder about just using MAY. But happy either way. SHOULD and MAY mean the same thing. \r\n\r\n",
          "createdAt": "2023-10-16T17:17:06Z",
          "updatedAt": "2023-10-16T17:17:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 279,
      "id": "PR_kwDOG2Ho4M5c66xT",
      "title": "Resetting Streams doesn't affect MoQ",
      "url": "https://github.com/moq-wg/moq-transport/pull/279",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #202",
      "createdAt": "2023-10-16T16:04:09Z",
      "updatedAt": "2023-10-16T17:24:12Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "f842a4d06ad5773d86a6721b7660b5d9f9fb8c5c",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ianswett-reset-streams",
      "headRefOid": "59faf9a8f712c639bdcc5364317942a9b34172b3",
      "closedAt": "2023-10-16T17:23:57Z",
      "mergedAt": "2023-10-16T17:23:57Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "fedd13b06b821d6fdcea6af74feb53b4baad9b8f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5kK2il",
          "commit": {
            "abbreviatedOid": "9cec047"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Might want to make it clear this does not apply to control streams ",
          "createdAt": "2023-10-16T17:11:36Z",
          "updatedAt": "2023-10-16T17:11:36Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5kK7Oi",
          "commit": {
            "abbreviatedOid": "59faf9a"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Like the change. ",
          "createdAt": "2023-10-16T17:24:12Z",
          "updatedAt": "2023-10-16T17:24:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 280,
      "id": "PR_kwDOG2Ho4M5c7E2d",
      "title": "Define a control stream",
      "url": "https://github.com/moq-wg/moq-transport/pull/280",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #230\r\nFixes #138\r\nFixes #137\r\nFixes #31",
      "createdAt": "2023-10-16T16:28:23Z",
      "updatedAt": "2023-10-16T17:19:04Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "fbde56a237942020d0b05f26cd10d8775edcb72a",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ianswett-control-stream",
      "headRefOid": "4a5d9bb55870e6a2cd95ff1a2d7bfa636a651935",
      "closedAt": "2023-10-16T17:19:03Z",
      "mergedAt": "2023-10-16T17:19:03Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "f842a4d06ad5773d86a6721b7660b5d9f9fb8c5c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5kKzu1",
          "commit": {
            "abbreviatedOid": "58c3641"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I would add a note that data streams are sent on unidirectional streams, but looks gud.",
          "createdAt": "2023-10-16T17:03:53Z",
          "updatedAt": "2023-10-16T17:03:53Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5kK10-",
          "commit": {
            "abbreviatedOid": "58c3641"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2023-10-16T17:09:37Z",
          "updatedAt": "2023-10-16T17:09:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 281,
      "id": "PR_kwDOG2Ho4M5c7qYP",
      "title": "Add SUBSCRIBE_FIN and SUBSCRIBE_RST messages",
      "url": "https://github.com/moq-wg/moq-transport/pull/281",
      "state": "MERGED",
      "author": "afrind",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes: #203",
      "createdAt": "2023-10-16T18:13:11Z",
      "updatedAt": "2023-10-17T03:52:40Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "db8110b913c19f7f43180a05573ad9f5f94876ba",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "subscribe-fin",
      "headRefOid": "73b81debcff8f0cbfd568dd56a86b30f44a0a1a7",
      "closedAt": "2023-10-17T00:22:46Z",
      "mergedAt": "2023-10-17T00:22:46Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "4b798a358716bf20a2ef138e7b3a16093d0c8e27"
      },
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Delayed LGTM.",
          "createdAt": "2023-10-17T03:52:40Z",
          "updatedAt": "2023-10-17T03:52:40Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5kLWKD",
          "commit": {
            "abbreviatedOid": "673423e"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Some small questions on framing, but overall LG",
          "createdAt": "2023-10-16T18:15:41Z",
          "updatedAt": "2023-10-16T18:18:20Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "Other control messages use the Track Name and Namespace (or will).  Should we do the same here for consistency?",
              "createdAt": "2023-10-16T18:15:42Z",
              "updatedAt": "2023-10-16T18:18:20Z"
            },
            {
              "originalPosition": 95,
              "body": "Do we want to use (b) here as well?",
              "createdAt": "2023-10-16T18:17:15Z",
              "updatedAt": "2023-10-16T18:18:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kLYND",
          "commit": {
            "abbreviatedOid": "673423e"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-16T18:21:30Z",
          "updatedAt": "2023-10-16T18:21:31Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "I copied from another ERROR message.  Let's make an editorial pass for all of them together?",
              "createdAt": "2023-10-16T18:21:30Z",
              "updatedAt": "2023-10-16T18:21:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kLarq",
          "commit": {
            "abbreviatedOid": "673423e"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-16T18:28:26Z",
          "updatedAt": "2023-10-16T18:28:27Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "SG",
              "createdAt": "2023-10-16T18:28:27Z",
              "updatedAt": "2023-10-16T18:28:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kNAk8",
          "commit": {
            "abbreviatedOid": "73b81de"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-17T00:22:25Z",
          "updatedAt": "2023-10-17T00:22:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 283,
      "id": "PR_kwDOG2Ho4M5c73eP",
      "title": "MoQ has no TCP/etc fallback",
      "url": "https://github.com/moq-wg/moq-transport/pull/283",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Editorial"
      ],
      "body": "Fixes #88",
      "createdAt": "2023-10-16T18:48:53Z",
      "updatedAt": "2023-10-17T12:53:23Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "12b724c883d4a25721e27bcbe2a3034ebbb31882",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ianswett-no-tcp",
      "headRefOid": "d01431d7dcc558bdce9eeff68dd6bdd9554eab4f",
      "closedAt": "2023-10-17T12:53:23Z",
      "mergedAt": "2023-10-17T12:53:23Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "34e542187097a27197859497dbac54010b81e43a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5kNzY-",
          "commit": {
            "abbreviatedOid": "120ec2e"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-17T04:28:34Z",
          "updatedAt": "2023-10-17T04:28:52Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "> when QUIC and WebTransport\r\n\r\nshould be:\r\n\r\n> when QUIC or WebTransport",
              "createdAt": "2023-10-17T04:28:34Z",
              "updatedAt": "2023-10-17T04:28:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kOJCp",
          "commit": {
            "abbreviatedOid": "120ec2e"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-17T06:08:22Z",
          "updatedAt": "2023-10-17T06:08:22Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5kRQCh",
          "commit": {
            "abbreviatedOid": "120ec2e"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-17T12:50:36Z",
          "updatedAt": "2023-10-17T12:50:37Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nneed to fallback to another protocol when QUIC or WebTransport aren't\r\n```",
              "createdAt": "2023-10-17T12:50:36Z",
              "updatedAt": "2023-10-17T12:50:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kRQhN",
          "commit": {
            "abbreviatedOid": "120ec2e"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-17T12:51:11Z",
          "updatedAt": "2023-10-17T12:51:12Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "SG, feel free to leave a suggestion I can just commit it for editorial suggestions like this.",
              "createdAt": "2023-10-17T12:51:12Z",
              "updatedAt": "2023-10-17T12:51:12Z"
            }
          ]
        }
      ]
    },
    {
      "number": 285,
      "id": "PR_kwDOG2Ho4M5c8r4n",
      "title": "Change message names to use _",
      "url": "https://github.com/moq-wg/moq-transport/pull/285",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Editorial"
      ],
      "body": "Fixes #275\r\n\r\nAlso renames SUBSCRIBE to SUBSCRIBE_REQUEST, since it was already being referred to as SUBSCRIBE in multiple cases and it's parallel to ANNOUNCE.",
      "createdAt": "2023-10-16T21:18:04Z",
      "updatedAt": "2023-10-17T12:48:40Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "4b798a358716bf20a2ef138e7b3a16093d0c8e27",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ianswett-underscores",
      "headRefOid": "5031e9d95a7486b5ccb29b10e673f43eb946851d",
      "closedAt": "2023-10-17T12:48:33Z",
      "mergedAt": "2023-10-17T12:48:33Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "d76504e36019b0292543bd5f0cb0e6aa1f0dab8d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5kNvfN",
          "commit": {
            "abbreviatedOid": "080a3a7"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "+1 to SUBSCRIBE instead of SUBSCRIBE_REQUEST",
          "createdAt": "2023-10-17T04:04:05Z",
          "updatedAt": "2023-10-17T04:04:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 286,
      "id": "PR_kwDOG2Ho4M5c8zR6",
      "title": "Reduce usage of the term QUIC",
      "url": "https://github.com/moq-wg/moq-transport/pull/286",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Editorial"
      ],
      "body": "Given this also runs over WebTransport, it's best to avoid QUIC unless it's specifically referring to the transport.\r\n\r\nFixes #223",
      "createdAt": "2023-10-16T21:41:08Z",
      "updatedAt": "2023-10-17T12:42:46Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "db8110b913c19f7f43180a05573ad9f5f94876ba",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ianswett-less-quic",
      "headRefOid": "7b7bb377d840a10a0a9c4364586a2731cfc23a57",
      "closedAt": "2023-10-17T12:42:36Z",
      "mergedAt": "2023-10-17T12:42:36Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "e8ea2f4eb4ccc07c8203444ebc272a1c90350f34"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5kMlOk",
          "commit": {
            "abbreviatedOid": "7b7bb37"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-16T21:51:32Z",
          "updatedAt": "2023-10-16T21:51:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 287,
      "id": "PR_kwDOG2Ho4M5c9PIW",
      "title": "Protocols directly over UDP",
      "url": "https://github.com/moq-wg/moq-transport/pull/287",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Editorial"
      ],
      "body": "Fixes #73",
      "createdAt": "2023-10-16T23:45:43Z",
      "updatedAt": "2023-10-19T03:09:27Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "34e542187097a27197859497dbac54010b81e43a",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ianswett-direct-udp",
      "headRefOid": "c6454260f1375569a657ede19247f64c735f4950",
      "closedAt": "2023-10-19T03:09:27Z",
      "mergedAt": "2023-10-19T03:09:26Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "22df6cae40549471fcdebbdb8eb0d33d39248c40"
      },
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am fine with any phrasing that makes it clear that an intervening full-featured transport over UDP negates the issue.",
          "createdAt": "2023-10-18T16:25:09Z",
          "updatedAt": "2023-10-18T16:25:09Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5kNvlN",
          "commit": {
            "abbreviatedOid": "5dcad66"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-17T04:04:44Z",
          "updatedAt": "2023-10-17T04:04:45Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Is there a better way to phrase this?",
              "createdAt": "2023-10-17T04:04:45Z",
              "updatedAt": "2023-10-17T04:04:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kRPba",
          "commit": {
            "abbreviatedOid": "5dcad66"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-17T12:49:52Z",
          "updatedAt": "2023-10-17T12:49:53Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Probably, I was trying to take @martinduke suggestion.\r\n\r\nWhat about \"Using UDP directly avoids queueing...\"?",
              "createdAt": "2023-10-17T12:49:53Z",
              "updatedAt": "2023-10-17T12:49:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kUiSH",
          "commit": {
            "abbreviatedOid": "dd4fc56"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-17T18:31:21Z",
          "updatedAt": "2023-10-18T00:37:58Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "There are many ways to say this. The language in this PR is fine, but some alternatives...\r\n\r\n\"UDP-based protocols aside from QUIC...\"\r\n\r\n\"Applications that use UDP but not QUIC avoid queuing, but are now responsible...\"\r\n\r\nWhatever people like is fine.\r\n\r\n",
              "createdAt": "2023-10-17T18:31:21Z",
              "updatedAt": "2023-10-17T18:31:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kWxsb",
          "commit": {
            "abbreviatedOid": "5dcad66"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T00:41:20Z",
          "updatedAt": "2023-10-18T00:41:21Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I don't like UDP-based protocols aside from QUIC, because one can run SCTP or another transport over UDP, and those have their own properties.",
              "createdAt": "2023-10-18T00:41:21Z",
              "updatedAt": "2023-10-18T00:41:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kX4bb",
          "commit": {
            "abbreviatedOid": "dd4fc56"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "\"Protocols utilizing UDP directly\" would be my vote but anything works.",
          "createdAt": "2023-10-18T04:37:17Z",
          "updatedAt": "2023-10-18T04:37:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 289,
      "id": "PR_kwDOG2Ho4M5dEnnf",
      "title": "Add subscribe hints",
      "url": "https://github.com/moq-wg/moq-transport/pull/289",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a initial PR to get some basic definition of subscription hints. I would like to get us to an agreement for the basic proposal and then discuss further on error codes, edge cases and impacts/interactions with other messages (Sub Fin, RST, UPD)\r\n\r\nFixes #111 \r\nFixes #245 \r\nFixes #260",
      "createdAt": "2023-10-17T23:18:17Z",
      "updatedAt": "2023-10-23T18:19:15Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "407f68f605296627fc09f69de1f6b4b34bbca09e",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "hints",
      "headRefOid": "474471bde1184209d57aa5e25c873a07e24c7017",
      "closedAt": "2023-10-23T18:19:14Z",
      "mergedAt": "2023-10-23T18:19:14Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "759f52940e2370ed61b22ead62f09cbbac0a6960"
      },
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Can you mark this as Fixes: #245 so it shows as having a PR attached (also possibly 111 and 260)?  Also recommend closing #246 as this replaces it.",
          "createdAt": "2023-10-18T00:04:43Z",
          "updatedAt": "2023-10-18T00:04:43Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> Here's my proposal: [#245 (comment)](https://github.com/moq-wg/moq-transport/issues/245#issuecomment-1767492853)\r\n\r\nI feel #245 proposal is more ambiguous though.  I agree we can make the proposed ending in this PR to make it easier to encode/decode.\r\n\r\nI have to get higher level idea agreed upon\r\n\r\n1. There are subscription hints. 2 hints are defined in this PR  a) StartPoint b) Interval\r\n2. There may be hints we might want to add in future and hence a Hint structure identifies a type and value\r\n3. StartPoint hint can support 4 modes. These modes are only applicable when the HintType is StartPoint \r\n4. Interval hint is totally separate hintType that defines ranges of groups/objects\r\n\r\n\r\n",
          "createdAt": "2023-10-18T03:33:17Z",
          "updatedAt": "2023-10-18T03:33:17Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> Regarding the `HintType`, how is this defined? Suppose that I want to define a new hint type, what do I do? Will there be an IANA registry? Will there be a range of numbers reserved for experimentation?\r\n\r\nHaving a registry is the idea and I was thinking once we get to agreement of Hint strucutres , then we can follow with defining error codes, registries for types and  cleaning up track request params",
          "createdAt": "2023-10-18T03:51:42Z",
          "updatedAt": "2023-10-18T03:51:42Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> SUBSCRIPTION HINT {\r\n>   HintType (i),\r\n>   HintLength(i),\r\n>   Payload (...)\r\n> }\r\n\r\nPayload(b) is defined to have len and value .  Here is the definition as defined in the draft today \r\n**x (b): : Indicates that x consists of a variable length integer, followed by that many bytes of binary data.**",
          "createdAt": "2023-10-18T03:54:25Z",
          "updatedAt": "2023-10-18T03:54:25Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "So pushed few more commits cleaning up somethings and considering suggestion from Alan on TrackOffset and removing text on error.  Thanks everyone for the review feedback\r\n\r\nWould love to hear feedback on the whole text.",
          "createdAt": "2023-10-18T05:28:42Z",
          "updatedAt": "2023-10-18T05:30:28Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> 1. Do the use cases mentioned by Luke in 245 need to be covered now?\r\n\r\nGiven the length of 245. Could you please summarize the use-cases to help focus the discussion.\r\n\r\nIn the order of small to big, my suggestion of the order would be \"3, 4, 5,  2, 1 \"",
          "createdAt": "2023-10-20T03:50:43Z",
          "updatedAt": "2023-10-20T04:08:52Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "> Given the length of 245. Could you please summarize the use-cases to help focus the discussion.\r\n\r\nThere are 4 examples right at the end of 245, I copied them in this review comment:\r\n\r\nhttps://github.com/moq-wg/moq-transport/pull/289#pullrequestreview-1685348042\r\n\r\nWe can discuss tomorrow.",
          "createdAt": "2023-10-20T05:00:05Z",
          "updatedAt": "2023-10-20T05:00:05Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Alan proposed we use 6 parameters.\r\n\r\nStart Object\r\nStart Group\r\nStart relative / absolute flag \r\n\r\nEnd Object\r\nEnd Group \r\nEnd relative / absolute flag \r\n\r\nPreference for not two ways to say same thing. Use 0 to indicate current. Offset encoding. \r\n\r\nYou can subscribe to the track twice with two different hints if that is what you want. \r\n\r\nSeems good consensus on call for this. \r\n\r\nFurther conversation got to the point that this fails to be able to do both the first object of current group and current object in current group. So we need to do that too. \r\n\r\nUpdate on this luke porposed make rel/abs flag for both object and group which solves this",
          "createdAt": "2023-10-20T17:36:38Z",
          "updatedAt": "2023-10-20T17:46:23Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "My proposal is 4 parameters, combining the flag with the value:\r\n\r\n- Start Group + Relative/Absolute Flag\r\n- Start Object + Relative/Absolute Flag\r\n- End Group + Relative/Absolute Flag\r\n- End Object + Relative/Absolute Flag\r\n\r\nI'm using the lower bits of the VarInt to save some bytes and make parsing easier. Otherwise you have to deal with missing the corresponding sequence/mode parameter.\r\n\r\nI think it's even easier if these 4 VarInts are just encoded as part of SUBSCRIBE instead of being parameters. There would be a None flag if you don't want an end group and/or object.",
          "createdAt": "2023-10-20T18:10:29Z",
          "updatedAt": "2023-10-20T18:10:29Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> My proposal is 4 parameters, combining the flag with the value:\r\n> \r\n> * Start Group + Relative/Absolute Flag\r\n> * Start Object + Relative/Absolute Flag\r\n> * End Group + Relative/Absolute Flag\r\n> * End Object + Relative/Absolute Flag\r\n> \r\n> I'm using the lower bits of the VarInt to save some bytes and make parsing easier. Otherwise you have to deal with missing the corresponding sequence/mode parameter.\r\n> \r\n\r\nEven with flags embedded, the logic is exactly same. Either you need to handle missing parameter or a flag bits set to a certain value. May be we can add this optimization later too ?\r\n\r\n> I think it's even easier if these 4 VarInts are just encoded as part of SUBSCRIBE instead of being parameters. There would be a None flag if you don't want an end group and/or object.\r\n\r\n+1 on making it part of Subscribe. ",
          "createdAt": "2023-10-20T18:38:53Z",
          "updatedAt": "2023-10-20T18:38:53Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Regardless of the approach, I think these are the use-cases we MUST support:\r\n\r\n| start group | start object | end group | end object | notes |\r\n|-|-|-|-|-|\r\n| absolute | 0 | fin | fin | start at timestamp in catalog |\r\n| absolute | absolute | fin | fin | reconnect from max object |\r\n| absolute | 0 | absolute | fin | repopulate group cache (unknown end) |\r\n| absolute | absolute | absolute | absolute | repopulate object cache (known end) |\r\n| latest-N | 0 | fin | fin | live with initial buffer of at most N groups |\r\n| latest | latest-N | fin | fin | live with initial buffer of at most N objects  |\r\n| latest+1 | 0 | fin | fin | wait for next sync point |\r\n\r\nI think these are use-cases worth considering:\r\n\r\n| start group | start object | end group | end object | notes |\r\n|-|-|-|-|-|\r\n| latest-N | 0 | latest-M | fin | fetch the latest M-N groups (ex. clip) |\r\n| latest+N | 0 | fin | fin | start at a group further in the future |\r\n| latest-N | 0 | latest+M | fin | subscribe for M-N groups pending a resubscribe (keep-alive) |\r\n| absolute | absolute | latest | latest | fetch the track as it currently exists (live unsupported)  |\r\n\r\nAnd not mentioned in this PR, but I do think we need UNSUBSCRIBE hints.\r\n\r\n| end group | end object | notes |\r\n|-|-|-|\r\n| latest | latest | end immediately |\r\n| latest | fin | end after current group |\r\n| absolute | fin | end after target group (session migration) |\r\n| latest+M | fin | end after future group (session migration) |\r\n| start group | start object | end before next SUBSCRIBE starts (deduplication?) |",
          "createdAt": "2023-10-20T18:47:58Z",
          "updatedAt": "2023-10-20T18:47:58Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "New proposal:\r\n\r\n```\r\nSUBSCRIBE {\r\n  Start Group + Absolute/Relative/Future (i)\r\n  Start Object + Absolute/Relative/Future (i)\r\n}\r\n\r\nUNSUBSCRIBE {\r\n  End Group + Absolute/Relative/Future (i)\r\n  End Object + Absolute/Relative/Future (i)\r\n}\r\n```\r\n\r\nRange requests would be accomplished with a SUBSCRIBE followed by an immediate UNSUBSCRIBE. This is a race though, and a reason to not take this approach. \r\n\r\nKeep-alive would be kinda funny if only the latest UNSUBSCRIBE is active.\r\n```\r\nSUBSCRIBE start=latest\r\nUNSUBSCRIBE end=latest+4\r\n...\r\nUNSUBSCRIBE end=latest+4\r\n...\r\nUNSUBSCRIBE end=latest+4\r\n...\r\n```",
          "createdAt": "2023-10-20T18:53:39Z",
          "updatedAt": "2023-10-20T19:03:46Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In addition to what is summarized above, we had a discussion about the way to express relative ranges. In the case of the start hint, the well understood scenarios that I heard are:\r\n\r\n* start at a specific point (specific group, specific object)\r\n* start at the current point (current group, current object)\r\n* start at the beginning of the current group (e.g., because the receiver needs all the frames from the beginning of the current group to synchronize its decoder)\r\n* start at the beginning of the next group (e.g., because the receiver does not want to process old frames, and would rather start clean on a group start)\r\n\r\nWe can make it more complicated, and we have proposals such as:\r\n\r\n* start N (groups, objects) before the current one (in the past)\r\n* start N (groups, objects) after the current one (in the future).\r\n\r\nI think that these relative offsets bring a lot of complexity, and a lot of corner cases. They are somewhat undefined, because the subscriber does not know what the current group or object is. If it knew, it could just ask for a specific start point. The combination of groups and objects is a bit weird, because the subscriber does not know how many objects there are in the past groups. The syntax allows for silly requests, like \"start 1,000,000 groups in the past\", or requests that are latent DOS attack like \"start 1,000,000 groups in the future\", which means \"keep state in memory forever\". There is a potential simplification there...",
          "createdAt": "2023-10-20T19:46:40Z",
          "updatedAt": "2023-10-20T19:48:12Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "I want to keep the scope simple and focussed. When i presented on Subscription hints, there were few real use-cases that had a need for hints \r\n   - User joining a mid call  and want to start from the beginning of the group to catchup or wait until next group\r\n   - User rejoins mid call and want wherever the current state of group/object is\r\n   - User disconnected and joining at a known point and want to catch up from there ( say to 2x catchup render)\r\n   - User wants to buffer a few seconds from past to keep the player go smoothly\r\n   - User asking for range of frames and be done with it as catch up\r\n   \r\nCan we define a system that works for all possible combinations ever - Oh YEAH .. But do we really need it - I DOUBT IT\r\n\r\nI am waiting on Alan's proposal for the promised simplification. @afrind  no pressure :-)\r\n",
          "createdAt": "2023-10-21T03:32:09Z",
          "updatedAt": "2023-10-21T03:36:43Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I was pretty busy today but have been written up what we discussed during the call - using 6 track request parameters offering the full range of options that are available in this PR as is.  By using defaults when a param is omitted, there was only one invalid combination, which I like.  The logic to determine what group and object to actually start serving is about 20 lines of pseudo code, which I added as an appendix.\r\n\r\nI'm not sure what to make of the discussion on this PR.  I'll write a second PR that is simpler and just includes the 4 basic modes, and maybe something for range.  Stay tuned.\r\n\r\nWould it be better to submit both as separate PR's, and leave this proposal as is, or should I push what we discussed this morning here?",
          "createdAt": "2023-10-21T03:43:07Z",
          "updatedAt": "2023-10-21T03:43:07Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'm not sure what to make of the discussion on this PR. I'll write a second PR that is simpler and just includes the 4 basic modes, and maybe something for range. Stay tuned.\r\n> \r\n> Would it be better to submit both as separate PR's, and leave this proposal as is, or should I push what we discussed this morning here?\r\n\r\nIts ok to push here .. how easy would it be merge both into a single commit ?",
          "createdAt": "2023-10-21T03:58:34Z",
          "updatedAt": "2023-10-21T04:07:17Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Commenting on Luke's table of use cases:\r\n\r\nLove this way of enumerating and sorting the use cases. Thanks. All the use case I think are critical are covered in the first table and nothing that I did not care about seemed like it was going to complicated implementations so my first reaction was YES. But looking at it, we were getting close to covering 100% of all the cases and since relays are likely to upgrade slower than clients, I just came down to we should just support all the possible combinations even if it is not clear  there is s use case for it today - that will actually make implementations simpler. I think the proposed solutions are starting to look like they do all the cases anyways. By all the cases, I mean a subscribe can \r\n\r\nStart at absolute or relative for both group and object. Relative can have delta to current.  \r\n\r\nStart at absolute or relative or fin for both group and object. Relative can have delta to current.  \r\n\r\n",
          "createdAt": "2023-10-21T20:35:07Z",
          "updatedAt": "2023-10-21T20:35:07Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On the topic of do we need unsubscribe hints .... \r\n\r\nHow I think of it is subscribe installs some state on the relay or publisher telling it what to do. It can say what the first and last object is that should be forwarded. However, I think as unsubscribe as the message that removes all that state. \r\n\r\nIf we start making unsubscribe be \"forward until you see object X\" then remove all the state, we get into questions like what happens if object X-1 arrives after X. \r\n\r\nThat said, I do agree with the use case that Luke is getting at of things like. Client was subscribed to something forever, but now I only want to be subscribe up to the end of the current group so that the client can do a clean switch over to some different subscription at the group boundary ",
          "createdAt": "2023-10-21T20:40:15Z",
          "updatedAt": "2023-10-21T20:40:15Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I was thinking about use case for things like text media some of the stuff with the game moves draft that are not audio and video.  It is pretty common to  want to be able to get the last N things in a group first then later go get the earlier things in a group. The usual rest style pagination type thing where. Imagine you had a group where each object was a message in a chat, you might only want the most recent 10 messages but then when user scrolled back, to get the rest. \r\n\r\nThe more I thought about this, I think we have a requirement for \r\n\r\nstart group | start object | end group | end object | notes\r\n-- | -- | -- | -- | --\r\nabsolute | latest-N | absolute | latest | Get last N object in a given group \r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2023-10-21T21:39:15Z",
          "updatedAt": "2023-10-21T21:39:15Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> On the topic of do we need unsubscribe hints ....\r\n\r\nYeah, I'm thinking we should use RESUBSCRIBE instead of adding hints to UNSUBSCRIBE. UNSUBSCRIBE would always be an immediate and cleanup any state, while RESUBSCRIBE would be used to update the start/end bounds.",
          "createdAt": "2023-10-21T21:45:34Z",
          "updatedAt": "2023-10-21T21:45:34Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I took the liberty of adding a 3rd proposal to the PR but did not change anything else in the PR. ",
          "createdAt": "2023-10-21T22:08:21Z",
          "updatedAt": "2023-10-21T22:08:21Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > On the topic of do we need unsubscribe hints ....\r\n> \r\n> Yeah, I'm thinking we should use RESUBSCRIBE instead of adding hints to UNSUBSCRIBE. UNSUBSCRIBE would always be an immediate and cleanup any state, while RESUBSCRIBE would be used to update the start/end bounds.\r\n\r\n+1 - that does seem like it will be a very good way to deal with it ",
          "createdAt": "2023-10-21T22:09:48Z",
          "updatedAt": "2023-10-21T22:09:48Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "@fluffy I wrote this up on my phone before noticing your commit. It's basically your proposal 3, but not using optional parameters.\r\n\r\nIt would be encoded as:\r\n\r\n```\r\nSUBSCRIBE {\r\n  ...\r\n  start_group_hint: (i)\r\n  start_object_hint: (i)\r\n  end_group_hint (i)\r\n  end_object_hint (i)\r\n  ...\r\n}\r\n```\r\n\r\nI really like that Alan wrote some pseudo-code, although I agree that it shouldn't be in the final draft. The devil is in the details with this encoding, and I think this scheme is both the simplest and the most powerful. It's also the smallest on the wire if that's any consolation prize.\r\n\r\n```python\r\n# Each hint is a VarInt, where the lower two bits specify the mode\r\ndef resolve_hint(hint, latest):\r\n  match hint & 0x3:\r\n    case 0x0: # absolute\r\n      return hint >> 2\r\n    case 0x1: # relative\r\n      return max(latest - hint >> 2, 0)\r\n    case 0x2: # future\r\n      return latest + hint >> 2 + 1\r\n    case 0x3: # none\r\n      return Infinity\r\n    \r\n# Convert subscribe hints on the wire into absolute subscribes\r\ndef subscribe_hint(start_group, start_object, end_group, end_object): \r\n  # latest_group: returns max group in cache\r\n  # latest_object: returns max object in cache for given group\r\n  # both will be async when relay has no active subscription \r\n  start_group = resolve(start_group, latest_group())\r\n  start_object = resolve(start_object, latest_object(start_group))\r\n  end_group = resolve(end_group, latest_group())\r\n  end_object = resolve(end_object, latest_object(end_group))\r\n\r\n  # now they can be used with should_serve\r\n  return ( start_group, start_object, end_group, end_object )\r\n\r\n# Called for each object (same for all proposals)\r\ndef should_serve(obj, start_group, start_object, end_group, end_object)\r\n  if obj.group < start_group or obj.group > end_group:\r\n    return false\r\n  elif obj.group == start_group and obj.sequence < start_object:\r\n    return false\r\n  elif obj.group == end_group and obj.sequence > end_object:\r\n    return false\r\n  else:\r\n    return true \r\n\r\n```",
          "createdAt": "2023-10-21T22:28:31Z",
          "updatedAt": "2023-10-21T22:29:26Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "And I thought it would be a bug to specify start_object=none with my encoding, but it actually seems like a valid use-case.\r\n\r\nstart group | start object | end group | end object | notes\r\n-- | -- | -- | -- | --\r\nnone | none | none | none | Check if a track exists\r\n\r\nYou would get a SUBSCRIBE_OK if the track exists, but the subscription won't actually do anything. It kinda seems useful for specifying intent too.\r\n\r\nstart group | start object | end group | end object | notes\r\n-- | -- | -- | -- | --\r\nN | none | N | none | Start warning the cache for group N",
          "createdAt": "2023-10-21T22:41:15Z",
          "updatedAt": "2023-10-21T22:44:36Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> Yeah, I'm thinking we should use RESUBSCRIBE instead of adding hints to UNSUBSCRIBE. UNSUBSCRIBE would always be an immediate and cleanup any state, while RESUBSCRIBE would be used to update the start/end bounds.\r\n\r\nMy proposal in one of the authors call was Subscribe Update message.",
          "createdAt": "2023-10-22T00:07:26Z",
          "updatedAt": "2023-10-22T00:07:26Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So @kixelated proposal in the thread above that is similar to mine just seems better than what I proposed.  It covers all the cases, it is easy to describe and validate work and does not have a bunch of uses cases. \r\n\r\nI would put in a very weak argument for instead of taking the bottom two bits to encode the (absolute, relative, future, none ) , instead just put that into it's own VarInt. I would not argue very much for that because this is all going to get put in 5 lines of code I will never look at again and it's does not turn up on the wire in something that has to be small. Probably the worst part of is is someone looking at network dump might be confused but that just means the wireshark dissector needs to know about how to the >>2 works. I'd be totally fine with proposal as is. \r\n\r\nSome strong points I see for this:\r\n1) we could merge it by Monday \r\n2) It covers all the uses case we can imagine now plus has a high chance of  covering the future cases we can not imagine now\r\n3) It is simple to understand, think about, and test \r\n",
          "createdAt": "2023-10-22T01:41:34Z",
          "updatedAt": "2023-10-22T01:41:34Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": " > I think I would also use a separate varint for the mode for each param rather that the LSBs. Keep in mind that taking 2 bits from a varint means only 0-15 can be encoded in a single byte, and we shouldn't be trying to squeeze bytes out of this control message.\r\n\r\nA 0-16 range would work for the majority of relative/future hints, so it would definitely save that byte. But I'm fine keeping it verbose for now; the important part is the reusable `Hint` encoding.\r\n\r\n> Start Group and Start Object cannot be None. End Group and Object must either both be None (Closed Range), or Neither (Open Subscribe).\r\n\r\n`start_group=none` would be useful for checking track existence without receiving OBJECTs. But let's rule it out for now because it would mean a subscription that will never match objects, which would need some extra text.\r\n\r\n`start_group=N, start_object=none` would be same as `start_group=N+1, start_object=0` but that's not obvious. We can also rule it out.\r\n\r\n`end_group=N, end_object=none` is required to specify the FIN of a group. ex. end at the last object of group 69.\r\n\r\n`end_group=none, end_object=N` is invalid though.\r\n\r\n> Also bikeshed on whether this is a Hint or a Parameter (not to be confused with Track Request Parameter). Hint implies that it's ok if the publisher ignores it.\r\n\r\nI think it's a hint right now, since the publisher can choose to drop objects/groups on a whim. Even if you ask to start at group 3, you might never get it for congestion control reasons.\r\n\r\nBut the bigger issue is that a subscriber doesn't know the upstream's expiration time. A publisher may only cache the last 3 groups, so a subscriber can't just ask for the the last 8 groups and expect to receive them all. Throwing an error in that situation seems futile.\r\n\r\nBut I think the publisher should signal the (absolute) start/end range in SUBSCRIBE_OK, which may be a subset of the requested range. Then it would be a start/end range request, resulting in a start/end range response.",
          "createdAt": "2023-10-22T10:41:21Z",
          "updatedAt": "2023-10-22T10:50:25Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like the direction that Alan has take Lukes stuff. \r\n\r\nTo bikeshed the Hint. I think \"Location\" would be a better name than \"Hint\". I think this is not really a hint but more a filter that relay will not send me objects on this subscription before the Start location or after the end Location. So if you want my bikeshedy 0.000002 cents, I would define \r\n\r\nLocation {\r\n  GroupMode (i),\r\n  GroupValue (i),\r\n  ObjectMode (i),\r\n  ObjectValue (i)\r\n}\r\nObjectModes = None, Absolute, Past, Future \r\nGroupModes = None, Absolute, Past, Future \r\n\r\nThe the subscribe would have a Start and End  Location.\r\n\r\nLocation become a clean way to specify a specific a specific object in a track and may turn out to be useful in other parts of the spec. \r\n\r\n",
          "createdAt": "2023-10-22T16:30:48Z",
          "updatedAt": "2023-10-22T16:30:48Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "< rant > \r\nI'd like to take a moment to reflect that the notation we are using for is both shitty and bad. \r\n\r\nTake\r\nHint {\r\n  Mode (i),\r\n  [Value (i)]\r\n}\r\nModes = None, Relative, Next, Absolute\r\n\r\nBy shitty, I mean super non intuitive. What does (i) mean? Is [X] optional or an array? But no, that would be ... Can I have more than one X?  If I had Mode(2) followed by [Value(i)], would it be bit packed or would the Mode be padded out to a byte? And what type is Mode. Or if Mode is a type what is then encoding of all that crap. Most schema languages are fairly intuitive to read and guess what they might mean. This is not. \r\n\r\nThen there is the bad. Say I want to define a type called Mode then have two fields in a record called ObjectMode and GroupMode both of type Mode. What do I do?\r\n\r\nLocation {\r\nGroupMode (i),\r\nObjectMode (i)\r\n}\r\nObjectModes = None, Absolute, Past, Future\r\nGroupModes = None, Absolute, Past, Future\r\n\r\nThis can not possibly be the right way to do it. I mean now that Mode is not reusable and repeats itself. \r\n\r\nIf only we had a well defined language for expressing this. Oh wait we do https://datatracker.ietf.org/doc/html/rfc5234",
          "createdAt": "2023-10-22T16:42:23Z",
          "updatedAt": "2023-10-22T16:42:44Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> Option 3 looks good, but I'm unsure why we might want different modes for the group and object. I guess it depends upon how you define how the group modes affects the object?\r\n\r\nI went ahead and enumerated the permutations\r\n\r\ngroup | object | useful | notes\r\n-|-|-|-\r\nabsolute | absolute | yes | range request \r\nabsolute | relative | audio* | tail of group \r\nabsolute | future | no | \r\nabsolute | none | yes | full group \r\nrelative | absolute | yes | head of live group\r\nrelative | relative | audio* | tail of live group\r\nrelative | future | audio* | next audio sample(s) \r\nrelative | none | yes | full group \r\nfuture | absolute | yes | head of future group\r\nfuture | relative | no |  \r\nfuture | future | no |\r\nfuture | none | yes | future group(s)\r\nnone | none | yes | tail of track \r\nnone | * | no |\r\n\r\nThe ones labeled with audio* are only when you have partially independent samples.  For example, each audio GROUP is 2s long and each audio OBJECT is 21ms. \r\n\r\n```\r\nSUBSCRIBE audio start_group=relative/0 start_object=relative/5\r\n```\r\n\r\nThis would get you the last 105ms of audio (target initial buffer) most of the time. However, you could get unlucky and a new group could have started with less than that available, but it doesn't really matter if the target buffer is small because the player will just wait.\r\n\r\nPersonally, I want to remove this use-case. If objects can be independent, then they should be separate groups IMO. So each audio frame would be a group of size 21ms. You could then combine the group/object mode since object boundaries can either be absolute or none.",
          "createdAt": "2023-10-22T21:48:09Z",
          "updatedAt": "2023-10-22T21:57:40Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I pushed a new commit with PROPOSAL 4, which we have been discussing, pulling the \"best of\" text and examples from the other proposals.  I deleted the PROPOSAL 1 sample code and didn't add code for 4.\r\n\r\nThere's one DISCUSS, whether we should allow Start/EndObject to be None and have defaults, or require them to be specified.\r\n\r\n\ud83e\udd1e",
          "createdAt": "2023-10-23T03:51:29Z",
          "updatedAt": "2023-10-23T03:51:29Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5kWlRP",
          "commit": {
            "abbreviatedOid": "3cddae3"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Overall, that's a complicated syntax. You have optional elements, but the TLS1.3 syntax that we use limits how we can specify optional elements. For example, when you write:\r\n~~~\r\nStartPoint Payload {\r\n  Mode (i),\r\n  [GroupCount (i)]\r\n}\r\n~~~\r\nthe decoder has an issue. If there are bytes in the message following the encoding of encoding of \"mode\", do those bytes encode the `GroupCount`, or do they belong to the encoding of the next element in the subscribe command? Your description of \"now\" says that \"The optional parameter `GroupCount`, if specified, MUST be ignored\" -- but there the decoder is really in a bind.\r\n\r\nThis is a problem throughout. You allow extension points, but the syntax is not designed to \"skip over\" unknown extensions. To be on the safe side, I would change the syntax of the subscription hint to be:\r\n~~~\r\nSUBSCRIPTION HINT {\r\n  HintType (i),\r\n  HintLength(i),\r\n  Payload (...)\r\n}\r\n~~~\r\nIf you do that, then you can have optional elements for each payload type. (I would rename \"payload\" to \"hint parameters\" or \"hintValue\".)\r\n\r\nRegarding the `HintType`, how is this defined? Suppose that I want to define a new hint type, what do I do? Will there be an IANA registry? Will there be a range of numbers reserved for experimentation?\r\n\r\n\r\n",
          "createdAt": "2023-10-17T23:32:42Z",
          "updatedAt": "2023-10-17T23:52:55Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "What has value 0x1? The groupcount parameter?",
              "createdAt": "2023-10-17T23:32:43Z",
              "updatedAt": "2023-10-17T23:52:55Z"
            },
            {
              "originalPosition": 75,
              "body": "What has value 0x2? The groupcount parameter?",
              "createdAt": "2023-10-17T23:33:31Z",
              "updatedAt": "2023-10-17T23:52:56Z"
            },
            {
              "originalPosition": 77,
              "body": "What has value 0x3? The groupcount parameter?",
              "createdAt": "2023-10-17T23:33:33Z",
              "updatedAt": "2023-10-17T23:52:56Z"
            },
            {
              "originalPosition": 39,
              "body": "Why a fixed 8 bits field? we are using varint everywhere. ",
              "createdAt": "2023-10-17T23:50:10Z",
              "updatedAt": "2023-10-17T23:52:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kWkU9",
          "commit": {
            "abbreviatedOid": "3cddae3"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Individual Review\r\n\r\nThanks for this PR, I think it's directionally right but needs a few tweaks for parseability.",
          "createdAt": "2023-10-17T23:27:21Z",
          "updatedAt": "2023-10-17T23:53:30Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Should it be a separate field or track request parameter?  Track Request Params has group/object sequence already which can maybe be collapsed here one way or another.",
              "createdAt": "2023-10-17T23:27:21Z",
              "updatedAt": "2023-10-17T23:53:30Z"
            },
            {
              "originalPosition": 34,
              "body": "Someone will say \"varint\", I just wanted to be first.",
              "createdAt": "2023-10-17T23:27:56Z",
              "updatedAt": "2023-10-17T23:53:30Z"
            },
            {
              "originalPosition": 78,
              "body": "I don't think you can have it be optional and ignored, since there's no flag indicating it's presence or absence other than `mode`.  PREVIOUS and NEXT mean there is a GroupCount and CURRENT and NOW mean there is not.",
              "createdAt": "2023-10-17T23:29:58Z",
              "updatedAt": "2023-10-17T23:53:30Z"
            },
            {
              "originalPosition": 78,
              "body": "s/obect/object/",
              "createdAt": "2023-10-17T23:31:26Z",
              "updatedAt": "2023-10-17T23:53:30Z"
            },
            {
              "originalPosition": 111,
              "body": "I think this is not parseable as written - I don't know when there is or isn't an EndGroupSequence or EndGroupObject. \r\n\r\nMaybe something like the following\r\n\r\n```\r\nTrackOffset {\r\n  Type (i),  // 0 = Group, 1 = Group and Object\r\n  Group (i),\r\n  [Object (i)]\r\n}\r\n\r\nHint Types = RelativeStart, AbsoluteStart, AbsoluteInterval\r\nRelativeStartPayload {\r\n  Mode (i),\r\n  [GroupCount(i)]\r\n}\r\nModes = Previous, Next, Current, Now\r\n// Previous and Next have a GroupCount, Current and Now do not have GroupCount.\r\n\r\nAbsoluteStartPayload {\r\n  TrackOffset start\r\n}\r\nThis would replace the track request params for GROUP SEQUENCE / OBJECT SEQUENCE\r\n\r\nAbsoluteIntervalPayload {\r\n  TrackOffset start,\r\n  TrackOffset end\r\n}\r\n```",
              "createdAt": "2023-10-17T23:51:10Z",
              "updatedAt": "2023-10-17T23:53:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kWspS",
          "commit": {
            "abbreviatedOid": "3cddae3"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T00:09:01Z",
          "updatedAt": "2023-10-18T00:09:02Z",
          "comments": [
            {
              "originalPosition": 111,
              "body": "You can also spell it a little differently, like:\r\n\r\n```\r\nHint Types = Current, Now, RelativeStartPrevious, RelativeStartNext, AbsoluteStart, AbsoluteInterval\r\n\r\nCurrentPayload = Empty\r\n\r\nNowPayload = Empty\r\n\r\nRelativeStartPreviousPayload {\r\n  GroupCount(i)\r\n}\r\n\r\nRelativeStartNextPayload {\r\n  GroupCount(i)\r\n}\r\n\r\nAbsoluteStartPayload {\r\n  TrackOffset start\r\n}\r\n\r\nAbsoluteIntervalPayload {\r\n  TrackOffset start,\r\n  TrackOffset end\r\n}\r\n```",
              "createdAt": "2023-10-18T00:09:02Z",
              "updatedAt": "2023-10-18T00:09:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kW0wI",
          "commit": {
            "abbreviatedOid": "3cddae3"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "It's really a complicated encoding and yet not that flexible. I don't like modes that can't be generalized; we'll end up with spaghetti.\r\n\r\nHere's my proposal: https://github.com/moq-wg/moq-transport/issues/245#issuecomment-1767492853",
          "createdAt": "2023-10-18T00:58:57Z",
          "updatedAt": "2023-10-18T02:05:32Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "We should remove the start group/object sequence from params, since they're being rolled into the more fleshed out subscription hints.",
              "createdAt": "2023-10-18T00:58:57Z",
              "updatedAt": "2023-10-18T02:06:04Z"
            },
            {
              "originalPosition": 4,
              "body": "How do you know the number of subscription hints? A decoder wouldn't know when the hints end and the parameters begin.",
              "createdAt": "2023-10-18T01:01:09Z",
              "updatedAt": "2023-10-18T02:05:20Z"
            },
            {
              "originalPosition": 65,
              "body": "If I understand correctly, this a mode within a mode? Can we collapse?",
              "createdAt": "2023-10-18T01:03:50Z",
              "updatedAt": "2023-10-18T02:05:20Z"
            },
            {
              "originalPosition": 4,
              "body": "Maybe I'm confused, can there only be a single hint? If so I would collapse the encoding and make it not plural (`hint` not `hints`).",
              "createdAt": "2023-10-18T01:05:26Z",
              "updatedAt": "2023-10-18T02:05:20Z"
            },
            {
              "originalPosition": 46,
              "body": "Why are we reserving 0?",
              "createdAt": "2023-10-18T01:06:13Z",
              "updatedAt": "2023-10-18T02:05:20Z"
            },
            {
              "originalPosition": 66,
              "body": "I don't like how this is optional and its presence depends on the mode. It's not wrong, but it's difficult to understand and parse.\r\n\r\nAnd we'll likely have future modes that need more than GroupCount. The modes should specify their parameters.",
              "createdAt": "2023-10-18T01:09:08Z",
              "updatedAt": "2023-10-18T02:06:52Z"
            },
            {
              "originalPosition": 85,
              "body": "It's a hint, so a relay can ignore it. I don't want to error because the client didn't know what the server had in cache.\r\n\r\nex. if you ask for -6 groups in the past but the relay only has -4, then it should just serve that instead of erroring. There's no guarantee that objects arrive in MoQ; they can be dropped at any time for any reason.\r\n\r\nThis is also relevant for the start of the broadcast. The client might specify mode=PREVIOUS GroupCount=4 but the broadcast just started and there's only 2 groups; it shouldn't be an error.",
              "createdAt": "2023-10-18T01:11:43Z",
              "updatedAt": "2023-10-18T02:10:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kXF8T",
          "commit": {
            "abbreviatedOid": "3cddae3"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-10-18T02:07:51Z",
          "updatedAt": "2023-10-18T02:11:13Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "+1 a registry/table would be clearer.",
              "createdAt": "2023-10-18T02:07:51Z",
              "updatedAt": "2023-10-18T02:11:13Z"
            },
            {
              "originalPosition": 78,
              "body": "Good catch.",
              "createdAt": "2023-10-18T02:08:41Z",
              "updatedAt": "2023-10-18T02:11:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kXj6t",
          "commit": {
            "abbreviatedOid": "3cddae3"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T03:34:25Z",
          "updatedAt": "2023-10-18T03:34:26Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "this is a not a mode in a mode. Its mode in a given hintType called StartPoint",
              "createdAt": "2023-10-18T03:34:25Z",
              "updatedAt": "2023-10-18T03:34:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kXkEc",
          "commit": {
            "abbreviatedOid": "3cddae3"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T03:35:05Z",
          "updatedAt": "2023-10-18T03:35:05Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "0x1 correspond to Mode and not the groupCount. I can clarify the same.",
              "createdAt": "2023-10-18T03:35:05Z",
              "updatedAt": "2023-10-18T03:35:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kXkHc",
          "commit": {
            "abbreviatedOid": "3cddae3"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T03:35:10Z",
          "updatedAt": "2023-10-18T03:35:10Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "0x2 correspond to Mode and not the groupCount. I can clarify the same.",
              "createdAt": "2023-10-18T03:35:10Z",
              "updatedAt": "2023-10-18T03:35:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kXkNL",
          "commit": {
            "abbreviatedOid": "3cddae3"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T03:35:17Z",
          "updatedAt": "2023-10-18T03:35:18Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "0x3 correspond to Mode and not the groupCount. I can clarify the same.",
              "createdAt": "2023-10-18T03:35:18Z",
              "updatedAt": "2023-10-18T03:35:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kXlPG",
          "commit": {
            "abbreviatedOid": "3cddae3"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T03:36:35Z",
          "updatedAt": "2023-10-18T03:36:36Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "I am fine with varint. I didn't see it being needed in this case.",
              "createdAt": "2023-10-18T03:36:35Z",
              "updatedAt": "2023-10-18T03:36:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kXlgn",
          "commit": {
            "abbreviatedOid": "3cddae3"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T03:37:21Z",
          "updatedAt": "2023-10-18T03:37:21Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "yes , once we get the hints agreed upon, i will do a follow up PR to change Track Params. Trying to keep the PR focussed.",
              "createdAt": "2023-10-18T03:37:21Z",
              "updatedAt": "2023-10-18T03:37:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kXl9q",
          "commit": {
            "abbreviatedOid": "3cddae3"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T03:39:03Z",
          "updatedAt": "2023-10-18T03:39:03Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "Mode is the flag that defined the presence and absence. The text is trying to say that, if for mode \"Now\", some one encodes GroupCount, don't process that param than treating it as error.\r\n\r\nI am not sure its ambiguous, but happy to take suggestions on how to make it clear.",
              "createdAt": "2023-10-18T03:39:03Z",
              "updatedAt": "2023-10-18T03:39:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kXnSi",
          "commit": {
            "abbreviatedOid": "3cddae3"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T03:45:22Z",
          "updatedAt": "2023-10-18T03:45:23Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "yes , agree with the analysis. I did had it written originally aligning so, but not able to remember why i decided to go otherway.\r\n\r\nBut, i will update it.",
              "createdAt": "2023-10-18T03:45:22Z",
              "updatedAt": "2023-10-18T03:45:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kX1Im",
          "commit": {
            "abbreviatedOid": "3cddae3"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-10-18T04:23:09Z",
          "updatedAt": "2023-10-18T04:53:17Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "It's the same encoding for values < 2^6 , so you might as well specify a varint.",
              "createdAt": "2023-10-18T04:23:09Z",
              "updatedAt": "2023-10-18T04:53:17Z"
            },
            {
              "originalPosition": 65,
              "body": "What I'm suggesting is that you merge `Mode` and `HintType`. So there would be 5 possible values, instead of 4+1. The parameters for each would be based on the type; there would be a `group` for PREVIOUS/NEXT and a start/end pair for INTERVAL.",
              "createdAt": "2023-10-18T04:23:58Z",
              "updatedAt": "2023-10-18T04:53:17Z"
            },
            {
              "originalPosition": 78,
              "body": "What Alan is trying to say is that there's no way to specify \"GroupCount\" when mode=CURRENT or NOW. The field is optional and the mode determines if the field is present, or at least that's our interpretation. If the field is always present and MUST be ignored like this text specifies, then `[GroupCount (i)]` shouldn't be wrapped in brackets.\r\n",
              "createdAt": "2023-10-18T04:31:06Z",
              "updatedAt": "2023-10-18T04:53:17Z"
            },
            {
              "originalPosition": 111,
              "body": "Yeah, the bracket notation that QUIC uses doesn't encode if a field is present.\r\n\r\n```\r\n[EndGroupSequence(i)]\r\n```\r\n\r\nNeeds to be written as something like:\r\n\r\n```\r\nEndGroupPresent (i) // 1 or 0\r\n[EndGroupSequence(i)]\r\n```\r\n\r\nThis is quite wasteful, which is why you generally have flags or modes to specify if multiple fields are present. Or a special meaning for 0.",
              "createdAt": "2023-10-18T04:52:53Z",
              "updatedAt": "2023-10-18T04:53:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kX9Bm",
          "commit": {
            "abbreviatedOid": "3cddae3"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T04:53:54Z",
          "updatedAt": "2023-10-18T04:53:54Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "nit: `Range` instead of `Interval`",
              "createdAt": "2023-10-18T04:53:54Z",
              "updatedAt": "2023-10-18T04:53:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kdF7K",
          "commit": {
            "abbreviatedOid": "d464618"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Individual Review:\r\n\r\nThank you for the update.  This looks implementable. I'd probably just have one hint with this definition rather than a list.  The main open question is if we need the additional flexibility mentioned in Luke's last comment in #245:\r\n\r\n> Here's some things you can't do with the proposed encoding:\r\n> \r\n> * Start 4 groups in the past and end 2 in the future: start=relative/4 end=future/1\r\n> * Start at group 69 and end at latest: start=absolute/69 end=relative/0\r\n> * Start at 69 and end 4 groups in the past (might be a noop): start=absolute/69 end=relative/4\r\n> * Keep refreshing a relative subscription while it's needed: start=relative/4 end=future/3\r\n\r\nIf these are important then we can shuffle the encoding a bit.",
          "createdAt": "2023-10-18T15:06:15Z",
          "updatedAt": "2023-10-18T15:19:39Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I think allowing more than one hint causes more possible conflicts than it solves, based on the way hints are currently defined (eg: multiple start points).  I guess you get the option for multiple discontiguous ranges?",
              "createdAt": "2023-10-18T15:06:15Z",
              "updatedAt": "2023-10-18T15:19:39Z"
            },
            {
              "originalPosition": 65,
              "body": "Yeah, this comment I left from the previous draft shows one possible way to merge Mode and HintType - https://github.com/moq-wg/moq-transport/pull/289#discussion_r1362945991.  I think I like that slightly better because it has only one extension axis, and it's more compact, but I can live with this too.",
              "createdAt": "2023-10-18T15:10:12Z",
              "updatedAt": "2023-10-18T15:19:39Z"
            },
            {
              "originalPosition": 63,
              "body": "Maybe SUBSCRIBE OK should tell you the absolute value of the publisher's start point.  The first object I receive may not be the start.",
              "createdAt": "2023-10-18T15:18:18Z",
              "updatedAt": "2023-10-18T15:19:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kdaZE",
          "commit": {
            "abbreviatedOid": "d464618"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This is progressing. Apart from the comments below, I would take a hard look at the extension points. Do we need them, or can we just say that \"a future version of this spec may define more hint types\"?\r\n\r\nThis would be in line with only having extensions by version number, negotiated during the connection. ",
          "createdAt": "2023-10-18T15:36:34Z",
          "updatedAt": "2023-10-18T15:45:25Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "I was going to make the same suggestion. We can certainly collapse these two layers. We would end up with Hints being a choice of \"Now, Current, Previous, Next, Absolute, Range\".",
              "createdAt": "2023-10-18T15:36:34Z",
              "updatedAt": "2023-10-18T15:45:25Z"
            },
            {
              "originalPosition": 132,
              "body": "The syntax seems uselessly complicated. I would remove the type, just define:\r\n~~~\r\nTrackOffset {\r\n  GroupSequence (i),\r\n  ObjectSequence (i)\r\n}\r\n~~~\r\nAnd set Object to 0 if the range shall include the whole group.\r\n\r\nYou also need to specify whether the end is inclusive or exclusive. I like exclusive, because it allows to set the end to \"Group=N+1, Object=0\", which would mean \"until the end of Group N\" without knowing in advance how many objects there are in group N.",
              "createdAt": "2023-10-18T15:43:01Z",
              "updatedAt": "2023-10-18T15:45:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kdunm",
          "commit": {
            "abbreviatedOid": "d464618"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T16:12:10Z",
          "updatedAt": "2023-10-18T16:12:11Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "> And set Object to 0 if the range shall include the whole group.\r\n\r\nThanks @huitema for this suggestion, it makes much more sense.\r\n\r\n`group=7, object=0` vs `type=0, group=7`\r\n`group=9, object=17` vs `type=1, group=9, object=17`",
              "createdAt": "2023-10-18T16:12:10Z",
              "updatedAt": "2023-10-18T16:12:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5ke39W",
          "commit": {
            "abbreviatedOid": "d464618"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T18:18:00Z",
          "updatedAt": "2023-10-18T18:18:00Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "I wonder there is any way a subscriber can know this info. Whatever publisher says in the OBJECT message is considered to be the start for all relative requests. isn't it ?",
              "createdAt": "2023-10-18T18:18:00Z",
              "updatedAt": "2023-10-18T18:18:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5ke5du",
          "commit": {
            "abbreviatedOid": "d464618"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T18:21:48Z",
          "updatedAt": "2023-10-18T18:21:48Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "My thought was that the first object received might not be the first object sent by the publisher (due to out of order delivery, congestion, etc), hence it might be good for the publisher to indicate to the subscriber what they are going to get.",
              "createdAt": "2023-10-18T18:21:48Z",
              "updatedAt": "2023-10-18T18:21:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kfv07",
          "commit": {
            "abbreviatedOid": "d464618"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T20:03:51Z",
          "updatedAt": "2023-10-18T20:03:52Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "the thing is , when you send subscribe , there might not be any publisher started publishing .. so info in OK is not sufficient .. \r\nMay be we need a bit in the object header, that if set means its the first object in the track",
              "createdAt": "2023-10-18T20:03:51Z",
              "updatedAt": "2023-10-18T20:03:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kgaW2",
          "commit": {
            "abbreviatedOid": "d464618"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T21:57:26Z",
          "updatedAt": "2023-10-18T21:57:26Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "> the thing is , when you send subscribe , there might not be any publisher started publishing .. so info in OK is not sufficient ..\r\n\r\nThis makes sense too. Optional flag in SUBSCRIBE OK?   I could live with punting this feature also for now.",
              "createdAt": "2023-10-18T21:57:26Z",
              "updatedAt": "2023-10-18T21:57:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kgsTF",
          "commit": {
            "abbreviatedOid": "1d15301"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Just one minor comment. I think this is pretty much ready.",
          "createdAt": "2023-10-18T22:18:27Z",
          "updatedAt": "2023-10-18T22:19:17Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "I would think that `ObjectSequence` set to 0x0 implies ~until the end~ *from the beginning* of the group identified in `GroupSequence`.",
              "createdAt": "2023-10-18T22:18:27Z",
              "updatedAt": "2023-10-18T22:19:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kgPKz",
          "commit": {
            "abbreviatedOid": "1d15301"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T21:21:07Z",
          "updatedAt": "2023-10-18T22:26:06Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Since this is a varint, the range actually extends up to `0x3fffffffffffffff`.",
              "createdAt": "2023-10-18T21:21:07Z",
              "updatedAt": "2023-10-18T22:26:06Z"
            },
            {
              "originalPosition": 4,
              "body": "Could you explain what does it mean to have multiple hints?  Like, semantically, if I supply both a relative and an absolute offset, what should happen?",
              "createdAt": "2023-10-18T22:20:40Z",
              "updatedAt": "2023-10-18T22:26:06Z"
            },
            {
              "originalPosition": 98,
              "body": "What is the relationship between Current, RelativeStartPrevious with count 0, and RelativeStartNext with count 0?  Are they identical? Is count 0 disallowed by the protocol?",
              "createdAt": "2023-10-18T22:23:56Z",
              "updatedAt": "2023-10-18T22:26:06Z"
            },
            {
              "originalPosition": 102,
              "body": "Can `TrackOffset` be in the future? If so, please document the expected behavior.",
              "createdAt": "2023-10-18T22:25:16Z",
              "updatedAt": "2023-10-18T22:26:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kgu-J",
          "commit": {
            "abbreviatedOid": "d464618"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T22:26:32Z",
          "updatedAt": "2023-10-18T22:26:32Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "(ignore this, somehow submitted outdated comment)",
              "createdAt": "2023-10-18T22:26:32Z",
              "updatedAt": "2023-10-18T22:26:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kgyFc",
          "commit": {
            "abbreviatedOid": "d464618"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T22:34:10Z",
          "updatedAt": "2023-10-18T22:34:10Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "yes, let's open an new issue to add  a flag to the OBJECT and also have some info on OK message",
              "createdAt": "2023-10-18T22:34:10Z",
              "updatedAt": "2023-10-18T22:34:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kg10o",
          "commit": {
            "abbreviatedOid": "1d15301"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T22:49:16Z",
          "updatedAt": "2023-10-18T22:49:17Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "i was thinking if we define a new hint type that is not related to start point in future, allowing it to be useful.  OTOH i wonder if we can make a request that if there exists both relative and absolute start point, have absolute take preference always ?\r\n\r\nI don't know why would one define, but we need to define what happens when one does so",
              "createdAt": "2023-10-18T22:49:16Z",
              "updatedAt": "2023-10-18T22:49:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kg26d",
          "commit": {
            "abbreviatedOid": "1d15301"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T22:54:34Z",
          "updatedAt": "2023-10-18T22:54:34Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "my thinking is count of 0 for RelativeStartPrevious gives the current group. Do you see if there is any issues with that ? We can have GroupCount > 0 always too .. ",
              "createdAt": "2023-10-18T22:54:34Z",
              "updatedAt": "2023-10-18T22:54:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kg3Ca",
          "commit": {
            "abbreviatedOid": "1d15301"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T22:55:12Z",
          "updatedAt": "2023-10-18T22:55:13Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "yes, it can be .. What aspects were you thinking we should document ? Happy to add\r\n",
              "createdAt": "2023-10-18T22:55:12Z",
              "updatedAt": "2023-10-18T22:55:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5khAnE",
          "commit": {
            "abbreviatedOid": "1d15301"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Individual Review",
          "createdAt": "2023-10-18T23:30:21Z",
          "updatedAt": "2023-10-18T23:47:08Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "My preference is for only a single hint.  The current hint set can be mixed in non-sensical ways.",
              "createdAt": "2023-10-18T23:30:21Z",
              "updatedAt": "2023-10-18T23:47:08Z"
            },
            {
              "originalPosition": 37,
              "body": "As currently defined, the length is not needed because the length of all hint types is known.",
              "createdAt": "2023-10-18T23:38:54Z",
              "updatedAt": "2023-10-18T23:47:09Z"
            },
            {
              "originalPosition": 140,
              "body": "So that's:\r\n\r\n[0, 0], to [2, 0] = all of groups 0 and 1\r\n[0, 0], to [2, 1] = all of groups 0 and 1, and group 2, object 0, \r\n\r\netc?",
              "createdAt": "2023-10-18T23:43:03Z",
              "updatedAt": "2023-10-18T23:47:09Z"
            },
            {
              "originalPosition": 102,
              "body": "Maybe - 1) state that it is intended that subscribers can ask for a future offset (similar to RelativeStartNext with a positive number), and then specify if the publisher needs to wait for those objects to be available to issue SUBSCRIBE OK, or it issues a SUBSCRIBE OK immediately?  What if those objects never materialize?",
              "createdAt": "2023-10-18T23:46:39Z",
              "updatedAt": "2023-10-18T23:47:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5khqjB",
          "commit": {
            "abbreviatedOid": "1d15301"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I wanted to +1 Alan's comment but I think it got buried in changes. We will eventually need the selected start/end group/object echoed in SUBSCRIBE_OK. Otherwise I don't think you can actually use these relative hints; there's a bunch of edge cases and races.",
          "createdAt": "2023-10-19T02:32:35Z",
          "updatedAt": "2023-10-19T02:49:48Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I really don't want multiple hints. It's not clear how overlapping hints are supposed to interact, which makes it implementation specific.",
              "createdAt": "2023-10-19T02:32:35Z",
              "updatedAt": "2023-10-19T02:49:48Z"
            },
            {
              "originalPosition": 37,
              "body": "Yeah, you only need the length if you want to support unknown HintTypes. However, I think it should just be a protocol violation if you use an unknown type, so you don't need the length.",
              "createdAt": "2023-10-19T02:33:52Z",
              "updatedAt": "2023-10-19T02:49:48Z"
            },
            {
              "originalPosition": 74,
              "body": "Does this include the most recent object? If so, the latest object could have been generated hours ago, so \"now\" is a little misleading.\r\n\r\nI would rename:\r\n\r\n| old | new |\r\n|-|-|\r\n| Current | CurrentGroup |\r\n| Now | CurrentObject |\r\n",
              "createdAt": "2023-10-19T02:34:57Z",
              "updatedAt": "2023-10-19T02:49:48Z"
            },
            {
              "originalPosition": 79,
              "body": "Would `RelativeStartPrevious GroupCount = 0` be identical to `Current`?\r\n\r\nCan you clarify if this is the case, and give an example?\r\n",
              "createdAt": "2023-10-19T02:38:12Z",
              "updatedAt": "2023-10-19T02:49:48Z"
            },
            {
              "originalPosition": 91,
              "body": "Would `RelativeStartNext GroupCount = 0` be identical to `Current`?\r\n\r\nCan you clarify if this is the case, and give an example?",
              "createdAt": "2023-10-19T02:38:46Z",
              "updatedAt": "2023-10-19T02:49:48Z"
            },
            {
              "originalPosition": 98,
              "body": "It's just confusing and you need to clarify at least. This is a classic off-by-one bug waiting to happen. It also might make caching more difficult because there's 3 different ways to request the latest group.\r\n\r\nIMO\r\n`RelativeStartPrevious` is relative to `current`\r\n`RelativeStartNext` is relative to `current+1`\r\n`Current` is removed in favor of `RelativeStartPrevious count=0`",
              "createdAt": "2023-10-19T02:43:32Z",
              "updatedAt": "2023-10-19T02:49:48Z"
            },
            {
              "originalPosition": 125,
              "body": "+100\r\n\r\nHow are you supposed to request the first object from a group otherwise? What is even the use-case of requesting the max object from an old group?",
              "createdAt": "2023-10-19T02:45:02Z",
              "updatedAt": "2023-10-19T02:49:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kh6nR",
          "commit": {
            "abbreviatedOid": "1d15301"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-19T03:56:54Z",
          "updatedAt": "2023-10-19T03:56:54Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "I don't see it causes implementation confusion or off-by-one bug. The semantics are clear and yes, more text can be added, if needed.  \r\n\r\n5 4 3 2 1 CURRENT (0)  1 2 3 4 5\r\n",
              "createdAt": "2023-10-19T03:56:54Z",
              "updatedAt": "2023-10-19T03:59:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kh7SO",
          "commit": {
            "abbreviatedOid": "1d15301"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-19T04:01:18Z",
          "updatedAt": "2023-10-19T04:01:19Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "The existing text does say the count needs to be happen from the current group as anchor. That seems pretty clear though.",
              "createdAt": "2023-10-19T04:01:18Z",
              "updatedAt": "2023-10-19T04:01:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kh7hF",
          "commit": {
            "abbreviatedOid": "1d15301"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-19T04:02:44Z",
          "updatedAt": "2023-10-19T04:02:44Z",
          "comments": [
            {
              "originalPosition": 74,
              "body": "I tend to like Now better than CurrentObject since it feels more suited when used with subscribe. CurrentObject makes me wonder if it is more befitting to Fetch/Get semantics (#111 )",
              "createdAt": "2023-10-19T04:02:44Z",
              "updatedAt": "2023-10-19T04:02:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kiPTZ",
          "commit": {
            "abbreviatedOid": "1d15301"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-19T05:15:44Z",
          "updatedAt": "2023-10-19T05:15:44Z",
          "comments": [
            {
              "originalPosition": 140,
              "body": "Yes, seems right. The problem is that if you want inclusive, you have to write:\r\n\r\n[0, 0], to [1, 7563] = all of groups 0 and 1\r\n\r\nBut you can only do that if you know in advance that group 1 has exactly 7563 objects -- and that's no obvious.",
              "createdAt": "2023-10-19T05:15:44Z",
              "updatedAt": "2023-10-19T05:15:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kiS63",
          "commit": {
            "abbreviatedOid": "1d15301"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-19T05:22:49Z",
          "updatedAt": "2023-10-19T05:22:49Z",
          "comments": [
            {
              "originalPosition": 140,
              "body": "that's true ..  as a mental model, it helps me build nice breakpoints between end of one range and start of new range in a easier way .. ",
              "createdAt": "2023-10-19T05:22:49Z",
              "updatedAt": "2023-10-19T05:22:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kp8sL",
          "commit": {
            "abbreviatedOid": "d464618"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-19T21:42:19Z",
          "updatedAt": "2023-10-19T21:42:20Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "TO DISCUSS LIVE",
              "createdAt": "2023-10-19T21:42:20Z",
              "updatedAt": "2023-10-19T21:42:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kp8w-",
          "commit": {
            "abbreviatedOid": "1d15301"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-19T21:42:37Z",
          "updatedAt": "2023-10-19T21:42:37Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "DISCUSS LIVE",
              "createdAt": "2023-10-19T21:42:37Z",
              "updatedAt": "2023-10-19T21:42:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kp8zM",
          "commit": {
            "abbreviatedOid": "1d15301"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-19T21:42:46Z",
          "updatedAt": "2023-10-19T21:42:46Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "DISCUSS LIVE",
              "createdAt": "2023-10-19T21:42:46Z",
              "updatedAt": "2023-10-19T21:42:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kp82f",
          "commit": {
            "abbreviatedOid": "1d15301"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-19T21:42:59Z",
          "updatedAt": "2023-10-19T21:42:59Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "DISCUSS LIVE",
              "createdAt": "2023-10-19T21:42:59Z",
              "updatedAt": "2023-10-19T21:42:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kp858",
          "commit": {
            "abbreviatedOid": "1d15301"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-19T21:43:10Z",
          "updatedAt": "2023-10-19T21:43:11Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "DISCUSS LIVE",
              "createdAt": "2023-10-19T21:43:11Z",
              "updatedAt": "2023-10-19T21:43:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kp9NK",
          "commit": {
            "abbreviatedOid": "1d15301"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-19T21:43:38Z",
          "updatedAt": "2023-10-19T21:43:38Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "DISCUSS LIVE",
              "createdAt": "2023-10-19T21:43:38Z",
              "updatedAt": "2023-10-19T21:43:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5krKW2",
          "commit": {
            "abbreviatedOid": "1d15301"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Trying to summarize what we need to discuss live:\r\n\r\n1. Do the use cases mentioned by Luke in 245 need to be covered now?\r\n2. One hint or multiple hints?\r\n3. Is RelativeStart(Next/Prev), Group=0 the same as Current?\r\n3a. If so, should those be disallowed?\r\n4. How should a publisher respond to a hint in the future?\r\n5. Does TrackOffset ObjectSequence=0 mean \"from the beginning\" or \"til the end\" of the group?\r\n\r\nAnything else?",
          "createdAt": "2023-10-20T02:00:05Z",
          "updatedAt": "2023-10-20T02:00:05Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5kwGi6",
          "commit": {
            "abbreviatedOid": "1d15301"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T15:32:50Z",
          "updatedAt": "2023-10-20T15:32:51Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "I'd be inclined towards a less flexible approach that encodes:\r\n - bool as to whether it's relative or absolute start\r\n - start value\r\n - Optional end value, which I think can always be absolute.\r\n\r\nIf we're going for this more TLV style framing, I think we should just use the existing parameters section and not create something new.",
              "createdAt": "2023-10-20T15:32:51Z",
              "updatedAt": "2023-10-20T15:32:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kz5-H",
          "commit": {
            "abbreviatedOid": "3696bfa"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I prefer Proposal 2, but I can live with Proposal 1 as well.",
          "createdAt": "2023-10-21T19:44:11Z",
          "updatedAt": "2023-10-21T19:53:59Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "I thought we decided it wasn't clear we needed this, except maybe there was interest in the 0 case when you want to start at the next group.",
              "createdAt": "2023-10-21T19:44:11Z",
              "updatedAt": "2023-10-21T19:53:59Z"
            },
            {
              "originalPosition": 150,
              "body": "Overall, I prefer this, because I think it's easier to reason about and there are fewer edge cases.",
              "createdAt": "2023-10-21T19:53:32Z",
              "updatedAt": "2023-10-21T19:53:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kz6Wx",
          "commit": {
            "abbreviatedOid": "3696bfa"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-21T20:01:04Z",
          "updatedAt": "2023-10-21T20:01:05Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "If one makes both of these the end values the max varint value, does that indicate an open ended subscription?",
              "createdAt": "2023-10-21T20:01:04Z",
              "updatedAt": "2023-10-21T20:01:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kz8S4",
          "commit": {
            "abbreviatedOid": "3696bfa"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Both of these proposals don't meet the requirement Luke had in his MUST table of starting at latest group and latest-N object. ",
          "createdAt": "2023-10-21T21:04:54Z",
          "updatedAt": "2023-10-21T21:28:11Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "I think the \"+1\" on current object here is a problem. For audio where you don't send packets, you often want the last packet even so that you can see things are in VAD ( Voice Activity Detection ) mode where you are not sending audio. It's only a small tweek to proposal but given there no is way to specify the relative object, I would want therelative object to be the current, not the current+1. ",
              "createdAt": "2023-10-21T21:04:54Z",
              "updatedAt": "2023-10-21T21:28:11Z"
            },
            {
              "originalPosition": 161,
              "body": "Again, I think I would want current  , not current +1 in object. We could add another enum value to have both \r\n\r\nRecent | 0xXXX| Current | Current \r\nand \r\nNow | 0xXXX | Current | Current + 1\r\n",
              "createdAt": "2023-10-21T21:12:27Z",
              "updatedAt": "2023-10-21T21:28:11Z"
            },
            {
              "originalPosition": 245,
              "body": "I'm not keen on adding code like to the draft. If the design is so hard to explain in text that we need code like this, then the design is too complicated. \r\n\r\nA big part of why I don't like code like this is inevitably over time it gets slightly out of sync with the normative code in the draft but lots of people use it and then you have huge conflicts on what the normative specification is and that makes interoperability worse. ",
              "createdAt": "2023-10-21T21:13:56Z",
              "updatedAt": "2023-10-21T21:28:11Z"
            },
            {
              "originalPosition": 104,
              "body": "One not huge change to fix this would be to say that if start/end_object was zero or a positive number, then it was the the absolute object number. If it was negative, then it is a delta applied to the current object +1. ( So a value of -1 gives you the current object, -2 the object before that, and so on ). \r\n\r\nThis all feels like it is getting too clever and too complicated.  Not sure I like it. ",
              "createdAt": "2023-10-21T21:25:10Z",
              "updatedAt": "2023-10-21T21:28:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kz9w0",
          "commit": {
            "abbreviatedOid": "328d0bd"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks for the feedback and the additional proposal. I think there's a few details that need to be filled in if that's the direction folks want to take.",
          "createdAt": "2023-10-21T22:24:20Z",
          "updatedAt": "2023-10-21T22:44:44Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "I added the +1 because `Current Object` implies that every hop needs to cache the latest object, or refetch it on subscribe, and I wasn't sure if that was the intention. So \"Now\" was intended to mean - I'm subscribed and don't need any old objects, just give me the new ones.\r\n\r\n> If it was negative\r\n\r\nvarints are non-negative\r\n\r\n> This all feels like it is getting too clever and too complicated. Not sure I like it.\r\n\r\nThat's also where I ended up when I finished the PR.",
              "createdAt": "2023-10-21T22:24:20Z",
              "updatedAt": "2023-10-21T22:44:44Z"
            },
            {
              "originalPosition": 173,
              "body": "I think that's the net effect, but it's preferred to not use RANGE to issue open ended subscriptions.",
              "createdAt": "2023-10-21T22:27:23Z",
              "updatedAt": "2023-10-21T22:44:44Z"
            },
            {
              "originalPosition": 245,
              "body": "I wrote the code before I wrote the PR, so I thought I would include it to help illustrate.  It doesn't have to stay.  The design might be too complicated.",
              "createdAt": "2023-10-21T22:29:06Z",
              "updatedAt": "2023-10-21T22:44:44Z"
            },
            {
              "originalPosition": 197,
              "body": "Looks like you are using just two modes (relative and absolute), with a signed delta.",
              "createdAt": "2023-10-21T22:30:02Z",
              "updatedAt": "2023-10-21T22:44:44Z"
            },
            {
              "originalPosition": 219,
              "body": "We need to express a signed integer encoding since varints don't have one, but maybe this is easier.",
              "createdAt": "2023-10-21T22:31:54Z",
              "updatedAt": "2023-10-21T22:44:44Z"
            },
            {
              "originalPosition": 207,
              "body": "I assume you intended the start and end group parameters to be consistently named (either START_GROUP/END_GROUP or START_GROUP_DELAT/END_GROUP_DELTA)?",
              "createdAt": "2023-10-21T22:34:15Z",
              "updatedAt": "2023-10-21T22:44:44Z"
            },
            {
              "originalPosition": 203,
              "body": "I had gone on the assumption that I tried to validate in the meeting, which is that relative objects only make sense in the current group, relative to the current object.  I'm a bit surprised to see we need \"Nth from end\" of a group, given that at least one of the functions of group is a join point.\r\n\r\nThis encoding also allows some invalid things to be specified, like starting at future objects in old groups: \r\n\r\nSTART_MODE=Relative, START_GROUP_DELTA=-100, START_OBJECT_MODE=Relative, START_OBJECT_DELTA=100  ==> Start 100 objects after the end of a group that ended a long time ago.",
              "createdAt": "2023-10-21T22:41:48Z",
              "updatedAt": "2023-10-21T22:44:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kz_bi",
          "commit": {
            "abbreviatedOid": "328d0bd"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-22T00:16:11Z",
          "updatedAt": "2023-10-22T00:16:11Z",
          "comments": [
            {
              "originalPosition": 144,
              "body": "My least favorite right now is proposal -1 .. This basically looks like original proposal is (which is one varint encdoding 6 values) expanded into 6 different parameters.",
              "createdAt": "2023-10-22T00:16:11Z",
              "updatedAt": "2023-10-22T00:16:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kz_g1",
          "commit": {
            "abbreviatedOid": "328d0bd"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-22T00:21:05Z",
          "updatedAt": "2023-10-22T00:21:06Z",
          "comments": [
            {
              "originalPosition": 186,
              "body": "thing i like about this proposal is having just 2 dimensions to define the combinations of things. This also seems pretty flexible.\r\n\r\nI feel we don't need signed value but rather a  direction  indicator instead to compute the resultign object/group -  Increasing/Decreasing Delta \r\n\r\nHaving thought about it a bit more , I seem to agree with @fluffy  on Relay update cycles and thus supporting flexibility is a good way to move. ",
              "createdAt": "2023-10-22T00:21:05Z",
              "updatedAt": "2023-10-22T00:21:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kz_il",
          "commit": {
            "abbreviatedOid": "328d0bd"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-22T00:22:43Z",
          "updatedAt": "2023-10-22T00:22:43Z",
          "comments": [
            {
              "originalPosition": 203,
              "body": "START_MODE=Relative, START_GROUP_DELTA=-100, START_OBJECT_MODE=Relative, START_OBJECT_DELTA=100\r\n\r\nThe way I read it as\r\nGo back 100 groups from the current group, then start at the 100th   from the beginning of the group",
              "createdAt": "2023-10-22T00:22:43Z",
              "updatedAt": "2023-10-22T00:22:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kz_lt",
          "commit": {
            "abbreviatedOid": "328d0bd"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-22T00:25:34Z",
          "updatedAt": "2023-10-22T00:25:34Z",
          "comments": [
            {
              "originalPosition": 186,
              "body": "One clarification needed in the text is ,\r\n\r\nOne should compute target group index first  and then compute the object index. \r\nIf the start_group mode is relative, then either use +ve or -ve delta from the current group to compute the target group\r\nif the start_group mode is absolute, then target group is the group in the request\r\n\r\nSame thing is one for target object index.\r\n\r\n\r\nif ",
              "createdAt": "2023-10-22T00:25:34Z",
              "updatedAt": "2023-10-22T00:25:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5k0ANW",
          "commit": {
            "abbreviatedOid": "3696bfa"
          },
          "author": "huitema",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-22T01:11:51Z",
          "updatedAt": "2023-10-22T01:11:51Z",
          "comments": [
            {
              "originalPosition": 161,
              "body": "I think that the real \"relative\" cases for video are:\r\n\r\n- current group, current object (now)\r\n- current group, first object of current group (previous)\r\n- next group, first object (next)\r\n\r\nThere might be a specific problem for audio, in which receiving N packets before the current one allows for fast re-synchronization of the audio codec. Whether that requires asking for \"group N-1\" is debatable, but the syntax would be \"N objects before current\", and treated really like an optional hint.\r\n\r\nThe option \"125 groups in the future\" feels like a foot gun, not sure that we need it.",
              "createdAt": "2023-10-22T01:11:51Z",
              "updatedAt": "2023-10-22T01:11:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5k0AWe",
          "commit": {
            "abbreviatedOid": "3696bfa"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-22T01:21:31Z",
          "updatedAt": "2023-10-22T01:21:31Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "True but we can make  a SignedVarInt if we need one. Just about everywhere but QUIC VarInts are signed and UnsignedVarInts are not :-) ",
              "createdAt": "2023-10-22T01:21:31Z",
              "updatedAt": "2023-10-22T01:21:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5k0AXV",
          "commit": {
            "abbreviatedOid": "3696bfa"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-22T01:22:31Z",
          "updatedAt": "2023-10-22T01:22:31Z",
          "comments": [
            {
              "originalPosition": 245,
              "body": "It did help me understand the definition of how it works. ",
              "createdAt": "2023-10-22T01:22:31Z",
              "updatedAt": "2023-10-22T01:22:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5k0Ats",
          "commit": {
            "abbreviatedOid": "328d0bd"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-22T01:45:31Z",
          "updatedAt": "2023-10-22T01:45:31Z",
          "comments": [
            {
              "originalPosition": 219,
              "body": "it had not really occurred to me we would not end up having a signed but yes, make sense how you had the mode help express the direction.  I see Luke's proposal does the same which I like better than option 3",
              "createdAt": "2023-10-22T01:45:31Z",
              "updatedAt": "2023-10-22T01:45:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5k0AuV",
          "commit": {
            "abbreviatedOid": "328d0bd"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-22T01:46:11Z",
          "updatedAt": "2023-10-22T01:46:11Z",
          "comments": [
            {
              "originalPosition": 207,
              "body": "Oh, crap, yes, mean to have that all be name the same way. SOrry ",
              "createdAt": "2023-10-22T01:46:11Z",
              "updatedAt": "2023-10-22T01:46:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5k0Ayf",
          "commit": {
            "abbreviatedOid": "328d0bd"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-22T01:50:52Z",
          "updatedAt": "2023-10-22T01:50:53Z",
          "comments": [
            {
              "originalPosition": 203,
              "body": "In the meeting I was just thinking about real time interactive audio and video - and I don't see where it would need it. But later I started thinking about a text chat client where each \"chat room\" was a track, and each thread was a group, and each message was in an object. MIMI would be better with MoQ.  Regardless of if this use case is bogus or not, it does make you think there might be future uses cases were flexibility was good as long as it did not make the current implementations way more complicated. \r\n",
              "createdAt": "2023-10-22T01:50:52Z",
              "updatedAt": "2023-10-22T01:50:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5k0FVo",
          "commit": {
            "abbreviatedOid": "328d0bd"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Per Luke's proposal:\r\n\r\n> It would be encoded as:\r\n>\r\n>SUBSCRIBE {\r\n>  ...\r\n>  start_group_hint: (i)\r\n>  start_object_hint: (i)\r\n>  end_group_hint (i)\r\n>  end_object_hint (i)\r\n>  ...\r\n>}\r\n\r\nI think I would also use a separate varint for the mode for each param rather that the LSBs.  Keep in mind that taking 2 bits from a varint means only 0-15 can be encoded in a single byte, and we shouldn't be trying to squeeze bytes out of this control message.\r\n\r\n```\r\nHint {\r\n  Mode (i),\r\n  [Value (i)]\r\n}\r\nModes = None, Relative, Next, Absolute\r\nValue is not present when Mode is None\r\n\r\nSUBSCRIBE {\r\n  ...\r\n  start_group_hint: Hint\r\n  start_object_hint: Hint\r\n  end_group_hint: Hint\r\n  end_object_hint: Hint\r\n  ...\r\n}\r\n```\r\nStart Group and Start Object cannot be None.  End Group and Object must either both be None (Closed Range), or Neither (Open Subscribe).\r\n\r\nAlso bikeshed on whether this is a Hint or a Parameter (not to be confused with Track Request Parameter).  Hint implies that it's ok if the publisher ignores it.",
          "createdAt": "2023-10-22T05:45:03Z",
          "updatedAt": "2023-10-22T05:47:31Z",
          "comments": [
            {
              "originalPosition": 203,
              "body": "> Go back 100 groups from the current group, then start at the 100th from the beginning of the group\r\n\r\nI think that would be \r\n\r\n```\r\nSTART_GROUP_MODE=relative\r\nSTART_GROUP=-100\r\nSTART_OBJECT_MODE=*absolute*\r\nSTART_OBJECT=100\r\n```\r\n\r\n> But later I started thinking about a text chat client where each \"chat room\" was a track, and each thread was a group, and each message was in an object.\r\n\r\nThis implies a track with multiple active groups.  I guess the current draft doesn't prohibit that, but I'm not sure we're thought through the implications completely.  \r\n\r\nI guess I can see \"give me the N previous objects from Now (current group)\", but struggling to see why I would want N previous objects from the largest one you have in some previous group.  That said, the simplicity of the Luke's proposal is alluring, even if it allows you do request some bizarre things.",
              "createdAt": "2023-10-22T05:45:03Z",
              "updatedAt": "2023-10-22T05:47:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5k0Zqr",
          "commit": {
            "abbreviatedOid": "328d0bd"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-22T16:14:46Z",
          "updatedAt": "2023-10-22T16:14:46Z",
          "comments": [
            {
              "originalPosition": 197,
              "body": "I'm also totally fine taking the signed relative and using unhinged and replacing relative with two modes of  future and past. ",
              "createdAt": "2023-10-22T16:14:46Z",
              "updatedAt": "2023-10-22T16:14:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5k0Zu1",
          "commit": {
            "abbreviatedOid": "328d0bd"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-22T16:17:12Z",
          "updatedAt": "2023-10-22T16:17:13Z",
          "comments": [
            {
              "originalPosition": 203,
              "body": "Active groups from way back might not happen, but getting the last objects of group N slightly after the first objects of group N+1 seems like it will happen often.  Luke's proposal relies on that working for prioritization ",
              "createdAt": "2023-10-22T16:17:12Z",
              "updatedAt": "2023-10-22T16:17:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5k0BKK",
          "commit": {
            "abbreviatedOid": "328d0bd"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Option 3 looks good, but I'm unsure why we might want different modes for the group and object.  I guess it depends upon how you define how the group modes affects the object?",
          "createdAt": "2023-10-22T02:16:57Z",
          "updatedAt": "2023-10-22T18:13:09Z",
          "comments": [
            {
              "originalPosition": 245,
              "body": "+1 to removing it before merging, but I'm glad it helped people understand.",
              "createdAt": "2023-10-22T02:16:57Z",
              "updatedAt": "2023-10-22T18:13:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5k0dag",
          "commit": {
            "abbreviatedOid": "328d0bd"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-22T18:22:27Z",
          "updatedAt": "2023-10-22T18:22:27Z",
          "comments": [
            {
              "originalPosition": 197,
              "body": "Do we really need future?  Except for 'next group', I thought we didn't have a clear use case, so that'd just be a matter of defining 0 to be the next group.\r\n\r\nI also think it'd be useful to have a 3rd mode for 'Head/Latest Group'.  If that was present, then I don't think we'd need a mode for Group?  It could always be absolute.",
              "createdAt": "2023-10-22T18:22:27Z",
              "updatedAt": "2023-10-22T18:22:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5k1WLg",
          "commit": {
            "abbreviatedOid": "8739262"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T04:49:13Z",
          "updatedAt": "2023-10-23T05:14:23Z",
          "comments": [
            {
              "originalPosition": 297,
              "body": "I like being explicit since the defaults aren't obvious. If the goal is to save bytes, there's other options.",
              "createdAt": "2023-10-23T04:49:14Z",
              "updatedAt": "2023-10-23T05:14:23Z"
            },
            {
              "originalPosition": 291,
              "body": "> StartGroup's Mode MUST NOT be None.\r\n\r\nFiled #296 for a potential use-case. We should merge this first though.",
              "createdAt": "2023-10-23T04:59:55Z",
              "updatedAt": "2023-10-23T05:14:23Z"
            },
            {
              "originalPosition": 305,
              "body": "> EndObject's Mode MUST NOT be None if EndGroup's Mode is NOT None.\r\n\r\nI don't think this is true. `end_object=none` means you want the entire group. \r\n\r\nFor example, this would request the subscription end once all objects in group 69 have been transmitted:\r\n```\r\nend_group=absolute/69\r\nend_object=none\r\n```\r\n\r\nIn my head and likely in many implementations, `none` means infinity. `end_object=infinity` means there's no end object.",
              "createdAt": "2023-10-23T05:05:17Z",
              "updatedAt": "2023-10-23T05:14:23Z"
            },
            {
              "originalPosition": 318,
              "body": "This is technically `Now+1` because the object doesn't exist yet. But yeah I understand it's meant to align with the other proposals.",
              "createdAt": "2023-10-23T05:07:17Z",
              "updatedAt": "2023-10-23T05:14:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5k4rdg",
          "commit": {
            "abbreviatedOid": "8739262"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "4 looks good, though I think there are a lot of cases RelativeNext and RelativePrevious don't make much sense for StartGroup and EndGroup.",
          "createdAt": "2023-10-23T13:36:24Z",
          "updatedAt": "2023-10-23T13:48:15Z",
          "comments": [
            {
              "originalPosition": 236,
              "body": "This is pre-existing nomenclature, but the use of the word sequence is awkward to me.  Is it shorthand for sequence number?",
              "createdAt": "2023-10-23T13:36:25Z",
              "updatedAt": "2023-10-23T13:48:15Z"
            },
            {
              "originalPosition": 301,
              "body": "SHOULD be None for an open-ended subscription?\r\n\r\nOr just \"is None for an open-ended subscription.\"",
              "createdAt": "2023-10-23T13:40:57Z",
              "updatedAt": "2023-10-23T13:48:15Z"
            },
            {
              "originalPosition": 305,
              "body": "I would agree.",
              "createdAt": "2023-10-23T13:43:56Z",
              "updatedAt": "2023-10-23T13:48:15Z"
            },
            {
              "originalPosition": 294,
              "body": "I think None means you want the whole group, but I guess that's identical to absolute/0 and I'm ok with being explicit.\r\n\r\nIf I specify a StartGroup of absolute or RelativePrevious/1, then the entire group is available.  What does RelativePrevious or RelativeNext for StartObject in those cases?",
              "createdAt": "2023-10-23T13:44:56Z",
              "updatedAt": "2023-10-23T13:48:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5k6BRx",
          "commit": {
            "abbreviatedOid": "8739262"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T15:53:41Z",
          "updatedAt": "2023-10-23T16:03:13Z",
          "comments": [
            {
              "originalPosition": 236,
              "body": "Yes, I think it's supposed to be a sequence number.",
              "createdAt": "2023-10-23T15:53:42Z",
              "updatedAt": "2023-10-23T16:03:13Z"
            },
            {
              "originalPosition": 294,
              "body": "> I think None means you want the whole group, but I guess that's identical to absolute/0 and I'm ok with being explicit.\r\n\r\nProposal 1 had default values everywhere to reduce edge cases but I decided explicit everywhere is better.\r\n\r\n> If I specify a StartGroup of absolute or RelativePrevious/1, then the entire group is available. What does RelativePrevious or RelativeNext for StartObject in those cases?\r\n\r\nRelative is just relative to the largest sequence (number).  If the entire group is known, RelativePrevious is how you specify the tail, and RelativeNext is equivalent to the next group, object 0, I guess?  \r\n\r\nA relay may have groups N and N+1 but group N might not be fully available yet?  Cullen also raised a use case of multiple open groups, which the protocol does not prohibit.",
              "createdAt": "2023-10-23T15:57:30Z",
              "updatedAt": "2023-10-23T16:03:13Z"
            },
            {
              "originalPosition": 301,
              "body": "Yeah, either it better than MAY probably.",
              "createdAt": "2023-10-23T15:58:12Z",
              "updatedAt": "2023-10-23T16:03:13Z"
            },
            {
              "originalPosition": 305,
              "body": "You can get the same behavior with:\r\n\r\n```\r\nend_group=absolute/70\r\nend_object=0\r\n```\r\n\r\nMy preference is for always explicit, no defaults, and try to avoid having more than one way to say the same thing.",
              "createdAt": "2023-10-23T16:00:30Z",
              "updatedAt": "2023-10-23T16:03:13Z"
            },
            {
              "originalPosition": 318,
              "body": "I think we can split this to two examples:\r\n\r\n```\r\n1. Latest (give me the most recent object on this group)\r\n\r\nStart Group: Mode=RelativePrevious, Value=0\r\nStart Object: Mode=RelateivePrevious, Value=0\r\nEnd Group: Mode=None\r\nEnd Object: Mode=None\r\n\r\nStartGroup=Largest Group\r\nStartObject=Largest Object\r\n\r\n2. Now (I just joined.  I don't care about the past, but give me everything new)\r\n\r\nStart Group: Mode=RelativePrevious, Value=0\r\nStart Object: Mode=RelateiveNext, Value=0\r\nEnd Group: Mode=None\r\nEnd Object: Mode=None\r\n\r\nStartGroup=Largest Group\r\nStartObject=Largest Object + 1\r\n```",
              "createdAt": "2023-10-23T16:02:51Z",
              "updatedAt": "2023-10-23T16:03:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5k6iaR",
          "commit": {
            "abbreviatedOid": "7bf617b"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Merge it :-)",
          "createdAt": "2023-10-23T17:02:12Z",
          "updatedAt": "2023-10-23T17:02:12Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5k62NB",
          "commit": {
            "abbreviatedOid": "11abacb"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-23T17:43:28Z",
          "updatedAt": "2023-10-23T17:43:28Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5k64FP",
          "commit": {
            "abbreviatedOid": "11abacb"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T17:47:21Z",
          "updatedAt": "2023-10-23T17:47:22Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "```suggestion\r\nMAY send a SUBSCRIBE_ERROR with code TBD. A publisher MUST NOT send objects\r\nfrom outside the requested start and end.\r\n```",
              "createdAt": "2023-10-23T17:47:21Z",
              "updatedAt": "2023-10-23T17:47:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5k64P3",
          "commit": {
            "abbreviatedOid": "9699d03"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T17:47:49Z",
          "updatedAt": "2023-10-23T17:47:49Z",
          "comments": [
            {
              "originalPosition": 147,
              "body": "```suggestion\r\n\r\n```",
              "createdAt": "2023-10-23T17:47:49Z",
              "updatedAt": "2023-10-23T17:47:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5k7G_9",
          "commit": {
            "abbreviatedOid": "62b2422"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T18:16:48Z",
          "updatedAt": "2023-10-23T18:16:49Z",
          "comments": [
            {
              "originalPosition": 155,
              "body": "```suggestion\r\n```",
              "createdAt": "2023-10-23T18:16:48Z",
              "updatedAt": "2023-10-23T18:16:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5k7HLj",
          "commit": {
            "abbreviatedOid": "1ee8fad"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T18:17:18Z",
          "updatedAt": "2023-10-23T18:17:18Z",
          "comments": [
            {
              "originalPosition": 163,
              "body": "```suggestion\r\n\r\n\r\n```",
              "createdAt": "2023-10-23T18:17:18Z",
              "updatedAt": "2023-10-23T18:17:18Z"
            }
          ]
        }
      ]
    },
    {
      "number": 290,
      "id": "PR_kwDOG2Ho4M5dE2yx",
      "title": "Reorder Terms and Definitions",
      "url": "https://github.com/moq-wg/moq-transport/pull/290",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Editorial"
      ],
      "body": "",
      "createdAt": "2023-10-18T00:34:49Z",
      "updatedAt": "2023-10-19T02:25:04Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "3189ba6818834a8db11e0251e4982e1da2f0f341",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ianswett-terms",
      "headRefOid": "dbea17ac81778a8be720751fd20d686c258eab8a",
      "closedAt": "2023-10-19T02:25:04Z",
      "mergedAt": "2023-10-19T02:25:04Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "63914228bb145e98a5f61db75394854b0ab7d6b9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5kWw08",
          "commit": {
            "abbreviatedOid": "52e38f8"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T00:35:32Z",
          "updatedAt": "2023-10-18T00:35:33Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\n: The party initiating a MoQ transport session.\r\n```",
              "createdAt": "2023-10-18T00:35:32Z",
              "updatedAt": "2023-10-18T00:35:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kX4S7",
          "commit": {
            "abbreviatedOid": "090a951"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-18T04:36:27Z",
          "updatedAt": "2023-10-18T04:36:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 291,
      "id": "PR_kwDOG2Ho4M5dFTEf",
      "title": "Fix a reference to RFC9000",
      "url": "https://github.com/moq-wg/moq-transport/pull/291",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-18T02:22:04Z",
      "updatedAt": "2023-10-19T02:21:32Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "34e542187097a27197859497dbac54010b81e43a",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ianswett-ref",
      "headRefOid": "74e0a9956bc03f51c27f1b6b3ee5b89c6cacc49c",
      "closedAt": "2023-10-19T02:21:32Z",
      "mergedAt": "2023-10-19T02:21:32Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "3189ba6818834a8db11e0251e4982e1da2f0f341"
      },
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, I could never figure out the syntax to link to a specific section in an RFC.",
          "createdAt": "2023-10-18T04:35:56Z",
          "updatedAt": "2023-10-18T04:35:56Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5kX4Il",
          "commit": {
            "abbreviatedOid": "74e0a99"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-18T04:35:31Z",
          "updatedAt": "2023-10-18T04:35:31Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5kcAGf",
          "commit": {
            "abbreviatedOid": "74e0a99"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-18T13:19:24Z",
          "updatedAt": "2023-10-18T13:19:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 292,
      "id": "PR_kwDOG2Ho4M5dNgxb",
      "title": "Add an .editorconfig file.",
      "url": "https://github.com/moq-wg/moq-transport/pull/292",
      "state": "MERGED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It's not a full linter, but it's quite useful to avoid spurious changes, like trailing whitespace and long lines.\r\n\r\nFixes #263",
      "createdAt": "2023-10-19T02:15:13Z",
      "updatedAt": "2023-10-19T02:20:42Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "34e542187097a27197859497dbac54010b81e43a",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "editorconfig",
      "headRefOid": "b38001263eac29a68b298bc6dc027502560089fc",
      "closedAt": "2023-10-19T02:20:42Z",
      "mergedAt": "2023-10-19T02:20:42Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "d5be3bb0244727e1fe1c690075a95be2a1203d62"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5khoIH",
          "commit": {
            "abbreviatedOid": "b380012"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-19T02:20:37Z",
          "updatedAt": "2023-10-19T02:20:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 293,
      "id": "PR_kwDOG2Ho4M5dNt7c",
      "title": "Reflow long lines.",
      "url": "https://github.com/moq-wg/moq-transport/pull/293",
      "state": "MERGED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "before: \r\n```\r\n% editorconfig-checker\r\n.github/workflows/deploy.yml:\r\n\t54: Line too long (83 instead of 80)\r\nMakefile:\r\n\t12: Wrong amount of left-padding spaces(want multiple of 2)\r\n\t13: Wrong amount of left-padding spaces(want multiple of 2)\r\n\t16: Wrong amount of left-padding spaces(want multiple of 2)\r\n\t19: Wrong amount of left-padding spaces(want multiple of 2)\r\nREADME.md:\r\n\t4: Line too long (84 instead of 80)\r\n\t9: Line too long (92 instead of 80)\r\n\t10: Line too long (82 instead of 80)\r\n\t12: Line too long (163 instead of 80)\r\ndraft-ietf-moq-transport.md:\r\n\t166: Trailing whitespace\r\n\t433: Line too long (81 instead of 80)\r\n\t732: Line too long (129 instead of 80)\r\n\t743: Line too long (149 instead of 80)\r\n\t744: Line too long (174 instead of 80)\r\n\t924: Line too long (140 instead of 80)\r\n\r\n15 errors found\r\n```\r\n\r\nafter:\r\n```\r\n% editorconfig-checker\r\nREADME.md:\r\n\t4: Line too long (84 instead of 80)\r\n\r\n1 errors found\r\n```\r\n\r\nI don't know how to fix that last issue because it's just a long URL. It doesn't matter though.",
      "createdAt": "2023-10-19T03:18:10Z",
      "updatedAt": "2023-10-20T15:08:14Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "22df6cae40549471fcdebbdb8eb0d33d39248c40",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "editorfix",
      "headRefOid": "b88ec98978b7310c148f29df0ab6f4a3860fc99d",
      "closedAt": "2023-10-20T15:08:14Z",
      "mergedAt": "2023-10-20T15:08:14Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "d68366a3d3c09b7677e5a60e3e04293a7ae4f8af"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5koMwF",
          "commit": {
            "abbreviatedOid": "b88ec98"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-19T17:04:14Z",
          "updatedAt": "2023-10-19T17:04:14Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5kv6Dc",
          "commit": {
            "abbreviatedOid": "b88ec98"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-20T15:08:07Z",
          "updatedAt": "2023-10-20T15:08:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 294,
      "id": "PR_kwDOG2Ho4M5dUxb_",
      "title": "Smaller Parameter Reform",
      "url": "https://github.com/moq-wg/moq-transport/pull/294",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #247.\r\n\r\nPeople asked for a less controversial version of #256. Here it is, defaulting to the status quo where there is disagreement.\r\n\r\nThere is some renaming and moving around of sections.\r\n\r\nConcrete changes:\r\n- Receivers SHOULD kill the connection on duplicate parameters, instead of MUST, to ease bookkeeping.\r\n- Clarify that receivers ignore unknown parameters\r\n- Clarify what to do when messages contain parameters they shouldn't (ignore)\r\n- Made all integers varints, but retained the redundant length field. Clarify what to do when they don't match (ignore)\r\n- Explicitly state the type of each parameter value\r\n\r\nI would like to eliminate the parameter length in varints as in #256, but that does not have consensus.\r\n\r\n@kixelated would like to have a separate parameter namespace for each message type, but this also does not have consensus. So I've defaulted to the current arrangement: one for SETUP, and one for SUBSCRIBE/ANNOUNCE, though I renamed the latter.",
      "createdAt": "2023-10-19T23:22:36Z",
      "updatedAt": "2023-10-20T16:57:14Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "22df6cae40549471fcdebbdb8eb0d33d39248c40",
      "headRepository": "martinduke/moq-transport",
      "headRefName": "param2",
      "headRefOid": "58314ce09b0825c8978d054f3d772816ce849143",
      "closedAt": "2023-10-20T16:57:14Z",
      "mergedAt": "2023-10-20T16:57:13Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "0043fe952747bb9798b84bcd96943773c2a2fdbf"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5kvrcE",
          "commit": {
            "abbreviatedOid": "8b36a3d"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This looks like a good start",
          "createdAt": "2023-10-20T14:50:24Z",
          "updatedAt": "2023-10-20T14:53:27Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "I'd argue for closing the connection, but I guess this is ok.",
              "createdAt": "2023-10-20T14:50:24Z",
              "updatedAt": "2023-10-20T14:53:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kvtbE",
          "commit": {
            "abbreviatedOid": "8b36a3d"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T14:54:12Z",
          "updatedAt": "2023-10-20T14:54:13Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Q: We ignore unknown parameters, so I'm unsure what this paragraph is saying?",
              "createdAt": "2023-10-20T14:54:12Z",
              "updatedAt": "2023-10-20T14:54:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kwMD1",
          "commit": {
            "abbreviatedOid": "8b36a3d"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T15:43:45Z",
          "updatedAt": "2023-10-20T15:43:45Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "If the receiver didn't know the parameter it wouldn't know it was a varint and couldn't apply this.\r\n\r\nIt is totally consistent to say \"if you know the parameter is malformed kill the connection\" but this seemed easier to write.",
              "createdAt": "2023-10-20T15:43:45Z",
              "updatedAt": "2023-10-20T15:43:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kwMoU",
          "commit": {
            "abbreviatedOid": "8b36a3d"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T15:45:04Z",
          "updatedAt": "2023-10-20T15:45:05Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Oh I meant \"the parameter appears in the wrong message\". I'll fix it.",
              "createdAt": "2023-10-20T15:45:04Z",
              "updatedAt": "2023-10-20T15:45:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kw46N",
          "commit": {
            "abbreviatedOid": "8b36a3d"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T16:51:14Z",
          "updatedAt": "2023-10-20T16:51:15Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "That makes sense, let's ship it.",
              "createdAt": "2023-10-20T16:51:14Z",
              "updatedAt": "2023-10-20T16:51:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kw5f1",
          "commit": {
            "abbreviatedOid": "58314ce"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-20T16:52:17Z",
          "updatedAt": "2023-10-20T16:52:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 295,
      "id": "PR_kwDOG2Ho4M5dZf99",
      "title": "Version and Extension Negotiation",
      "url": "https://github.com/moq-wg/moq-transport/pull/295",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #265 ",
      "createdAt": "2023-10-20T16:00:51Z",
      "updatedAt": "2023-10-20T18:13:17Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "0043fe952747bb9798b84bcd96943773c2a2fdbf",
      "headRepository": "martinduke/moq-transport",
      "headRefName": "vn",
      "headRefOid": "d916812646a6b68172aa364124616413d750e5e6",
      "closedAt": "2023-10-20T18:13:17Z",
      "mergedAt": "2023-10-20T18:13:17Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "3b93c6fc381ad0b9a7fb57cf6697e133116818b1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5kw-Gq",
          "commit": {
            "abbreviatedOid": "860e022"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-20T17:00:09Z",
          "updatedAt": "2023-10-20T17:00:54Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "This feels a bit chicken and egg.  How about \"which existing extensions\" and \"existing versions\"",
              "createdAt": "2023-10-20T17:00:09Z",
              "updatedAt": "2023-10-20T17:00:55Z"
            },
            {
              "originalPosition": 26,
              "body": "nit: parameter types or parameters?",
              "createdAt": "2023-10-20T17:00:51Z",
              "updatedAt": "2023-10-20T17:00:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kxAnE",
          "commit": {
            "abbreviatedOid": "860e022"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-20T17:04:28Z",
          "updatedAt": "2023-10-20T17:04:28Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5kxBSP",
          "commit": {
            "abbreviatedOid": "860e022"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T17:06:08Z",
          "updatedAt": "2023-10-20T17:06:08Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Should this be a top level section?",
              "createdAt": "2023-10-20T17:06:08Z",
              "updatedAt": "2023-10-20T17:06:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kxBTr",
          "commit": {
            "abbreviatedOid": "860e022"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Look like good start to me. Merge it. ",
          "createdAt": "2023-10-20T17:06:11Z",
          "updatedAt": "2023-10-20T17:06:11Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5kxTfJ",
          "commit": {
            "abbreviatedOid": "860e022"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T17:53:19Z",
          "updatedAt": "2023-10-20T17:53:20Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Where else would it go?",
              "createdAt": "2023-10-20T17:53:20Z",
              "updatedAt": "2023-10-20T17:53:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kxYfR",
          "commit": {
            "abbreviatedOid": "860e022"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T17:58:37Z",
          "updatedAt": "2023-10-20T17:58:37Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Maybe closer to section 3 since it talks about SETUP: https://moq-wg.github.io/moq-transport/draft-ietf-moq-transport.html#section-3.2\r\n\r\nThis PR makes a new section 5. IMO it just feels a little late in the draft and not quite enough for a stand-alone section.",
              "createdAt": "2023-10-20T17:58:37Z",
              "updatedAt": "2023-10-20T17:58:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5kxeis",
          "commit": {
            "abbreviatedOid": "d916812"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-20T18:13:09Z",
          "updatedAt": "2023-10-20T18:13:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 297,
      "id": "PR_kwDOG2Ho4M5djghD",
      "title": "Split SETUP messages",
      "url": "https://github.com/moq-wg/moq-transport/pull/297",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #212",
      "createdAt": "2023-10-23T17:09:32Z",
      "updatedAt": "2023-10-23T17:16:29Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "3b93c6fc381ad0b9a7fb57cf6697e133116818b1",
      "headRepository": "vasilvv/warp-draft",
      "headRefName": "split-setup",
      "headRefOid": "1f21a976c02c14847c533430c84a9f3cc4905b79",
      "closedAt": "2023-10-23T17:16:29Z",
      "mergedAt": "2023-10-23T17:16:29Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "407f68f605296627fc09f69de1f6b4b34bbca09e"
      },
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Feel free to change the numbers to any ones you prefer.",
          "createdAt": "2023-10-23T17:09:51Z",
          "updatedAt": "2023-10-23T17:09:51Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5k6nnI",
          "commit": {
            "abbreviatedOid": "1f21a97"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2023-10-23T17:14:48Z",
          "updatedAt": "2023-10-23T17:14:48Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5k6oex",
          "commit": {
            "abbreviatedOid": "1f21a97"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-23T17:16:18Z",
          "updatedAt": "2023-10-23T17:16:18Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5k6ogo",
          "commit": {
            "abbreviatedOid": "1f21a97"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-23T17:16:23Z",
          "updatedAt": "2023-10-23T17:16:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 298,
      "id": "PR_kwDOG2Ho4M5dk_Fc",
      "title": "Reinitialize repository",
      "url": "https://github.com/moq-wg/moq-transport/pull/298",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR reinitializes the repository using the [internet-draft-template repo](https://github.com/martinthomson/internet-draft-template) to allow the usual actions to work",
      "createdAt": "2023-10-23T21:31:31Z",
      "updatedAt": "2023-10-23T23:20:27Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "759f52940e2370ed61b22ead62f09cbbac0a6960",
      "headRepository": null,
      "headRefName": "fix_automations",
      "headRefOid": "d3ca7b0d2c4ae0251e80de56b41387906e2a3d66",
      "closedAt": "2023-10-23T23:20:27Z",
      "mergedAt": "2023-10-23T23:20:27Z",
      "mergedBy": "afrind",
      "mergeCommit": {
        "oid": "b3c3d73f706d02751e637d16b3e202a8f8516404"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5k82Ga",
          "commit": {
            "abbreviatedOid": "d3ca7b0"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "We may be losing some .editorconfig customizations but we can fix them later",
          "createdAt": "2023-10-23T23:19:58Z",
          "updatedAt": "2023-10-23T23:19:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 299,
      "id": "PR_kwDOG2Ho4M5dlKN0",
      "title": "s/moq/moqt/ in described URI scheme",
      "url": "https://github.com/moq-wg/moq-transport/pull/299",
      "state": "MERGED",
      "author": "englishm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "per https://github.com/moq-wg/moq-transport/issues/268 \r\n\r\nTODO: Denote need to register w/ IANA",
      "createdAt": "2023-10-23T22:16:25Z",
      "updatedAt": "2024-02-14T17:22:31Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "759f52940e2370ed61b22ead62f09cbbac0a6960",
      "headRepository": "englishm/moq-transport",
      "headRefName": "patch-1",
      "headRefOid": "5bd7fb25b5d7307ad65c7973c094b158aeed641a",
      "closedAt": "2024-02-14T17:22:31Z",
      "mergedAt": "2024-02-14T17:22:31Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "59a2a3a9a060bf1a78e191ee9b266211654eeb3f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5k9Kfx",
          "commit": {
            "abbreviatedOid": "5bd7fb2"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-24T00:42:06Z",
          "updatedAt": "2023-10-24T00:42:06Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5mJtk2",
          "commit": {
            "abbreviatedOid": "5bd7fb2"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-04T16:49:53Z",
          "updatedAt": "2023-11-04T16:49:53Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5sG0MX",
          "commit": {
            "abbreviatedOid": "5bd7fb2"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2024-01-10T17:17:46Z",
          "updatedAt": "2024-01-10T17:17:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 302,
      "id": "PR_kwDOG2Ho4M5dr-CB",
      "title": "Remove OBJECT_SEQUENCE and GROUP_SEQUENCE params",
      "url": "https://github.com/moq-wg/moq-transport/pull/302",
      "state": "MERGED",
      "author": "afrind",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This were replaced in Subscribe Locations (hints)\r\n\r\nFixes: #300",
      "createdAt": "2023-10-24T21:50:29Z",
      "updatedAt": "2023-10-26T18:42:28Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "7ceab8cef8648014daa382f9f215b7024fa553d8",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "remove-unused-params",
      "headRefOid": "d80cbc7a065fc89bcc3a4d053f10f23aa3bed95a",
      "closedAt": "2023-10-26T18:42:28Z",
      "mergedAt": "2023-10-26T18:42:28Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "94b209d57669cc9c54985e878894c404c41ea2dd"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5lFjLD",
          "commit": {
            "abbreviatedOid": "d80cbc7"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-24T21:57:29Z",
          "updatedAt": "2023-10-24T21:57:29Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5lWZ_3",
          "commit": {
            "abbreviatedOid": "d80cbc7"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-26T18:42:23Z",
          "updatedAt": "2023-10-26T18:42:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 303,
      "id": "PR_kwDOG2Ho4M5d5qUu",
      "title": "Switch types to (b)",
      "url": "https://github.com/moq-wg/moq-transport/pull/303",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #301",
      "createdAt": "2023-10-26T18:46:33Z",
      "updatedAt": "2023-10-27T01:33:43Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "94b209d57669cc9c54985e878894c404c41ea2dd",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ianswett-nolength",
      "headRefOid": "0c737b193d73a467e33fc8de8c01b87bd6cf8875",
      "closedAt": "2023-10-27T01:33:43Z",
      "mergedAt": "2023-10-27T01:33:43Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "f8dd2386d2c2d471d76e4b19aaaa811f2e13ddfe"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5lWmR4",
          "commit": {
            "abbreviatedOid": "0c737b1"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-26T18:54:10Z",
          "updatedAt": "2023-10-26T18:54:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 305,
      "id": "PR_kwDOG2Ho4M5d_khr",
      "title": "Add Subscribe Id support",
      "url": "https://github.com/moq-wg/moq-transport/pull/305",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR is expected to be base PR to support multi-subscribe like flows that will follow up.\r\n\r\nIt adds support for SubscribeID and also renames the trackId to `Full Track Name Alias` to avoid the confusion and make the scope clear.\r\n\r\n",
      "createdAt": "2023-10-27T17:14:58Z",
      "updatedAt": "2023-12-07T21:14:06Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "de5e92e3668272cb70a27dda5b52c642dae0406d",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "track-sn",
      "headRefOid": "1b6a41b273cfca844ee5fa3f2dfd0a58bca68ede",
      "closedAt": "2023-12-07T21:14:06Z",
      "mergedAt": "2023-12-07T21:14:06Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "d5d8cfe9084c2fb2d1ee1e3381341d67e487605a"
      },
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "@kixelated  @ianswett @afrind wondering if the latest commits address the feedback. thanks",
          "createdAt": "2023-11-06T09:54:31Z",
          "updatedAt": "2023-11-06T09:54:31Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5ldn6w",
          "commit": {
            "abbreviatedOid": "6a826ac"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Individual Review:\r\n\r\nThanks for this PR.  Can you link it to the corresponding issues?",
          "createdAt": "2023-10-27T17:37:58Z",
          "updatedAt": "2023-10-27T17:43:44Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "Not sure you can enforce this MUST NOT - 'SHOULD NOT' or 'need not'?",
              "createdAt": "2023-10-27T17:37:59Z",
              "updatedAt": "2023-10-27T17:43:44Z"
            },
            {
              "originalPosition": 63,
              "body": "My recommendation is to be more prescriptive on subscribe ID assignment rather than just uniqueness - even/odd for client/server, monotonically increasing, cannot re-use IDs even after they have expired/closed.",
              "createdAt": "2023-10-27T17:41:41Z",
              "updatedAt": "2023-10-27T17:43:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5lfv-T",
          "commit": {
            "abbreviatedOid": "6a826ac"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks for writing this.  I agree we need a Subscribe ID and this looks like it's heading in the right direction.\r\n\r\nCan we remove the rename of Track ID from this PR and discuss it separately, since it's purely editorial?",
          "createdAt": "2023-10-28T17:30:01Z",
          "updatedAt": "2023-10-28T17:33:45Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "I'd prefer to keep this as Track ID for now, because it's so much shorter.  Or we could call it 'Track Alias' if that's slightly clearer?  Either way, let's discuss some other names on a PR and then we can do the rename in a separate PR from adding a Subscribe ID.",
              "createdAt": "2023-10-28T17:30:01Z",
              "updatedAt": "2023-10-28T17:33:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5lhVUl",
          "commit": {
            "abbreviatedOid": "6a826ac"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "The approach is good. A lot of editorial nits.",
          "createdAt": "2023-10-30T04:27:58Z",
          "updatedAt": "2023-10-30T04:37:00Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "I think we prohibit reusing `Subscribe IDs` until we flesh out resubscriptions in a separate PR.",
              "createdAt": "2023-10-30T04:27:58Z",
              "updatedAt": "2023-10-30T04:37:00Z"
            },
            {
              "originalPosition": 63,
              "body": "I don't think we need even/odd. Each publisher would have their own number space as they do currently.\r\n\r\nBut +1 to it being +1 for each SUBSCRIBE. It would be required for a cumulative MAX_SUBSCRIBES if go that direction.\r\n\r\nnit: Can you add a space so its `Subscribe ID` instead of `SubscribeID`?",
              "createdAt": "2023-10-30T04:29:55Z",
              "updatedAt": "2023-10-30T04:37:00Z"
            },
            {
              "originalPosition": 36,
              "body": "+1 to `Track Alias`",
              "createdAt": "2023-10-30T04:32:19Z",
              "updatedAt": "2023-10-30T04:37:00Z"
            },
            {
              "originalPosition": 112,
              "body": "Can you configure your editor to obey `.editorconfig` and word wrap at 80 characters? It's difficult to determine what changed.",
              "createdAt": "2023-10-30T04:34:19Z",
              "updatedAt": "2023-10-30T04:37:00Z"
            },
            {
              "originalPosition": 175,
              "body": "This definition is useless. Can you at least include a link back to the `SUBSCRIBE` section?",
              "createdAt": "2023-10-30T04:35:41Z",
              "updatedAt": "2023-10-30T04:37:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5lmkn3",
          "commit": {
            "abbreviatedOid": "6a826ac"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-30T16:36:49Z",
          "updatedAt": "2023-10-30T16:36:49Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "good point, i will remove this line and add it in the follow up PR i am working on",
              "createdAt": "2023-10-30T16:36:49Z",
              "updatedAt": "2023-10-30T16:36:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5lnBhZ",
          "commit": {
            "abbreviatedOid": "6a826ac"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-30T17:33:53Z",
          "updatedAt": "2023-10-30T17:33:53Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "+1 , i will update to",
              "createdAt": "2023-10-30T17:33:53Z",
              "updatedAt": "2023-10-30T17:33:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5mHgsg",
          "commit": {
            "abbreviatedOid": "6a826ac"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-03T17:53:10Z",
          "updatedAt": "2023-11-03T17:53:10Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Individual Comment:\r\n\r\nAn alternate design is to put the Subscribe ID here, effectively merging it with Full Track Name Alias (I think this was Will's suggestion too).  Subscribe ID becomes an alias both for the name and the other subscribe params.  That simplifies a number of things, but the cost comes if we allow overlapping subscriptions to the same track and want to deduplicate objects among them.\r\n\r\nDeduplicating overlapping subscriptions is a pain to the subscriber, who needs to track the ranges of their open subscriptions to know which callers want a given object, and for the server to deduplicate the objects before sending.",
              "createdAt": "2023-11-03T17:53:10Z",
              "updatedAt": "2023-11-03T17:53:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5mJtRW",
          "commit": {
            "abbreviatedOid": "d9e58da"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM. \r\n\r\nI like how this makes it clear what is the transaction identifier for subscribes and the compression alias for objects full track names. ",
          "createdAt": "2023-11-04T16:38:17Z",
          "updatedAt": "2023-11-04T16:38:17Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5mNBo5",
          "commit": {
            "abbreviatedOid": "91f4631"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "The normative bits look fine.  PR needs some cleanup.  \r\n\r\nRecommend splitting ID -> Alias to another PR, so this subscribe ID doesn't get caught up with bikeshedding the field name.",
          "createdAt": "2023-11-06T09:56:22Z",
          "updatedAt": "2023-11-06T10:00:40Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Still recommend this name change go in a separate PR",
              "createdAt": "2023-11-06T09:56:22Z",
              "updatedAt": "2023-11-06T10:00:40Z"
            },
            {
              "originalPosition": 63,
              "body": "Max 80 chars per line please, here and elsewhere.",
              "createdAt": "2023-11-06T09:56:46Z",
              "updatedAt": "2023-11-06T10:00:40Z"
            },
            {
              "originalPosition": 191,
              "body": "Typo",
              "createdAt": "2023-11-06T09:57:51Z",
              "updatedAt": "2023-11-06T10:00:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5mXX4Z",
          "commit": {
            "abbreviatedOid": "22eab24"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Still looks fine after the split ",
          "createdAt": "2023-11-07T10:55:05Z",
          "updatedAt": "2023-11-07T10:55:05Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5nU2NN",
          "commit": {
            "abbreviatedOid": "22eab24"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Having reviewed some code that does subscription matching with the current draft, I strongly endorse splitting those.",
          "createdAt": "2023-11-16T05:09:31Z",
          "updatedAt": "2023-11-16T05:09:31Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5nU4H_",
          "commit": {
            "abbreviatedOid": "22eab24"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM but I would like Subscribe ID to be the first field in every `SUBSCRIBE_*` message for consistency.",
          "createdAt": "2023-11-16T05:19:14Z",
          "updatedAt": "2023-11-16T05:20:30Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "IMO this should be the first field.",
              "createdAt": "2023-11-16T05:19:14Z",
              "updatedAt": "2023-11-16T05:20:30Z"
            },
            {
              "originalPosition": 99,
              "body": "IMO this should be the first field.",
              "createdAt": "2023-11-16T05:19:25Z",
              "updatedAt": "2023-11-16T05:20:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5pkQyy",
          "commit": {
            "abbreviatedOid": "56bfa7f"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-07T20:53:56Z",
          "updatedAt": "2023-12-07T20:53:57Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "```suggestion\r\nspecify the `Subscribe ID` and it is included in the corresponding SUBSCRIBE_OK\r\nor SUBSCRIBE_ERROR.\r\n```",
              "createdAt": "2023-12-07T20:53:56Z",
              "updatedAt": "2023-12-07T20:53:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5pkTqO",
          "commit": {
            "abbreviatedOid": "2f28f9e"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-07T21:02:29Z",
          "updatedAt": "2023-12-07T21:02:30Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "```suggestion\r\nmessage headers of the requested track. Track IDs are shorter than\r\n```",
              "createdAt": "2023-12-07T21:02:30Z",
              "updatedAt": "2023-12-07T21:02:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5pkUMR",
          "commit": {
            "abbreviatedOid": "0b8c25c"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-07T21:04:10Z",
          "updatedAt": "2023-12-07T21:04:10Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "```suggestion\r\n```",
              "createdAt": "2023-12-07T21:04:10Z",
              "updatedAt": "2023-12-07T21:04:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5pkUzU",
          "commit": {
            "abbreviatedOid": "6c074f5"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-07T21:06:06Z",
          "updatedAt": "2023-12-07T21:06:06Z",
          "comments": [
            {
              "originalPosition": 103,
              "body": "```suggestion\r\n* Subscribe ID: Subscription Identifier specified in the corresponding SUBSCRIBE message.\r\n```",
              "createdAt": "2023-12-07T21:06:06Z",
              "updatedAt": "2023-12-07T21:06:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5pkVII",
          "commit": {
            "abbreviatedOid": "4ca525d"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-07T21:07:07Z",
          "updatedAt": "2023-12-07T21:07:07Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "```suggestion\r\n* Subscribe ID: Subscription Identifer as defined in {{message-subscribe-req}}.\r\n```",
              "createdAt": "2023-12-07T21:07:07Z",
              "updatedAt": "2023-12-07T21:07:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5pkVV4",
          "commit": {
            "abbreviatedOid": "181627b"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-07T21:07:49Z",
          "updatedAt": "2023-12-07T21:07:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 306,
      "id": "PR_kwDOG2Ho4M5eCIPp",
      "title": "Clarify (b)",
      "url": "https://github.com/moq-wg/moq-transport/pull/306",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Slightly clarifies what (b) is.",
      "createdAt": "2023-10-28T17:40:05Z",
      "updatedAt": "2023-10-30T15:27:28Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "f8dd2386d2c2d471d76e4b19aaaa811f2e13ddfe",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ianswett-clarify-b",
      "headRefOid": "291e1f4a895c9ab5465c85956c04194cde4fd67a",
      "closedAt": "2023-10-30T15:27:28Z",
      "mergedAt": "2023-10-30T15:27:28Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "eb35a4d0c92923a2da19c0921ac094be5c03d279"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5lhUu1",
          "commit": {
            "abbreviatedOid": "291e1f4"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-30T04:23:53Z",
          "updatedAt": "2023-10-30T04:23:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 307,
      "id": "PR_kwDOG2Ho4M5eCIs0",
      "title": "Use session more and specify error codes",
      "url": "https://github.com/moq-wg/moq-transport/pull/307",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #238 \r\n\r\nI also wonder if Connection URL should be renamed to Session URL?",
      "createdAt": "2023-10-28T17:48:31Z",
      "updatedAt": "2023-10-30T23:12:34Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "f8dd2386d2c2d471d76e4b19aaaa811f2e13ddfe",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ianswett-more-session",
      "headRefOid": "5382162d23a3f08b9843c076ecc11daaef742911",
      "closedAt": "2023-10-30T23:12:34Z",
      "mergedAt": "2023-10-30T23:12:34Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "769515acc19518a63da1f41f7492f25f6ab68f6f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5lfx8Z",
          "commit": {
            "abbreviatedOid": "5382162"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-28T17:49:14Z",
          "updatedAt": "2023-10-28T17:49:14Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Should we add a 'VN Failed' error code?",
              "createdAt": "2023-10-28T17:49:14Z",
              "updatedAt": "2023-10-28T17:49:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5lmBaH",
          "commit": {
            "abbreviatedOid": "5382162"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I would prefer:\r\n\r\n> close the session with a 'Protocol Violation'\r\n\r\ninstead of:\r\n\r\n> close the session as a 'Protocol Violation'",
          "createdAt": "2023-10-30T15:34:16Z",
          "updatedAt": "2023-10-30T15:35:15Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "I think so.",
              "createdAt": "2023-10-30T15:34:16Z",
              "updatedAt": "2023-10-30T15:35:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5lmuVG",
          "commit": {
            "abbreviatedOid": "5382162"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-30T16:55:25Z",
          "updatedAt": "2023-10-30T16:55:25Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5lm8uG",
          "commit": {
            "abbreviatedOid": "5382162"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2023-10-30T17:25:02Z",
          "updatedAt": "2023-10-30T17:25:02Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5lo3vh",
          "commit": {
            "abbreviatedOid": "5382162"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-30T23:12:18Z",
          "updatedAt": "2023-10-30T23:12:18Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "SG, will do in a different PR.",
              "createdAt": "2023-10-30T23:12:18Z",
              "updatedAt": "2023-10-30T23:12:18Z"
            }
          ]
        }
      ]
    },
    {
      "number": 308,
      "id": "PR_kwDOG2Ho4M5eCL_m",
      "title": "Remove TODOs",
      "url": "https://github.com/moq-wg/moq-transport/pull/308",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I believe some of this is covered by the recently updated GOAWAY section and I'm not sure what else to add here.",
      "createdAt": "2023-10-28T18:40:52Z",
      "updatedAt": "2023-10-31T00:10:20Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "f8dd2386d2c2d471d76e4b19aaaa811f2e13ddfe",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ianswett-remove-todos",
      "headRefOid": "a92fbc26ca17082ad387ef837b5845ed9fa35869",
      "closedAt": "2023-10-31T00:10:20Z",
      "mergedAt": "2023-10-31T00:10:20Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "5f8ba291c21839dc5addc8fb6c4cb59410c5fe0b"
      },
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think these TODOs have been covered yet. That being said, I would rather we file issues for these so there can be a conversation, rather than litter the draft with TODOs.",
          "createdAt": "2023-10-30T02:09:57Z",
          "updatedAt": "2023-10-30T02:09:57Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm unsure what's unresolved, but if you can file new issues as appropriate and link them to this PR, that would be helpful.",
          "createdAt": "2023-10-31T00:10:16Z",
          "updatedAt": "2023-10-31T00:10:16Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5lg--A",
          "commit": {
            "abbreviatedOid": "a92fbc2"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-30T02:10:04Z",
          "updatedAt": "2023-10-30T02:10:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 311,
      "id": "PR_kwDOG2Ho4M5eEwMa",
      "title": "susbscribe",
      "url": "https://github.com/moq-wg/moq-transport/pull/311",
      "state": "MERGED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-30T04:51:52Z",
      "updatedAt": "2023-10-30T07:30:58Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "f8dd2386d2c2d471d76e4b19aaaa811f2e13ddfe",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "susbscribe",
      "headRefOid": "b674c4eb5cb5ae3444d0e28fe13b064c145a6c13",
      "closedAt": "2023-10-30T07:30:55Z",
      "mergedAt": "2023-10-30T07:30:55Z",
      "mergedBy": "kixelated",
      "mergeCommit": {
        "oid": "6e08ca6ad06e4b32ea2f581e9912751e9c768bc3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5lhtwB",
          "commit": {
            "abbreviatedOid": "b674c4e"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-30T06:26:05Z",
          "updatedAt": "2023-10-30T06:26:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 316,
      "id": "PR_kwDOG2Ho4M5eLL_P",
      "title": "Describe how to use datagrams",
      "url": "https://github.com/moq-wg/moq-transport/pull/316",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #35\r\n\r\nAlso fixes #38 because there is existing text about streams:\r\n```\r\n\"A relay that reads from a stream and writes to stream in order will\r\nintroduce head-of-line blocking.  Packet loss will cause stream data to\r\nbe buffered in the library, awaiting in order delivery, which will\r\nincrease latency over additional hops.  To mitigate this, a relay SHOULD\r\nread and write stream data out of order subject to flow control\r\nlimits.  See section 2.2 in {{QUIC}}.\"\r\n```\r\n",
      "createdAt": "2023-10-30T23:23:25Z",
      "updatedAt": "2024-01-22T03:18:49Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "c107110ff473a8e28283b14b16acae45371bdc75",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ianswett-use-datagrams",
      "headRefOid": "e7d3693711c13d74dfecf8eeb4ef0ad995bb8b95",
      "closedAt": "2024-01-22T03:18:48Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 to providing more guidance. Using datagrams instead of streams is the wrong approach unless you really know what you're doing. I'm worried about the ecosystem treating them as interchangeable.\r\n\r\nI think we need to be more prescriptive. Streams are the default approach and datagrams are an extension, viable only in very specific circumstances:\r\n\r\n1. An OBJECT is below the MTU.\r\n2. Both endpoints have negotiated datagram support in SETUP.\r\n3. Some form of congestion is anticipated, otherwise QUIC datagrams are kind of pointless.\r\n4. A relay that received a stream needs to provide comparable reliability when sending as datagram instead.\r\n5. Datagrams are prioritized like streams, otherwise sending audio as datagrams (and video as streams) might produce the opposite effect.\r\n\r\nPersonally, I think vanilla QUIC datagrams are always the wrong approach.\r\n\r\n- QUIC datagrams over the internet with a negotiated FEC scheme make sense.\r\n- UDP datagrams within a CDN make sense. (lower overhead or multicast?)\r\n- TCP streams within a CDN make sense. (cost savings)\r\n \r\nBut I don't quite understand why you would use a QUIC `DATAGRAM` frame as opposed to a QUIC `STREAM` frame. They're almost identical on the wire except for an incrementing (stream) ID the aforementioned lack of flow control. What's your envisioned use-case @ianswett ?",
          "createdAt": "2023-10-31T02:29:45Z",
          "updatedAt": "2023-10-31T02:31:58Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Also another gotcha: DATAGRAM frames MAY be coalesced together depending on the QUIC implementation. Any application that uses datagrams with the expectation that datagram 1 has independent reliability from datagram 2 will be incorrect without tight QUIC bindings.\r\n\r\nI think this is why any sort of FEC and custom reliability should happen at the QUIC layer. If you want to send OBJECTs over datagrams for custom reliability, then it really needs to be done at the QUIC frame level, and you should just use STREAM_FIN instead of DATAGRAM so you don't screw up flow control.",
          "createdAt": "2023-10-31T02:41:50Z",
          "updatedAt": "2023-10-31T02:42:28Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Maybe move this discussion to an issue rather than a PR so we avoid another unicorn PR.",
          "createdAt": "2023-10-31T16:43:47Z",
          "updatedAt": "2023-10-31T16:43:47Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "this PR is right starting point. We will refine the text once we have more experience with implementation.",
          "createdAt": "2023-11-04T16:36:18Z",
          "updatedAt": "2023-11-04T16:36:18Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment:\r\n\r\nFirst, we'll see a proposal on object model at the next call that includes datagram\r\n\r\n> Forgot to leave a -1. I think we need `datagram in == datagram out`.\r\n\r\nThere are cases where this simply may not be possible due to MTU constraints. The ability to convert to a stream over a constrained hop and then back to datagram as allowed seems workable.  I guess the other option is \"drop\"?  Agree that we don't want arbitrary conversions.",
          "createdAt": "2023-11-14T01:15:25Z",
          "updatedAt": "2023-11-14T01:15:25Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5lo9Zr",
          "commit": {
            "abbreviatedOid": "10a08be"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Individual Review: \r\n\r\nShould we provide more guidance for publishers about the tradeoffs for sending an object on a stream vs a datagram?",
          "createdAt": "2023-10-30T23:45:10Z",
          "updatedAt": "2023-10-30T23:49:52Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "I think we need more specificity of how the maximum size is determined.  QUIC datagrams can have different maximum sizes (including 0 = disabled) at different hops.",
              "createdAt": "2023-10-30T23:45:10Z",
              "updatedAt": "2023-10-30T23:49:52Z"
            },
            {
              "originalPosition": 25,
              "body": "`a stream needs to ` or `a stream MUST` ?",
              "createdAt": "2023-10-30T23:45:41Z",
              "updatedAt": "2023-10-30T23:49:52Z"
            },
            {
              "originalPosition": 26,
              "body": "Should we mention that streams are subject to limits and datagrams are not?",
              "createdAt": "2023-10-30T23:46:19Z",
              "updatedAt": "2023-10-30T23:49:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5lo_3s",
          "commit": {
            "abbreviatedOid": "e7d3693"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks @afrind PTAL",
          "createdAt": "2023-10-31T00:01:15Z",
          "updatedAt": "2023-10-31T00:07:12Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "If it doesn't fit, what might the alternatives be?  We can use a MUST if you feel strongly.",
              "createdAt": "2023-10-31T00:01:15Z",
              "updatedAt": "2023-10-31T00:07:12Z"
            },
            {
              "originalPosition": 25,
              "body": "I added a sentence about how the decision of which to use is hop-by-hop.",
              "createdAt": "2023-10-31T00:02:09Z",
              "updatedAt": "2023-10-31T00:07:12Z"
            },
            {
              "originalPosition": 26,
              "body": "I added a sentence at the end.",
              "createdAt": "2023-10-31T00:06:58Z",
              "updatedAt": "2023-10-31T00:07:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5lpQrT",
          "commit": {
            "abbreviatedOid": "e7d3693"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-31T01:50:47Z",
          "updatedAt": "2023-10-31T02:30:04Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "We need an extension in SETUP to negotiate when datagrams are supported. WebTransport/QUIC support isn't enough, the MoQ library also needs to indicate support.",
              "createdAt": "2023-10-31T01:50:47Z",
              "updatedAt": "2023-10-31T02:30:04Z"
            },
            {
              "originalPosition": 14,
              "body": "I think this should be split into at least two paragraphs. The first paragraph talks about unidirectional streams and is the base behavior, while a second paragraph allows datagrams if negotiated.\r\n\r\n> OBJECTs are transmitted over unidirectional streams. Insert stream mapping stuff here.\r\n>\r\n> OBJECTs MAY be transmitted via datagrams instead if...",
              "createdAt": "2023-10-31T01:54:29Z",
              "updatedAt": "2023-10-31T02:30:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5mJtAf",
          "commit": {
            "abbreviatedOid": "e7d3693"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM. \r\n\r\nI think this will make a significant difference for applications doing interactive audio on networks with significant amount of loss. ",
          "createdAt": "2023-11-04T16:28:05Z",
          "updatedAt": "2023-11-04T16:28:05Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5mJtOc",
          "commit": {
            "abbreviatedOid": "e7d3693"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-04T16:36:33Z",
          "updatedAt": "2023-11-04T16:36:33Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5nBxt7",
          "commit": {
            "abbreviatedOid": "e7d3693"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Forgot to leave a -1. I think we need `datagram in == datagram out`.\r\n\r\nThis PR allows arbitrarily converting between streams and datagrams, but they have different reliability characteristics and it's not clear why you would do this. The text \"implementations can provide equivalent levels of reliability\" doesn't hold true because of [#15](https://github.com/quicwg/datagram/issues/15); datagram acknowledgements can't quuiiiite be used to provide reliability.\r\n\r\nThe bigger issue is that an application that sends datagrams to a relay expects to receive datagrams on the other side. This depends on the stream mapping discussion of course, but clearly the current abtraction of \"send objects via any mechanism\" is not a useful one.\r\n\r\nOf course a service is allowed to do whatever it wants inside of their network (including not using QUIC) but we don't need to specify that.",
          "createdAt": "2023-11-14T01:07:46Z",
          "updatedAt": "2023-11-14T01:12:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 323,
      "id": "PR_kwDOG2Ho4M5ektQb",
      "title": "Reapply #277 (track namespace + track name in SUBSCRIBE)",
      "url": "https://github.com/moq-wg/moq-transport/pull/323",
      "state": "MERGED",
      "author": "afrind",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-11-03T20:31:40Z",
      "updatedAt": "2023-11-07T12:45:55Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "5f8ba291c21839dc5addc8fb6c4cb59410c5fe0b",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "reapply-277",
      "headRefOid": "196010ed19ed479a8539449cb5470dad9a43420e",
      "closedAt": "2023-11-07T12:45:55Z",
      "mergedAt": "2023-11-07T12:45:55Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "5b3127c3992192d0ca77f535810240869261cb2c"
      },
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixes: #317",
          "createdAt": "2023-11-03T20:32:19Z",
          "updatedAt": "2023-11-03T20:32:19Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5mJoax",
          "commit": {
            "abbreviatedOid": "196010e"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-04T15:10:54Z",
          "updatedAt": "2023-11-04T15:10:54Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5mJsyY",
          "commit": {
            "abbreviatedOid": "196010e"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM ",
          "createdAt": "2023-11-04T16:21:02Z",
          "updatedAt": "2023-11-04T16:21:02Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5mYGjz",
          "commit": {
            "abbreviatedOid": "196010e"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-07T12:45:50Z",
          "updatedAt": "2023-11-07T12:45:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 324,
      "id": "PR_kwDOG2Ho4M5ekv4_",
      "title": "Clarify allowed messages during SETUP",
      "url": "https://github.com/moq-wg/moq-transport/pull/324",
      "state": "MERGED",
      "author": "afrind",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I think the intent of the draft was clear but this makes it explicit not to open a uni stream before setup exchange is done.\r\n\r\nFixes: #136",
      "createdAt": "2023-11-03T20:42:29Z",
      "updatedAt": "2023-11-07T13:16:40Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "67bac721f32c7f1943897d8f41dc9bfd10a5367e",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "messages-during-handshake",
      "headRefOid": "b6b00c56d8367172acb1954f2149cd4c9bded6f5",
      "closedAt": "2023-11-07T13:16:40Z",
      "mergedAt": "2023-11-07T13:16:40Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "b94c7b5489701a50358b31decc5ff183afa2881e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5mJoYj",
          "commit": {
            "abbreviatedOid": "fcda355"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-04T15:09:34Z",
          "updatedAt": "2023-11-04T15:10:34Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "I think this implies that the server has to wait until SERVER SETUP is acknowledged? It can really only know that when it receives the first non-setup control message.\r\n\r\nReally the text should say \"until after the receipt of a SUBSCRIBE message\". It's used as both an acknowledgement of the SETUP handshake being completed and It's just a protocol violation to send OBJECTs without a SUBSCRIBE anyway. But I'm also fine with \"until the receipt of the first non-SETUP message\" just to keep things generic for the future.",
              "createdAt": "2023-11-04T15:09:34Z",
              "updatedAt": "2023-11-04T15:10:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5mJs0y",
          "commit": {
            "abbreviatedOid": "fcda355"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-04T16:22:21Z",
          "updatedAt": "2023-11-04T16:22:21Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5mJz3M",
          "commit": {
            "abbreviatedOid": "fcda355"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-04T20:14:28Z",
          "updatedAt": "2023-11-04T20:14:29Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Never trust transport acks at the app layer!  Definitely don't want to imply that.  I can update it to:\r\n\r\n`An endpoint MUST not open a unidirectional stream or send an OBJECT* message until after receiving a SUBSCRIBE and sending a SUBSCRIBE OK. `\r\n\r\nThat transitively means you can't do it during setup, since you can't send or receive a subscrbie* until after setup is complete.  Would that work?",
              "createdAt": "2023-11-04T20:14:28Z",
              "updatedAt": "2023-11-04T20:14:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5mK_u-",
          "commit": {
            "abbreviatedOid": "fcda355"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-06T02:02:36Z",
          "updatedAt": "2023-11-06T02:02:36Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "> That transitively means you can't do it during setup, since you can't send or receive a subscrbie* until after setup is complete.\r\n\r\nMostly true. Now that control messages are sent on the same stream as SETUP, you can abuse head-of-line blocking. If client only supports versions/extensions with the same SUBSCRIBE encoding, then the client can send the SUBSCRIBE immediately:\r\n\r\n```\r\n--> SETUP (stream 1)\r\n--> SUBSCRIBE (stream 1)\r\n<-- SETUP (stream 1)\r\n<-- SUBSCRIBE_OK (stream 1)\r\n<-- OBJECT (stream 2)\r\n```\r\n\r\nYour proposed text now allows this so that's gud. I think it can be simplified even further:\r\n\r\n> An endpoint MUST not send an OBJECT before receiving a corresponding SUBSCRIBE message.\r\n\r\nThis rules out publisher push, independent of the handshake itself. ",
              "createdAt": "2023-11-06T02:02:36Z",
              "updatedAt": "2023-11-06T02:02:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5mYSCr",
          "commit": {
            "abbreviatedOid": "fcda355"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-07T13:08:58Z",
          "updatedAt": "2023-11-07T13:08:59Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "What Track ID would the OBJECTs have if a SUBSCRIBE hadn't been sent?",
              "createdAt": "2023-11-07T13:08:58Z",
              "updatedAt": "2023-11-07T13:08:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5mYVAv",
          "commit": {
            "abbreviatedOid": "fcda355"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-07T13:14:55Z",
          "updatedAt": "2023-11-07T13:14:56Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "I can add this MUST to the PR that makes it so the subscriber picks Track ID.",
              "createdAt": "2023-11-07T13:14:55Z",
              "updatedAt": "2023-11-07T13:14:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5mYVUt",
          "commit": {
            "abbreviatedOid": "b6b00c5"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-07T13:15:37Z",
          "updatedAt": "2023-11-07T13:15:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 325,
      "id": "PR_kwDOG2Ho4M5ema0Q",
      "title": "fix typo",
      "url": "https://github.com/moq-wg/moq-transport/pull/325",
      "state": "MERGED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Editorial"
      ],
      "body": "",
      "createdAt": "2023-11-04T16:34:57Z",
      "updatedAt": "2023-11-07T12:46:31Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "5f8ba291c21839dc5addc8fb6c4cb59410c5fe0b",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "typo1",
      "headRefOid": "e10ab8cd8deda7eb104d5003f92d092decea9c0a",
      "closedAt": "2023-11-07T12:46:31Z",
      "mergedAt": "2023-11-07T12:46:31Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "67bac721f32c7f1943897d8f41dc9bfd10a5367e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5mJtRS",
          "commit": {
            "abbreviatedOid": "e10ab8c"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-04T16:38:13Z",
          "updatedAt": "2023-11-04T16:38:13Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5mYGzn",
          "commit": {
            "abbreviatedOid": "e10ab8c"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-07T12:46:24Z",
          "updatedAt": "2023-11-07T12:46:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 327,
      "id": "PR_kwDOG2Ho4M5exBZo",
      "title": "Rename TrackID to Track Alias",
      "url": "https://github.com/moq-wg/moq-transport/pull/327",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-11-07T05:49:59Z",
      "updatedAt": "2023-11-07T12:42:23Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "5f8ba291c21839dc5addc8fb6c4cb59410c5fe0b",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "alias",
      "headRefOid": "3ef75b888fdcb6d5ee0dc34ee92cc83d2f79fb8f",
      "closedAt": "2023-11-07T12:42:23Z",
      "mergedAt": "2023-11-07T12:42:23Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "ee4d5d7ade79a2172aeacf736f57a6d9659037f9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5mXW-O",
          "commit": {
            "abbreviatedOid": "3ef75b8"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM ",
          "createdAt": "2023-11-07T10:53:07Z",
          "updatedAt": "2023-11-07T10:53:07Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5mYEWe",
          "commit": {
            "abbreviatedOid": "3ef75b8"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-07T12:40:49Z",
          "updatedAt": "2023-11-07T12:40:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 329,
      "id": "PR_kwDOG2Ho4M5ezMsI",
      "title": "Specify comparison for Track Name / Namespace",
      "url": "https://github.com/moq-wg/moq-transport/pull/329",
      "state": "MERGED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #284 ",
      "createdAt": "2023-11-07T12:27:07Z",
      "updatedAt": "2023-11-08T13:54:10Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "5f8ba291c21839dc5addc8fb6c4cb59410c5fe0b",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "compare",
      "headRefOid": "c4126a4b33186494ecfe1d6462ad098944c5de33",
      "closedAt": "2023-11-08T13:54:09Z",
      "mergedAt": "2023-11-08T13:54:09Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "de5e92e3668272cb70a27dda5b52c642dae0406d"
      },
      "comments": [
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks @ianswett  - all the proposed changes look like definite improvements. Thanks I need more coffee today.  ",
          "createdAt": "2023-11-07T13:23:31Z",
          "updatedAt": "2023-11-07T13:23:31Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5mYIlc",
          "commit": {
            "abbreviatedOid": "b742ac8"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Some small suggestions",
          "createdAt": "2023-11-07T12:50:22Z",
          "updatedAt": "2023-11-07T12:57:17Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nnot constrained to a specific encoding. They carry a sequence of\r\n```",
              "createdAt": "2023-11-07T12:50:22Z",
              "updatedAt": "2023-11-07T12:57:17Z"
            },
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nbytes and comparison between two Track Namespaces or Track Names is\r\n```",
              "createdAt": "2023-11-07T12:53:44Z",
              "updatedAt": "2023-11-07T12:57:17Z"
            },
            {
              "originalPosition": 7,
              "body": "```suggestion\r\ndone by exact comparison of the bytes. Specifications that use MoQ Transport\r\n```",
              "createdAt": "2023-11-07T12:54:15Z",
              "updatedAt": "2023-11-07T12:57:18Z"
            },
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nmay constrain the information in these fields, for example by restricting\r\nthem to UTF-8. Any specification that does that needs to\r\n```",
              "createdAt": "2023-11-07T12:56:26Z",
              "updatedAt": "2023-11-07T12:57:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5mYXFo",
          "commit": {
            "abbreviatedOid": "b742ac8"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks fine to me. Agree with most of the nits suggested by Ian",
          "createdAt": "2023-11-07T13:19:14Z",
          "updatedAt": "2023-11-07T13:19:14Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5miBe8",
          "commit": {
            "abbreviatedOid": "2e99191"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-08T12:17:48Z",
          "updatedAt": "2023-11-08T12:17:48Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "```suggestion\r\nTrack Name such that exact comparison works.\r\n```",
              "createdAt": "2023-11-08T12:17:48Z",
              "updatedAt": "2023-11-08T12:17:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5miBlL",
          "commit": {
            "abbreviatedOid": "65f7c9a"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-08T12:18:02Z",
          "updatedAt": "2023-11-08T12:18:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 330,
      "id": "PR_kwDOG2Ho4M5ezROU",
      "title": "SETUP is no longer a frame",
      "url": "https://github.com/moq-wg/moq-transport/pull/330",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Editorial"
      ],
      "body": "Replace SETUP with Setup.",
      "createdAt": "2023-11-07T12:39:24Z",
      "updatedAt": "2023-11-07T13:19:26Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "b94c7b5489701a50358b31decc5ff183afa2881e",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ianswett-setup",
      "headRefOid": "648b6dce699b4fe45f4f97e84677a1646c5f2785",
      "closedAt": "2023-11-07T13:19:26Z",
      "mergedAt": "2023-11-07T13:19:26Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "257dfba8284103958660832f25b0ca95ceaeeaf1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5mYWDd",
          "commit": {
            "abbreviatedOid": "09a213b"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-07T13:17:12Z",
          "updatedAt": "2023-11-07T13:17:12Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5mYW8d",
          "commit": {
            "abbreviatedOid": "648b6dc"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-07T13:18:56Z",
          "updatedAt": "2023-11-07T13:18:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 331,
      "id": "PR_kwDOG2Ho4M5ezvIW",
      "title": "Remove Full Track Name",
      "url": "https://github.com/moq-wg/moq-transport/pull/331",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It's only used a few times and now that Namespace and Name are an opaque sequence of bytes, it's even less compelling.\r\n\r\nFixes #328",
      "createdAt": "2023-11-07T13:40:48Z",
      "updatedAt": "2023-12-11T00:28:41Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "d5d8cfe9084c2fb2d1ee1e3381341d67e487605a",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ianswett-no-full-track-name",
      "headRefOid": "8f42fbfcc76a56ecc3e1af3c70b916020e426bdf",
      "closedAt": "2023-12-11T00:28:41Z",
      "mergedAt": "2023-12-11T00:28:41Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "1123e1cfc2759d99012b32c0785994b553e5dab6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5mY_Zw",
          "commit": {
            "abbreviatedOid": "aed96ba"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "love it",
          "createdAt": "2023-11-07T14:25:01Z",
          "updatedAt": "2023-11-07T14:25:01Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5maR5f",
          "commit": {
            "abbreviatedOid": "aed96ba"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-11-07T16:31:36Z",
          "updatedAt": "2023-11-07T16:32:31Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "s/  subscribing to the same Track Name and Track Namespace are guaranteed/  \r\n\r\n  ==> subscribing to the same tuple of Track Name and its Namespace results in ...\r\n\r\nIt is important to know the combination of these 2 (as a tuple) is what identifies a track and just track name, since they are no unique even within a moq scope ",
              "createdAt": "2023-11-07T16:31:36Z",
              "updatedAt": "2023-11-07T16:32:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5pvzAA",
          "commit": {
            "abbreviatedOid": "aed96ba"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-11T00:20:29Z",
          "updatedAt": "2023-12-11T00:20:29Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "```suggestion\r\nguaranteed to be unique. Within a single MOQT scope, the tuple of\r\nTrack Name and Track Namespace identify a specific track.  It is up\r\nto the application using MOQT to\r\n```",
              "createdAt": "2023-12-11T00:20:29Z",
              "updatedAt": "2023-12-11T00:20:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5pvzcw",
          "commit": {
            "abbreviatedOid": "78f3e15"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-11T00:25:44Z",
          "updatedAt": "2023-12-11T00:25:44Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "```suggestion\r\nBecause the tuple of Track Namespace and Track Name are unique within an\r\nMOQT scope, they can be used as a cache key.\r\n```",
              "createdAt": "2023-12-11T00:25:44Z",
              "updatedAt": "2023-12-11T00:25:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5pvzoq",
          "commit": {
            "abbreviatedOid": "aed96ba"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-11T00:28:10Z",
          "updatedAt": "2023-12-11T00:28:10Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Thanks Suhas, I clarified this and shortened the text.",
              "createdAt": "2023-12-11T00:28:10Z",
              "updatedAt": "2023-12-11T00:28:10Z"
            }
          ]
        }
      ]
    },
    {
      "number": 333,
      "id": "PR_kwDOG2Ho4M5e73Xg",
      "title": "Object Model to Transport Mapping",
      "url": "https://github.com/moq-wg/moq-transport/pull/333",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR brings in currently active proposals for supporting explicit indicators of mapping object model to quic transport.\r\n\r\nFixes #244 \r\n\r\n\r\n",
      "createdAt": "2023-11-08T14:34:57Z",
      "updatedAt": "2024-01-22T03:03:25Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "00f924c3d59a9ec6d4ae78598e0d397d83cd7ed5",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "tx-mode",
      "headRefOid": "2c3a441bfaeedc50a0db0e1b951111d1cd0129cf",
      "closedAt": "2024-01-22T03:03:25Z",
      "mergedAt": "2024-01-22T03:03:25Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "124aec92093f824eecd196a79d6fee69ec6d9abe"
      },
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Please keep discussion of the concepts on the issue #244 ",
          "createdAt": "2023-11-08T14:56:04Z",
          "updatedAt": "2023-11-08T14:56:04Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If there are any other proposed solutions to this, would be great to have them documented as additional proposal in this PR. ",
          "createdAt": "2023-11-08T16:19:35Z",
          "updatedAt": "2023-11-08T16:19:35Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "My recommendation is to pause a bit on this PR. We need more normative language, explanatory prose, and examples to help readers understand and evaluate the proposals without breaking github with a long chain of questions and comments. \r\n\r\nThe outcome from Monday's meeting was that the chairs were going to designate a small group to put the proposal forward.  I'll circle with Ian and Ted.",
          "createdAt": "2023-11-08T17:28:55Z",
          "updatedAt": "2023-11-08T17:28:55Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The outcome from Monday's meeting was that the chairs were going to designate a small group to put the proposal forward. I'll circle with Ian and Ted.\r\n\r\nOK - will wait for that ",
          "createdAt": "2023-11-09T10:14:17Z",
          "updatedAt": "2023-11-09T10:14:17Z"
        },
        {
          "author": "kixcord",
          "authorAssociation": "NONE",
          "body": "This is all just so confused. The number of messages, modes, and permutations are exploding. Some ideas are in the right direction (ex. stream header) but the hodgepodge of modes/messages is not.\r\n\r\nI'd like to explicitly add proposal 4: a relay forwards data streams.\r\n\r\n- when a relay receives an upstream stream, it creates a downstream stream (for each subscriber)\r\n- when a relay reads an OBJECT from an upstream, it writes it to the corresponding downstream if it matches the SUBSCRIBE criteria.\r\n- when the upstream is closed, the corresponding downstreams are closed with the same error code or FIN.\r\n- when a relay receives an upstream DATAGRAM, it sends it downstream if it matches the SUBSCRIBE criteria.\r\n\r\nNo wire changes. I would like a stream header eventually but it's more for compression and to prevent foot guns (ex. prioritization).\r\n\r\nThis unlocks experimentation as the application can perform any stream mapping. The relay doesn't care and remains simple. The important part is the guarantee that the relay (middlebox) won't rearrange or reorder shit if the application decided to use a stream.\r\n\r\nedit: oops was logged into my work account.",
          "createdAt": "2023-12-06T16:42:49Z",
          "updatedAt": "2023-12-06T16:47:10Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'd like to explicitly add proposal 4: a relay forwards data streams.\r\n> ...\r\n> No wire changes. I would like a stream header eventually but it's more for compression and to prevent foot guns (ex. prioritization).\r\n\r\nThe consensus in Prague was to move forward with a proposal that uses explicit signals for now, get more implementation experience and data, and revisit. Proposal 4 only uses implicit signals from the QUIC layer rather than explicit signals from the MoQ layer.  I think you can achieve similar outcomes with proposal 3 by adding the appropriate STREAM_HEADER at the beginning of each stream?",
          "createdAt": "2023-12-06T16:59:11Z",
          "updatedAt": "2023-12-06T16:59:11Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 to @afrind's proposal. once we clean it up by removing the other proposals , we should be good for merge review.  also +1 on dropping the priority for now",
          "createdAt": "2023-12-06T17:26:39Z",
          "updatedAt": "2023-12-06T18:01:19Z"
        },
        {
          "author": "kixcord",
          "authorAssociation": "NONE",
          "body": "Oh and we should be some text:\r\n\r\n> A relay MUST NOT reorder or drop OBJECTs within a stream.\r\n\r\nOtherwise we don't fix the core issue, which is that relays can arbitrarily change how OBJECTs are delivered. Stream mapping is useless if it's not enforced.",
          "createdAt": "2023-12-11T18:53:04Z",
          "updatedAt": "2023-12-11T18:53:24Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "3 is a nice refactor of approach in 1. I like it, expect for two things:\r\n- I don't think we need to support track-per-stream, and I don't remember if we ever actually got consensus for supporting it (we might need to discuss this separately).\r\n- Priority/send order should be a stream-global, since that's the level at which those are determined in QUIC.\r\n\r\nThe text is not entirely clear to me: is it still legal to have two open streams for the same group with STREAM_HEADER_GROUP (with understanding that they will get merged at the relay)?\r\n\r\nI think we could make approach 4 that does to 2 the same things that 3 does to 1. Canonical objects would have two fields:\r\n- 'Object Placement Preference' that says that object is either (1) to be placed on a new stream, or (2) to be placed on the same stream as object N.\r\n- 'Object Placement Close Bit' indicates whether there will be objects after this one on the stream or not (i.e. whether there is a FIN or not)\r\n\r\nThere's one OBJECT_STREAM frame with Track Alias, Group Sequence, Priority / Send Order as headers. You can trivially figure out how to backfill those fields (you only need to remember the most recent object for each stream); the placement when retrieving from cache is similarly easy (you do need a map for \"most recent object -> stream\").\r\n\r\nI think this fits in with the \"implicit-explicit\" approach that Luke has mentioned before. It also has a nice property that there are no cases in which what's on the wire can mismatch with what's in the canonical object (unless streams get randomly reset).",
          "createdAt": "2023-12-13T05:08:08Z",
          "updatedAt": "2023-12-13T05:08:08Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I don't think we need to support track-per-stream, and I don't remember if we ever actually got consensus for supporting it (we might need to discuss this separately).\r\n\r\nTrack-per-stream would be the preferred delivery mode for VOD files. I'd very much like to ensure that we keep support for that use case open, even if most current implementations are focused on live. ",
          "createdAt": "2023-12-13T08:15:38Z",
          "updatedAt": "2023-12-13T08:15:38Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": " > The text is not entirely clear to me: is it still legal to have two open streams for the same group with STREAM_HEADER_GROUP (with understanding that they will get merged at the relay)?\r\n\r\nI think it should be illegal as it breaks `implicit=explicit`. The broadcaster uses stream mapping A but wants downstream relays to use stream mapping B, assuming there even is a relay involved. I don't think there's a use-case for this special treatment of the first-hop. \r\n\r\nThe only use-case that I've heard is a broadcast client that is smart enough to detect group/object boundaries (ie. frames or key frames) to annotate each OBJECT with the correct stream mapping, but doesn't want to open multiple streams? That's a very poor reason, especially if the first hop may be congested, and the broadcast client should just use the indicated stream mapping.\r\n\r\nIMO a relay should not split or merge streams. It increases complexity and hurts performance. There's no need for your proposal 4 then.",
          "createdAt": "2023-12-13T16:07:24Z",
          "updatedAt": "2023-12-13T16:07:24Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> > I don't think we need to support track-per-stream, and I don't remember if we ever actually got consensus for supporting it (we might need to discuss this separately).\r\n> \r\n> Track-per-stream would be the preferred delivery mode for VOD files. I'd very much like to ensure that we keep support for that use case open, even if most current implementations are focused on live.\r\n\r\nMaybe.\r\n\r\nThe assumption is a track-per-stream would allow you to write a simple VOD-only client. It wouldn't need to reorder or reassemble objects because they're all delivered in order on a single stream. That's optimistic, as it will still need to support potentially unordered/unreliable objects (like a live client) due to seeking and gaps in the recording.\r\n\r\nBut I think we need to explore VOD and DVR more. I definitely don't want to require the server to modify the stream mapping at rest in order to serve VOD traffic, and it's not clear how that would even work for DVR.\r\n\r\nAt the very least we should first support VOD with the original stream mapping. Much like how HLS can use the same segments for live, DVR, and VOD (segment size == stream mapping). And I think we should focus on DVR first.",
          "createdAt": "2023-12-13T16:36:33Z",
          "updatedAt": "2023-12-13T16:42:38Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> That's optimistic, as it will still need to support potentially unordered/unreliable objects (like a live client) due to seeking and gaps in the recording.\r\n\r\nThis assumes LIVE-TO-VOD workflow. When I speak of VOD, its for pure VOD, which has no gaps, and was never live. The track-per-stream would would mean the client would never have to deal with out-of-order or lost objects, as the single stream would deliver them reliably and in order. Like you, I really like the appeal of the simple client interface for this. All I need is more space in my cache and I have a new market segment to address.",
          "createdAt": "2023-12-13T17:01:38Z",
          "updatedAt": "2023-12-13T17:01:38Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "> IMO a relay should not split or merge streams. It increases complexity and hurts performance. There's no need for your proposal 4 then.\r\n\r\nI'm confused. Proposal 4 does not allow merging or splitting streams.\r\n\r\n> Track-per-stream would be the preferred delivery mode for VOD files. I'd very much like to ensure that we keep support for that use case open, even if most current implementations are focused on live.\r\n\r\nThat is true, but VOD requires different delivery mechanism from what live does (e.g. live cares about catching up to the live state, but for VOD, you usually just want to show everything in order).",
          "createdAt": "2023-12-13T17:09:52Z",
          "updatedAt": "2023-12-13T17:09:52Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5mj3Ji",
          "commit": {
            "abbreviatedOid": "2a534da"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-11-08T15:40:43Z",
          "updatedAt": "2023-11-08T16:32:31Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "I don't quite understand the algorithm, but there's absolutely no way that it can handle reordering or gaps. ",
              "createdAt": "2023-11-08T15:40:43Z",
              "updatedAt": "2023-11-08T17:38:45Z"
            },
            {
              "originalPosition": 46,
              "body": "N and D are in the same OBJECT right? Can you just encode `N - D` instead?",
              "createdAt": "2023-11-08T15:42:45Z",
              "updatedAt": "2023-11-08T16:32:31Z"
            },
            {
              "originalPosition": 29,
              "body": "Major problems with implicit != explicit. It's also quite racy, to the point that different hops will have different stream mappings based on object arrival object.",
              "createdAt": "2023-11-08T15:48:44Z",
              "updatedAt": "2023-11-08T16:32:31Z"
            },
            {
              "originalPosition": 81,
              "body": "Is this per track or across all tracks?",
              "createdAt": "2023-11-08T15:52:04Z",
              "updatedAt": "2023-11-08T16:32:31Z"
            },
            {
              "originalPosition": 63,
              "body": "Does this enforce ordering? It's quite useless to use a stream per group if the objects can be out of order or contain gaps.",
              "createdAt": "2023-11-08T15:58:27Z",
              "updatedAt": "2023-11-08T16:32:31Z"
            },
            {
              "originalPosition": 52,
              "body": "Outside of this condition, when does a relay close streams on the stack? Won't they remain open just in case the next object arrives?",
              "createdAt": "2023-11-08T16:02:10Z",
              "updatedAt": "2023-11-08T16:32:31Z"
            },
            {
              "originalPosition": 57,
              "body": "It's so verbose to put this mode in every OBJECT. There's also a plethora of collisions that make it almost impossible to use multiple modes.\r\n\r\nWhat about a single mode per track in SUBSCRIBE_OK instead?",
              "createdAt": "2023-11-08T16:27:04Z",
              "updatedAt": "2023-11-08T16:32:31Z"
            },
            {
              "originalPosition": 68,
              "body": "If I set this mode for an OBJECT that would then prohibit:\r\n\r\n- any OBJECT in the same group from using StreamPerGroup\r\n- any OBJECT in the same track from using StreamPerTrack\r\n- any OBJECT in the same priority from using StreamPerPriority",
              "createdAt": "2023-11-08T16:29:18Z",
              "updatedAt": "2023-11-08T16:33:19Z"
            },
            {
              "originalPosition": 65,
              "body": "All OBJECTs in the specific group MUST also use mode StreamPerGroup.",
              "createdAt": "2023-11-08T16:29:52Z",
              "updatedAt": "2023-11-08T16:32:31Z"
            },
            {
              "originalPosition": 75,
              "body": "All OBJECTs in the specified track MUST also use mode StreamPerTrack",
              "createdAt": "2023-11-08T16:30:38Z",
              "updatedAt": "2023-11-08T16:32:31Z"
            },
            {
              "originalPosition": 81,
              "body": "All OBJECTs in the specified priority MUST also use mode StreamPerPriority",
              "createdAt": "2023-11-08T16:30:59Z",
              "updatedAt": "2023-11-08T16:32:31Z"
            },
            {
              "originalPosition": 87,
              "body": "> that objects are sent using QUIC datagrams\r\n\r\nYou mean the specified OBJECT only?",
              "createdAt": "2023-11-08T16:32:01Z",
              "updatedAt": "2023-11-08T16:32:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5mka8H",
          "commit": {
            "abbreviatedOid": "2a534da"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-08T16:46:16Z",
          "updatedAt": "2023-11-08T16:46:16Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Stream per group, every object that belongs to Group 1, send it on the stream that is assigned for Group 1.  So where is the out of order scenario coming from ? \r\n\r\nGaps has nothing to do with the transport mode mapping. A gap can be created due to object being dropped by a node on the path and if there exists an object for a group, it gets sent on the stream associated with the group",
              "createdAt": "2023-11-08T16:46:16Z",
              "updatedAt": "2023-11-08T16:46:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5mkbRX",
          "commit": {
            "abbreviatedOid": "2a534da"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-08T16:46:59Z",
          "updatedAt": "2023-11-08T16:46:59Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "that's right",
              "createdAt": "2023-11-08T16:46:59Z",
              "updatedAt": "2023-11-08T16:46:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5mkcOn",
          "commit": {
            "abbreviatedOid": "2a534da"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-08T16:48:59Z",
          "updatedAt": "2023-11-08T16:48:59Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "If you want send all the objects for a track over single stream , you set the mode as StreamPerTrack,\r\nif you want to send all the objects in a group together, you set StreamPerGroup,\r\nif you want to send objects on independent streams, you mark them as StreamPerObject.\r\n\r\n",
              "createdAt": "2023-11-08T16:48:59Z",
              "updatedAt": "2023-11-08T16:48:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5mkcjj",
          "commit": {
            "abbreviatedOid": "2a534da"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-08T16:49:35Z",
          "updatedAt": "2023-11-08T16:49:35Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "that's the intention with the existing statement",
              "createdAt": "2023-11-08T16:49:35Z",
              "updatedAt": "2023-11-08T16:49:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5mkffH",
          "commit": {
            "abbreviatedOid": "2a534da"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-08T16:55:28Z",
          "updatedAt": "2023-11-08T16:55:29Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Could you please clarify the major problems that you see ? also what do you see the concerns with different hops having different mappings ( not that I am proposing we allow that , but curious to understand more)",
              "createdAt": "2023-11-08T16:55:29Z",
              "updatedAt": "2023-11-08T16:55:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5mkmAs",
          "commit": {
            "abbreviatedOid": "2a534da"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-08T17:08:44Z",
          "updatedAt": "2023-11-08T17:25:13Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "As Cullen said at the mic, it's just a bug if the relay doesn't forward streams as they were intended.\r\n\r\nPacket loss will delay the delivery of a stream relative to others. This algorithm is quite stateful and works based on the most recently received object (regardless of stream) so it will race like crazy and produce wildly unexpected results.",
              "createdAt": "2023-11-08T17:08:44Z",
              "updatedAt": "2023-11-08T17:25:13Z"
            },
            {
              "originalPosition": 63,
              "body": "> Stream per group, every object that belongs to Group 1, send it on the stream that is assigned for Group 1. So where is the out of order scenario coming from ?\r\n\r\nIf objects arrive on different streams then they can arrive out of intended order. If we force implicit == explicit then this isn't an issue, but the text should mention that.\r\n\r\n> Gaps has nothing to do with the transport mode mapping. A gap can be created due to object being dropped by a node on the path and if there exists an object for a group, it gets sent on the stream associated with the group\r\n\r\nThat's fair, but then we need another mode with no gaps. An application that uses delta updates cannot tolerate an arbitrary hole in the middle.",
              "createdAt": "2023-11-08T17:16:31Z",
              "updatedAt": "2023-11-08T17:25:13Z"
            },
            {
              "originalPosition": 65,
              "body": "Yeah sorry I was suggesting that you add it.",
              "createdAt": "2023-11-08T17:16:55Z",
              "updatedAt": "2023-11-08T17:25:13Z"
            },
            {
              "originalPosition": 68,
              "body": "To clarify, I'm talking about when OBJECTs could have different modes. If you want ALL objects to use the same mode then that shouldn't be encoded per-OBJECT, it could be in SUBSCRIBE_OK instead.",
              "createdAt": "2023-11-08T17:18:35Z",
              "updatedAt": "2023-11-08T17:25:13Z"
            },
            {
              "originalPosition": 81,
              "body": "Sorry, is this a stream...\r\n\r\n- per priority per track?\r\n- per priority per namespace?\r\n- per priority (per session)?\r\n\r\nThe last one is my interpretation of the text and it's impossible because some other namespace/track will definitely want to use another mode.",
              "createdAt": "2023-11-08T17:19:03Z",
              "updatedAt": "2023-11-08T17:25:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5o1-lg",
          "commit": {
            "abbreviatedOid": "e4d84e6"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-01T04:24:47Z",
          "updatedAt": "2023-12-01T04:24:48Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "s/on a stream/on a QUIC stream",
              "createdAt": "2023-12-01T04:24:48Z",
              "updatedAt": "2023-12-01T04:24:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5o1-3J",
          "commit": {
            "abbreviatedOid": "e4d84e6"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-01T04:26:44Z",
          "updatedAt": "2023-12-01T04:26:45Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "I think we should also say , there MUST be only occurrence of `OBJECT_STREAM` message else its an protocol error.",
              "createdAt": "2023-12-01T04:26:45Z",
              "updatedAt": "2023-12-01T04:26:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5o6IBS",
          "commit": {
            "abbreviatedOid": "e4d84e6"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-01T15:43:33Z",
          "updatedAt": "2023-12-01T15:44:26Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "I left out QUIC to account for WebTransport or QUIC.  I think this matches elsewhere now?  In an earlier draft I said \"transport stream\".",
              "createdAt": "2023-12-01T15:43:33Z",
              "updatedAt": "2023-12-01T15:44:26Z"
            },
            {
              "originalPosition": 133,
              "body": "Is that not implied by saying that the payload length is determined by the length of the stream?",
              "createdAt": "2023-12-01T15:44:10Z",
              "updatedAt": "2023-12-01T15:44:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5pv4mP",
          "commit": {
            "abbreviatedOid": "e4d84e6"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-11T01:17:57Z",
          "updatedAt": "2023-12-11T01:17:58Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "```suggestion\r\n`OBJECT_STREAM` message MUST be the first and only message on a unidirectional stream.\r\n```",
              "createdAt": "2023-12-11T01:17:58Z",
              "updatedAt": "2023-12-11T01:17:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5pv49r",
          "commit": {
            "abbreviatedOid": "e4d84e6"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "3 LGTM overall, but I had some comments on the details.",
          "createdAt": "2023-12-11T01:21:12Z",
          "updatedAt": "2023-12-11T01:54:14Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "Don't we need a type value so if we receive a stream, we know what type of stream it is?",
              "createdAt": "2023-12-11T01:21:12Z",
              "updatedAt": "2023-12-11T01:54:14Z"
            },
            {
              "originalPosition": 161,
              "body": "```suggestion\r\nTo send an Object with `Object Forwarding Preference` = `Datagram`, determine\r\nthe length of the fields and payload, and compare the length with the maximum\r\n```",
              "createdAt": "2023-12-11T01:24:28Z",
              "updatedAt": "2023-12-11T01:54:14Z"
            },
            {
              "originalPosition": 164,
              "body": "```suggestion\r\ndatagram size of the session.  If the object size is less than or equal maximum\r\ndatagram size, send the serialized data as a datagram.  Otherwise, the object on a\r\nunidirectional stream as you would an OBJECT_STREAM message.  An implementation\r\n```",
              "createdAt": "2023-12-11T01:33:55Z",
              "updatedAt": "2023-12-11T01:54:14Z"
            },
            {
              "originalPosition": 183,
              "body": "What if the stream is reset?",
              "createdAt": "2023-12-11T01:36:39Z",
              "updatedAt": "2023-12-11T01:54:14Z"
            },
            {
              "originalPosition": 198,
              "body": "TRACK_STREAM or just TRACK would be simpler to me.",
              "createdAt": "2023-12-11T01:38:02Z",
              "updatedAt": "2023-12-11T01:54:14Z"
            },
            {
              "originalPosition": 216,
              "body": "How about GROUP?  Also, it'd be more natural to put this above TRACK in terms of ordering.",
              "createdAt": "2023-12-11T01:40:35Z",
              "updatedAt": "2023-12-11T01:54:14Z"
            },
            {
              "originalPosition": 203,
              "body": "How do I know if they're needed?\r\n\r\nDo we have one Object message at the beginning of the stream after the 'type' is serialized and then omit the duplicate fields on subsequent Object messages?\r\n\r\nOr do we have a 'message' that starts the stream that could be only the type, followed by the shared values, and then a sequence of objects?  They're fairly equivalent, but we should pick one.",
              "createdAt": "2023-12-11T01:45:17Z",
              "updatedAt": "2023-12-11T01:54:14Z"
            },
            {
              "originalPosition": 250,
              "body": "I don't think we need this.  I'd rather have every stream have a single priority.  If we want to do that later we can, but we all agree that mixing priorities on a single stream is problematic at best.",
              "createdAt": "2023-12-11T01:51:42Z",
              "updatedAt": "2023-12-11T01:54:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5p1Df-",
          "commit": {
            "abbreviatedOid": "e4d84e6"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-11T15:56:10Z",
          "updatedAt": "2023-12-11T17:21:15Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "The intent was anything with \"Message\" after it was a type.  I just didn't add them to the type table.",
              "createdAt": "2023-12-11T15:56:10Z",
              "updatedAt": "2023-12-11T17:21:15Z"
            },
            {
              "originalPosition": 164,
              "body": "I think you mean *send* the object",
              "createdAt": "2023-12-11T15:57:10Z",
              "updatedAt": "2023-12-11T17:21:15Z"
            },
            {
              "originalPosition": 183,
              "body": "Resetting a stream mid object isn't a connection level protocol violation, but sending a FIN in the middle of an OBJECT is.",
              "createdAt": "2023-12-11T16:02:48Z",
              "updatedAt": "2023-12-11T17:21:15Z"
            },
            {
              "originalPosition": 198,
              "body": "I'm fine with any naming.",
              "createdAt": "2023-12-11T16:03:13Z",
              "updatedAt": "2023-12-11T17:21:15Z"
            },
            {
              "originalPosition": 203,
              "body": "> How do I know if they're needed?\r\n\r\nIf you have to open a stream for this, then you need to send a header.\r\n\r\n> Or do we have a 'message' that starts the stream that could be only the type, followed by the shared values, and then a sequence of objects?\r\n\r\nThis one.\r\n",
              "createdAt": "2023-12-11T17:18:31Z",
              "updatedAt": "2023-12-11T17:21:15Z"
            },
            {
              "originalPosition": 216,
              "body": "Ok",
              "createdAt": "2023-12-11T17:19:39Z",
              "updatedAt": "2023-12-11T17:21:15Z"
            },
            {
              "originalPosition": 250,
              "body": "> I'd rather have every stream have a single priority. \r\n\r\nIf that's the case, I think you want this message and remove the GROUP one that allows a different send order per object.",
              "createdAt": "2023-12-11T17:21:03Z",
              "updatedAt": "2023-12-11T17:21:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5p18KS",
          "commit": {
            "abbreviatedOid": "e4d84e6"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-11T17:33:14Z",
          "updatedAt": "2023-12-11T17:33:15Z",
          "comments": [
            {
              "originalPosition": 250,
              "body": "+1 priority should definitely be hoisted to the stream header, and then this frame type can be deleted.\r\n\r\nThere's an argument that a relay could perform application-level prioritization by reordering objects on a stream, but that suffers from head-of-line blocking and contradicts the ordering/reliability that QUIC streams are supposed to provide. An application needs to make separate streams of they want separate priorities.",
              "createdAt": "2023-12-11T17:33:14Z",
              "updatedAt": "2023-12-11T17:35:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5p2VeT",
          "commit": {
            "abbreviatedOid": "e4d84e6"
          },
          "author": "kixcord",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "Sorry for the earlier outburst. Alan's proposal is definitely in the right direction and is starting to align with my vision. I think I just need an outlet to write that vision down because I'm getting overwhelmed by leaving piecewise opinions on Github.\r\n\r\nI think we should:\r\n- delete `OBJECT_STREAM`, unless somebody wants it.\r\n- delete `STREAM_HEADER_PRIORITY`, moving priority to the stream header instead.\r\n- add `OBJECT_DATAGRAM`, but we should discuss datagrams more in general.",
          "createdAt": "2023-12-11T18:13:28Z",
          "updatedAt": "2023-12-11T18:38:09Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "I would actually be in favor of removing this message type.\r\n\r\nI'm using objects with an unbounded length to get around the lack of stream mapping in the current draft. The idea is that an OBJECT_STREAM can't be moved or combined with other streams, so it's a way to actually enforce stream mapping across relays.\r\n\r\nHowever we don't need it any longer if there's explicit stream mapping and ordering/reliability. I would be fine with each OBJECT having a specified length (like HTTP/3 DATA frames) provided the relay can't rearrange them. It does mean that we have to buffer each frame to determine the length but that's often unavoidable.",
              "createdAt": "2023-12-11T18:13:28Z",
              "updatedAt": "2023-12-11T18:37:40Z"
            },
            {
              "originalPosition": 164,
              "body": "We do need to send RESET_STREAM for flow control reasons. What error code do we use? Do we need to indicate why the datagram was dropped (ex. flow control)?\r\n\r\nDoes the receiver also reply with a STOP_SENDING?",
              "createdAt": "2023-12-11T18:16:55Z",
              "updatedAt": "2023-12-11T18:37:40Z"
            },
            {
              "originalPosition": 169,
              "body": "I think this is a footgun. It has the same downsides as IP fragmentation.\r\n\r\nThe application want specific behavior from datagrams, namely that they are independent. If a relay converts a datagram a stream, it will be split across IP packets and may even share packets with other datagram fragments. This makes implementing something like FEC basically impossible.\r\n\r\nIn my opinion, we should require the datagram extension and that all OBJECT_DATAGRAM messages are smaller than 1.2kB.",
              "createdAt": "2023-12-11T18:26:47Z",
              "updatedAt": "2023-12-11T18:37:40Z"
            },
            {
              "originalPosition": 169,
              "body": "Also, is a relay expected to cache datagrams or does it require timely delivery? I feel like the intent of datagrams is for transient data, but currently it only disables retransmissions. That feels like the wrong behavior, especially with datagrams that span multiple MTU because it only serves to amplify loss.",
              "createdAt": "2023-12-11T18:27:18Z",
              "updatedAt": "2023-12-11T18:37:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5p1jNz",
          "commit": {
            "abbreviatedOid": "e4d84e6"
          },
          "author": "jordicenzano",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "Overall I like the proposal the explicitly map objects to quic streams. I left few comments",
          "createdAt": "2023-12-11T16:46:35Z",
          "updatedAt": "2023-12-13T21:07:28Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "isn't that type `Message Type` 0x2 (OBJECT without payload length) specified in draft-01",
              "createdAt": "2023-12-11T16:46:36Z",
              "updatedAt": "2023-12-13T21:07:28Z"
            },
            {
              "originalPosition": 173,
              "body": "Is it feasable/correct to implement sendOrder that is honored across Streams and datagrams? (For instance I think Chrome webtransport API for datagrams does NOT expose sendOrder today)\r\nIf not, what are we planning to do with sendOrder here? (just between datagrams? Ignore?)",
              "createdAt": "2023-12-13T16:17:28Z",
              "updatedAt": "2023-12-13T21:07:28Z"
            },
            {
              "originalPosition": 183,
              "body": "When we have ABR perhaps you would want to terminate stream 720p2Mbps because we are already receiving 1080p4Mbps ",
              "createdAt": "2023-12-13T16:20:07Z",
              "updatedAt": "2023-12-13T21:07:28Z"
            },
            {
              "originalPosition": 123,
              "body": "If the \"Object *MUST* be sent according to its `Object Forwarding Preference`\", should we remove the word \"Preference\". It seems contradictory with MUST",
              "createdAt": "2023-12-13T21:00:14Z",
              "updatedAt": "2023-12-13T21:07:28Z"
            },
            {
              "originalPosition": 121,
              "body": "We need a way to tell the publisher how to map QUIC streams and this seems like a good proposal to me. Perhaps we should add something about relay implementation, perhaps: The relay would need remember how those objects were received on the subscriber side and replicate that in the publisher side",
              "createdAt": "2023-12-13T21:04:33Z",
              "updatedAt": "2023-12-13T21:07:28Z"
            },
            {
              "originalPosition": 192,
              "body": "I assume we can send 1 track (ex: video track) in mutiple Streams with STREAM_HEADER_TRACK, can I or that would be a protocol violation?",
              "createdAt": "2023-12-13T21:05:27Z",
              "updatedAt": "2023-12-13T21:07:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5p2qPB",
          "commit": {
            "abbreviatedOid": "e4d84e6"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Individual Review",
          "createdAt": "2023-12-11T18:43:14Z",
          "updatedAt": "2023-12-14T04:35:23Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "This message currently makes the third example possible (line 1173).  Without it, a relay might combine objects from the two different input streams to a single output stream.",
              "createdAt": "2023-12-11T18:43:15Z",
              "updatedAt": "2023-12-14T04:35:23Z"
            },
            {
              "originalPosition": 164,
              "body": "I think we probably need to say more about the consequences of sending a datagram over a stream, because the default behavior means object becomes reliable over that hop (it will be rxmited until fully acked, or peer sends STOP_SENDING, triggering a RST_STREAM).  Other behaviors are possible, for example, RST_STREAM on loss detection, so maybe those need to be included in the preference, or made the explicit default?\r\n\r\nIf the datagram part of this PR seems less fully baked we can remove it for now.",
              "createdAt": "2023-12-11T18:49:32Z",
              "updatedAt": "2023-12-14T04:35:23Z"
            },
            {
              "originalPosition": 169,
              "body": "> In my opinion, we should require the datagram extension and that all OBJECT_DATAGRAM messages are smaller than 1.2kB.\r\n\r\nI think the peer can technically choose any max datagram size, even smaller than 1200 bytes.  I think I'm in favor of a fallback behavior rather than a black hole.",
              "createdAt": "2023-12-11T18:52:34Z",
              "updatedAt": "2023-12-14T04:35:23Z"
            },
            {
              "originalPosition": 121,
              "body": "I tried to capture this in the sections below describing how to determine the preference when receiving an object and how to send an object with a given preference.  I'm also going to add a normative bit to the relay section.",
              "createdAt": "2023-12-14T04:23:54Z",
              "updatedAt": "2023-12-14T04:35:23Z"
            },
            {
              "originalPosition": 123,
              "body": "Do we like \"Object forwarding mode\" better than preference?  I'm neutral.",
              "createdAt": "2023-12-14T04:24:39Z",
              "updatedAt": "2023-12-14T04:35:23Z"
            },
            {
              "originalPosition": 142,
              "body": "Jordi is right -- it's the same.",
              "createdAt": "2023-12-14T04:27:05Z",
              "updatedAt": "2023-12-14T04:35:23Z"
            },
            {
              "originalPosition": 161,
              "body": "I'm going to remove datagram for now.",
              "createdAt": "2023-12-14T04:27:58Z",
              "updatedAt": "2023-12-14T04:35:23Z"
            },
            {
              "originalPosition": 164,
              "body": "same as above.",
              "createdAt": "2023-12-14T04:28:27Z",
              "updatedAt": "2023-12-14T04:35:23Z"
            },
            {
              "originalPosition": 173,
              "body": "This field is to convey the priority signal to the next hop, which might be using an API that allows setting priority on datagrams.",
              "createdAt": "2023-12-14T04:30:16Z",
              "updatedAt": "2023-12-14T04:35:23Z"
            },
            {
              "originalPosition": 183,
              "body": "You can terminate it cleanly on an object boundary, or reset it, but you can't fin in the middle of an object.",
              "createdAt": "2023-12-14T04:30:54Z",
              "updatedAt": "2023-12-14T04:35:23Z"
            },
            {
              "originalPosition": 192,
              "body": "I'm going to add that a sender SHOULD only have one stream open with the exact same STREAM_HEADER.  It's not all that enforceable at the receiver though because of reordering.",
              "createdAt": "2023-12-14T04:32:34Z",
              "updatedAt": "2023-12-14T04:35:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5sE4Ig",
          "commit": {
            "abbreviatedOid": "2a534da"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-10T13:23:55Z",
          "updatedAt": "2024-01-10T13:23:55Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "Binding the transport mode to the subscription seems like a reasonable constraint. Once a publisher is producing a track, I can't find an obvious use-case as to why they would need to alter the object-to-transport mapping. If there was one in the future, the publisher could work around it by terminating the track and advertising a new one with the new mapping. Binding the mapping to the subscription means, as kixelated points out, that the mapping info can be sent just once in SUSBCRIBE_OK. For compactness, anything that doesn't change over the life of a subscription (such as track alias, subscribe ID and now mapping) should be communicated via SUBSCRIBE_OK. ",
              "createdAt": "2024-01-10T13:23:55Z",
              "updatedAt": "2024-01-10T13:23:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5sG_Ix",
          "commit": {
            "abbreviatedOid": "d061fe0"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-10T17:39:27Z",
          "updatedAt": "2024-01-10T17:39:27Z",
          "comments": [
            {
              "originalPosition": 211,
              "body": "I think this should be track alias not subscribe ID ",
              "createdAt": "2024-01-10T17:39:27Z",
              "updatedAt": "2024-01-10T17:39:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5o1_O9",
          "commit": {
            "abbreviatedOid": "5764876"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks @afrind  .. this is coming pretty close. I left few comments.",
          "createdAt": "2023-12-01T04:29:18Z",
          "updatedAt": "2024-01-12T04:06:37Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "The wire encoding of this and the previous message is exactly same. Are we missing defining the message type ?",
              "createdAt": "2023-12-01T04:29:18Z",
              "updatedAt": "2024-01-12T04:06:37Z"
            },
            {
              "originalPosition": 5,
              "body": "A relay can drop objects. This MUST is hard to enforce. ",
              "createdAt": "2024-01-11T20:20:28Z",
              "updatedAt": "2024-01-12T04:06:37Z"
            },
            {
              "originalPosition": 92,
              "body": "IIUC, this should be, if the current subscription (identified by SusbcribeId) doesn't correspond to the Track matching its Track Alias , the receiver MUST close ..",
              "createdAt": "2024-01-11T21:37:50Z",
              "updatedAt": "2024-01-12T04:06:37Z"
            },
            {
              "originalPosition": 116,
              "body": "Let's add Track Alias here too",
              "createdAt": "2024-01-12T03:57:15Z",
              "updatedAt": "2024-01-12T04:06:37Z"
            },
            {
              "originalPosition": 142,
              "body": "i think the last sentence is not needed. All we need to say is \"all the objects for a given group are sent on the same stream\".",
              "createdAt": "2024-01-12T03:59:12Z",
              "updatedAt": "2024-01-12T04:06:37Z"
            },
            {
              "originalPosition": 211,
              "body": "+1 let's add track alias here as well",
              "createdAt": "2024-01-12T03:59:30Z",
              "updatedAt": "2024-01-12T04:06:37Z"
            },
            {
              "originalPosition": 158,
              "body": "I really don't see a need to have a match on the SendOrder here. StreamPerGroup sends all the objects with the same groupId. if the application wants to send each priority in its own group, then it arranges that way. ",
              "createdAt": "2024-01-12T04:01:19Z",
              "updatedAt": "2024-01-12T04:06:37Z"
            },
            {
              "originalPosition": 188,
              "body": "sequence to Id",
              "createdAt": "2024-01-12T04:02:22Z",
              "updatedAt": "2024-01-12T04:06:37Z"
            },
            {
              "originalPosition": 192,
              "body": "May be we should have this example to extended as \r\n{Stream_Header_Track}{g1, o0}{g1, o1} ... {g2,o0}, {g2,o1}, ....",
              "createdAt": "2024-01-12T04:04:17Z",
              "updatedAt": "2024-01-12T04:06:37Z"
            },
            {
              "originalPosition": 203,
              "body": "sequence to Id",
              "createdAt": "2024-01-12T04:04:41Z",
              "updatedAt": "2024-01-12T04:06:37Z"
            },
            {
              "originalPosition": 196,
              "body": "the unordered object example is confusing here and I prefer not to include and create a new example for OBJECT_STREAM ",
              "createdAt": "2024-01-12T04:06:10Z",
              "updatedAt": "2024-01-12T04:06:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5sUlWg",
          "commit": {
            "abbreviatedOid": "5764876"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks for the quick review. I have addressed some, left some responses/suggestions for the others.\r\n\r\nFor examples, let's wait til all the feedback is in and we can make another pass.",
          "createdAt": "2024-01-12T04:16:52Z",
          "updatedAt": "2024-01-12T04:28:34Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I think we said in a previous author's call that we would relax this when we formally add concepts like TTL or drop preference, which give relay instructions about which objects are droppable.  I can update to \"A relay MUST not reorder or drop objects *without application specific information*\" - or something like that?",
              "createdAt": "2024-01-12T04:16:52Z",
              "updatedAt": "2024-01-12T04:28:34Z"
            },
            {
              "originalPosition": 142,
              "body": "The intent is to tell the receiver how to populate the canonical 'Object Send Order'.  I can say \"have the `Object Send Order` specified in the stream header\" ?",
              "createdAt": "2024-01-12T04:26:52Z",
              "updatedAt": "2024-01-12T04:28:34Z"
            },
            {
              "originalPosition": 158,
              "body": "The intent was to allow more flexibility than strictly stream-per-group.  With this design, the publisher can split a group into multiple streams with different priorities.  The original proposal 3 had both kinds of streams and the feedback was to combine them.",
              "createdAt": "2024-01-12T04:27:58Z",
              "updatedAt": "2024-01-12T04:28:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5sb_HL",
          "commit": {
            "abbreviatedOid": "5764876"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-12T23:06:59Z",
          "updatedAt": "2024-01-12T23:07:00Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "works for me. Thanks",
              "createdAt": "2024-01-12T23:07:00Z",
              "updatedAt": "2024-01-12T23:07:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5p2B5O",
          "commit": {
            "abbreviatedOid": "8a678a6"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "It's almost there. This is exponentially easier for a relay and receiver than prior proposals.",
          "createdAt": "2023-12-11T17:39:54Z",
          "updatedAt": "2024-01-16T22:15:43Z",
          "comments": [
            {
              "originalPosition": 152,
              "body": "I think we need more guidance on what a relay is supposed to do.\r\n\r\nSome questions:\r\n- Should a sender disable retransmissions? If so what error code should it use to RESET_STREAM?\r\n- Should a receiver immediately send STOP_SENDING to try to prevent retransmissions too?\r\n- What should happen if limited by MAX_STREAMS? Should the sender drop immediately?\r\n- What should happen if limited by MAX_STREAM_DATA? Should the sender drop immediately?\r\n- How long should a receiver wait before considering the object dropped? Is it a timer or does it wait for the RESET_STREAM, which may need to be retransmitted?\r\n- Does a sender need to provide packet mapping? If two datagrams are received on two different packets, do the resulting streams also need to be sent in different packets? How does FEC work otherwise?\r\n\r\nMy recommendation would be to just set a size limit of 1.2kB and always use datagrams. Emulating datagram behavior with streams is kinda gross.",
              "createdAt": "2023-12-11T17:54:22Z",
              "updatedAt": "2024-01-16T22:15:43Z"
            },
            {
              "originalPosition": 240,
              "body": "This is illegal right? Two objects have the same object ID and group ID (0,1).",
              "createdAt": "2024-01-16T21:52:00Z",
              "updatedAt": "2024-01-16T22:15:43Z"
            },
            {
              "originalPosition": 132,
              "body": "A relay could still convert single object streams into multi object streams that by buffering until EOF. The sentence you added is meant to prevent that, although it doesn't quuuiiite do so. Maybe it should be changed to:\r\n\r\n> A relay MUST not reorder or drop objects received on a ~multi-object~ stream when\r\n> forwarding to subscribers, unless it has application specific information.\r\n\r\n",
              "createdAt": "2024-01-16T21:55:17Z",
              "updatedAt": "2024-01-16T22:18:37Z"
            },
            {
              "originalPosition": 132,
              "body": "I don't think a relay can implement the draft until this is specified.\r\n\r\nI would like the incoming stream FIN to signal an outgoing stream FIN. But that takes us back to the \"implicit vs explicit\" discussion. I would like to avoid an \"explicit\" `STREAM_DONE` message followed by a QUIC FIN...",
              "createdAt": "2024-01-16T21:59:28Z",
              "updatedAt": "2024-01-16T22:23:37Z"
            },
            {
              "originalPosition": 153,
              "body": "I'm confused by this sentence. This seems like an implementation detail depending on the API?\r\n\r\nPersonally, I wouldn't lazy initialize the stream because then the MoQ library won't know when to close it. I think you can safely remove this sentence and just say that multiple objects follow.",
              "createdAt": "2024-01-16T22:08:36Z",
              "updatedAt": "2024-01-16T22:15:43Z"
            },
            {
              "originalPosition": 159,
              "body": "Can we add the constraint that both of these must be increasing over the life of the stream? Otherwise dropping and subsequent gap detection becomes very difficult. ",
              "createdAt": "2024-01-16T22:09:45Z",
              "updatedAt": "2024-01-16T22:15:43Z"
            },
            {
              "originalPosition": 191,
              "body": "Same thing, can we make this increasing only?",
              "createdAt": "2024-01-16T22:10:33Z",
              "updatedAt": "2024-01-16T22:15:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5s1JLK",
          "commit": {
            "abbreviatedOid": "8a678a6"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-17T00:07:14Z",
          "updatedAt": "2024-01-17T00:07:14Z",
          "comments": [
            {
              "originalPosition": 153,
              "body": "i think this needs to caoture the intent as \" all the objects for a given track is sent on the same stream\" . ",
              "createdAt": "2024-01-17T00:07:14Z",
              "updatedAt": "2024-01-17T00:07:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5s1M6T",
          "commit": {
            "abbreviatedOid": "8a678a6"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-17T00:10:51Z",
          "updatedAt": "2024-01-17T00:10:51Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "groupId and object Id are monotonically increasing integers.",
              "createdAt": "2024-01-17T00:10:51Z",
              "updatedAt": "2024-01-17T00:10:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5s1cOR",
          "commit": {
            "abbreviatedOid": "8a678a6"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-17T00:25:52Z",
          "updatedAt": "2024-01-17T00:25:52Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "agree we need to get to this , but I feel this can be done in a separate PR>",
              "createdAt": "2024-01-17T00:25:52Z",
              "updatedAt": "2024-01-17T00:25:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5s1_eY",
          "commit": {
            "abbreviatedOid": "8a678a6"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Individual comments",
          "createdAt": "2024-01-17T01:00:29Z",
          "updatedAt": "2024-01-17T01:15:04Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "> I don't think a relay can implement the draft until this is specified.\r\n\r\nI agree.\r\n\r\n> agree we need to get to this , but I feel this can be done in a separate PR\r\n\r\nI'm inclined to take the consensus we have, merge it and build on it, rather than keeping this PR open.\r\n\r\nI don't think we want to take it from the QUIC layer and we do need an MoQ layer signal.  Is the stream carrying the track data even sufficient or could it be reset?  The stream termination messages may need to go on the control stream?",
              "createdAt": "2024-01-17T01:00:29Z",
              "updatedAt": "2024-01-17T01:15:04Z"
            },
            {
              "originalPosition": 153,
              "body": "The intent was to explain how relays send outgoing objects, but make it generic for publishers too.  Similar language was used for other multi-object stream formats.\r\n\r\nI don't think it conflicts with your plan to not-lazy-initialize, that would fit in \"find the open stream...\", but I'm open to different language too.",
              "createdAt": "2024-01-17T01:09:03Z",
              "updatedAt": "2024-01-17T01:15:04Z"
            },
            {
              "originalPosition": 240,
              "body": "Yes, I think I meant for this to be Object ID=2.",
              "createdAt": "2024-01-17T01:10:57Z",
              "updatedAt": "2024-01-17T01:15:04Z"
            },
            {
              "originalPosition": 159,
              "body": "I'm ok adding an explicit restriction here.  Does anyone object?",
              "createdAt": "2024-01-17T01:11:37Z",
              "updatedAt": "2024-01-17T01:15:04Z"
            },
            {
              "originalPosition": 191,
              "body": "I'm ok adding an explicit restriction here.  Does anyone object?",
              "createdAt": "2024-01-17T01:11:52Z",
              "updatedAt": "2024-01-17T01:15:04Z"
            },
            {
              "originalPosition": 132,
              "body": "> A relay could still convert single object streams into multi object streams that by buffering until EOF.\r\n\r\nI don't think so.  The rules for sending objects say\r\n\r\n```\r\nTo send an Object with `Object Forwarding Preference` = `Object`, open a stream,\r\nserialize object fields below, and terminate the stream.\r\n```",
              "createdAt": "2024-01-17T01:14:21Z",
              "updatedAt": "2024-01-17T01:15:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5s8cJZ",
          "commit": {
            "abbreviatedOid": "4b2bd9a"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-17T17:08:29Z",
          "updatedAt": "2024-01-17T17:09:05Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5s8fRI",
          "commit": {
            "abbreviatedOid": "4b2bd9a"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-17T17:15:26Z",
          "updatedAt": "2024-01-17T17:15:26Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "> groupId and object Id are monotonically increasing integers.\r\n\r\nAre they monotonically increasing? I thought the use-case was two streams with objects interlaced, in which case they wouldn't be.",
              "createdAt": "2024-01-17T17:15:26Z",
              "updatedAt": "2024-01-17T17:15:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5s8y8x",
          "commit": {
            "abbreviatedOid": "4b2bd9a"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-17T17:59:47Z",
          "updatedAt": "2024-01-17T17:59:47Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5tE2-u",
          "commit": {
            "abbreviatedOid": "bfa15c0"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-18T15:40:41Z",
          "updatedAt": "2024-01-18T15:45:16Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "```suggestion\r\nIf the Track Namespace and Track Name identified by the Track Alias is different\r\n```",
              "createdAt": "2024-01-18T15:40:41Z",
              "updatedAt": "2024-01-18T15:45:16Z"
            },
            {
              "originalPosition": 125,
              "body": "Also, this applies to all types of mappings, so maybe move it up to the end of the previous section?",
              "createdAt": "2024-01-18T15:45:11Z",
              "updatedAt": "2024-01-18T15:45:16Z"
            }
          ]
        }
      ]
    },
    {
      "number": 334,
      "id": "PR_kwDOG2Ho4M5e8G2V",
      "title": "Add support for end message.",
      "url": "https://github.com/moq-wg/moq-transport/pull/334",
      "state": "OPEN",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR attempts to support the requirements needed for #318 and #244 ",
      "createdAt": "2023-11-08T15:09:47Z",
      "updatedAt": "2024-03-04T17:04:30Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "00f924c3d59a9ec6d4ae78598e0d397d83cd7ed5",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "fin",
      "headRefOid": "dbfea7e18d55c3664115bdc0218fb71b60d2f7b1",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As a wY of making progress on this, lets first focus on how we know about the end of group, then jump into the end of track. ",
          "createdAt": "2024-03-04T17:04:29Z",
          "updatedAt": "2024-03-04T17:04:29Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5nBrSR",
          "commit": {
            "abbreviatedOid": "0a8be02"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Individual Review:\r\n\r\nIf SUBSCRIBE_FIN works for END(Track), then the main missing use-case is group.  Maybe we can morph this to END_GROUP { Track Alias, Group, Object } for now?",
          "createdAt": "2023-11-14T00:32:41Z",
          "updatedAt": "2023-11-14T00:41:28Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "I'm somewhat concerned about including END on OBJECT streams.  In the case where the peer sends a STOP_SENDING, the original sender may not know if the receiver has received the END message.  Instead, I'm inclined to say that END must appear on a non-resettable stream.  This could be a track-specific control stream, or the sender can just open a stream, send END and close it.",
              "createdAt": "2023-11-14T00:32:41Z",
              "updatedAt": "2023-11-14T00:41:28Z"
            },
            {
              "originalPosition": 41,
              "body": "How is this different from SUBSCRIBE_FIN?",
              "createdAt": "2023-11-14T00:33:22Z",
              "updatedAt": "2023-11-14T00:41:28Z"
            },
            {
              "originalPosition": 49,
              "body": "I'm unsure when I would send this.  If I'm using OBJECT_WITH_LENGTH, the end is well known - it's over when you receive the terminal byte of payload.  If I'm using OBJECT_WITHOUT_LENGTH, there isn't a place to put END in the same stream, and presumably the end of the stream marks the end.\r\n\r\nDo you have another use-case in mind?",
              "createdAt": "2023-11-14T00:35:46Z",
              "updatedAt": "2023-11-14T00:41:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5nBuhk",
          "commit": {
            "abbreviatedOid": "0a8be02"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "As the protocol currently stands, we need a way to mark the end of a group, but we also need a way to mark when individual objects have been dropped. Otherwise, a subscriber waiting for an END object as signaled by this message may never unblock. I don't think this end group is useful otherwise, and perhaps misleading.",
          "createdAt": "2023-11-14T00:50:08Z",
          "updatedAt": "2023-11-14T00:58:18Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "This use-case is useful without stream mapping. I still want a stream per group, where the stream FIN signals the end of a group, instead of this (noisy) message on the control stream.",
              "createdAt": "2023-11-14T00:50:08Z",
              "updatedAt": "2023-11-14T00:58:18Z"
            },
            {
              "originalPosition": 49,
              "body": "+1 There's no use-case here.",
              "createdAt": "2023-11-14T00:50:59Z",
              "updatedAt": "2023-11-14T00:58:18Z"
            },
            {
              "originalPosition": 29,
              "body": "You also need to to include the last group/object like `SUBSCRIBE_RST/FIN`. Sending a boolean `END` message without them is extremely racey.",
              "createdAt": "2023-11-14T00:52:27Z",
              "updatedAt": "2023-11-14T00:58:18Z"
            },
            {
              "originalPosition": 54,
              "body": "We should remove the object mode because like this paragraph outlines, it provides duplicate functionality.\r\n\r\nHowever the `END` message MUST/SHOULD be sent for the end of each track/group, otherwise a receiver can't rely on it.",
              "createdAt": "2023-11-14T00:54:39Z",
              "updatedAt": "2023-11-14T00:58:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5xz6oj",
          "commit": {
            "abbreviatedOid": "dbfea7e"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2024-02-29T17:08:20Z",
          "updatedAt": "2024-02-29T17:10:38Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "This is in the data plane and does not change the subscription. That allows it to indicate the end of each group as well as the end of track. But even when using it for end of track, imagine a care where things are out of order. Lets say group 100 is the last one, group 99 may still arriver after the END object. The END object just tells you what the publisher is saying is the last object in the group or track. We could do this with flags in the object but that has other problems. ",
              "createdAt": "2024-02-29T17:08:20Z",
              "updatedAt": "2024-02-29T17:10:38Z"
            },
            {
              "originalPosition": 22,
              "body": "This needs more information to explain how this is differnt than what is happening with SUBSCRIBES and that relays need to cache this information and deliver it. I feel like it might be better done as as a special type of object. ",
              "createdAt": "2024-02-29T17:09:26Z",
              "updatedAt": "2024-02-29T17:10:38Z"
            },
            {
              "originalPosition": 54,
              "body": "I agree with Luke on this should not be optional",
              "createdAt": "2024-02-29T17:10:18Z",
              "updatedAt": "2024-02-29T17:10:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5x0CU3",
          "commit": {
            "abbreviatedOid": "dbfea7e"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-29T17:24:02Z",
          "updatedAt": "2024-02-29T17:24:03Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "I think we should signal the end of publication of a track, but it should not apply at the GROUP level otherwise we have a very chatty protocol. \r\n\r\nFurthermore, END can be scoped at multiple different layers. It think this should apply specifically to tracks and that it should look like this:\r\n\r\nTRACK_END\r\n{\r\n   Track Namespace (b),\r\n   Track Name (b),\r\n   LastGroup (Location),\r\n   LastObject (Location),\r\n}",
              "createdAt": "2024-02-29T17:24:02Z",
              "updatedAt": "2024-02-29T17:24:16Z"
            }
          ]
        }
      ]
    },
    {
      "number": 338,
      "id": "PR_kwDOG2Ho4M5fWTNt",
      "title": "Fail session on malformed parameter",
      "url": "https://github.com/moq-wg/moq-transport/pull/338",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #314 ",
      "createdAt": "2023-11-13T22:05:08Z",
      "updatedAt": "2024-01-10T17:36:40Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "4d42a78c12acf6f12389b8faf5edf4b5f9e3f512",
      "headRepository": "martinduke/moq-transport",
      "headRefName": "fail-length",
      "headRefOid": "4b0a7ab6cdade89594cdbc6f958b19686e717097",
      "closedAt": "2024-01-10T17:36:40Z",
      "mergedAt": "2024-01-10T17:36:40Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "e44aa48372942187027b899e5bb90c97ab279e0d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5nBwU3",
          "commit": {
            "abbreviatedOid": "f600c8a"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-14T00:59:55Z",
          "updatedAt": "2023-11-14T01:00:10Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Can we change this so it's not VarInt specific? If the type doesn't match the length (buffer under-run or over-run), then it's a error.",
              "createdAt": "2023-11-14T00:59:56Z",
              "updatedAt": "2023-11-14T01:00:10Z"
            },
            {
              "originalPosition": 9,
              "body": "With what error code?",
              "createdAt": "2023-11-14T01:00:03Z",
              "updatedAt": "2023-11-14T01:00:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5qAdk5",
          "commit": {
            "abbreviatedOid": "f600c8a"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-12T21:58:37Z",
          "updatedAt": "2023-12-12T21:58:37Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "done",
              "createdAt": "2023-12-12T21:58:37Z",
              "updatedAt": "2023-12-12T21:58:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5qAdvO",
          "commit": {
            "abbreviatedOid": "f600c8a"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-12T21:58:59Z",
          "updatedAt": "2023-12-12T21:58:59Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "I made it error code TBD because there aren't any error codes",
              "createdAt": "2023-12-12T21:58:59Z",
              "updatedAt": "2023-12-12T21:58:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5sGsIk",
          "commit": {
            "abbreviatedOid": "718568c"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LG, though we can bikeshed about the error code name.",
          "createdAt": "2024-01-10T17:00:10Z",
          "updatedAt": "2024-01-10T17:00:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 339,
      "id": "PR_kwDOG2Ho4M5hoGz0",
      "title": "Change Sequence to ID for Objects and Groups",
      "url": "https://github.com/moq-wg/moq-transport/pull/339",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Editorial"
      ],
      "body": "Sequence typically indicates a number of things.",
      "createdAt": "2023-12-11T01:12:19Z",
      "updatedAt": "2023-12-14T19:33:42Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "1123e1cfc2759d99012b32c0785994b553e5dab6",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ianswett-sequence-id",
      "headRefOid": "cd18f555456bed426a433719e7ae68df68334caf",
      "closedAt": "2023-12-14T19:33:41Z",
      "mergedAt": "2023-12-14T19:33:41Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "9c6a6a9c74df27e503e982611d9226155a3996a2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5p4Jq1",
          "commit": {
            "abbreviatedOid": "cd18f55"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This is a good change.",
          "createdAt": "2023-12-11T23:08:04Z",
          "updatedAt": "2023-12-11T23:08:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 340,
      "id": "PR_kwDOG2Ho4M5jtKAI",
      "title": "Add Ian Swett as Editor",
      "url": "https://github.com/moq-wg/moq-transport/pull/340",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "And remove Twitch from Luke Curley's entry.",
      "createdAt": "2024-01-10T16:41:53Z",
      "updatedAt": "2024-01-10T17:16:52Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "9c6a6a9c74df27e503e982611d9226155a3996a2",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ianswett-ian-editor",
      "headRefOid": "eafd50f817a8cbcd54de32dad1620eb46bcda620",
      "closedAt": "2024-01-10T17:16:52Z",
      "mergedAt": "2024-01-10T17:16:52Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "1416ad1af9584e7d425b0d5075bd1aa9cede8449"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5sGxvI",
          "commit": {
            "abbreviatedOid": "fe9f386"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-10T17:11:56Z",
          "updatedAt": "2024-01-10T17:11:56Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5sGyFj",
          "commit": {
            "abbreviatedOid": "fe9f386"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-10T17:12:46Z",
          "updatedAt": "2024-01-10T17:12:46Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n    organization: Discord\r\n```",
              "createdAt": "2024-01-10T17:12:46Z",
              "updatedAt": "2024-01-10T17:12:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5sGyID",
          "commit": {
            "abbreviatedOid": "fe9f386"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM ",
          "createdAt": "2024-01-10T17:12:52Z",
          "updatedAt": "2024-01-10T17:12:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 341,
      "id": "PR_kwDOG2Ho4M5jtm9I",
      "title": "Define SUBSCRIBE_ERROR error codes",
      "url": "https://github.com/moq-wg/moq-transport/pull/341",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes existing TODOs and TBDs",
      "createdAt": "2024-01-10T17:58:00Z",
      "updatedAt": "2024-01-17T17:04:45Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "e44aa48372942187027b899e5bb90c97ab279e0d",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ianswett-subscribe-error",
      "headRefOid": "ed1be1e584ba2f469954ae3e5bfbcee0c5a1b60e",
      "closedAt": "2024-01-17T17:04:44Z",
      "mergedAt": "2024-01-17T17:04:44Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "00f924c3d59a9ec6d4ae78598e0d397d83cd7ed5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5sHUhy",
          "commit": {
            "abbreviatedOid": "ed1be1e"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-10T18:29:46Z",
          "updatedAt": "2024-01-10T18:29:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 342,
      "id": "PR_kwDOG2Ho4M5j3oTm",
      "title": "Add Forwarding Preference=Datagram",
      "url": "https://github.com/moq-wg/moq-transport/pull/342",
      "state": "MERGED",
      "author": "afrind",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This was previously part of #333. It allows an object to be sent in a datagram f it fits, and put on a stream if it doesn't.\r\n\r\nCloses #316 ",
      "createdAt": "2024-01-11T23:56:21Z",
      "updatedAt": "2024-01-22T03:17:57Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "tx-mode",
      "baseRefOid": "2c3a441bfaeedc50a0db0e1b951111d1cd0129cf",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "datagram-preferred",
      "headRefOid": "6df1a5e3955639800e040a81b5b358db4a1b0372",
      "closedAt": "2024-01-22T03:17:57Z",
      "mergedAt": "2024-01-22T03:17:57Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "229a1f75eb25e17d0df5c66ca25c9533fcdbe10b"
      },
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Linking some feedback raised in the original PR that has not yet been addressed:\r\n\r\nhttps://github.com/moq-wg/moq-transport/pull/333#discussion_r1422925734\r\n\r\nhttps://github.com/moq-wg/moq-transport/pull/333#discussion_r1422937755",
          "createdAt": "2024-01-11T23:57:42Z",
          "updatedAt": "2024-01-11T23:57:42Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5s8eCb",
          "commit": {
            "abbreviatedOid": "7b44a95"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-17T17:12:36Z",
          "updatedAt": "2024-01-17T17:13:07Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "may be we can say \"It is the only message sent on a undirectional stream\"",
              "createdAt": "2024-01-17T17:12:36Z",
              "updatedAt": "2024-01-17T17:13:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5s8hKV",
          "commit": {
            "abbreviatedOid": "7b44a95"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks like a great starting point to me. ",
          "createdAt": "2024-01-17T17:19:51Z",
          "updatedAt": "2024-01-17T17:19:51Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5s9eBM",
          "commit": {
            "abbreviatedOid": "7b44a95"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Some minor comments, but LGTM",
          "createdAt": "2024-01-17T19:42:13Z",
          "updatedAt": "2024-01-17T19:45:23Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "How about OBJECT_PREFER_DATAGRAM ?",
              "createdAt": "2024-01-17T19:42:13Z",
              "updatedAt": "2024-01-17T19:45:23Z"
            },
            {
              "originalPosition": 37,
              "body": "```suggestion\r\nbe the first and only message on a unidirectional stream.\r\n```",
              "createdAt": "2024-01-17T19:44:06Z",
              "updatedAt": "2024-01-17T19:45:23Z"
            },
            {
              "originalPosition": 47,
              "body": "Are we going to enforce this MUST?  If not, I'd be inclined to say SHOULD NOT",
              "createdAt": "2024-01-17T19:45:04Z",
              "updatedAt": "2024-01-17T19:45:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5s9flB",
          "commit": {
            "abbreviatedOid": "7b44a95"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-17T19:46:15Z",
          "updatedAt": "2024-01-17T19:46:15Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5taMMZ",
          "commit": {
            "abbreviatedOid": "d9fdcaf"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-22T03:16:31Z",
          "updatedAt": "2024-01-22T03:16:31Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "```suggestion\r\n**Object Prefer Datagram Message**\r\n```",
              "createdAt": "2024-01-22T03:16:31Z",
              "updatedAt": "2024-01-22T03:16:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5taMR4",
          "commit": {
            "abbreviatedOid": "a5361ca"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-22T03:17:09Z",
          "updatedAt": "2024-01-22T03:17:09Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "```suggestion\r\nSHOULD NOT send an Object with `Object Forwarding Preference` = `Datagram` on a\r\n```",
              "createdAt": "2024-01-22T03:17:09Z",
              "updatedAt": "2024-01-22T03:17:09Z"
            }
          ]
        }
      ]
    },
    {
      "number": 343,
      "id": "PR_kwDOG2Ho4M5kuj9y",
      "title": "Add largest Group ID and Object ID to SUBSCRIBE_OK",
      "url": "https://github.com/moq-wg/moq-transport/pull/343",
      "state": "MERGED",
      "author": "wilaw",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes https://github.com/moq-wg/moq-transport/issues/337",
      "createdAt": "2024-01-22T14:19:42Z",
      "updatedAt": "2024-02-18T21:12:49Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "2d83972885a5b2f0b1dfb0aec6af20dd9aa6423f",
      "headRepository": "wilaw/moq-transport",
      "headRefName": "main",
      "headRefOid": "1baa9614b9c50642b9826a1a46611756036bdc03",
      "closedAt": "2024-02-18T21:12:49Z",
      "mergedAt": "2024-02-18T21:12:49Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "fc6a102eced02955bcae4ce9107559f5393de38f"
      },
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "nit: can you wrap the lines at 80 chars?",
          "createdAt": "2024-02-14T19:02:21Z",
          "updatedAt": "2024-02-14T19:02:21Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "In the call last Wednesday, we agreed this design was the correct approach, so merging even though there are some reviews outstanding requesting changes.",
          "createdAt": "2024-02-18T21:12:43Z",
          "updatedAt": "2024-02-18T21:12:43Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5teVQF",
          "commit": {
            "abbreviatedOid": "8961455"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2024-01-22T14:56:27Z",
          "updatedAt": "2024-01-22T15:09:32Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "What value should a relay return if the track is not yet active but subscription is authenticated ? I think this should be optional.\r\n\r\nAlso i feel a note is needed saying \" such value is relative to the relay responding with Subscribe_OK and may / may not reflect the latest group at the original producer \"\r\n\r\n",
              "createdAt": "2024-01-22T14:56:28Z",
              "updatedAt": "2024-01-22T15:27:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5tekks",
          "commit": {
            "abbreviatedOid": "8961455"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-22T15:22:29Z",
          "updatedAt": "2024-01-22T15:22:29Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "same comments as above applies here i think",
              "createdAt": "2024-01-22T15:22:29Z",
              "updatedAt": "2024-01-22T15:22:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5tfOmJ",
          "commit": {
            "abbreviatedOid": "8961455"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I was thinking we would add the start group and Object ID for the requested subscription.  Even for an absolute subscription, I can imagine cases the requested start values can't be served, so newer ones have to be served instead?\r\n\r\nIt'd also be nice to make these optional, but I think that's a detail that depends upon what fields we end up wanting here.",
          "createdAt": "2024-01-22T16:41:58Z",
          "updatedAt": "2024-01-22T16:41:58Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5u9YvI",
          "commit": {
            "abbreviatedOid": "95b5b33"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "This seems like it will have many race conditions. It seems like it would be better to transfer this in the STREAM_HEADER_TRACK and equivalent.  Thoughts on that ?\r\n\r\nI also worry about how long a subscribe would wait to find out this information - that seems like it could be problematic for the client knowing when to give up on a subscribe. \r\n\r\nHopefully we can discuss in Denver ",
          "createdAt": "2024-02-04T22:01:01Z",
          "updatedAt": "2024-02-04T22:01:01Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5wHjKj",
          "commit": {
            "abbreviatedOid": "69c530c"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-14T18:52:59Z",
          "updatedAt": "2024-02-14T18:52:59Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "This has now been resolved with the addition of the ContentExists flag. ",
              "createdAt": "2024-02-14T18:52:59Z",
              "updatedAt": "2024-02-14T18:52:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5wHjRL",
          "commit": {
            "abbreviatedOid": "69c530c"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-14T18:53:17Z",
          "updatedAt": "2024-02-14T18:53:17Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Same resolution. ",
              "createdAt": "2024-02-14T18:53:17Z",
              "updatedAt": "2024-02-14T18:53:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5wH-PO",
          "commit": {
            "abbreviatedOid": "69c530c"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Small nits. Thanks for the change.s",
          "createdAt": "2024-02-14T19:50:19Z",
          "updatedAt": "2024-02-14T19:51:49Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "I don't see a need to include text on locations here.",
              "createdAt": "2024-02-14T19:50:19Z",
              "updatedAt": "2024-02-14T19:51:49Z"
            },
            {
              "originalPosition": 18,
              "body": "Also , this seems uneccesary \"Note that the Group may not be complete when this value is returned.\".",
              "createdAt": "2024-02-14T19:50:50Z",
              "updatedAt": "2024-02-14T19:51:49Z"
            },
            {
              "originalPosition": 18,
              "body": "same comments as above, Let's just indicate largest object Id os the largest known object under the group indicated by \"LargestGroupId\".",
              "createdAt": "2024-02-14T19:51:39Z",
              "updatedAt": "2024-02-14T19:51:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5wIiIH",
          "commit": {
            "abbreviatedOid": "69c530c"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-14T20:48:51Z",
          "updatedAt": "2024-02-14T20:48:52Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "> I don't see a need to include text on locations here.\r\n\r\nI think we need to cleanly define what \"largest\" means in the context of groups and how this maps precisely to the Location description. Simply saying its the \"largest group\" doesn't tie in to how an subscriber would actually request that object. \r\n\r\n> Also , this seems unnecessary \"Note that the Group may not be complete when this value is returned.\".\r\n\r\nThis was added because there was some ambiguity as to whether this was the largest fully complete group available for the track, or just the largest group for which at least one object has started publishing. It's the latter, but thats not obvious if the language above is omitted. ",
              "createdAt": "2024-02-14T20:48:51Z",
              "updatedAt": "2024-02-14T20:48:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5wI_GR",
          "commit": {
            "abbreviatedOid": "69c530c"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-14T22:12:44Z",
          "updatedAt": "2024-02-14T22:12:44Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Largest is the largest know groupId and objectId for a given track seen so far or available. I think we are making it less clear by adding location information. Locations are filters and the answer one gets doesn't have to match it since the state of publisher may have very well moved out. \r\n\r\nI sitll feel if the group being full or not doesn't need to be specified here.",
              "createdAt": "2024-02-14T22:12:44Z",
              "updatedAt": "2024-02-14T22:12:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5wJi3X",
          "commit": {
            "abbreviatedOid": "bd5b252"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-15T00:34:02Z",
          "updatedAt": "2024-02-15T00:34:02Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Individual Comment: \r\n\r\nI recommend we keep the text here very simple, and reference the Locations section for a definition of what Largest Group and Largest Object mean, since they are used throughout that section.  Right now, isn't a good definition of Largest Group and Largest Object there, but we can add that in a follow-up PR?",
              "createdAt": "2024-02-15T00:34:02Z",
              "updatedAt": "2024-02-15T00:34:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5wfkrC",
          "commit": {
            "abbreviatedOid": "bd5b252"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-18T21:05:27Z",
          "updatedAt": "2024-02-18T21:05:27Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5wfk1h",
          "commit": {
            "abbreviatedOid": "935277d"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-18T21:10:48Z",
          "updatedAt": "2024-02-18T21:10:48Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "I shortened the descriptions some, though we could probably make them even shorter.",
              "createdAt": "2024-02-18T21:10:48Z",
              "updatedAt": "2024-02-18T21:10:48Z"
            }
          ]
        }
      ]
    },
    {
      "number": 344,
      "id": "PR_kwDOG2Ho4M5kvfjs",
      "title": "Land Datagram Preferred (PR #342)",
      "url": "https://github.com/moq-wg/moq-transport/pull/344",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Update main to reflect the tx-mode branch after #342 was merged.",
      "createdAt": "2024-01-22T16:34:44Z",
      "updatedAt": "2024-01-22T20:17:57Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "124aec92093f824eecd196a79d6fee69ec6d9abe",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "tx-mode",
      "headRefOid": "be469ed63c9c012a19e86dcde10a3e0ea7826696",
      "closedAt": "2024-01-22T20:17:57Z",
      "mergedAt": "2024-01-22T20:17:57Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "d97485d4fb39d1f1fc0e88b7291dd14c36ebe836"
      },
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "> Individual Review:\r\n> \r\n> There was some feedback on previous iterations about this PR lacking guidance when encountering flow control limits (eg: send as datagram, relay converts to stream, but is out of streams or flow control)\r\n\r\nAgreed, but I'm not sure there's any normative language there.  Is this a case of writing a paragraph cautioning that such limits could cause issues?",
          "createdAt": "2024-01-22T20:17:39Z",
          "updatedAt": "2024-01-22T20:17:39Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5tf2d5",
          "commit": {
            "abbreviatedOid": "7029bc9"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Looks fine . Have one comment though",
          "createdAt": "2024-01-22T18:09:12Z",
          "updatedAt": "2024-01-22T18:14:21Z",
          "comments": [
            {
              "originalPosition": 116,
              "body": "i think we need to preserve the fact that this is preferred as datagram when we put it in a stream . Wonder where should that go ? \r\n\r\nShould we extend OBJECT_STREAM message with a bool saying \"preferred_datagram\". This is needed for receviers handling and forwarding ",
              "createdAt": "2024-01-22T18:09:12Z",
              "updatedAt": "2024-01-22T18:14:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5tf5_2",
          "commit": {
            "abbreviatedOid": "7029bc9"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-22T18:18:20Z",
          "updatedAt": "2024-01-22T18:18:20Z",
          "comments": [
            {
              "originalPosition": 116,
              "body": "this can be added in a separate PR too",
              "createdAt": "2024-01-22T18:18:20Z",
              "updatedAt": "2024-01-22T18:18:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5tf7Nb",
          "commit": {
            "abbreviatedOid": "7029bc9"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-22T18:21:35Z",
          "updatedAt": "2024-01-22T18:21:35Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5tf8Pe",
          "commit": {
            "abbreviatedOid": "7029bc9"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Individual Review: \r\n\r\nThere was some feedback on previous iterations about this PR lacking guidance when encountering flow control limits (eg: send as datagram, relay converts to stream, but is out of streams or flow control)",
          "createdAt": "2024-01-22T18:24:16Z",
          "updatedAt": "2024-01-22T18:26:19Z",
          "comments": [
            {
              "originalPosition": 116,
              "body": "Preserving the preference was the intent.  When datagram is sent on a stream, it starts with OBJECT_PREFER_DATAGRAM (0x1) to communicate this.",
              "createdAt": "2024-01-22T18:24:16Z",
              "updatedAt": "2024-01-22T18:26:19Z"
            },
            {
              "originalPosition": 107,
              "body": "s/first/only/  based on a comment in 342.",
              "createdAt": "2024-01-22T18:24:56Z",
              "updatedAt": "2024-01-22T18:26:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5tgr6r",
          "commit": {
            "abbreviatedOid": "7029bc9"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-22T20:16:22Z",
          "updatedAt": "2024-01-22T20:16:22Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "```suggestion\r\nbe the only message on a unidirectional stream.\r\n```",
              "createdAt": "2024-01-22T20:16:22Z",
              "updatedAt": "2024-01-22T20:16:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5tgsCN",
          "commit": {
            "abbreviatedOid": "7029bc9"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Whoa, I've missed some PRs, but LGTM",
          "createdAt": "2024-01-22T20:16:39Z",
          "updatedAt": "2024-01-22T20:16:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 352,
      "id": "PR_kwDOG2Ho4M5lmZxN",
      "title": "Restore number of parameters in SUBSCRIBE",
      "url": "https://github.com/moq-wg/moq-transport/pull/352",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #349 ",
      "createdAt": "2024-01-31T17:43:06Z",
      "updatedAt": "2024-02-08T19:02:45Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "d97485d4fb39d1f1fc0e88b7291dd14c36ebe836",
      "headRepository": "martinduke/moq-transport",
      "headRefName": "num-params",
      "headRefOid": "343eb727f5533e3085dad12de56e7148491c3fdf",
      "closedAt": "2024-02-08T19:02:45Z",
      "mergedAt": "2024-02-08T19:02:45Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "527831ac01b5a8ab47b9a58e76659ae50547abf5"
      },
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think that's right. I can argue by example: the format (..) ... does not have \"number of things\" prepended without explicity stating so in the spec.\r\n\r\nx (L) ...:\r\nIndicates that x is repeated zero or more times and that each instance has a length of L\r\n\r\nGiven that definition, I read x (..) ... as it is repeated zero or more time, and the length of each is variable. It says nothing about the explicitly writing the number of actions.",
          "createdAt": "2024-02-01T15:49:51Z",
          "updatedAt": "2024-02-01T15:49:51Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "NONE",
          "body": "I think Martin is correct, but I also find it a little confusing because section 1.3 of MOQT adds the notation x (b) for binary data, which really includes a length field followed by that many bytes. But that is currently only defined for binary data. This also recently changed for the new OBJECT messages. They used to have Object Payload (b) but now they are defined as Object Payload (...) with the length explicitly defined as Object Payload Length (i). Tracknames etc. still use the x(b) notation.\r\n\r\nMaybe it would be good to be consistent on all of these. We could remove x(b) or use something similar for binary fields and parameters.",
          "createdAt": "2024-02-01T16:19:46Z",
          "updatedAt": "2024-02-01T16:20:39Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK ... look at the high level, we all agree we need the count on the wire, we are only poking at the arcane syntax to represent that and it is clearly not clear. So lets go with this PR as is but would people be OK if moved all the syntax to ABNF. I think that would be far more clear, is widely used in ietf docs, and I think would work out much better for implementers. I'm happy to use any other well defined things instead but I'm not keep on using something where none of us are sure and I know developers are confuse. ",
          "createdAt": "2024-02-01T19:15:19Z",
          "updatedAt": "2024-02-01T19:15:19Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Dug into it and 100% agree with this PR. Sorry it took a bit to get there. Deleting other comments so as not to cause confusion later. ",
          "createdAt": "2024-02-04T21:49:37Z",
          "updatedAt": "2024-02-04T21:49:37Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5ujGB3",
          "commit": {
            "abbreviatedOid": "343eb72"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-31T19:45:41Z",
          "updatedAt": "2024-01-31T19:45:41Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5ujOHs",
          "commit": {
            "abbreviatedOid": "343eb72"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-31T20:03:48Z",
          "updatedAt": "2024-01-31T20:03:48Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5uqNxu",
          "commit": {
            "abbreviatedOid": "343eb72"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I don't think this is right but I could be wrong. I never fully understand the syntax from RFC 9000 because it is very confusing and I don't think we should use it because of that but .... \r\n\r\nMy understanding of the syntax of  \r\n```\r\nx (L) ... \r\n```\r\nis that will encode on the wire the number of things of size L in x.  See section 1.3 of RFC 9000. \r\n\r\nClearly we need the number of things in this but we don't need it twice.  Am I missing the boat on this ? I'm sure Martin knows this stuff better than me.\r\n",
          "createdAt": "2024-02-01T13:56:12Z",
          "updatedAt": "2024-02-01T13:56:12Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5utVvF",
          "commit": {
            "abbreviatedOid": "343eb72"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-01T19:15:49Z",
          "updatedAt": "2024-02-01T19:15:49Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5vhbtt",
          "commit": {
            "abbreviatedOid": "343eb72"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-08T19:02:39Z",
          "updatedAt": "2024-02-08T19:02:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 354,
      "id": "PR_kwDOG2Ho4M5l9UDe",
      "title": "clean up details on binary encoding syntax",
      "url": "https://github.com/moq-wg/moq-transport/pull/354",
      "state": "MERGED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR cleans up some nits to make all the places we use the RFC9000 encoding syntax valid, updates our extensions to it, and add a non normative summary of parts of the syntax we use. \r\n\r\nI don't think this is making any changes to anything on the wire or normative changes to spec other than the statement SHOULD use smallest number of bytes for variable length integers which RFC9000 only requires for some fields. \r\n\r\n",
      "createdAt": "2024-02-04T21:42:04Z",
      "updatedAt": "2024-02-18T21:41:55Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "fc6a102eced02955bcae4ce9107559f5393de38f",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "encoding1",
      "headRefOid": "ef2b6260892d123d2a54e64bf8e481f2f937c5d3",
      "closedAt": "2024-02-18T21:41:55Z",
      "mergedAt": "2024-02-18T21:41:55Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "e0a52442219909393933a9c4f4518c697034ac8c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5u9Wp5",
          "commit": {
            "abbreviatedOid": "fbe690f"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-04T21:46:54Z",
          "updatedAt": "2024-02-04T21:46:54Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "The above sentence is the only part of this PR that seems non editorial to me. If I should put it in a separate PR, glad to do that ... ",
              "createdAt": "2024-02-04T21:46:54Z",
              "updatedAt": "2024-02-04T21:46:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5u9ZkU",
          "commit": {
            "abbreviatedOid": "e8f6b29"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I am not in love with the ABNF idea, but this is non-controversial.",
          "createdAt": "2024-02-04T22:20:53Z",
          "updatedAt": "2024-02-18T21:23:26Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5u-vKn",
          "commit": {
            "abbreviatedOid": "e8f6b29"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-05T05:58:54Z",
          "updatedAt": "2024-02-18T21:23:26Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5u-7lf",
          "commit": {
            "abbreviatedOid": "e8f6b29"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-05T06:50:16Z",
          "updatedAt": "2024-02-18T21:23:26Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5vRGLh",
          "commit": {
            "abbreviatedOid": "fbe690f"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-07T02:11:06Z",
          "updatedAt": "2024-02-07T02:12:41Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "`RECOMMENDED` maybe, but I would just remove this sentence IMO.\r\n\r\nI actually used a 2-byte varint for packet sizes in QUIC so I could avoid a copy once the final size is known. I imagine you could do something similar in MoQ, or use larger varints to make rewriting OBJECT headers easier.\r\n\r\nEither way we can't say MUST and I'm not sure what we gain with a SHOULD. A decoder has to be prepared for anything.",
              "createdAt": "2024-02-07T02:11:06Z",
              "updatedAt": "2024-02-07T02:12:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5vRRkt",
          "commit": {
            "abbreviatedOid": "fbe690f"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-07T02:48:06Z",
          "updatedAt": "2024-02-07T02:48:06Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Consider an RFC 6919 \"OUGHT TO\" https://datatracker.ietf.org/doc/html/rfc6919#section-4",
              "createdAt": "2024-02-07T02:48:06Z",
              "updatedAt": "2024-02-07T02:48:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5wGi8o",
          "commit": {
            "abbreviatedOid": "fbe690f"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-14T16:36:26Z",
          "updatedAt": "2024-02-14T16:36:26Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Agree that is a real change and happy to refactor it into a separate PR. ",
              "createdAt": "2024-02-14T16:36:26Z",
              "updatedAt": "2024-02-14T16:36:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5wGvCJ",
          "commit": {
            "abbreviatedOid": "90012aa"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-14T16:59:45Z",
          "updatedAt": "2024-02-14T16:59:45Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "OK - updated this. I will note that from https://datatracker.ietf.org/doc/html/rfc2119#section-3 SHOULD just means \"RECOMMENDED\" not \"REQUIRED\"",
              "createdAt": "2024-02-14T16:59:45Z",
              "updatedAt": "2024-02-14T16:59:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5wGyJD",
          "commit": {
            "abbreviatedOid": "fbe690f"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-14T17:05:12Z",
          "updatedAt": "2024-02-14T17:05:12Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "> OK - updated this. I will note that from https://datatracker.ietf.org/doc/html/rfc2119#section-3 SHOULD just means \"RECOMMENDED\" not \"REQUIRED\"\r\n\r\nAh okay I missed that memo. ",
              "createdAt": "2024-02-14T17:05:12Z",
              "updatedAt": "2024-02-14T17:05:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5wHJCR",
          "commit": {
            "abbreviatedOid": "e8f6b29"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-14T17:55:01Z",
          "updatedAt": "2024-02-18T21:23:26Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5wfmei",
          "commit": {
            "abbreviatedOid": "415dffc"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-18T21:33:50Z",
          "updatedAt": "2024-02-18T21:33:50Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "I find this forward reference a bit odd, and it's only used for one frame, which is likely to change soon, so I'm going to remove it to avoid it becoming out of sync.",
              "createdAt": "2024-02-18T21:33:50Z",
              "updatedAt": "2024-02-18T21:33:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5wfmgQ",
          "commit": {
            "abbreviatedOid": "13a5cda"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-18T21:34:49Z",
          "updatedAt": "2024-02-18T21:34:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 360,
      "id": "PR_kwDOG2Ho4M5mTyKY",
      "title": "Make Datagram mode as REQUIRED",
      "url": "https://github.com/moq-wg/moq-transport/pull/360",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #359 ",
      "createdAt": "2024-02-07T21:17:55Z",
      "updatedAt": "2024-02-21T17:19:15Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "0edb987f6bddf4b7f0d62a626d174a23bb229458",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "datagram",
      "headRefOid": "222dac9cdf834bff185c4094269ba8f86c00ee1f",
      "closedAt": "2024-02-21T17:19:15Z",
      "mergedAt": "2024-02-21T17:19:14Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "2941044ffc2d58998c9abff9fc28c2ccbd57473d"
      },
      "comments": [
        {
          "author": "kixcord",
          "authorAssociation": "NONE",
          "body": "We should have some text on what to do if the datagram extension is not negotiated.",
          "createdAt": "2024-02-14T18:05:41Z",
          "updatedAt": "2024-02-14T18:05:41Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "> We should have some text on what to do if the datagram extension is not negotiated.\r\n\r\nDo you want a behavior other than \"all datagrams will be dropped\"?  We could have the publisher reply with SUBSCRIBE ERROR.\r\n",
          "createdAt": "2024-02-14T19:00:52Z",
          "updatedAt": "2024-02-14T19:00:52Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "Datagram is object preference like the other one. I don't understand the meaning of not being negotiated. The same rule applies to all the object preferences and if we want to say something then it might be more beneficial to indicate that in a general section for object preferences. ",
          "createdAt": "2024-02-15T04:21:37Z",
          "updatedAt": "2024-02-15T04:22:37Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "> I don't understand the meaning of not being negotiated.\r\n\r\nI think Luke meant if the QUIC Datagram extension is not negotiated.  I believe it's required for WebTransport, but for raw QUIC the peer may not advertise support.  We could also require it for MoQ also just simply fail the entire MoQ connection without datagrams.",
          "createdAt": "2024-02-15T16:12:54Z",
          "updatedAt": "2024-02-15T16:12:54Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> > I don't understand the meaning of not being negotiated.\r\n> \r\n> I think Luke meant if the QUIC Datagram extension is not negotiated. I believe it's required for WebTransport, but for raw QUIC the peer may not advertise support. We could also require it for MoQ also just simply fail the entire MoQ connection without datagrams.\r\n\r\nAh thanks for the clarification.  Makes sense , but I also wonder if that would be in its own PR as it is not specific to object preference. Thoughts ?",
          "createdAt": "2024-02-15T17:41:55Z",
          "updatedAt": "2024-02-15T17:41:55Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> > > I don't understand the meaning of not being negotiated.\r\n> > \r\n> > \r\n> > I think Luke meant if the QUIC Datagram extension is not negotiated. I believe it's required for WebTransport, but for raw QUIC the peer may not advertise support. We could also require it for MoQ also just simply fail the entire MoQ connection without datagrams.\r\n> \r\n> Ah thanks for the clarification. Makes sense , but I also wonder if that would be in its own PR as it is not specific to object preference. Thoughts ?\r\n\r\nI think we should make the datagram extension required as part of this PR.\r\n\r\nThe PREFER_DATAGRAM message over streams was a fallback when datagrams are not supported. By removing that fallback, we're in a state where servers and clients might silently drop all datagrams which is no bueno.\r\n\r\n@ianswett we should have a section in connection establishment section that requires datagram support.",
          "createdAt": "2024-02-15T17:49:48Z",
          "updatedAt": "2024-02-15T17:49:48Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Here's the text from WebTransport if we want to copy it:\r\n\r\n```\r\nWebTransport over HTTP/3 also requires support for QUIC datagrams. To indicate support, both the client and the server MUST send a max_datagram_frame_size transport parameter with a value greater than 0 (see Section 3 of [QUIC-DATAGRAM]).\r\n```",
          "createdAt": "2024-02-15T18:24:13Z",
          "updatedAt": "2024-02-15T18:24:13Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I wrote #384 to require DATAGRAM support when using QUIC directly.",
          "createdAt": "2024-02-18T21:51:36Z",
          "updatedAt": "2024-02-18T21:51:36Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5wHHIc",
          "commit": {
            "abbreviatedOid": "ec7537f"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2024-02-14T17:50:59Z",
          "updatedAt": "2024-02-14T17:50:59Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5w4roh",
          "commit": {
            "abbreviatedOid": "4568128"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-21T17:17:05Z",
          "updatedAt": "2024-02-21T17:17:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 366,
      "id": "PR_kwDOG2Ho4M5mV2Y9",
      "title": "Changes Subscription ID to Subscribe ID",
      "url": "https://github.com/moq-wg/moq-transport/pull/366",
      "state": "MERGED",
      "author": "zafergurel",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR fixes #365.",
      "createdAt": "2024-02-08T07:31:01Z",
      "updatedAt": "2024-02-08T18:54:11Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "d97485d4fb39d1f1fc0e88b7291dd14c36ebe836",
      "headRepository": "zafergurel/moq-transport",
      "headRefName": "main",
      "headRefOid": "64ec57ee1419b7b082e681d00d12ac7d1bee4133",
      "closedAt": "2024-02-08T18:54:11Z",
      "mergedAt": "2024-02-08T18:54:11Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "91502859ed5aab9a0eb57b24ef7016f4f5ed4a0d"
      },
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the fix!",
          "createdAt": "2024-02-08T18:52:44Z",
          "updatedAt": "2024-02-08T18:52:44Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5vhVGS",
          "commit": {
            "abbreviatedOid": "64ec57e"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-08T18:52:24Z",
          "updatedAt": "2024-02-08T18:52:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 367,
      "id": "PR_kwDOG2Ho4M5mV36a",
      "title": "Cleans up SUBSCRIBE_OK text",
      "url": "https://github.com/moq-wg/moq-transport/pull/367",
      "state": "MERGED",
      "author": "zafergurel",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR fixes #364.",
      "createdAt": "2024-02-08T07:36:55Z",
      "updatedAt": "2024-02-08T19:00:19Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "91502859ed5aab9a0eb57b24ef7016f4f5ed4a0d",
      "headRepository": "zafergurel/moq-transport",
      "headRefName": "fix-subscribe-ok-text",
      "headRefOid": "a089a7245914f6eb80fcc9755fe26ab40eaaa094",
      "closedAt": "2024-02-08T19:00:19Z",
      "mergedAt": "2024-02-08T19:00:19Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "e6df31467094692dcf5268d1f016cae84c90c01b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5vhYAL",
          "commit": {
            "abbreviatedOid": "f769af7"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks for the cleanup!",
          "createdAt": "2024-02-08T18:55:17Z",
          "updatedAt": "2024-02-08T18:55:17Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5vhaxE",
          "commit": {
            "abbreviatedOid": "a089a72"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-08T19:00:13Z",
          "updatedAt": "2024-02-08T19:00:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 375,
      "id": "PR_kwDOG2Ho4M5mgpdA",
      "title": "One forwarding preference per track",
      "url": "https://github.com/moq-wg/moq-transport/pull/375",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #351.\r\n\r\nThere could stand to be (1) a section on a subscriptions, and (2) rearranging the sections here to pull objects out of the message section. But I think it would be easier to review if cut-and-paste happens in a separate PR.\r\n\r\nThere are other issues (e.g. explicit payload length all the time) that are not addressed in this PR.",
      "createdAt": "2024-02-09T18:43:16Z",
      "updatedAt": "2024-02-18T20:28:54Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "59a2a3a9a060bf1a78e191ee9b266211654eeb3f",
      "headRepository": "martinduke/moq-transport",
      "headRefName": "fwd-pref",
      "headRefOid": "59bd823511c640a5cc25870f8944a390dbd43317",
      "closedAt": "2024-02-18T20:28:54Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's subscription-level rather than track-level because\r\n\r\n(1) the only convenient place to communicate forwarding preference is SUBSCRIBE_OK\r\n(2) as it currently stands, objects are sent once per subscription\r\n(3) I am not a Use Case Haver, but I can see that an archival subscribe might want a single track stream while the live edge probably would not, even for the same track.",
          "createdAt": "2024-02-09T18:51:02Z",
          "updatedAt": "2024-02-09T18:51:02Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@suhasHere yes, see the comment immediately before your question. If this is really objectionable, we can change it, but it would require an error condition check if two SUBSCRIBE_OKs had different preferences for the same track_alias.\r\n\r\nI have no strong opinion on this, but this is way easier. When I write a server, it will probably always use one preference for a track.\r\n\r\nIf we change objects to be sent once per track, instead of once per subscription, this would have to change.",
          "createdAt": "2024-02-10T01:26:36Z",
          "updatedAt": "2024-02-10T01:26:36Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "I expect this will be a straightforward PR once we figure out the FETCH/SUBSCRIBE work, but in the meantime it's caught up in #350",
          "createdAt": "2024-02-11T02:49:00Z",
          "updatedAt": "2024-02-11T02:49:00Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No one seemed to like subscription scope, so I changed it.\r\n\r\nI think we can merge this before the FETCH/SUBSCRIBE stuff. The bulk of the changes are in the Object message.",
          "createdAt": "2024-02-12T16:50:31Z",
          "updatedAt": "2024-02-12T16:50:31Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "> Frankly, I don't even want the relay to know about forwarding preference. It should just receive a stream, apply the subscription as a filter, send the stream. The stream headers are only meant to remove redundant encoding.\r\n\r\nChair Comment:\r\n\r\nThe WG agreed to have an explicit encoding of the forwarding preference for now and revisit that based on experimental data at a later date.  The current signal serves dual purpose with object property compression.\r\n\r\nIndividual Comment:\r\n\r\nThe publisher should be able to communicate immutable Track properties in Subscribe OK without those being properties of the Subscribe.  Using HTTP as an example, response headers contain immutable properties of the requested resource (Content-Length) and variable properties (Date, Server).",
          "createdAt": "2024-02-12T22:00:41Z",
          "updatedAt": "2024-02-12T22:00:41Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> The publisher should be able to communicate immutable Track properties in Subscribe OK without those being properties of the Subscribe. Using HTTP as an example, response headers contain immutable properties of the requested resource (Content-Length) and variable properties (Date, Server).\r\n\r\n\r\nThere are 3  kinds of information that would be good to learn and we need to separate architectural constraints for the same\r\n\r\n\r\n- Static track level properties like track info, preferences that the end-point subscriber needs to know about -> this can go in catalog and hence served over control plane/slow path.\r\n\r\n- Dynamic properties reflecting the current state of objects like live/expiry edge, last object/group info --> this would be best served on data plane/fast path along with data. \r\n\r\n- Data that relay doesn't usually have access to but it needs to make decision on per object basis. this includes  object properties like priority, its preferences, alias (some of which can be inherited from track level settings and set by the original producer endpoint when publishing) --> this would be best served on the fast path as well.\r\n",
          "createdAt": "2024-02-13T03:28:21Z",
          "updatedAt": "2024-02-13T04:44:45Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "After discussion at today's meeting, the conclusion was that we'd like to do the minimal change of saying you can't have different forwarding preferences for a given track and if a subscriber receives different ones, close the session with an error.",
          "createdAt": "2024-02-14T17:30:44Z",
          "updatedAt": "2024-02-14T17:30:44Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5vqNDS",
          "commit": {
            "abbreviatedOid": "199c116"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "This changes the direction of the original intent with the forwarding preference. Originally it was one preferred producer's intent that applies uniformly to all the subscribers. With the current proposal, it seems like it can vary across subscribers IIUC.\r\n\r\nAm i understanding the proposal properly ? ",
          "createdAt": "2024-02-09T23:41:25Z",
          "updatedAt": "2024-02-09T23:41:25Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5vtxrM",
          "commit": {
            "abbreviatedOid": "199c116"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Lets talk about this but I don't think this reflect what was said in the meeting and I don't think it will work. We said we could move to one forwarding preference per track, not per subscription. \r\n\r\nAs this is not, I a very much against merging it. ",
          "createdAt": "2024-02-10T22:23:13Z",
          "updatedAt": "2024-02-10T22:23:13Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5vzgop",
          "commit": {
            "abbreviatedOid": "06866fa"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-12T17:15:01Z",
          "updatedAt": "2024-02-12T17:15:01Z",
          "comments": [
            {
              "originalPosition": 294,
              "body": "i personally feel that all the track level information can be learnt from catalog.  I wonder if we should have anything in Subscribe OK ?",
              "createdAt": "2024-02-12T17:15:01Z",
              "updatedAt": "2024-02-12T17:15:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5vzlyx",
          "commit": {
            "abbreviatedOid": "06866fa"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-12T17:25:48Z",
          "updatedAt": "2024-02-12T17:25:48Z",
          "comments": [
            {
              "originalPosition": 294,
              "body": "But relays need to know the forwarding preference and they can't read the catalog, so SUBSCRIBE_OK is a good location to carry subscription-scoped metadata. ",
              "createdAt": "2024-02-12T17:25:48Z",
              "updatedAt": "2024-02-12T17:25:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5vzpDR",
          "commit": {
            "abbreviatedOid": "06866fa"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-12T17:33:05Z",
          "updatedAt": "2024-02-12T17:33:05Z",
          "comments": [
            {
              "originalPosition": 294,
              "body": "Our encoding (object_stream, datagram, stream_header_group, stream_header_track)  has all the necessary information to know the object forwarding preference. The data plane/fast path has the needed information for relays to make necessary mapping. I am not sure if we need to replicate the same info in the control path.\r\n\r\nmy implementation, for example, uses that info and sets up the needed forwarding preference today and it does at the data plane.",
              "createdAt": "2024-02-12T17:33:05Z",
              "updatedAt": "2024-02-12T17:35:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5vzu0R",
          "commit": {
            "abbreviatedOid": "06866fa"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-12T17:46:48Z",
          "updatedAt": "2024-02-12T17:46:48Z",
          "comments": [
            {
              "originalPosition": 294,
              "body": "The PR eliminates that encoding to save a byte on objects, since it's extraneous.",
              "createdAt": "2024-02-12T17:46:48Z",
              "updatedAt": "2024-02-12T17:46:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5vzu16",
          "commit": {
            "abbreviatedOid": "06866fa"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I think we just need some text to say it's a protocol violation (connection closed) if you do dumb like have two streams cover the same object/group/track twice. This PR prevents some instances of that, but at the cost of making decoding more annoying.\r\n\r\nFrankly, I don't even want the relay to know about forwarding preference. It should just receive a stream, apply the subscription as a filter, send the stream. The stream headers are only meant to remove redundant encoding. ",
          "createdAt": "2024-02-12T17:46:49Z",
          "updatedAt": "2024-02-12T17:47:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 376,
      "id": "PR_kwDOG2Ho4M5mkY3w",
      "title": "Objects are identical",
      "url": "https://github.com/moq-wg/moq-transport/pull/376",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Regardless of where they're retrieved from and over time.\r\n\r\nFixes #361",
      "createdAt": "2024-02-11T03:09:32Z",
      "updatedAt": "2024-02-18T21:02:13Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "2af4e44a941bc5e1fe37922f52afa6ef679bf519",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ianswett-identical-objects",
      "headRefOid": "9f09b0068a0df6181ec61e5b12ed698f55089d51",
      "closedAt": "2024-02-18T21:02:13Z",
      "mergedAt": "2024-02-18T21:02:13Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "2d83972885a5b2f0b1dfb0aec6af20dd9aa6423f"
      },
      "comments": [
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I put a two very small nit comments but don't care either way. They do not change the substance of the PR and +1 on the overall thing this is saying. \r\n",
          "createdAt": "2024-02-11T15:34:49Z",
          "updatedAt": "2024-02-11T15:34:49Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5vuOOQ",
          "commit": {
            "abbreviatedOid": "11741ac"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-11T15:21:25Z",
          "updatedAt": "2024-02-11T15:21:25Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5vuOlV",
          "commit": {
            "abbreviatedOid": "11741ac"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2024-02-11T15:30:49Z",
          "updatedAt": "2024-02-11T15:32:43Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "perhaps \"track namespace\" and \"track name\". \r\n\r\n",
              "createdAt": "2024-02-11T15:30:49Z",
              "updatedAt": "2024-02-11T15:32:43Z"
            },
            {
              "originalPosition": 8,
              "body": "So if it has expired, or gets an error, you don't get the bytes. I wonder if it is better to say something more like they contents of an object can never be changed and if it is retried, will always have the same bit wise exact data in it. ",
              "createdAt": "2024-02-11T15:32:39Z",
              "updatedAt": "2024-02-11T15:32:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5wfkgm",
          "commit": {
            "abbreviatedOid": "11741ac"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-18T21:00:27Z",
          "updatedAt": "2024-02-18T21:00:27Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I tried to capture the idea that it doesn't change over time, but I couldn't figure out a good rephrase for the rest, so I left it as is for now.  Feel free to write an editorial PR to improve the text after it is merged if you'd like.",
              "createdAt": "2024-02-18T21:00:27Z",
              "updatedAt": "2024-02-18T21:00:27Z"
            }
          ]
        }
      ]
    },
    {
      "number": 381,
      "id": "PR_kwDOG2Ho4M5nIUMO",
      "title": "Subscriber indicator on track readiness",
      "url": "https://github.com/moq-wg/moq-transport/pull/381",
      "state": "OPEN",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Attempts to address some of the usecases discussed in #372 \r\n\r\nLove to hear feedback",
      "createdAt": "2024-02-16T20:20:32Z",
      "updatedAt": "2024-02-28T00:02:39Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "d8e0951dbe8d1f8d0186e59c0afd5e26cc858925",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "warmup",
      "headRefOid": "d2bd96883d20f559cd0df7acd376d87e94cd60bf",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> A small nit, in calling , park and pickup are commonly used to mean something different than this that has to do with moving media from one device to another so I would prefer a name other than park. That said, I can live with park and I think we should merge this.\r\n\r\nUpdated to rename park to freeze.",
          "createdAt": "2024-02-24T06:39:38Z",
          "updatedAt": "2024-02-24T06:39:38Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "TBH, I'm still not convinced we need this.  I feel like it's a fix for a problem we may have in the future, but we're unsure, because we haven't resolved a number of other details about how priorities, unreliability, etc work.",
          "createdAt": "2024-02-28T00:02:37Z",
          "updatedAt": "2024-02-28T00:02:37Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5wawe_",
          "commit": {
            "abbreviatedOid": "6bb3be2"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-16T21:30:42Z",
          "updatedAt": "2024-02-16T21:30:42Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Individual Comment:\r\n\r\nHow do you unpark?  Do you send another subscribe with `Ready`, or maybe you were thinking subscribe update would allow you to do that?  Can a subscriber go from Ready back to Parked?",
              "createdAt": "2024-02-16T21:30:42Z",
              "updatedAt": "2024-02-16T21:30:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5wb2gl",
          "commit": {
            "abbreviatedOid": "6bb3be2"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-17T03:17:53Z",
          "updatedAt": "2024-02-17T03:17:53Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Sending subscribe with same subscribe_id is used to update an existing subscription. Yes it is possible to move between park and ready states multiple times. There is some text on this in the DeliveryPreference explanation under Subscribe message in this PR which I think should address the above questions IIRC.",
              "createdAt": "2024-02-17T03:17:53Z",
              "updatedAt": "2024-02-17T03:19:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5w4tcZ",
          "commit": {
            "abbreviatedOid": "6bb3be2"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-21T17:19:12Z",
          "updatedAt": "2024-02-21T17:19:12Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "For what it is worth, I prefer calling these frozen instead of parked but I don't care much ",
              "createdAt": "2024-02-21T17:19:12Z",
              "updatedAt": "2024-02-21T17:19:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5w8FNF",
          "commit": {
            "abbreviatedOid": "6bb3be2"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This approach is reasonable, but I dunno I'd rather punt pre-warming. It's an optional, pre-mature optimization that I don't imagine anyone will implement (on either side).",
          "createdAt": "2024-02-22T03:39:47Z",
          "updatedAt": "2024-02-22T03:39:47Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5w_AK0",
          "commit": {
            "abbreviatedOid": "6bb3be2"
          },
          "author": "zafergurel",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-22T11:04:49Z",
          "updatedAt": "2024-02-22T11:04:50Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "What would be the response of the relay if DeliveryPreference is `Park` in the Subscribe message and relay does not support/prefer parking?",
              "createdAt": "2024-02-22T11:04:50Z",
              "updatedAt": "2024-02-22T11:04:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5xLGwB",
          "commit": {
            "abbreviatedOid": "6bb3be2"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-23T18:50:07Z",
          "updatedAt": "2024-02-23T18:50:07Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "The relay returns Subscribe Error in that case",
              "createdAt": "2024-02-23T18:50:07Z",
              "updatedAt": "2024-02-23T18:50:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5xMcZa",
          "commit": {
            "abbreviatedOid": "6bb3be2"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-23T23:25:33Z",
          "updatedAt": "2024-02-23T23:25:34Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I don't think this should be something that is optional for Relays. ",
              "createdAt": "2024-02-23T23:25:33Z",
              "updatedAt": "2024-02-23T23:25:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5xMcrB",
          "commit": {
            "abbreviatedOid": "6bb3be2"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "A small nit, in calling , park and pickup are commonly used to mean something different than this that has to do with moving media from one device to another so I would prefer a name other than park. That said, I can live with park and I think we should merge this. ",
          "createdAt": "2024-02-23T23:27:33Z",
          "updatedAt": "2024-02-23T23:27:33Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5xMxvF",
          "commit": {
            "abbreviatedOid": "d2bd968"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Individual Review",
          "createdAt": "2024-02-24T02:20:36Z",
          "updatedAt": "2024-02-25T16:08:59Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "nit: extra whitespace",
              "createdAt": "2024-02-25T16:00:33Z",
              "updatedAt": "2024-02-25T16:08:59Z"
            },
            {
              "originalPosition": 12,
              "body": "lowercase `may` - did you want MAY or something else?\r\n\r\nMy read of this text is that it's ok for a relay to send a subscribe OK and not issue an upstream subscription, or issue an upstream subscription with pref=Freeze.  Is that your intent?",
              "createdAt": "2024-02-25T16:00:53Z",
              "updatedAt": "2024-02-25T16:08:59Z"
            },
            {
              "originalPosition": 21,
              "body": "nit: extra newline?",
              "createdAt": "2024-02-25T16:01:38Z",
              "updatedAt": "2024-02-25T16:08:59Z"
            },
            {
              "originalPosition": 40,
              "body": "I'm a little uneasy about defining the semantics of subscribe update in this PR, which has a quite different thesis, and also without explaining the implications of changing location preferences.  If others are ok to do that in a follow up I can be convinced.",
              "createdAt": "2024-02-25T16:03:03Z",
              "updatedAt": "2024-02-25T16:08:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5xPtB1",
          "commit": {
            "abbreviatedOid": "d2bd968"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-26T04:37:36Z",
          "updatedAt": "2024-02-26T04:37:37Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "This part is defining subscirbe update in the context of DeliveryPreference. I think we should add text to define the same in terms of location too. I do see these coming in 2 different PRs thouhg.",
              "createdAt": "2024-02-26T04:37:36Z",
              "updatedAt": "2024-02-26T04:37:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5xPtO7",
          "commit": {
            "abbreviatedOid": "d2bd968"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-26T04:38:57Z",
          "updatedAt": "2024-02-26T04:38:57Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Since every hop is a new subscription, Relays can make either of the choices.  In that context, your interpretation is correct.",
              "createdAt": "2024-02-26T04:38:57Z",
              "updatedAt": "2024-02-26T04:38:57Z"
            }
          ]
        }
      ]
    },
    {
      "number": 382,
      "id": "PR_kwDOG2Ho4M5nMymi",
      "title": "Forwarding preference can't change for a track",
      "url": "https://github.com/moq-wg/moq-transport/pull/382",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #351 \r\n\r\nCloses #375",
      "createdAt": "2024-02-18T00:53:19Z",
      "updatedAt": "2024-02-19T00:02:54Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "59a2a3a9a060bf1a78e191ee9b266211654eeb3f",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ianswett-single-forwarding-preference",
      "headRefOid": "d1c3a238e3917e12e2305ea355b99dc1952ab7ca",
      "closedAt": "2024-02-18T20:28:53Z",
      "mergedAt": "2024-02-18T20:28:53Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "2af4e44a941bc5e1fe37922f52afa6ef679bf519"
      },
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> This is an improvement, though I would still like to get rid of all the wasted bits\r\n\r\nThey won't be wasted until we have 64 message types valid on unidirectional streams. We currently only have 3 valid messages types.\r\n\r\nI think you mean that we could save the message type byte if OBJECT is the only message allowed on unidirectional streams, but that's not forward-compatible.",
          "createdAt": "2024-02-19T00:02:13Z",
          "updatedAt": "2024-02-19T00:02:54Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5wesd-",
          "commit": {
            "abbreviatedOid": "9101d31"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-18T06:07:11Z",
          "updatedAt": "2024-02-18T06:07:11Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5wetls",
          "commit": {
            "abbreviatedOid": "9101d31"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-18T06:54:48Z",
          "updatedAt": "2024-02-18T06:54:49Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "type on prefernces",
              "createdAt": "2024-02-18T06:54:48Z",
              "updatedAt": "2024-02-18T06:54:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5wfeyA",
          "commit": {
            "abbreviatedOid": "9101d31"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "This is an improvement, though I would still like to get rid of all the wasted bits",
          "createdAt": "2024-02-18T18:12:19Z",
          "updatedAt": "2024-02-18T18:12:19Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5wfivu",
          "commit": {
            "abbreviatedOid": "9101d31"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-18T20:05:24Z",
          "updatedAt": "2024-02-18T20:05:24Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5wfjV4",
          "commit": {
            "abbreviatedOid": "9101d31"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-18T20:24:00Z",
          "updatedAt": "2024-02-18T20:24:01Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nIf a subscriber receives different forwarding preferences for a track, it\r\n```",
              "createdAt": "2024-02-18T20:24:00Z",
              "updatedAt": "2024-02-18T20:24:01Z"
            }
          ]
        }
      ]
    },
    {
      "number": 383,
      "id": "PR_kwDOG2Ho4M5nMyz4",
      "title": "Remove 'Generic Error'",
      "url": "https://github.com/moq-wg/moq-transport/pull/383",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "'Generic Error' is never used in the draft and given \"Protocol Violation\" is also available, I don't think it's useful.\r\n\r\nI didn't renumber the error codes, but I could.",
      "createdAt": "2024-02-18T00:58:06Z",
      "updatedAt": "2024-02-21T04:16:31Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "59a2a3a9a060bf1a78e191ee9b266211654eeb3f",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ianswett-generic-error",
      "headRefOid": "47da7a904cf1c676708bf4e680190b8aaa7cef7f",
      "closedAt": "2024-02-21T04:16:31Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "We use this quite a bit in our code similar to how we use \"internal error\" in QUIC.  Maybe rename it to just that?  We definitely need some kind of \"syscall failed unexpectedly and now I just have to tear down your connection\" code.",
          "createdAt": "2024-02-18T20:17:43Z",
          "updatedAt": "2024-02-18T20:17:43Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks Victor, so is the intent that this is similar to a 500 in HTTP?  If so, renaming it to 'Internal Error' seems appropriate.",
          "createdAt": "2024-02-18T20:21:59Z",
          "updatedAt": "2024-02-18T20:21:59Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5wesfc",
          "commit": {
            "abbreviatedOid": "47da7a9"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-18T06:08:00Z",
          "updatedAt": "2024-02-18T06:08:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 384,
      "id": "PR_kwDOG2Ho4M5nOd8t",
      "title": "Require DATAGRAM support when using QUIC directly",
      "url": "https://github.com/moq-wg/moq-transport/pull/384",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From discussion on #360",
      "createdAt": "2024-02-18T21:49:59Z",
      "updatedAt": "2024-02-19T21:20:55Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "e0a52442219909393933a9c4f4518c697034ac8c",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ianswett-require-datagram",
      "headRefOid": "736ea1630eefa5abf1533cec735ce9ed65db7b64",
      "closedAt": "2024-02-19T21:20:55Z",
      "mergedAt": "2024-02-19T21:20:55Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "d05521bc7428754389a20f17f43a79be1bd1ddd7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5wftnP",
          "commit": {
            "abbreviatedOid": "8ba2a6a"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-18T23:35:07Z",
          "updatedAt": "2024-02-18T23:52:49Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "This phrase is a bit awkward since \"use of QUIC\" includes WebTransport. It's not immediately clear to the reader that WebTransport already requires support.\r\n\r\nI would say:\r\n> QUIC datagrams MUST be supported via the [QUIC-DATAGRAM] extension, which is already a requirement for WebTransport over HTTP/3.\r\n\r\nOr just say datagrams are required and punt the details, including the `max_dataframe_frame_size` parameter, to the QUIC section below. ",
              "createdAt": "2024-02-18T23:35:08Z",
              "updatedAt": "2024-02-18T23:52:49Z"
            },
            {
              "originalPosition": 11,
              "body": "Do we want a minimum/maximum size? QUIC can get away with negotiating the size but we can't really because of relays.\r\n\r\nI would have a datagram section with something like:\r\n\r\n> To facilitate relays, datagrams SHOULD NOT be larger than 1150 bytes and `max_datafram_frame_size` SHOULD be greater than 1150 bytes.\r\n\r\nI'm also just fine leaving it zero. Or punting this to its own issue.",
              "createdAt": "2024-02-18T23:50:02Z",
              "updatedAt": "2024-02-18T23:52:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5wlRb5",
          "commit": {
            "abbreviatedOid": "8ba2a6a"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-19T16:25:49Z",
          "updatedAt": "2024-02-19T16:25:50Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Good question, let's punt that to #360?",
              "createdAt": "2024-02-19T16:25:49Z",
              "updatedAt": "2024-02-19T16:25:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5wlRn0",
          "commit": {
            "abbreviatedOid": "8ba2a6a"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-19T16:26:17Z",
          "updatedAt": "2024-02-19T16:26:18Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Thanks, suggestion applied.",
              "createdAt": "2024-02-19T16:26:17Z",
              "updatedAt": "2024-02-19T16:26:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5wlSGe",
          "commit": {
            "abbreviatedOid": "23b8292"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-19T16:27:32Z",
          "updatedAt": "2024-02-19T16:27:33Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nconnection is established.  When using QUIC, QUIC datagrams MUST be\r\nsupported via the [QUIC-DATAGRAM] extension, which is already a\r\nrequirement for WebTransport over HTTP/3.\r\n```",
              "createdAt": "2024-02-19T16:27:33Z",
              "updatedAt": "2024-02-19T16:27:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5wlSOT",
          "commit": {
            "abbreviatedOid": "0f6f4ae"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-19T16:27:50Z",
          "updatedAt": "2024-02-19T16:27:50Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nconnection is established.  When using QUIC, datagrams MUST be\r\n```",
              "createdAt": "2024-02-19T16:27:50Z",
              "updatedAt": "2024-02-19T16:27:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5wlYyx",
          "commit": {
            "abbreviatedOid": "736ea16"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-19T16:38:34Z",
          "updatedAt": "2024-02-19T16:38:34Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5wl52t",
          "commit": {
            "abbreviatedOid": "736ea16"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-19T18:15:06Z",
          "updatedAt": "2024-02-19T18:15:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 385,
      "id": "PR_kwDOG2Ho4M5nUkw7",
      "title": "Add SUBSCRIBE_UPDATE",
      "url": "https://github.com/moq-wg/moq-transport/pull/385",
      "state": "OPEN",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Subscribe"
      ],
      "body": "Fixes #363, Fixes #269\r\n\r\nThis attempts to provide the minimum functionality I expect we'll need, regardless of how SUBSCRIBE is changed in the near future.",
      "createdAt": "2024-02-19T19:05:04Z",
      "updatedAt": "2024-03-04T02:57:49Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "06d9acf2564ca79fc3dcb78303f93047691c4b07",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ianswett-subscribe-update",
      "headRefOid": "7cefe686c995176d8278ec4f41c3fab3dae65a6c",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5wmHwU",
          "commit": {
            "abbreviatedOid": "c3d7e3e"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-19T19:12:56Z",
          "updatedAt": "2024-02-19T19:12:57Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "```suggestion\r\nA subscriber issues a `SUBSCRIBE_UPDATE` message to a publisher to request a\r\n```",
              "createdAt": "2024-02-19T19:12:57Z",
              "updatedAt": "2024-02-19T19:12:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5wmIPO",
          "commit": {
            "abbreviatedOid": "f02f39f"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-19T19:14:01Z",
          "updatedAt": "2024-02-19T19:14:01Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "```suggestion\r\nIf an update cannot be completed by the relay, it replies with a SUBSCRIBE_ERROR\r\n```",
              "createdAt": "2024-02-19T19:14:01Z",
              "updatedAt": "2024-02-19T19:14:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5wmOqF",
          "commit": {
            "abbreviatedOid": "cd92dba"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-19T19:37:58Z",
          "updatedAt": "2024-02-19T19:37:58Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "```suggestion\r\nA SUBSCRIBE_UPDATE MUST NOT fail if the specified EndGroup and EndObject are\r\nearlier than the current values.\r\n```",
              "createdAt": "2024-02-19T19:37:58Z",
              "updatedAt": "2024-02-19T19:37:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5wmOw4",
          "commit": {
            "abbreviatedOid": "83ee597"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-19T19:38:24Z",
          "updatedAt": "2024-02-19T19:38:24Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "```suggestion\r\nA SUBSCRIBE_UPDATE MUST NOT fail if the specified EndGroup and EndObject are\r\nearlier than the current values for the subscription.\r\n```",
              "createdAt": "2024-02-19T19:38:24Z",
              "updatedAt": "2024-02-19T19:38:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5wnx_x",
          "commit": {
            "abbreviatedOid": "6bb489e"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-20T04:26:36Z",
          "updatedAt": "2024-02-20T04:26:37Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "This needs to be optional and only set if the subscription needs to be ended.",
              "createdAt": "2024-02-20T04:26:37Z",
              "updatedAt": "2024-02-20T04:26:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5wnyST",
          "commit": {
            "abbreviatedOid": "6bb489e"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2024-02-20T04:28:23Z",
          "updatedAt": "2024-02-20T04:28:30Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I feel Unsubscribe makes more sense if one wants to end the subscription.\r\nWe don;t need a new message to update an existing subscription. A subscriber can update an existing subscription by sending `SUBSCRIBE` message with SubscribeId that matches an existing subscription ( as described in https://github.com/moq-wg/moq-transport/pull/381)",
              "createdAt": "2024-02-20T04:28:23Z",
              "updatedAt": "2024-02-20T04:29:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5wouNT",
          "commit": {
            "abbreviatedOid": "6bb489e"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2024-02-20T08:08:01Z",
          "updatedAt": "2024-02-20T08:22:29Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "But what about SUBSCRIBE_OK? We should send it too, especially if the end groups use relative offsets.",
              "createdAt": "2024-02-20T08:08:02Z",
              "updatedAt": "2024-02-20T08:22:29Z"
            },
            {
              "originalPosition": 44,
              "body": "I don't like the subscription being unchanged. It causes a partial failure which is just really difficult to support. ",
              "createdAt": "2024-02-20T08:12:37Z",
              "updatedAt": "2024-02-20T08:22:29Z"
            },
            {
              "originalPosition": 43,
              "body": "Also what if there are multiple SUBSCRIBE_UPDATES? Do the SUBSCRIBE_ERRORs have to be returned in order? With no OK, it's impossible to differentiate if the 1st or 2nd UPDATE failed.",
              "createdAt": "2024-02-20T08:14:08Z",
              "updatedAt": "2024-02-20T08:22:29Z"
            },
            {
              "originalPosition": 59,
              "body": "Can we also update the start group/object? It would be super useful for relays to deal with:\r\n\r\nviewer1: SUBSCRIBE start=-2\r\n(pause)\r\nviewer2: SUBSCRIBE start=-3\r\n\r\nCurrently, the relay would issue to origin:\r\nSUBSCRIBE start=-2\r\n(wait for SUBSCRIBE_OK -2=65)\r\nSUBSCRIBE start=64 end=65\r\n\r\nWhich is complicated and incurs delay. But if we allow updating start ranges:\r\nSUBSCRIBE start=-2\r\nSUBSCRIBE_UPDATE start=-3",
              "createdAt": "2024-02-20T08:21:31Z",
              "updatedAt": "2024-02-20T08:22:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5xWQWi",
          "commit": {
            "abbreviatedOid": "6bb489e"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Individual Review:\r\n\r\nWe should have a way to update the endpoint of a subscription (like subscribe update), and also a way to unsubscribe immediately when you don't know or care about the end.  I suppose we can do that by setting the new end-point to absolute 0/0.",
          "createdAt": "2024-02-26T18:09:54Z",
          "updatedAt": "2024-02-26T18:13:00Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "Updating the start point can mess with object mapping to streams, especially moving backwards.  In your example, if the track is stream-per-track, the publisher may open a stream and being publishing group=65.  In the current design, where subscription ID appears in objects, the second subscribe for group=64 will come on its own new stream.  If we allow updating the subscription start point backwards to 64, what should the publisher do? Should it close the open stream and open a new one, beginning at group=64, and resend objects from group=65?",
              "createdAt": "2024-02-26T18:09:54Z",
              "updatedAt": "2024-02-26T18:13:00Z"
            },
            {
              "originalPosition": 62,
              "body": "In the context of this PR and the current draft, where the only thing you can change is the end, this message is OK.  However, if we add more parameters to subscribe (eg #381), then we need a way to update some of the parameters and not others.\r\n\r\nWe should also clarify what happens if you issue the SUBSCRIBE twice for the same ID - I expect in this PR as is, we would make that an error?",
              "createdAt": "2024-02-26T18:12:39Z",
              "updatedAt": "2024-02-26T18:13:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5xp4ar",
          "commit": {
            "abbreviatedOid": "938bc4c"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-28T17:03:46Z",
          "updatedAt": "2024-02-28T17:03:46Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "I do think updating the start is potentially interesting and useful.\r\n\r\nUpdates of the start should not be able to move the start point of the subscription earlier.  As you said, it's just too complex.  For similar reasons, I think updating the end to be farther in the future is error prone as well, though there may be use cases for that.",
              "createdAt": "2024-02-28T17:03:46Z",
              "updatedAt": "2024-02-28T17:03:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5xzmMF",
          "commit": {
            "abbreviatedOid": "938bc4c"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "My main comment is I don't think we shoudl try and use UPDATE as the way we do UNSUSCRIBE ",
          "createdAt": "2024-02-29T16:32:55Z",
          "updatedAt": "2024-02-29T16:55:47Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "I think the \"end of existing\" should say the \"end of the subscription range\". ",
              "createdAt": "2024-02-29T16:32:55Z",
              "updatedAt": "2024-02-29T16:55:47Z"
            },
            {
              "originalPosition": 41,
              "body": "I don't think this is right. The update should just be to change the metadata about the subscribe, not change the state of the subscribe. We should use some other message to cause the SUSBCRIBE to end and remove all the state about the SUBSCRIBE. ",
              "createdAt": "2024-02-29T16:36:22Z",
              "updatedAt": "2024-02-29T16:55:47Z"
            },
            {
              "originalPosition": 29,
              "body": "I think we need both the UNSUBSCRIBE and UPDATE ( or whatever names we decide to call them ). ",
              "createdAt": "2024-02-29T16:37:52Z",
              "updatedAt": "2024-02-29T16:55:47Z"
            },
            {
              "originalPosition": 43,
              "body": "I think this should be an UPDATE_OK/ERROR. Don't care if it is two message or not. But should be clear that if some part of the UPDATE can not be applied, then no part of the update is applied, subscribe stays with same meta data as before, and error returned. So an update is all or nothing. ",
              "createdAt": "2024-02-29T16:40:17Z",
              "updatedAt": "2024-02-29T16:55:47Z"
            },
            {
              "originalPosition": 51,
              "body": "Uh, I think this needs to be UNSUBSCRIBE or whatever the  SUBSCRIBE CLOSE/STOP/FIN/RST/END is called ",
              "createdAt": "2024-02-29T16:41:44Z",
              "updatedAt": "2024-02-29T16:55:47Z"
            },
            {
              "originalPosition": 59,
              "body": "+1 on start can only be moved forward, end can only be moved backwards",
              "createdAt": "2024-02-29T16:43:35Z",
              "updatedAt": "2024-02-29T16:55:47Z"
            },
            {
              "originalPosition": 59,
              "body": "As a side note where I don't really care ... I'm not sure the use case to move the start forward",
              "createdAt": "2024-02-29T16:44:29Z",
              "updatedAt": "2024-02-29T16:55:47Z"
            },
            {
              "originalPosition": 61,
              "body": "This is not a location this shoudl be an optional var int",
              "createdAt": "2024-02-29T16:45:56Z",
              "updatedAt": "2024-02-29T16:55:47Z"
            },
            {
              "originalPosition": 62,
              "body": "This should be var int not Location ",
              "createdAt": "2024-02-29T16:46:08Z",
              "updatedAt": "2024-02-29T16:55:47Z"
            },
            {
              "originalPosition": 71,
              "body": "I would prefer to make the end group / object optional in the update instead of having a None value. I think it makes a better patter for how to add future things to the update. ",
              "createdAt": "2024-02-29T16:54:58Z",
              "updatedAt": "2024-02-29T16:55:47Z"
            }
          ]
        }
      ]
    },
    {
      "number": 386,
      "id": "PR_kwDOG2Ho4M5nUtiv",
      "title": "Rename SUBSCRIBE_RST to SUBSCRIBE_RESET",
      "url": "https://github.com/moq-wg/moq-transport/pull/386",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Editorial"
      ],
      "body": "QUIC uses RESET, we should too.",
      "createdAt": "2024-02-19T19:35:24Z",
      "updatedAt": "2024-02-20T15:20:33Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "d05521bc7428754389a20f17f43a79be1bd1ddd7",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ianswett-subscribe-reset",
      "headRefOid": "c611c75c47adde07af17abcaebf6e3b89a1f2030",
      "closedAt": "2024-02-20T15:20:32Z",
      "mergedAt": "2024-02-20T15:20:32Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "1169f20fd065f90452754057a653cb870309e24d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5wny7Q",
          "commit": {
            "abbreviatedOid": "c611c75"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-20T04:32:20Z",
          "updatedAt": "2024-02-20T04:32:21Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I prefer `SUBSCRIBE_CANCEL` to indicate an existing subscription is canceled now. I do understand RESET goes with QUIC naming, but Cancel seems more nature given the nomenclature of subscription vs that of a transport stream construct.",
              "createdAt": "2024-02-20T04:32:21Z",
              "updatedAt": "2024-02-20T04:32:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5woskZ",
          "commit": {
            "abbreviatedOid": "c611c75"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Teeechnically, QUIC uses STOP for receiver-initiated closes. But RESET is better than RST.",
          "createdAt": "2024-02-20T08:04:11Z",
          "updatedAt": "2024-02-20T08:04:11Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5wsitB",
          "commit": {
            "abbreviatedOid": "c611c75"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-20T15:20:14Z",
          "updatedAt": "2024-02-20T15:20:14Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I used CANCEL in the ANNOUNCE PR, and happy to consider different names, and we should make an effort to be somewhat consistent between SUBSCRIBE and ANNOUNCE to avoid confusion.",
              "createdAt": "2024-02-20T15:20:14Z",
              "updatedAt": "2024-02-20T15:20:14Z"
            }
          ]
        }
      ]
    },
    {
      "number": 387,
      "id": "PR_kwDOG2Ho4M5nUycy",
      "title": "Don't send Objects for failed subscriptions",
      "url": "https://github.com/moq-wg/moq-transport/pull/387",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #357",
      "createdAt": "2024-02-19T19:50:24Z",
      "updatedAt": "2024-02-20T23:40:38Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "d05521bc7428754389a20f17f43a79be1bd1ddd7",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ianswett-failed-subs",
      "headRefOid": "b340c51ca29fcd101616849e8e6507c8cf60997f",
      "closedAt": "2024-02-20T23:40:37Z",
      "mergedAt": "2024-02-20T23:40:37Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "fd9574281c4dc0fdeb977b4ed49715577c2d7f0b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5wnzDj",
          "commit": {
            "abbreviatedOid": "c5f3147"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-20T04:33:10Z",
          "updatedAt": "2024-02-20T04:33:10Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5wtVMS",
          "commit": {
            "abbreviatedOid": "c5f3147"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-20T16:37:25Z",
          "updatedAt": "2024-02-20T16:37:25Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nreceives a SUBSCRIBE_ERROR after receiving objects, it MUST close the session\r\n```",
              "createdAt": "2024-02-20T16:37:25Z",
              "updatedAt": "2024-02-20T16:37:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5wtVUY",
          "commit": {
            "abbreviatedOid": "c5f3147"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-20T16:37:39Z",
          "updatedAt": "2024-02-20T16:37:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 388,
      "id": "PR_kwDOG2Ho4M5nU3tj",
      "title": "Formatting and Text Cleanup",
      "url": "https://github.com/moq-wg/moq-transport/pull/388",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Editorial"
      ],
      "body": "Cleaned up formatting and make description succint",
      "createdAt": "2024-02-19T20:08:57Z",
      "updatedAt": "2024-02-19T20:39:40Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "e0a52442219909393933a9c4f4518c697034ac8c",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "suhas",
      "headRefOid": "bb47915d41eda60a137f38f0def87fb7eb2cda89",
      "closedAt": "2024-02-19T20:39:40Z",
      "mergedAt": "2024-02-19T20:39:40Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "53746179d687d2b1903268d77cee8bcf445101b4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5wmfam",
          "commit": {
            "abbreviatedOid": "bb47915"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks Suhas!",
          "createdAt": "2024-02-19T20:39:01Z",
          "updatedAt": "2024-02-19T20:39:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 389,
      "id": "PR_kwDOG2Ho4M5nU7AE",
      "title": "Specify if Objects were published in SUBSCRIBE_FIN and SUBSCRIBE_RST",
      "url": "https://github.com/moq-wg/moq-transport/pull/389",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #313 by adding an explicit bool indicating whether any Objects were published for a subscription, similar to the explicit bool added to SUBSCRIBE_OK in #343.",
      "createdAt": "2024-02-19T20:21:38Z",
      "updatedAt": "2024-02-21T17:15:31Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "f845852fd96120627dd89a3f08c7df4af8b9bb76",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ianswett-no-objects-fin",
      "headRefOid": "67985751c08292f7a2bb7d5e354c9621c4e2d43e",
      "closedAt": "2024-02-21T17:15:31Z",
      "mergedAt": "2024-02-21T17:15:31Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "0edb987f6bddf4b7f0d62a626d174a23bb229458"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 391,
      "id": "PR_kwDOG2Ho4M5nU-93",
      "title": "Remove 'Expires' from SUBSCRIBE_OK",
      "url": "https://github.com/moq-wg/moq-transport/pull/391",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #390",
      "createdAt": "2024-02-19T20:37:42Z",
      "updatedAt": "2024-03-05T19:41:11Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "06d9acf2564ca79fc3dcb78303f93047691c4b07",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ianswett-no-expires",
      "headRefOid": "f1963f5a1cc48098f792fa2510df911e55d92c0f",
      "closedAt": "2024-03-05T19:41:11Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe this PR is a step in the right direction, since the current subscription expiry mechanism feels underspecified; I can think of some cases in which that would be useful, but I'd rather have a `SUBSCRIBE_GOAWAY` message that tells the peer they should resubscribe rather than a timer.",
          "createdAt": "2024-02-20T18:17:56Z",
          "updatedAt": "2024-02-20T18:17:56Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm concerned about state that *never* goes away if some downstream connection had a slight bug or timing hickup.  ",
          "createdAt": "2024-03-04T17:01:13Z",
          "updatedAt": "2024-03-04T17:01:13Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this for now, we can always remove 'Expires' easily later on.",
          "createdAt": "2024-03-05T19:41:11Z",
          "updatedAt": "2024-03-05T19:41:11Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5wncxL",
          "commit": {
            "abbreviatedOid": "f72662d"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2024-02-20T02:22:56Z",
          "updatedAt": "2024-02-20T02:23:00Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "I do feel expires is needed. This is a way for CDN/relay provider to indicate the subscriber to renew their interest in subscription.  I would think Hops within a CDN network might configure a different (larger) value for this compared to end point client subscribing to edge relay.\r\n\r\nI might be convinced otherwise, but love to discuss this a bit.",
              "createdAt": "2024-02-20T02:22:56Z",
              "updatedAt": "2024-02-20T02:23:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5woQ7v",
          "commit": {
            "abbreviatedOid": "f72662d"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This change might be controversial but I'm all for it.",
          "createdAt": "2024-02-20T06:44:37Z",
          "updatedAt": "2024-02-20T06:58:46Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "I know we've talked at length about this, but can you give some example use-cases?\r\n\r\nIf the intent is an idle timeout, then QUIC already provides most of that. The connection will be closed and any subscriptions cancelled after a period of inactivity. There's also a congestion window that will prevent sending bytes well before that timeout is hit. Performing the idle timeout at the MoQ level will catch some more scenarios, like a bug in the MoQ library that prevents unsubscribes, but eh it's fringe.\r\n\r\nIf the intent is to force reauthorization, well that needs to be thought out a bit more. What behavior should the subscriber perform on expiration? Does it need to refresh it's authorization token every time, or only every x minutes? Heh I already know the answer is going to be \"it depends on the application\". And I agree!\r\n\r\nThe expiration should be part of the authorization scheme itself and signaled independently. For example, you can put the expiration in the token itself. A client already needs to understand the authorization scheme in order to refresh tokens, so it can totally parse the expiration out of the token too.",
              "createdAt": "2024-02-20T06:44:37Z",
              "updatedAt": "2024-02-20T06:58:46Z"
            },
            {
              "originalPosition": 25,
              "body": "Yeah, I agree that the transition from a valid to invalid subscription at an arbitrary point in time is problematic\r\n\r\nIf we end up keeping `expires`, then an explicit `SUBSCRIBE_RESET` message (with an error code) should actually be required to terminate the subscription.",
              "createdAt": "2024-02-20T06:56:13Z",
              "updatedAt": "2024-02-20T06:58:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5wtdPm",
          "commit": {
            "abbreviatedOid": "f72662d"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-20T16:51:21Z",
          "updatedAt": "2024-02-20T16:51:21Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Individual Comment:\r\n\r\nThat might be a nice middle ground -- `expires` is advisory to the client that it's going to get a SUBSCRIBE_RESET at that time.  It can avoid that (make before break) by resubscribing before that point.",
              "createdAt": "2024-02-20T16:51:21Z",
              "updatedAt": "2024-02-20T16:51:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5wt_ng",
          "commit": {
            "abbreviatedOid": "f72662d"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-20T17:53:35Z",
          "updatedAt": "2024-02-20T17:53:35Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "@afrind That's not just the middle ground. but  expected behavior for relay provider not to waste its resources if the susbcriber doesn't renew its interest in a given track.  Also good point on make before break scenario.",
              "createdAt": "2024-02-20T17:53:35Z",
              "updatedAt": "2024-02-20T17:53:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5wwYA3",
          "commit": {
            "abbreviatedOid": "f72662d"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-20T22:47:35Z",
          "updatedAt": "2024-02-20T22:47:35Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "What does renewing its interest mean?  It continues to ACK packets and supply flow control for streams to allow the data for the subscription to be delivered, so it's not completely passive.\r\n\r\nI don't know what action to take based on this field a subscriber.  There's no guarantee the subscription will last as long as the expires indicates.  There's also no guarantee it won't last much longer, especially if we still require a SUBSCRIBE_RESET or FIN, which I think we should to ensure the state machine is simpler.",
              "createdAt": "2024-02-20T22:47:35Z",
              "updatedAt": "2024-02-20T22:47:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5w4iy1",
          "commit": {
            "abbreviatedOid": "71d3207"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Lets talk about this but I think we need very long lasting session ( imagine weeks or years that are common with security cameras )  to periodically be reauthenticated and I had imagined this was the place to do it. ",
          "createdAt": "2024-02-21T17:07:03Z",
          "updatedAt": "2024-02-21T17:07:03Z",
          "comments": []
        }
      ]
    },
    {
      "number": 392,
      "id": "PR_kwDOG2Ho4M5nVF1J",
      "title": "Add ANNOUNCE_CANCEL",
      "url": "https://github.com/moq-wg/moq-transport/pull/392",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "To allow subscribers to indicate that no new subscriptions will be routed to the publisher for a given namespace.\r\n\r\nHappy to bikeshed on the name and whether we really need another frame for this.\r\n\r\nFixes #319",
      "createdAt": "2024-02-19T21:05:42Z",
      "updatedAt": "2024-02-21T22:39:41Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "2941044ffc2d58998c9abff9fc28c2ccbd57473d",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ianswett-announce-cancel",
      "headRefOid": "3a8d48afc147b3517bb0c7d9e0b5cc246a38a4b9",
      "closedAt": "2024-02-21T22:39:41Z",
      "mergedAt": "2024-02-21T22:39:41Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "a02b1a57b50cfa6ee56e110f27495619bfc249c4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5wmmVq",
          "commit": {
            "abbreviatedOid": "f800792"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-19T21:09:04Z",
          "updatedAt": "2024-02-19T21:09:04Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nnamespace it previously responded ANNOUNCE_OK to, it sends an\r\n```",
              "createdAt": "2024-02-19T21:09:04Z",
              "updatedAt": "2024-02-19T21:09:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5woKTD",
          "commit": {
            "abbreviatedOid": "20ff796"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "If we're going to combine `SUBSCRIBE_ERROR` and `SUBSCRIBE_RESET`, then we should just combine `ANNOUNCE_ERROR` and `ANNOUNCE_CANCEL` now.\r\n\r\nMy desire is to have four messages:\r\npublisher create: ANNOUNCE\r\npublisher close: UNANNOUNCE\r\nsubscriber accept: ANNOUNCE_OK\r\nsubscriber close: ANNOUNCE_STOP\r\n\r\nThe same goes for subscriptions:\r\nsubscriber create: SUBSCRIBE\r\nsubscriber close: UNSUBSCRIBE\r\npublisher accept: SUBSCRIBE_OK\r\npublisher close: SUBSCRIBE_STOP",
          "createdAt": "2024-02-20T06:20:41Z",
          "updatedAt": "2024-02-20T06:30:54Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Bikeshed: `ANNOUNCE_RESET` so it matches `SUBSCRIBE_RESET`.",
              "createdAt": "2024-02-20T06:20:41Z",
              "updatedAt": "2024-02-20T06:30:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5w4xmJ",
          "commit": {
            "abbreviatedOid": "3a8d48a"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-21T17:23:20Z",
          "updatedAt": "2024-02-21T22:38:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 394,
      "id": "PR_kwDOG2Ho4M5nVQss",
      "title": "Track Namespace is an exact match",
      "url": "https://github.com/moq-wg/moq-transport/pull/394",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #252",
      "createdAt": "2024-02-19T21:45:13Z",
      "updatedAt": "2024-02-23T18:01:25Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "2941044ffc2d58998c9abff9fc28c2ccbd57473d",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ianswett-exact-track-namespace",
      "headRefOid": "4bf4c72fab1439abc1973f96605a527b8cf34363",
      "closedAt": "2024-02-23T18:01:25Z",
      "mergedAt": "2024-02-23T18:01:25Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "d8e0951dbe8d1f8d0186e59c0afd5e26cc858925"
      },
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "PR updated, PTAL",
          "createdAt": "2024-02-21T22:37:39Z",
          "updatedAt": "2024-02-21T22:37:39Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5wmwZS",
          "commit": {
            "abbreviatedOid": "cfa1d31"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-19T21:48:26Z",
          "updatedAt": "2024-02-19T21:48:27Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "\"Relays send\" feels ambiguous to me, as in, I don't understand what is the actual normative requirement that we are trying to communicate here.",
              "createdAt": "2024-02-19T21:48:26Z",
              "updatedAt": "2024-02-19T21:48:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5woJ2n",
          "commit": {
            "abbreviatedOid": "cfa1d31"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2024-02-20T06:18:53Z",
          "updatedAt": "2024-02-20T06:19:04Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Same, I don't understand this.",
              "createdAt": "2024-02-20T06:18:53Z",
              "updatedAt": "2024-02-20T06:19:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5wwY9H",
          "commit": {
            "abbreviatedOid": "cfa1d31"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-20T22:51:15Z",
          "updatedAt": "2024-02-20T22:51:16Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Agreed, I was having a difficult time determining what text to add and where.  Suggestions or alternate PRs are welcome.",
              "createdAt": "2024-02-20T22:51:15Z",
              "updatedAt": "2024-02-20T22:51:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5wxyBR",
          "commit": {
            "abbreviatedOid": "cfa1d31"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-21T04:45:24Z",
          "updatedAt": "2024-02-21T04:45:25Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "May be this is what we can say \r\n\r\n\" For publishers with successful announces, a Relay issues subscriptions to such publishers only when the `Track Namespace`  in the subscription has exact bitwise match with the announced `Track Namespace` \".\r\n",
              "createdAt": "2024-02-21T04:45:24Z",
              "updatedAt": "2024-02-21T04:45:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5w4gxh",
          "commit": {
            "abbreviatedOid": "cfa1d31"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I'm not sure how to wordsmith this but +1 to what it is saying. ",
          "createdAt": "2024-02-21T17:04:37Z",
          "updatedAt": "2024-02-21T17:04:37Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5w5gnB",
          "commit": {
            "abbreviatedOid": "cfa1d31"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-21T18:21:49Z",
          "updatedAt": "2024-02-21T18:21:50Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I think the text is trying to be too technical. Here's my suggestion:\r\n\r\nA relay manages sessions from multiple publishers and subscribers, connecting them based on the track namespace. This SHOULD use a full string match unless otherwise negotiated by the application. For example, a `SUBSCRIBE namespace=foobar` message will be forwarded to the session that sent `ANNOUNCE namespace=foobar`.\r\n\r\nI put a SHOULD instead of a MUST so we leave door open. Relays are going to rewriting the namespace, or using a portion of it based on the application, and it would be impossible to enforce anyway. ",
              "createdAt": "2024-02-21T18:21:50Z",
              "updatedAt": "2024-02-21T18:21:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5w7Gm7",
          "commit": {
            "abbreviatedOid": "cfa1d31"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-21T22:33:26Z",
          "updatedAt": "2024-02-21T22:33:26Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Given you specify the unless, I'd prefer MUST unless, but otherwise LG.",
              "createdAt": "2024-02-21T22:33:26Z",
              "updatedAt": "2024-02-21T22:33:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5w8D2c",
          "commit": {
            "abbreviatedOid": "4bf4c72"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-22T03:31:03Z",
          "updatedAt": "2024-02-22T03:31:03Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5xBRF6",
          "commit": {
            "abbreviatedOid": "4bf4c72"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for the update ",
          "createdAt": "2024-02-22T15:29:24Z",
          "updatedAt": "2024-02-22T15:29:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 395,
      "id": "PR_kwDOG2Ho4M5nVUsD",
      "title": "Clarify what ROLE means",
      "url": "https://github.com/moq-wg/moq-transport/pull/395",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Needs Discussion"
      ],
      "body": "Add some normative text and requires both client and server to send their role.\r\n\r\nI can also see the argument for removing this entirely, but it's in the current draft, so if we're going to keep it, I'd like to define it better.\r\n\r\nFixes #151, Fixes #250",
      "createdAt": "2024-02-19T22:02:17Z",
      "updatedAt": "2024-02-23T18:00:54Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "fd9574281c4dc0fdeb977b4ed49715577c2d7f0b",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ianswett-normative-role",
      "headRefOid": "4ebb90649060f172e5c56c8d36718b5fd161452a",
      "closedAt": "2024-02-23T18:00:54Z",
      "mergedAt": "2024-02-23T18:00:54Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "3b9cd050aa5d8305560ca3bb674c60a61825fad0"
      },
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> This explicit flag in SETUP is a lot better than crashing if an unsupported message is sent by the peer.\r\n\r\nHaving a flag in SETUP doesn't stop from someone sending unsupported messages. A faulty implementation or intentionally malicious endpoint can send unsupported messages. A receiver should be prepared to handle unsupported messages regardless.",
          "createdAt": "2024-02-20T06:22:28Z",
          "updatedAt": "2024-02-20T06:22:28Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> > This explicit flag in SETUP is a lot better than crashing if an unsupported message is sent by the peer.\r\n> \r\n> Having a flag in SETUP doesn't stop from someone sending unsupported messages. A faulty implementation or intentionally malicious endpoint can send unsupported messages. A receiver should be prepared to handle unsupported messages regardless.\r\n\r\nRight, an implementation is still going to crash if it receives an unsupported message, but there's a difference between signaling that upfront and yolo.\r\n\r\nA one-sided implementation will look something like this:\r\n```\r\nreceive(message) {\r\n  switch (message.type) {\r\n  case SUBSCRIBE:\r\n    // ...\r\n  case UNSUBSCRIBE:\r\n    // ..\r\n  default:\r\n    throw PROTOCOL_ERROR\r\n  }\r\n}\r\n```\r\n\r\nThe purpose of the ROLE parameter is to avoid accidentally triggering that default, as it will close the connection.\r\n\r\nFor example, I absolutely want to have a way to get per-viewer feedback: a `feedback` track produced by each viewer. Without this ROLE field, a viewer might cause a crash if it sends an `ANNOUNCE feedback` to the server, or the server might cause a crash if it sends a `SUBSCRIBE feedback` to the viewer. It will only work if both endpoints explicitly flag `ROLE=both`. \r\n\r\nThe only alternative to the ROLE field is to implement the entire protocol, but that's unnecessarily restrictive. Take HTTP for example, it's almost taken for granted that an implementation is for a client or a server, but rarely both. I imagine that will also be the case with MoQ with the sole exception of relays. OBS is not going to implement subscribing, and VLC is not going to implement publishing.\r\n\r\nEven in my MoQ.js library that does support both modes, I ran into a deadlock because of ROLE=both. My publisher was not consuming ANNOUNCE messages because it was not expecting them. Explicitly signaling ROLE=publisher would have prevented this, making it a protocol violation to send half of the messages in the draft.",
          "createdAt": "2024-02-20T07:14:46Z",
          "updatedAt": "2024-02-20T07:17:12Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "A resilient implementation state machine will be something like\r\n\r\n```\r\neceive(message) {\r\n  switch (message.type) {\r\n  case SUBSCRIBE:\r\n    // ...\r\n  case UNSUBSCRIBE:\r\n    // ..\r\n  default:\r\n    // drop the message\r\n  }\r\n}\r\n```\r\n\r\nSince for unsupported messages, you don't want a protocol action as it will be DOS surface, for example.\r\n\r\nAlso, Many of the conferencing examples will mostly always be send and receive by default. Our client for example does pub and subscribe always.\r\n\r\nI personally feel the implementation constraints are resolvable and I feel still unconvinced for a ROLE parameter.",
          "createdAt": "2024-02-20T07:23:24Z",
          "updatedAt": "2024-02-20T07:24:23Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> A resilient implementation state machine will be something like\r\n> \r\n> ```\r\n> eceive(message) {\r\n>   switch (message.type) {\r\n>   case SUBSCRIBE:\r\n>     // ...\r\n>   case UNSUBSCRIBE:\r\n>     // ..\r\n>   default:\r\n>     // drop the message\r\n>   }\r\n> }\r\n> ```\r\n\r\nHeh, please don't do that. This is exactly why we have version/extension negotiation; not supporting a message after negotiating it is a protocol violation.\r\n\r\nOtherwise, my endpoint has to assume that your endpoint could ignore messages, and the MoQ draft in general, on a whim. Just tell me that you don't support ANNOUNCE via ROLE. Otherwise I would have to send an ANNOUNCE, start a timer, and guess that no OK/ERROR means no support? Probing for support is miserable.\r\n\r\n> Since for unsupported messages, you don't want a protocol action as it will be DOS surface, for example.\r\n\r\nYou close the connection on an unsupported message.\r\n\r\n> Also, Many of the conferencing examples will mostly always be send and receive by default. Our client for example does pub and subscribe always.\r\n> \r\n> I personally feel the implementation constraints are resolvable and I feel still unconvinced for a ROLE parameter.\r\n\r\nJust send ROLE=both then. Not every conferencing is bidirectional though, for example clubhouse-style. At Discord we also have a dedicated connection for screen sharing (don't ask) and a very explicit role=publisher vs role=subscriber flag.",
          "createdAt": "2024-02-20T08:00:11Z",
          "updatedAt": "2024-02-20T08:00:11Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The only alternative to the ROLE field is to implement the entire protocol, but that's unnecessarily restrictive. \r\n\r\nI don't think this is necessarily true. Without ROLE, you can still choose to only implement half the protocol and reject the messages you don't support. **Every client has to be built to be resilient to arbitrary incoming messages**. It can't break because the other side said their role was subscriber but then they send you an ANNOUCE. Therefore sending an upfront role seems like a promise to behave in a certain way. A system that relies on promises to not break will be brittle. I agree that ROLE seems superfluous.\r\n\r\n\r\n",
          "createdAt": "2024-02-20T08:04:40Z",
          "updatedAt": "2024-02-20T08:04:40Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> **Every client has to be built to be resilient to arbitrary incoming messages**. It can't break because the other side said their role was subscriber but then they send you an ANNOUCE. \r\n\r\nI want publisher and subscriber support to be optional. That way it's only necessary to implement half of the draft on many cases. A CDN distribution edge would be one such situation. In fact, it's a hardening measure to ensure the edge cannot receive a ANNOUNCE which might otherwise cause a vulnerability.\r\n\r\nAnd generally speaking, if something is optional, then it should be negotiated. Otherwise you end up with Schroeder's extension. Silently ignoring unknown/unsupported messages is just terrible protocol design and it's s far better to close the connection with a protocol violation instead.\r\n\r\nThat's the point of the ROLE parameter. But yeah let's chat about it on Wed.",
          "createdAt": "2024-02-20T08:43:08Z",
          "updatedAt": "2024-02-20T08:43:08Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment:\r\n\r\nEvery implementation has to have that switch statement and some not-crash action when it receives a message it doesn't support.  Some logical options are:\r\n\r\n1. Ignore the message\r\n2. Send the corresponding error message (eg SUBSCRIBE_ERROR, ANNOUNCE_ERROR) with an error code like \"not-implemented\"\r\n3. Close the entire connection\r\n\r\nI think the value of ROLE is that it gives a consistent behavior early in the life of the session.  If I want to send subscribes and the peer says they are subscriber only, I close the connection.  But I still have to have the switch statement because of broken or malicious peers.  The MUST in this PR can be improved by explaining what happens when you don't like the value you see, or the peer sends messages inconsistent with its advertised role.",
          "createdAt": "2024-02-20T16:42:28Z",
          "updatedAt": "2024-02-20T16:45:13Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> If I want to send subscribes and the peer says they are subscriber only, I close the connectio\r\n\r\nIn that case the peer will close the connection since it knows that it is subscribe only implementation and the role in the setup is supreflous",
          "createdAt": "2024-02-21T01:52:45Z",
          "updatedAt": "2024-02-21T03:34:51Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is the type of things where I don't think we need it but it does not break anything, is not a big deal to implement, and does not hit performance. Given other people feel strongly this is needed, I can easily live with this. If this helps us get to consensus, I'm fine with adding it. I think the rewrite makes things clearer than they were before. ",
          "createdAt": "2024-02-21T16:55:08Z",
          "updatedAt": "2024-02-21T16:55:08Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussion concluded that supporting this was not that difficult and it's a clear signal of what's supported, to so AI is to fix up the PR to clarify behavior.",
          "createdAt": "2024-02-21T17:29:09Z",
          "updatedAt": "2024-02-21T17:29:09Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5wndPo",
          "commit": {
            "abbreviatedOid": "e2151b7"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-20T02:25:52Z",
          "updatedAt": "2024-02-20T02:25:55Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "I still don't see a need for the ROLE parameter. I wonder what's the value add here and be fine if we don't need it.\r\n\r\nThe implementation can decipher the role based on arrival of subscribe/publish/both messages.\r\n\r\nHowever, happy to hear what problem are we addressing to solve with the Role.",
              "createdAt": "2024-02-20T02:25:52Z",
              "updatedAt": "2024-02-20T02:25:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5woJVt",
          "commit": {
            "abbreviatedOid": "e2151b7"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Love it.\r\n\r\n@suhasHere I definitely want ROLE in the protocol because there will be many one-sided implementations. A broadcaster like OBS won't support ROLE=subscriber, likewise a viewer like VLC won't support ROLE=publisher. This explicit flag in SETUP is a lot better than crashing if an unsupported message is sent by the peer.",
          "createdAt": "2024-02-20T06:16:50Z",
          "updatedAt": "2024-02-20T06:17:18Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5woJpj",
          "commit": {
            "abbreviatedOid": "e2151b7"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-20T06:18:06Z",
          "updatedAt": "2024-02-20T06:18:06Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "`is missing or is not`",
              "createdAt": "2024-02-20T06:18:06Z",
              "updatedAt": "2024-02-20T06:18:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5wod00",
          "commit": {
            "abbreviatedOid": "e2151b7"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "DISMISSED",
          "body": "I wonder if it helps to discuss the role of role parameter during authors call for a short bit @ianswett ",
          "createdAt": "2024-02-20T07:26:32Z",
          "updatedAt": "2024-02-20T07:29:27Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5w4YmC",
          "commit": {
            "abbreviatedOid": "d956129"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-21T16:56:24Z",
          "updatedAt": "2024-02-21T16:56:24Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Small nit. I think these three different values should each have a name because it will make them easier to talk about. ",
              "createdAt": "2024-02-21T16:56:24Z",
              "updatedAt": "2024-02-21T16:56:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5xDm9G",
          "commit": {
            "abbreviatedOid": "d956129"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-22T19:24:14Z",
          "updatedAt": "2024-02-22T19:24:14Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Agreed, I named the third type 'PubSub', but I'm open to a better name.",
              "createdAt": "2024-02-22T19:24:14Z",
              "updatedAt": "2024-02-22T19:24:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5xFJLN",
          "commit": {
            "abbreviatedOid": "4ebb906"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-22T23:42:59Z",
          "updatedAt": "2024-02-22T23:43:59Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "If we reorganized the document into \"publisher messages\" and \"subscriber messages\", then the text here (and below) could be improved.  We could say:\r\n\r\nThe endpoint MUST NOT send any subscriber messages.  If the endpoint receives any publisher messages, it MUST close the connection with \"error code TBD\".",
              "createdAt": "2024-02-22T23:43:00Z",
              "updatedAt": "2024-02-22T23:43:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5xFb0l",
          "commit": {
            "abbreviatedOid": "4ebb906"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-23T01:10:02Z",
          "updatedAt": "2024-02-23T01:10:03Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "+1 I would love to see this.",
              "createdAt": "2024-02-23T01:10:03Z",
              "updatedAt": "2024-02-23T01:10:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5xFcFe",
          "commit": {
            "abbreviatedOid": "4ebb906"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-23T01:11:56Z",
          "updatedAt": "2024-02-23T01:11:56Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "A simple way of doing it would be to add a \"sent by (role)\" column to the table of messages and IDs.",
              "createdAt": "2024-02-23T01:11:56Z",
              "updatedAt": "2024-02-23T01:14:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5xJo-U",
          "commit": {
            "abbreviatedOid": "4ebb906"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM me. Ship it!",
          "createdAt": "2024-02-23T15:15:17Z",
          "updatedAt": "2024-02-23T15:15:17Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5xKzhK",
          "commit": {
            "abbreviatedOid": "4ebb906"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-23T17:57:24Z",
          "updatedAt": "2024-02-23T17:57:25Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "This SGTM, but seems like it could be a reasonably large change to the doc organization, so I'd prefer to do it in a separate PR.",
              "createdAt": "2024-02-23T17:57:24Z",
              "updatedAt": "2024-02-23T17:57:25Z"
            }
          ]
        }
      ]
    },
    {
      "number": 397,
      "id": "PR_kwDOG2Ho4M5nc7CS",
      "title": "Rename 'Generic Error' to 'Internal Error'",
      "url": "https://github.com/moq-wg/moq-transport/pull/397",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Internal server error has been useful in HTTP, so it makes sense to include something similar for MoQ.\r\n\r\nCloses #383 ",
      "createdAt": "2024-02-20T22:57:29Z",
      "updatedAt": "2024-02-21T04:16:30Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "fd9574281c4dc0fdeb977b4ed49715577c2d7f0b",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ianswett-internal-error",
      "headRefOid": "111e57578c44b6a600f6bd98f77d5867ad7b103b",
      "closedAt": "2024-02-21T04:16:30Z",
      "mergedAt": "2024-02-21T04:16:30Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "f845852fd96120627dd89a3f08c7df4af8b9bb76"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5wxkdy",
          "commit": {
            "abbreviatedOid": "111e575"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-21T04:02:48Z",
          "updatedAt": "2024-02-21T04:02:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 401,
      "id": "PR_kwDOG2Ho4M5oMQ4m",
      "title": "Merge SUBSCRIBE_RESET and SUBSCRIBE_FIN ",
      "url": "https://github.com/moq-wg/moq-transport/pull/401",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Into SUBSCRIBE_DONE.\r\n\r\nI didn't remove the SUBSCRIBE_ERROR message in favor of SUBSCRIBE_CLOSED as @kixelated suggested in this PR.\r\n\r\nFixes #398 \r\nFixes #356\r\nAddresses some comments in #310, but possibly not all",
      "createdAt": "2024-02-28T16:15:42Z",
      "updatedAt": "2024-03-04T02:51:01Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "d8e0951dbe8d1f8d0186e59c0afd5e26cc858925",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ianswett-better-naming",
      "headRefOid": "0c53359a477479c9043e09609ded8d08662b13b7",
      "closedAt": "2024-03-04T02:51:01Z",
      "mergedAt": "2024-03-04T02:51:01Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "06d9acf2564ca79fc3dcb78303f93047691c4b07"
      },
      "comments": [
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So my notes from this discussion. CLOSE is confusing with QUIC layer.  People seemed to prefer UNSUBSCRIBE over SUBSCRIBE_CLOSE. I love the move aware from RST and FIN as naming. \r\n\r\n",
          "createdAt": "2024-02-28T17:31:57Z",
          "updatedAt": "2024-02-28T17:31:57Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5xpiXq",
          "commit": {
            "abbreviatedOid": "e97a5c7"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I like it.\r\n\r\nI would also like to merge ERROR with CLOSED, but we'll chat about that.",
          "createdAt": "2024-02-28T16:23:57Z",
          "updatedAt": "2024-02-28T16:23:57Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5xp0Za",
          "commit": {
            "abbreviatedOid": "87c2488"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-28T16:57:21Z",
          "updatedAt": "2024-02-28T16:57:22Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "So what are these error codes? It's important to identify what they are, and I don't think they're like the other error codes (because some of them are not really \"errors\" in the classic sense.\r\n\r\nIn fact, I'd prefer if we called them a \"status code\". As I commented in #356, I think there are numerous states the sender might wish to communicate:\r\n1) You got all of the objects in the range;\r\n2) You got almost all of the objects, but some were dropped for latency/bandwidth reasons\r\n3) The track was truncated for some reason\r\nand possibly, a relay might say:\r\n4) You got everything I have but i'm not sure if that's everything",
              "createdAt": "2024-02-28T16:57:22Z",
              "updatedAt": "2024-02-28T16:57:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5xp1Z6",
          "commit": {
            "abbreviatedOid": "87c2488"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-28T16:58:47Z",
          "updatedAt": "2024-02-28T16:58:48Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "I am not going to lie down in the road over this bikeshed, but I think Unsubscribe is a better word. It commonly understood as a subscriber-initiated verb, while SUBSCRIBE_CANCEL is a bit more ambiguous as to who initiates it, without reading the spec.",
              "createdAt": "2024-02-28T16:58:47Z",
              "updatedAt": "2024-02-28T16:58:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5xp1cV",
          "commit": {
            "abbreviatedOid": "87c2488"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-28T16:58:52Z",
          "updatedAt": "2024-02-28T16:58:52Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5xp4Yr",
          "commit": {
            "abbreviatedOid": "87c2488"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-28T17:03:42Z",
          "updatedAt": "2024-02-28T17:03:43Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "I agree with Martin on this. UNSUBSCRIBE is clearly the semantic negation of SUBSCRIBE, while SUBSCRIBE_CANCEL leaves me with no intuitive understanding as to what is happening. ",
              "createdAt": "2024-02-28T17:03:42Z",
              "updatedAt": "2024-02-28T17:03:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5xp68L",
          "commit": {
            "abbreviatedOid": "87c2488"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-28T17:08:43Z",
          "updatedAt": "2024-02-28T17:08:43Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "I am not pushing against the PR ,but slight preference on the names. But I can live with it \r\n\r\nMy preference would be\r\n\r\nSubscribe --> Unsubscribe (both sent by the subscriber)\r\nSubscribeCancel -> Sent by the publisher after sending an OK to subscribe\r\n",
              "createdAt": "2024-02-28T17:08:43Z",
              "updatedAt": "2024-02-28T17:08:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5xqqGB",
          "commit": {
            "abbreviatedOid": "87c2488"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-28T18:42:45Z",
          "updatedAt": "2024-02-28T18:42:45Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "I renamed these back to UNSUBSCRIBE and UNANNOUNCE.",
              "createdAt": "2024-02-28T18:42:45Z",
              "updatedAt": "2024-02-28T18:42:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5xq3l5",
          "commit": {
            "abbreviatedOid": "87c2488"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-28T19:03:43Z",
          "updatedAt": "2024-02-28T19:03:43Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "I renamed to \"status code\" and added some that seemed straightforward.  I'm not sure if 2, 3 and 4 should be status codes or something else.  Suggestions welcome.",
              "createdAt": "2024-02-28T19:03:43Z",
              "updatedAt": "2024-02-28T19:03:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5xumTH",
          "commit": {
            "abbreviatedOid": "928bc1b"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks Ian .. Overall it looks fine except for using SubscribeClosed as a response for Unsubsubscrib.\r\n \r\nAlso another nit, I preferred SubscribeEnded better than closed since it seems more easy to think when you read the name",
          "createdAt": "2024-02-29T06:11:12Z",
          "updatedAt": "2024-02-29T06:13:55Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "I don't think we need a response for Unsubscribe . The data path should carry the information on the final group/object. ",
              "createdAt": "2024-02-29T06:11:12Z",
              "updatedAt": "2024-02-29T06:13:55Z"
            },
            {
              "originalPosition": 66,
              "body": "I think this should be renamed to unsubscribe.",
              "createdAt": "2024-02-29T06:11:37Z",
              "updatedAt": "2024-02-29T06:13:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5xy0fX",
          "commit": {
            "abbreviatedOid": "928bc1b"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-29T15:12:56Z",
          "updatedAt": "2024-02-29T15:12:57Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "s/SUBSCRIBE_CLOSED/SUBSCRIBE_ENDED to have naming not to conflate with underlying transport usages",
              "createdAt": "2024-02-29T15:12:56Z",
              "updatedAt": "2024-02-29T15:13:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5xzR-R",
          "commit": {
            "abbreviatedOid": "928bc1b"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-29T15:58:06Z",
          "updatedAt": "2024-02-29T15:58:06Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "Putting it in the data path makes sense if it's going to be cached and it's \"Part of the track\", but for state that's specific to a subscription, like the last Object sent, I think its makes more sense for it to be in subscription specific messages.",
              "createdAt": "2024-02-29T15:58:06Z",
              "updatedAt": "2024-02-29T15:58:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5xzSW4",
          "commit": {
            "abbreviatedOid": "928bc1b"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-29T15:58:43Z",
          "updatedAt": "2024-02-29T15:58:43Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "```suggestion\r\n{: #moq-transport-unsubscribe-format title=\"MOQT UNSUBSCRIBE Message\"}\r\n```",
              "createdAt": "2024-02-29T15:58:43Z",
              "updatedAt": "2024-02-29T15:58:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5xzTJY",
          "commit": {
            "abbreviatedOid": "928bc1b"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-29T16:00:03Z",
          "updatedAt": "2024-02-29T16:00:04Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "Good catch, fixed.",
              "createdAt": "2024-02-29T16:00:03Z",
              "updatedAt": "2024-02-29T16:00:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5xz9_a",
          "commit": {
            "abbreviatedOid": "04fcf9d"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2024-02-29T17:14:54Z",
          "updatedAt": "2024-02-29T17:16:26Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "I don't know what causes this one on a relay. ",
              "createdAt": "2024-02-29T17:14:54Z",
              "updatedAt": "2024-02-29T17:16:26Z"
            },
            {
              "originalPosition": 28,
              "body": "Just becasue a track has ended does not mean all the data has been delivered. I don't know how a relay would know when it could send this. I think it is better for the subscriber to just unsubscribe once it has the data. To put this more specifically, I don't know how a relay would be able to know when to send this. ",
              "createdAt": "2024-02-29T17:16:18Z",
              "updatedAt": "2024-02-29T17:16:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5x2XVV",
          "commit": {
            "abbreviatedOid": "04fcf9d"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-01T00:03:03Z",
          "updatedAt": "2024-03-01T00:03:04Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "> I don't know how a relay would be able to know when to send this.\r\n\r\nA relay could send it when it receives a SUBSCRIBE_CLOSE from the publisher with code=Track Ended?",
              "createdAt": "2024-03-01T00:03:04Z",
              "updatedAt": "2024-03-01T00:03:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5x2ZS-",
          "commit": {
            "abbreviatedOid": "04fcf9d"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-01T00:13:28Z",
          "updatedAt": "2024-03-01T00:13:28Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "You delivered all the requested data up to the end Object and Group.",
              "createdAt": "2024-03-01T00:13:28Z",
              "updatedAt": "2024-03-01T00:13:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5x2ZoB",
          "commit": {
            "abbreviatedOid": "04fcf9d"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-01T00:15:16Z",
          "updatedAt": "2024-03-01T00:15:16Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "I have mixed feelings about this one, so I'd be happy to remove it if we think the track end should be explicit in the Object model.  If so, we could just use Subscription Ended when the track ends.",
              "createdAt": "2024-03-01T00:15:16Z",
              "updatedAt": "2024-03-01T00:15:16Z"
            }
          ]
        }
      ]
    },
    {
      "number": 405,
      "id": "PR_kwDOG2Ho4M5onjRh",
      "title": "bit align ContentExists. Fixes #404",
      "url": "https://github.com/moq-wg/moq-transport/pull/405",
      "state": "MERGED",
      "author": "fluffy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-03-04T17:26:26Z",
      "updatedAt": "2024-03-18T00:39:28Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "80a1fc4eec92a05439e473edb60dcea399b3ca62",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ce-bits",
      "headRefOid": "98adbc27f6b6ab9b29808bc255a02b487370a655",
      "closedAt": "2024-03-18T00:39:28Z",
      "mergedAt": "2024-03-18T00:39:28Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "ad67a19f1e6abbe4331b73ad49360726783a2bb8"
      },
      "comments": [
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Note from call. \r\n\r\nFixe subscribeDone at same time.  \r\n\r\nDefine a new bool type. \r\n\r\np[ick new leatter other than b \r\n\r\n",
          "createdAt": "2024-03-04T18:03:30Z",
          "updatedAt": "2024-03-04T18:03:30Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "Also make sure to fix SUBSCRIBE_DONE at the same time.",
          "createdAt": "2024-03-04T22:12:17Z",
          "updatedAt": "2024-03-04T22:12:17Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ianswett - I updated, have another read and see if it looks OK. Thanks \r\n",
          "createdAt": "2024-03-04T22:46:06Z",
          "updatedAt": "2024-03-04T22:46:06Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5yLG6Z",
          "commit": {
            "abbreviatedOid": "42579a0"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-04T22:56:47Z",
          "updatedAt": "2024-03-04T22:56:47Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5yL385",
          "commit": {
            "abbreviatedOid": "98adbc2"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-05T02:12:45Z",
          "updatedAt": "2024-03-05T02:14:06Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "f makes me think float.  Admittedly, we don't use floats, so maybe this is fine.",
              "createdAt": "2024-03-05T02:12:45Z",
              "updatedAt": "2024-03-05T02:13:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5yMaaD",
          "commit": {
            "abbreviatedOid": "42579a0"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-05T04:38:37Z",
          "updatedAt": "2024-03-05T04:38:38Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "As I wrote this, I had the same concern, and failed to come up with better idea but, uh, yah, not thrilled about the conflict with float. ",
              "createdAt": "2024-03-05T04:38:37Z",
              "updatedAt": "2024-03-05T04:38:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5yUa-k",
          "commit": {
            "abbreviatedOid": "42579a0"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-05T19:37:58Z",
          "updatedAt": "2024-03-05T19:37:58Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I thought about this for a while and couldn't come up with anything better, so I'm fine with f for flag.",
              "createdAt": "2024-03-05T19:37:58Z",
              "updatedAt": "2024-03-05T19:37:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5zuy04",
          "commit": {
            "abbreviatedOid": "98adbc2"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-18T00:39:17Z",
          "updatedAt": "2024-03-18T00:39:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 406,
      "id": "PR_kwDOG2Ho4M5opXSS",
      "title": "Clarify the use of Expires in SUBSCRIBE",
      "url": "https://github.com/moq-wg/moq-transport/pull/406",
      "state": "MERGED",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "And add a new SUBSCRIBE_DONE status code.\r\n\r\nFixes part of #390, but it's still unclear how one might refresh a subscription without interruption.",
      "createdAt": "2024-03-04T22:18:49Z",
      "updatedAt": "2024-03-04T22:46:31Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "06d9acf2564ca79fc3dcb78303f93047691c4b07",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ianswett-clarify-expires",
      "headRefOid": "53d764fe9c93cb63f7b51f805c97489f9358d465",
      "closedAt": "2024-03-04T22:46:31Z",
      "mergedAt": "2024-03-04T22:46:31Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "80a1fc4eec92a05439e473edb60dcea399b3ca62"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5yK8Uh",
          "commit": {
            "abbreviatedOid": "53d764f"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-04T22:22:14Z",
          "updatedAt": "2024-03-04T22:22:14Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5yLCM9",
          "commit": {
            "abbreviatedOid": "53d764f"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2024-03-04T22:41:15Z",
          "updatedAt": "2024-03-04T22:41:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 407,
      "id": "PR_kwDOG2Ho4M5opsGx",
      "title": "Split messages by stream type.",
      "url": "https://github.com/moq-wg/moq-transport/pull/407",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Editorial"
      ],
      "body": "- Control messages\r\n- Data messages\r\n- Datagram messages\r\n\r\nTried to keep things completely editorial. I would like to do more cleanup but I would absolutely get carried away.",
      "createdAt": "2024-03-04T23:29:01Z",
      "updatedAt": "2024-03-23T12:31:03Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "80a1fc4eec92a05439e473edb60dcea399b3ca62",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "message-types",
      "headRefOid": "1fd9aad046ca5f225461a87be71f368600953076",
      "closedAt": "2024-03-23T12:31:03Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah I'll split it into two PRs. First PR just moves the data sections unchanged.",
          "createdAt": "2024-03-18T00:37:15Z",
          "updatedAt": "2024-03-18T00:37:43Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "I'll make another pass after splitting this PR into two.",
          "createdAt": "2024-03-23T12:31:03Z",
          "updatedAt": "2024-03-23T12:31:03Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5yL0w2",
          "commit": {
            "abbreviatedOid": "e6c1e4b"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-05T02:00:05Z",
          "updatedAt": "2024-03-05T02:00:05Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "```suggestion\r\nA publisher uses unidirectional streams or datagrams to carry message data ({{message-data}}).\r\n```",
              "createdAt": "2024-03-05T02:00:05Z",
              "updatedAt": "2024-03-05T02:01:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5yL1ht",
          "commit": {
            "abbreviatedOid": "e6c1e4b"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-05T02:02:59Z",
          "updatedAt": "2024-03-05T02:02:59Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "```suggestion\r\nThis avoids retransmissions, minimizes framing and flow control overhead, and is useful for transient objects.\r\n```",
              "createdAt": "2024-03-05T02:02:59Z",
              "updatedAt": "2024-03-05T02:02:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5yL11g",
          "commit": {
            "abbreviatedOid": "e6c1e4b"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-05T02:04:37Z",
          "updatedAt": "2024-03-05T02:04:38Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "```suggestion\r\nControl messages are transmitted over the bidirectional stream used to establish the session.\r\n```",
              "createdAt": "2024-03-05T02:04:37Z",
              "updatedAt": "2024-03-05T02:04:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5yL2Vd",
          "commit": {
            "abbreviatedOid": "e6c1e4b"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-05T02:07:08Z",
          "updatedAt": "2024-03-05T02:07:08Z",
          "comments": [
            {
              "originalPosition": 598,
              "body": "The distinction between data messages and those sent over datagrams is a bit odd to me, since it's the same type of data.",
              "createdAt": "2024-03-05T02:07:08Z",
              "updatedAt": "2024-03-05T02:07:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5yL2gf",
          "commit": {
            "abbreviatedOid": "e6c1e4b"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This is going in the right direction, but it creates a large diff, so it would be useful to have more reviewers.",
          "createdAt": "2024-03-05T02:08:05Z",
          "updatedAt": "2024-03-05T02:08:05Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5yL_ta",
          "commit": {
            "abbreviatedOid": "e6c1e4b"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "My major question is does this change make the data objects larger on the wire ? If so, I think we should figure out how to get them as small as we can. ",
          "createdAt": "2024-03-05T02:48:57Z",
          "updatedAt": "2024-03-05T04:37:27Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Uh, I'm not sure this is going to work very well. If A has congestion and cancels a stream from B, and then B just instantly opens a new stream, that is not going to help. ",
              "createdAt": "2024-03-05T02:48:57Z",
              "updatedAt": "2024-03-05T04:37:27Z"
            },
            {
              "originalPosition": 25,
              "body": "I would like to have one place in the spec where we explain how a Protocol Violation is handled and then just reference that in every place there is a Protocol Violation. Right now we sort of explain it half way in each place.  ( could be a different PR but I am thinking about it reading this ) ",
              "createdAt": "2024-03-05T02:50:41Z",
              "updatedAt": "2024-03-05T04:37:27Z"
            },
            {
              "originalPosition": 111,
              "body": "I can see the reason to move away from Type to something else but  have slight preference for something other than ID. When I see ID I expect to see some sort of counter that changes for each message. ",
              "createdAt": "2024-03-05T02:52:43Z",
              "updatedAt": "2024-03-05T04:37:27Z"
            },
            {
              "originalPosition": 123,
              "body": "This is probably a comment where I am just confused on what is being proposed but ... Uh, do these overlapping mean we add an extra byte to the Data messages ? I would really rather not do that. The industry right now is dropping literal millions of dollars into reducing the audio codecs from say 6 kbps to 2 kbs so adding a byte to 20 ms audio packets is big deal.   I still think we can easily do this just by making sure the numeric values are unique across all three tables and still have three tables but just want to make sure we are not making the data packets larger.",
              "createdAt": "2024-03-05T04:30:56Z",
              "updatedAt": "2024-03-05T04:37:27Z"
            },
            {
              "originalPosition": 858,
              "body": "It's hard to figure out what changed in this diff where things are moved. Not sure this is worth it but would easier with a two PR one that just had moves of text and one with diffs.  Did anything other than heading change or get deleted ? I could not see anything but was not sure ",
              "createdAt": "2024-03-05T04:36:27Z",
              "updatedAt": "2024-03-05T04:37:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5yUZjq",
          "commit": {
            "abbreviatedOid": "e6c1e4b"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-05T19:34:26Z",
          "updatedAt": "2024-03-05T19:34:26Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "I think this text is largely existing.",
              "createdAt": "2024-03-05T19:34:26Z",
              "updatedAt": "2024-03-05T19:34:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5yUZ7x",
          "commit": {
            "abbreviatedOid": "e6c1e4b"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-05T19:35:22Z",
          "updatedAt": "2024-03-05T19:35:23Z",
          "comments": [
            {
              "originalPosition": 111,
              "body": "Good point, I'd prefer to stick with Type.  ID does imply something that increments, like a Subscribe ID or Stream ID to me.",
              "createdAt": "2024-03-05T19:35:22Z",
              "updatedAt": "2024-03-05T19:35:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5yUqFf",
          "commit": {
            "abbreviatedOid": "e6c1e4b"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-05T20:12:59Z",
          "updatedAt": "2024-03-05T20:12:59Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Yeah this is copy-paste.",
              "createdAt": "2024-03-05T20:12:59Z",
              "updatedAt": "2024-03-05T20:12:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5yUzO4",
          "commit": {
            "abbreviatedOid": "e6c1e4b"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-05T20:19:48Z",
          "updatedAt": "2024-03-05T20:19:48Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "We should definitely do a pass and create more specific error codes. \"Protocol Violation\" is really a \"TODO\".\r\n\r\nIn this instance, I think we'll remove this error case eventually. I'd like to support multiple control streams, ideally one per session/broadcast, to avoid head-of-line blocking between unrelated tracks.",
              "createdAt": "2024-03-05T20:19:48Z",
              "updatedAt": "2024-03-05T20:19:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5yU0Su",
          "commit": {
            "abbreviatedOid": "e6c1e4b"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-05T20:20:36Z",
          "updatedAt": "2024-03-05T20:20:37Z",
          "comments": [
            {
              "originalPosition": 111,
              "body": "Agreed, the table below used `ID` so I wanted to be consistent. I can change the table instead.",
              "createdAt": "2024-03-05T20:20:36Z",
              "updatedAt": "2024-03-05T20:20:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5yU4y5",
          "commit": {
            "abbreviatedOid": "e6c1e4b"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-05T20:30:35Z",
          "updatedAt": "2024-03-05T20:30:35Z",
          "comments": [
            {
              "originalPosition": 123,
              "body": "No, everything is wire identical to today and we're not using extra bytes.\r\n\r\nI'm trying to specify proposal 2 in #379 but without reflowing the types yet so this PR is editorial only. For example, the meaning of message type = 3 depends on if the message was received over a bidirectional or unidirectional stream (or datagram).\r\n\r\nThe benefit is that we can reuse IDs (saving bits) and avoid constantly checking the context of a message. It's no longer possible to receive a SUBSCRIBE message over a data stream (unidirectional) or datagram because that type is only registered for control streams (bidirectional).",
              "createdAt": "2024-03-05T20:30:35Z",
              "updatedAt": "2024-03-05T20:31:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5yU5u0",
          "commit": {
            "abbreviatedOid": "e6c1e4b"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-05T20:33:02Z",
          "updatedAt": "2024-03-05T20:33:02Z",
          "comments": [
            {
              "originalPosition": 858,
              "body": "I can make it easier to review by splitting it into two commits. The first one changes the order of messages while the second one reflows some text, specifically about data messages.",
              "createdAt": "2024-03-05T20:33:02Z",
              "updatedAt": "2024-03-05T20:33:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5yU7ai",
          "commit": {
            "abbreviatedOid": "e6c1e4b"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-05T20:37:35Z",
          "updatedAt": "2024-03-05T20:37:36Z",
          "comments": [
            {
              "originalPosition": 598,
              "body": "It's just to specify that only a subset of messages are allowed in datagram contexts. There might be a better way of doing that though.\r\n\r\nAlso I thought the plan is to add a length to OBJECT_STREAM, but we definitely shouldn't do that for OBJECT_DATAGRAM. Maybe we also add datagram-only messages in the future and it's just more future-compatible to have a separate object type registry for datagrams.",
              "createdAt": "2024-03-05T20:37:36Z",
              "updatedAt": "2024-03-05T20:37:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5yVDKz",
          "commit": {
            "abbreviatedOid": "e6c1e4b"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-05T20:57:07Z",
          "updatedAt": "2024-03-05T20:57:07Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "I don't want to upsell datagrams. They save 2-4 bytes (just the stream ID) but that's not the reason why you should use them.\r\n\r\nI'll write another blurb that focuses on the timeliness angle.",
              "createdAt": "2024-03-05T20:57:07Z",
              "updatedAt": "2024-03-05T20:57:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5yVMB7",
          "commit": {
            "abbreviatedOid": "e6c1e4b"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-05T21:21:23Z",
          "updatedAt": "2024-03-05T21:21:23Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "+1 on Ian's suggestions. ",
              "createdAt": "2024-03-05T21:21:23Z",
              "updatedAt": "2024-03-05T21:21:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5yVXCa",
          "commit": {
            "abbreviatedOid": "1fd9aad"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-05T21:51:34Z",
          "updatedAt": "2024-03-05T21:51:35Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "I don't think queuing or caching statement is appropriate here. Its relay implementation detail and they are free to cache objects or not reagrdless of where they come from (stream/datagram)",
              "createdAt": "2024-03-05T21:51:35Z",
              "updatedAt": "2024-03-05T21:51:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5yWQpP",
          "commit": {
            "abbreviatedOid": "1fd9aad"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2024-03-06T00:38:37Z",
          "updatedAt": "2024-03-06T00:38:44Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "how do we define transient in the context of MoQ ? ",
              "createdAt": "2024-03-06T00:38:37Z",
              "updatedAt": "2024-03-06T00:38:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5yXtzA",
          "commit": {
            "abbreviatedOid": "1fd9aad"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-06T06:07:39Z",
          "updatedAt": "2024-03-06T06:07:39Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "> I don't think queuing or caching statement is appropriate here. Its relay implementation detail and they are free to cache objects or not reagrdless of where they come from (stream/datagram)\r\n\r\nSure, I didn't realize this statement would be controversial and we can discuss in #408 instead.",
              "createdAt": "2024-03-06T06:07:39Z",
              "updatedAt": "2024-03-06T06:07:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5zuv8q",
          "commit": {
            "abbreviatedOid": "e6c1e4b"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-18T00:32:14Z",
          "updatedAt": "2024-03-18T00:32:14Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "I agree the byte savings is small, but it's also easy to understand.  I think flow control is the most compelling reason to use datagrams instead of object per stream.  If a connection only allows 100 streams at once, it's extremely easy for stream limits to be a constraint.\r\n\r\nOne doesn't have to retransmit stream data, but I agree that is the assumed default behavior.",
              "createdAt": "2024-03-18T00:32:14Z",
              "updatedAt": "2024-03-18T00:32:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5zuw5N",
          "commit": {
            "abbreviatedOid": "1fd9aad"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I think this is good, but splitting it into two PRs to make it easier to see the changes would be very helpful.",
          "createdAt": "2024-03-18T00:35:40Z",
          "updatedAt": "2024-03-18T00:36:19Z",
          "comments": [
            {
              "originalPosition": 858,
              "body": "That would be very helpful.  I think this is a good change, but I'm hesitant to merge such a large single change because it is difficult to know exactly what changed.",
              "createdAt": "2024-03-18T00:35:40Z",
              "updatedAt": "2024-03-18T00:36:19Z"
            }
          ]
        }
      ]
    },
    {
      "number": 413,
      "id": "PR_kwDOG2Ho4M5pQ3BU",
      "title": "Fix the bit encoding of ContentExists",
      "url": "https://github.com/moq-wg/moq-transport/pull/413",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is a one-byte field, not a one-bit field",
      "createdAt": "2024-03-11T16:00:10Z",
      "updatedAt": "2024-03-18T00:40:13Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "80a1fc4eec92a05439e473edb60dcea399b3ca62",
      "headRepository": "martinduke/moq-transport",
      "headRefName": "patch-1",
      "headRefOid": "7472397fd1d579f761c00a6124f6a1f37840bce7",
      "closedAt": "2024-03-18T00:40:12Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "This is already being fixed in #405",
          "createdAt": "2024-03-11T16:42:04Z",
          "updatedAt": "2024-03-11T16:42:04Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "body": "This issue was fixed by #405 ",
          "createdAt": "2024-03-18T00:40:12Z",
          "updatedAt": "2024-03-18T00:40:12Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 414,
      "id": "PR_kwDOG2Ho4M5piWe8",
      "title": "Add a message type for ANNOUNCE_CANCEL",
      "url": "https://github.com/moq-wg/moq-transport/pull/414",
      "state": "MERGED",
      "author": "kixelated",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #409",
      "createdAt": "2024-03-13T17:49:27Z",
      "updatedAt": "2024-03-18T00:38:11Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "80a1fc4eec92a05439e473edb60dcea399b3ca62",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "announce_cancel",
      "headRefOid": "ee777f3e1c6cb631f1a3369859e89f35046f9269",
      "closedAt": "2024-03-18T00:38:11Z",
      "mergedAt": "2024-03-18T00:38:11Z",
      "mergedBy": "ianswett",
      "mergeCommit": {
        "oid": "8ef98bdbe4ac29aa0405c441814b308c5cc48e2b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5zuyLn",
          "commit": {
            "abbreviatedOid": "ee777f3"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Good catch, thanks for fixing this.",
          "createdAt": "2024-03-18T00:38:06Z",
          "updatedAt": "2024-03-18T00:38:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 417,
      "id": "PR_kwDOG2Ho4M5p7yW_",
      "title": "Clarify Send Order",
      "url": "https://github.com/moq-wg/moq-transport/pull/417",
      "state": "OPEN",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Merges the two send order approaches because it appears they're very similar from the perspective of MoQ transport and removes text that is not relevant to MoQ Transport.",
      "createdAt": "2024-03-18T12:28:48Z",
      "updatedAt": "2024-03-24T22:21:21Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "ad67a19f1e6abbe4331b73ad49360726783a2bb8",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ianswett-clarify-send-order",
      "headRefOid": "921363e93501e29720da445de5e15238f2697d79",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 on the simplification and keep it focussed.",
          "createdAt": "2024-03-19T08:19:10Z",
          "updatedAt": "2024-03-19T08:19:10Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "Also +1 to renaming `send order` to `priority`.",
          "createdAt": "2024-03-23T12:31:57Z",
          "updatedAt": "2024-03-23T12:31:57Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> Also +1 to renaming `send order` to `priority`.\n\n+1 ",
          "createdAt": "2024-03-23T18:14:07Z",
          "updatedAt": "2024-03-23T18:14:07Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5z89K0",
          "commit": {
            "abbreviatedOid": "fcecc71"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-19T07:10:10Z",
          "updatedAt": "2024-03-19T07:10:10Z",
          "comments": [
            {
              "originalPosition": 120,
              "body": "So the algorithm above refers to \"priority\". I agree we only need one integer but need to align names. ",
              "createdAt": "2024-03-19T07:10:10Z",
              "updatedAt": "2024-03-19T07:10:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5z9AbM",
          "commit": {
            "abbreviatedOid": "fcecc71"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-19T07:17:02Z",
          "updatedAt": "2024-03-19T07:17:02Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "This sounds right for subscribe, I think it would be reasonable for Fetch to add an preference to deliver in order, or in reverse order. ",
              "createdAt": "2024-03-19T07:17:02Z",
              "updatedAt": "2024-03-19T07:17:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5z9Djc",
          "commit": {
            "abbreviatedOid": "fcecc71"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Few small comments on the text.  \r\n\r\nAt some level, I don't think this is enough. It does not deal with deciding what track to send next when there are objects from multiple tracks waiting to be sent to the same client.  But that said, I think we should merge this, start using it, then fix it and extend it as we learn more. ",
          "createdAt": "2024-03-19T07:25:20Z",
          "updatedAt": "2024-03-19T07:25:20Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5z9aqM",
          "commit": {
            "abbreviatedOid": "fcecc71"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This PR is needed and is focussed.",
          "createdAt": "2024-03-19T08:20:13Z",
          "updatedAt": "2024-03-19T08:20:13Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5z91fq",
          "commit": {
            "abbreviatedOid": "fcecc71"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I very much like the cleanup but there's some conflicts, hence being two separate sections in the first place.",
          "createdAt": "2024-03-19T09:09:47Z",
          "updatedAt": "2024-03-19T09:22:16Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "Priorities are applied to streams so this gets super confusing based on the stream mode. The object_id is not always known after the stream header (track/group mode).",
              "createdAt": "2024-03-19T09:09:47Z",
              "updatedAt": "2024-03-19T09:22:34Z"
            },
            {
              "originalPosition": 104,
              "body": "What happens when a newer group has a higher send order?\r\n\r\nI think it's a great recommendation to send newer groups first... unless you want head-of-line blocking for reliable live or VOD. This text makes it seem illegal?",
              "createdAt": "2024-03-19T09:10:05Z",
              "updatedAt": "2024-03-19T09:22:16Z"
            },
            {
              "originalPosition": 77,
              "body": "I think this text could be salvaged by recommending how `send_order` is computed. Otherwise it conflicts with the above paragraphs that just tell you to use send order.\r\n\r\n```suggestion\r\nWhen the publisher chooses which object to send next via `send_order`, they\r\n```",
              "createdAt": "2024-03-19T09:14:05Z",
              "updatedAt": "2024-03-19T09:23:00Z"
            },
            {
              "originalPosition": 70,
              "body": "I feel like this proposal has been deprecated since implementing stream mapping, since the priority is in the stream header now. Relays are expected to respect it and forward streams as they were received.",
              "createdAt": "2024-03-19T09:14:23Z",
              "updatedAt": "2024-03-19T09:22:16Z"
            },
            {
              "originalPosition": 102,
              "body": "Regardless of send order?",
              "createdAt": "2024-03-19T09:21:03Z",
              "updatedAt": "2024-03-19T09:22:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M50Ceif",
          "commit": {
            "abbreviatedOid": "fcecc71"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-19T16:39:47Z",
          "updatedAt": "2024-03-19T16:39:48Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "@kixelated can you please elaborate on what needs clarification here ?   Streaming modes naturally fit with priorities and we have implemented the same.\r\n\r\nIf stream per group is selected , all the objects with in a group have same priority.  So objects are delivered in the receive order at a relay within a stream.\r\nif stream per object is selected and if the application marks all the objects with same priority within a group, then objects end up on the same priority queue level and are sent in the receive order.  If application marks each object with a different priorities, they end up on different levels in the queue and are sent according to the priority order.\r\n\r\nThe above text seems to cover all the cases if am reading it right.",
              "createdAt": "2024-03-19T16:39:47Z",
              "updatedAt": "2024-03-19T16:39:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M50GAc6",
          "commit": {
            "abbreviatedOid": "6ce66e9"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-20T00:43:02Z",
          "updatedAt": "2024-03-20T00:43:02Z",
          "comments": [
            {
              "originalPosition": 120,
              "body": "Good point, personally I think I like \"Object Priority\" based on how it's discussed and used.  But suggestions are welcome.",
              "createdAt": "2024-03-20T00:43:02Z",
              "updatedAt": "2024-03-20T00:43:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M50Nh9F",
          "commit": {
            "abbreviatedOid": "921363e"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-20T18:15:00Z",
          "updatedAt": "2024-03-20T18:28:41Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "So in general this text needs some clarification on if it's normative or non-normative. I interpret it as normative, outlining the algorithm that each publisher uses to compute `send_order`. It's a good algorithm for low-latency, but I'd like a to throw in a SHOULD.\r\n\r\nIf this MUST be the algorithm used to determine send order, then it breaks some use-cases, like using send order for head-of-line blocking. It also just makes the `send_order` redundant, as a publisher could compute the send order using `group_id`, `object_id` and these rules. \r\n\r\nAnd what happens when there's a mismatch? Is a relay supposed to error if `send_order` does not follow these rules?\r\n\r\nI mean this was the crux of the debate way back then and why there are two sections. I thought the publisher should bake the rules into the send_order, while Christian thought we should have explicit rules. This PR is effectively doing both by merging the sections together; allowing publishers to choose the send order per stream but dictating the rules?",
              "createdAt": "2024-03-20T18:24:36Z",
              "updatedAt": "2024-03-20T18:30:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M50nt6o",
          "commit": {
            "abbreviatedOid": "fcecc71"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-24T14:34:45Z",
          "updatedAt": "2024-03-24T14:34:45Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "Priority is saved as part of \"Canonical Object\" along with Object Forwarding preference . So that when they are served from  cache, regardless of stream mapping, right priority is applied and mapped to the right stream.",
              "createdAt": "2024-03-24T14:34:45Z",
              "updatedAt": "2024-03-24T14:34:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M50oFxN",
          "commit": {
            "abbreviatedOid": "921363e"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Individual Review:\r\n\r\nOverall this is an improvement over the text that we have.  I don't think it's the end of the story but it's probably a good incremental step for now?",
          "createdAt": "2024-03-24T22:04:08Z",
          "updatedAt": "2024-03-24T22:21:21Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "s/still/always/ ?",
              "createdAt": "2024-03-24T22:04:08Z",
              "updatedAt": "2024-03-24T22:21:21Z"
            },
            {
              "originalPosition": 81,
              "body": "We've got text elsewhere that says that:\r\n\r\n* when using stream-per-group, all objects have the same priority (sort of, see note)\r\n* when using stream-per-group, the relay can't skip or reorder objects within the group\r\n\r\nIt might help clarify if this section referenced those bits, or explained the intersection of forwarding preferences and priorities.\r\n\r\nNote: Our wire format allows the same group to be transmitted with different priorities if the group is carried on two or more streams (eg: disconnect in the middle of a group, objects 1-10 on stream 1, objects 11-20 on a different stream, or connection).  ",
              "createdAt": "2024-03-24T22:12:10Z",
              "updatedAt": "2024-03-24T22:21:21Z"
            },
            {
              "originalPosition": 104,
              "body": "I think this text should be scoped to tiebreakers:\r\n\r\n\"When objects from two or more groups have the same priority, send the objects from the more recent group first\"\r\n\r\nBut for the \"reliable live\" case, you probably still want a subscriber side override to get groups in ascending order.",
              "createdAt": "2024-03-24T22:15:48Z",
              "updatedAt": "2024-03-24T22:21:21Z"
            },
            {
              "originalPosition": 102,
              "body": "Here priority == send order, so the qualifier (within the same group and priority) is that these objects have identical send order.",
              "createdAt": "2024-03-24T22:17:56Z",
              "updatedAt": "2024-03-24T22:21:21Z"
            }
          ]
        }
      ]
    },
    {
      "number": 418,
      "id": "PR_kwDOG2Ho4M5p_T54",
      "title": "Fix some typos",
      "url": "https://github.com/moq-wg/moq-transport/pull/418",
      "state": "MERGED",
      "author": "levaitamas",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-03-18T19:36:24Z",
      "updatedAt": "2024-03-23T12:32:41Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "ad67a19f1e6abbe4331b73ad49360726783a2bb8",
      "headRepository": "levaitamas/moq-transport",
      "headRefName": "fix-typo",
      "headRefOid": "fdf125139760c68ae975987bc5a24a8676c40c22",
      "closedAt": "2024-03-23T12:32:41Z",
      "mergedAt": "2024-03-23T12:32:41Z",
      "mergedBy": "kixelated",
      "mergeCommit": {
        "oid": "8f4d441c5f799e80bb2f8291f82a3d936e7e7799"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5z4WSs",
          "commit": {
            "abbreviatedOid": "d20f5aa"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-18T20:41:07Z",
          "updatedAt": "2024-03-18T20:41:07Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5z6ilx",
          "commit": {
            "abbreviatedOid": "d20f5aa"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-19T00:52:50Z",
          "updatedAt": "2024-03-19T00:52:50Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5z9Eme",
          "commit": {
            "abbreviatedOid": "d20f5aa"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-19T07:28:07Z",
          "updatedAt": "2024-03-19T07:28:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 421,
      "id": "PR_kwDOG2Ho4M5qC1Xh",
      "title": "Split SUBSCRIBE into SUBSCRIBE and FETCH",
      "url": "https://github.com/moq-wg/moq-transport/pull/421",
      "state": "OPEN",
      "author": "ianswett",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Subscribe"
      ],
      "body": "A PR corresponding to: https://datatracker.ietf.org/meeting/119/materials/slides-119-moq-subscribe-and-fetch\r\n\r\nFixes #269 \r\nFixes #296\r\nFixes #350 \r\nFixes #326\r\nFixes #377\r\nFixes #312 \r\nFixes #353\r\n\r\nAlso relevant to #396, #326\r\n\r\nSome open questions:\r\n - Do we want OBJECT_FETCH_DATAGRAM to be transmitted over datagrams only?",
      "createdAt": "2024-03-19T06:11:41Z",
      "updatedAt": "2024-03-28T20:39:52Z",
      "baseRepository": "moq-wg/moq-transport",
      "baseRefName": "main",
      "baseRefOid": "ad67a19f1e6abbe4331b73ad49360726783a2bb8",
      "headRepository": "moq-wg/moq-transport",
      "headRefName": "ianswett-subscribe-v2",
      "headRefOid": "6e19b12483d3ac0856a6738d470c9ffe7a1036ce",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "body": "How would a live player that wants to start 3 groups back from the live head use this combination of SUBSCRIBE and FETCH? It could issue the SUBSCRIBE, which would deliver the latest group and all future groups as well as information about the latest (largest) group number. However, since group numbers increase monotonically by a variable increment, the player cannot use this information to construct the appropriate FETCH, because it cannot predict the two prior group numbers. ",
          "createdAt": "2024-03-19T11:40:52Z",
          "updatedAt": "2024-03-19T11:40:52Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> However, since group numbers increase monotonically by a variable increment, the player cannot use this information to construct the appropriate FETCH, because it cannot predict the two prior group numbers.\r\n\r\nPlayer needs to know how the group numbers increment.  Its the application and if it has no clue , then something is already wrong.",
          "createdAt": "2024-03-19T13:37:54Z",
          "updatedAt": "2024-03-19T13:37:54Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> If that's a sticking point for folks, then I much rather add that restriction to the current SUBSCRIBE message along with `order=ASC|DESC` as proposed in #411.\r\n\r\nCan you please answer my question on the open issue on how can relay make such decision upstream when there are conflicting subscriptions with respect to the order.  May be last mile subscribe has a utility, but I am not sure how to solve the open issue on this.",
          "createdAt": "2024-03-19T16:43:39Z",
          "updatedAt": "2024-03-19T16:43:39Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "body": "> > If that's a sticking point for folks, then I much rather add that restriction to the current SUBSCRIBE message along with `order=ASC|DESC` as proposed in #411.\r\n> \r\n> Can you please answer my question on the open issue on how can relay make such decision upstream when there are conflicting subscriptions with respect to the order. May be last mile subscribe has a utility, but I am not sure how to solve the open issue on this.\r\n\r\nWhat about `order=ASC | DESC | DEFAULT`? The relay could let the publisher/upstream choose like it does today.\r\n\r\nNote that FETCH is not immune to this. There could be a continuous SUBSCRIBE from broadcaster -> origin (ascending) and a FETCH from origin -> relay (descending). Or a viewer could SUBSCRIBE and later another viewer could FETCH, leveraging some of the existing subscription.\r\n\r\nviewer1:\r\n```\r\n-> SUBSCRIBE \r\n<- SUBSCRIBE_OK start=420\r\n<- OBJECT 420\r\n(upstream congestion)\r\n<- OBJECT 422\r\n<- OBJECT 423\r\n<- OBJECT 421\r\n```\r\n\r\nviewer2:\r\n```\r\n-> FETCH start=419 end=421\r\n<- OBJECT 420 (cached)\r\n<- OBJECT 422\r\n(blocked on 423)\r\n<- OBJECT 421\r\n```\r\n\r\nBut I dunno, I kind of feel like this is a non-issue. Viewers will either request the same order, or upstream congestion is rare, or defaulting to ORDER=desc is required for live and good enough for VOD and reliable live. We're talking about edge cases of a prioritization scheme, which historically don't have much impact.",
          "createdAt": "2024-03-20T18:06:41Z",
          "updatedAt": "2024-03-20T18:07:39Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "body": "> What about `order=ASC | DESC | DEFAULT`? The relay could let the publisher/upstream choose like it does today.\r\n\r\nThe challenge here is any recommendation we give here will not be appropriate for Relays. I am unaware of cases where given an application, say that publishes oldest to newest, have some percentage of subscribers wanting oldest to newest and rest asking newest to oldest. Subscribers (endpoints) knows what application they are participating it and they know the right expectation. \r\n\r\nOTOH I can see  where having some form of control in the receive order might be needed, given each fetch is a independent request. Also I again wonder will there be a case where few endpoints fetch in one order vs few in a different order within a given application, may be there is and hence adding it here might be fine.\r\n\r\nMy main concern is we are pushing recommendations/suggestions on relays for applications and Relays can't make a informed decision under ambiguities. \r\n\r\n",
          "createdAt": "2024-03-23T15:33:20Z",
          "updatedAt": "2024-03-24T01:44:11Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Individual Comment:\r\n\r\n> I am unaware of cases where given an application, say that publishes oldest to newest, have some percentage of subscribers wanting oldest to newest and rest asking newest to oldest\r\n\r\nHere's a use case: A live stream with a recording option.  Some subscribers are watching live, so want newest first.  Recording subscriber doesn't care about latency and would prefer oldest first.  I think the SUBSCRIBE verb is still the right one for both cases, rather than forcing the recorder to use FETCH in a loop?",
          "createdAt": "2024-03-24T22:28:43Z",
          "updatedAt": "2024-03-24T22:28:43Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The requirements for recording are usually record all the objects that were sent. If a object was lost and never sent, the recording system would not want to wait for it and not record future packets.  I'm pretty skeptical of any use case where latency does not matter being a core case for MoQ. That said, a recoding system that did a subscribe to the whole namespace to get all the objects as they were produced sounds like the most likely thing for recording systems to build. ",
          "createdAt": "2024-03-24T23:29:46Z",
          "updatedAt": "2024-03-24T23:29:46Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Please see my related email on the the list. Thanks\r\n",
          "createdAt": "2024-03-24T23:32:36Z",
          "updatedAt": "2024-03-24T23:32:36Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOG2Ho4M5z8twQ",
          "commit": {
            "abbreviatedOid": "d849664"
          },
          "author": "hardie",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-19T06:22:46Z",
          "updatedAt": "2024-03-19T06:22:46Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "I thought we had agreed that a client could want multiple copies for different uses (e.g. storage vs. render).  If it did that, using two different start locations, why would that be forbidden in a single session?",
              "createdAt": "2024-03-19T06:22:46Z",
              "updatedAt": "2024-03-19T06:22:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5z8u5A",
          "commit": {
            "abbreviatedOid": "506eb32"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-19T06:26:42Z",
          "updatedAt": "2024-03-19T06:26:42Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "The cases one would want multiple copies are covered by FETCH.  Having multiple subscribes can add complexity in some cases and I'm not aware of a clear usecase.",
              "createdAt": "2024-03-19T06:26:42Z",
              "updatedAt": "2024-03-19T06:26:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5z8vmW",
          "commit": {
            "abbreviatedOid": "506eb32"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-19T06:29:01Z",
          "updatedAt": "2024-03-19T06:29:01Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "For use-case where i want to catch up last 5 mins, while i join the call live. I can see it implemented with subscribe , fetch combination ..",
              "createdAt": "2024-03-19T06:29:01Z",
              "updatedAt": "2024-03-19T06:29:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5z8v6M",
          "commit": {
            "abbreviatedOid": "506eb32"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-19T06:29:56Z",
          "updatedAt": "2024-03-19T06:29:56Z",
          "comments": [
            {
              "originalPosition": 239,
              "body": "```suggestion\r\nTODO: Should these be the first Group being delivered?  If the last group\r\n```",
              "createdAt": "2024-03-19T06:29:56Z",
              "updatedAt": "2024-03-19T06:29:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5z8wGY",
          "commit": {
            "abbreviatedOid": "506eb32"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-19T06:30:34Z",
          "updatedAt": "2024-03-19T06:30:34Z",
          "comments": [
            {
              "originalPosition": 163,
              "body": "wonder if we should make it invalid to set its value as 0 to avoid ambiguities or make it optional field and if it is omitted it means as long as track is alive?",
              "createdAt": "2024-03-19T06:30:34Z",
              "updatedAt": "2024-03-19T06:30:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5z8wP-",
          "commit": {
            "abbreviatedOid": "32ad770"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-19T06:31:03Z",
          "updatedAt": "2024-03-19T06:31:03Z",
          "comments": [
            {
              "originalPosition": 279,
              "body": "```suggestion\r\n{: #moq-transport-fetch-format title=\"MOQT FETCH Message\"}\r\n```",
              "createdAt": "2024-03-19T06:31:03Z",
              "updatedAt": "2024-03-19T06:31:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5z8wyg",
          "commit": {
            "abbreviatedOid": "4ae0963"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-19T06:32:44Z",
          "updatedAt": "2024-03-19T06:32:44Z",
          "comments": [
            {
              "originalPosition": 123,
              "body": "s/from from/from ",
              "createdAt": "2024-03-19T06:32:44Z",
              "updatedAt": "2024-03-19T06:32:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5z8yVx",
          "commit": {
            "abbreviatedOid": "4ae0963"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-19T06:36:56Z",
          "updatedAt": "2024-03-19T06:36:56Z",
          "comments": [
            {
              "originalPosition": 163,
              "body": "I think we need a way to say that there is no limit on the number of groups.  We can encode that in a number of ways, ie: 6 modes instead of 3, etc.",
              "createdAt": "2024-03-19T06:36:56Z",
              "updatedAt": "2024-03-19T06:36:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5z8yhg",
          "commit": {
            "abbreviatedOid": "4ae0963"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks @ianswett  This seems to be heading in the right direction. I do have few nits and clarification questions (posted)",
          "createdAt": "2024-03-19T06:37:19Z",
          "updatedAt": "2024-03-19T06:37:19Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOG2Ho4M5z83RG",
          "commit": {
            "abbreviatedOid": "0905273"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-19T06:52:39Z",
          "updatedAt": "2024-03-19T06:52:39Z",
          "comments": [
            {
              "originalPosition": 304,
              "body": "slight tweak, instead of  earlier, I think it would be better to use lower object id because order of things were delivered in time could be different than that",
              "createdAt": "2024-03-19T06:52:39Z",
              "updatedAt": "2024-03-19T06:52:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5z83pm",
          "commit": {
            "abbreviatedOid": "0905273"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-19T06:53:52Z",
          "updatedAt": "2024-03-19T06:53:52Z",
          "comments": [
            {
              "originalPosition": 329,
              "body": "perhaps change \"subscription\" to \"fetch\"",
              "createdAt": "2024-03-19T06:53:52Z",
              "updatedAt": "2024-03-19T06:53:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5z85Qs",
          "commit": {
            "abbreviatedOid": "0905273"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-19T06:58:54Z",
          "updatedAt": "2024-03-19T06:58:54Z",
          "comments": [
            {
              "originalPosition": 110,
              "body": "STREAM_SUBSCRIBE_GROUP/STREAM_FETCH_GROUP",
              "createdAt": "2024-03-19T06:58:54Z",
              "updatedAt": "2024-03-19T06:58:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5z86YC",
          "commit": {
            "abbreviatedOid": "0905273"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-19T07:02:25Z",
          "updatedAt": "2024-03-19T07:02:25Z",
          "comments": [
            {
              "originalPosition": 286,
              "body": "If the last group was cached , but TTL expired on it and got removed. Subscribe should start from the data it has.. ",
              "createdAt": "2024-03-19T07:02:25Z",
              "updatedAt": "2024-03-19T07:02:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5z9EWF",
          "commit": {
            "abbreviatedOid": "0905273"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-19T07:27:24Z",
          "updatedAt": "2024-03-19T07:27:35Z",
          "comments": [
            {
              "originalPosition": 322,
              "body": "This comment could be in a different PR, but I think it might be good to add an flag to the fetch that indicated the results should be delivered in reverse order. ",
              "createdAt": "2024-03-19T07:27:24Z",
              "updatedAt": "2024-03-19T07:27:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5z9IFq",
          "commit": {
            "abbreviatedOid": "0905273"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-19T07:36:48Z",
          "updatedAt": "2024-03-19T07:36:48Z",
          "comments": [
            {
              "originalPosition": 110,
              "body": "```suggestion\r\nSTREAM_SUBSCRIBE_GROUP/STREAM_FETCH_GROUP Message {\r\n```",
              "createdAt": "2024-03-19T07:36:48Z",
              "updatedAt": "2024-03-19T07:36:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5z9IT6",
          "commit": {
            "abbreviatedOid": "22d1966"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-19T07:37:18Z",
          "updatedAt": "2024-03-19T07:37:18Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "```suggestion\r\nNext Group (0x2): Start at the first Object from the next group.\r\n```",
              "createdAt": "2024-03-19T07:37:18Z",
              "updatedAt": "2024-03-19T07:37:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5z9T1d",
          "commit": {
            "abbreviatedOid": "0905273"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-19T08:04:55Z",
          "updatedAt": "2024-03-19T08:04:56Z",
          "comments": [
            {
              "originalPosition": 322,
              "body": "Thanks, I would like to have that conversation along with the larger priorities conversation if possible, but it's a completely reasonable idea.",
              "createdAt": "2024-03-19T08:04:55Z",
              "updatedAt": "2024-03-19T08:04:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5z9UrX",
          "commit": {
            "abbreviatedOid": "0905273"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-19T08:06:55Z",
          "updatedAt": "2024-03-19T08:06:55Z",
          "comments": [
            {
              "originalPosition": 286,
              "body": "Agreed, my concern is that if last isn't available, how is that indicated?  If one finds out the largest group ID is 3, and it asked for last, it would expect to receive group 2, but if it's not available, it wouldn't.",
              "createdAt": "2024-03-19T08:06:55Z",
              "updatedAt": "2024-03-19T08:06:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5z9at2",
          "commit": {
            "abbreviatedOid": "6e19b12"
          },
          "author": "janaiyengar",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "Broadly looks good, follows the arc of what we discussed. ",
          "createdAt": "2024-03-19T08:20:18Z",
          "updatedAt": "2024-03-19T08:31:07Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "@Ted: We had agreed on allowing this for FETCH, and explicitly disallowing dups for SUBSCRIBE, since FETCH is more like an HTTP GET.",
              "createdAt": "2024-03-19T08:20:18Z",
              "updatedAt": "2024-03-19T08:31:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5z9j6q",
          "commit": {
            "abbreviatedOid": "6e19b12"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I understand the desire to split the world into VOD and REALTIME via FETCH and SUBSCRIBE, but I think this proposal misses the nuances of live streams that startle between both worlds. I'd like some clarification in #419 as to how a player is supposed to use this API because it seems poor.\r\n\r\nAnd I think the duplication between SUBSCRIBE/FETCH is just super messy. The justification is that now a relay doesn't need to implement relative ranges beyond +- 1 group. If that's a sticking point for folks, then I much rather add that restriction to the current SUBSCRIBE message along with `order=ASC|DESC` as proposed in #411.",
          "createdAt": "2024-03-19T08:37:11Z",
          "updatedAt": "2024-03-19T08:55:16Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "What's the benefit to adding this restriction, effectively mandating deduplication? I don't see what's the harm in allowing dumb proxies that don't deduplicate subscriptions.",
              "createdAt": "2024-03-19T08:37:11Z",
              "updatedAt": "2024-03-19T08:54:18Z"
            },
            {
              "originalPosition": 322,
              "body": "I'd like a flag too, see #411. We need it for SUBSCRIBE in the reliable live use-case.",
              "createdAt": "2024-03-19T08:38:46Z",
              "updatedAt": "2024-03-19T08:54:18Z"
            },
            {
              "originalPosition": 15,
              "body": "There needs to be a `FETCH_OK`/`FETCH_ERROR` message too. I don't see how you can signal stuff like 404 or unauthorized otherwise.",
              "createdAt": "2024-03-19T08:42:30Z",
              "updatedAt": "2024-03-19T08:54:18Z"
            },
            {
              "originalPosition": 26,
              "body": "Can we shard the `id` (even/odd) based on if it's a FETCH/SUBSCRIBE?\r\n\r\nScratch that, why does it even matter? Why not have SUBSCRIBE and FETCH share the same ID space?",
              "createdAt": "2024-03-19T08:44:19Z",
              "updatedAt": "2024-03-19T08:54:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M5z9vJx",
          "commit": {
            "abbreviatedOid": "6e19b12"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "And I think this breaks ABR if I understand correctly?",
          "createdAt": "2024-03-19T08:58:21Z",
          "updatedAt": "2024-03-19T09:00:34Z",
          "comments": [
            {
              "originalPosition": 144,
              "body": "I think `Last` is super confusing, because this is actually the N-1 group. I would call this `Prev`.\r\n\r\nI also think we just remove this. It's not sufficient for higher latency playback and it's super strange to keep a cache of the last two groups in cache.",
              "createdAt": "2024-03-19T08:58:21Z",
              "updatedAt": "2024-03-19T09:00:34Z"
            },
            {
              "originalPosition": 141,
              "body": "Doesn't this break seamless ABR, since you can no longer subscribe using an absolute group in the future? The best you can do is subscribe to next group and pray for no race conditions.",
              "createdAt": "2024-03-19T09:00:03Z",
              "updatedAt": "2024-03-19T09:01:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M50Dh6b",
          "commit": {
            "abbreviatedOid": "d849664"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-19T18:38:36Z",
          "updatedAt": "2024-03-19T18:38:37Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "Deduping multiple conflicting subscriptions is not straighforward, also it leads to weird edge cases when there is partial data . I think these were reflected during Denver interim discussions at some point.",
              "createdAt": "2024-03-19T18:38:37Z",
              "updatedAt": "2024-03-19T18:38:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M50GMy7",
          "commit": {
            "abbreviatedOid": "d849664"
          },
          "author": "fluffy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-20T00:52:36Z",
          "updatedAt": "2024-03-20T00:52:36Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "Is there an use that drives need for duplicate subscriptions ",
              "createdAt": "2024-03-20T00:52:36Z",
              "updatedAt": "2024-03-20T00:52:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M50M_1v",
          "commit": {
            "abbreviatedOid": "6e19b12"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-20T17:15:12Z",
          "updatedAt": "2024-03-20T17:15:12Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "> Is there an use that drives need for duplicate subscriptions\r\n\r\nAs of the current draft, AUTH is in the SUBSCRIBE message. A relay that doesn't know the auth scheme would have to forward each SUBSCRIBE upstream, but that's prevented by this text.\r\n\r\nI strongly think we should decouple auth anyway. I'd like to see an AUTH_NAMESPACE message that could be used for subsequent ANNOUNCE and SUBSCRIBE messages on the control stream.\r\n\r\n> Deduping multiple conflicting subscriptions is not straighforward, also it leads to weird edge cases when there is partial data . I think these were reflected during Denver interim discussions at some point.\r\n\r\nYeah that's my point. This restriction forces a relay to deduplicate, for example if two viewers issue:\r\n\r\n```\r\nviewer1 -> SUBSCRIBE start=next\r\n...\r\nviewer2 -> SUBSCRIBE start=prev\r\n```\r\n\r\nA relay SHOULD deduplicate these for the upstream subscribe, but this text makes it a MUST. Doing this is tricky much like the existing SUBSCRIBE message.",
              "createdAt": "2024-03-20T17:15:12Z",
              "updatedAt": "2024-03-20T17:15:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M50NDZC",
          "commit": {
            "abbreviatedOid": "6e19b12"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-20T17:21:12Z",
          "updatedAt": "2024-03-20T17:21:12Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "As a side note.\r\n\r\n> A subscriber MUST NOT subscribe to the same track twice within a session.\r\n\r\nI think the intent is to prevent duplicate concurrent subscriptions. However, a literal interpretation is that you're never allowed to subscribe again even after an unsubscribe, which of course breaks many things.",
              "createdAt": "2024-03-20T17:21:12Z",
              "updatedAt": "2024-03-20T17:21:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M50NFYR",
          "commit": {
            "abbreviatedOid": "6e19b12"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-20T17:24:33Z",
          "updatedAt": "2024-03-20T17:27:44Z",
          "comments": [
            {
              "originalPosition": 318,
              "body": "What happens if the start group/object is in the future?",
              "createdAt": "2024-03-20T17:24:33Z",
              "updatedAt": "2024-03-20T17:27:44Z"
            },
            {
              "originalPosition": 15,
              "body": "Speaking of 404, what happens if some of the groups/objects in the range requested don't exist or have expired? Without a way of signaling that, the subscriber could wait indefinitely for the FETCH to complete.\r\n\r\nex. a DVR client that issues a FETCH for 60s ago to replay a highlight. However the start of the highlight may have been evicted from the LRU by then, and is no longer available on origin either. Some of the highlight may arrive alluding to success, but the player will get stuck buffering for the first group.",
              "createdAt": "2024-03-20T17:27:40Z",
              "updatedAt": "2024-03-20T17:29:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M50dPJX",
          "commit": {
            "abbreviatedOid": "6e19b12"
          },
          "author": "suhasHere",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-22T02:30:38Z",
          "updatedAt": "2024-03-22T02:30:38Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "+1 on needing a way for the fetch response to identify gaps.  We need to add FETCH_OK to include something on the lines of\r\n\r\nSay if FETCH request was for the range 100-200 and and let's say for whatever reasons 110-120, 190-200 are missing, the response should have\r\n\r\n```\r\n{\r\n    Gaps {\r\n    type-group \r\n    [110-120,  190-200]\r\n  }\r\n}\r\n```\r\n\r\nNice thing about fetch is it is able to find answers ",
              "createdAt": "2024-03-22T02:30:38Z",
              "updatedAt": "2024-03-22T02:30:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M50wG7j",
          "commit": {
            "abbreviatedOid": "6e19b12"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-25T20:55:50Z",
          "updatedAt": "2024-03-25T20:55:50Z",
          "comments": [
            {
              "originalPosition": 144,
              "body": "Individual comment:\r\n\r\n> the largest group for which the relay has received the last object\r\n\r\nI find this strange and hard to reason about.  \r\n\r\nFirst, we don't yet have a mechanism for the relay to know the last object in the group (though we all assume we will eventually have one).  But if we really want this semantic, maybe we want to delay adding this mode to the draft until we can actually implement it.\r\n\r\nWhat's strange to me is that if the relay has received [group 7: all objects] and [group 8: all object *except the last*], and [group 9, object 0], a request for `Last Group` would serve 7 instead of 8.  Is there an application where that's the desired behavior?  \r\n\r\nI find it hard to reason about because I could ask 3 different relays and get 3 different groups relative to the live head, depending on what happens to be in their cache. \r\n\r\nThere are two other ways to handle last that seem more straightforward to me:\r\n\r\n1. Last is the largest group smaller than current for which the relay has *any* objects\r\n2. Last is `current group - 1`\r\n\r\nOption 1 suffers from the same potential relay inconsistency as the proposed text, but it seems more likely to be useful.\r\n\r\nI prefer option 2 because it is *predictable* - I know exactly what group I am going to get relative to the live head.  I get the vibe that some folks have a specific use case in mind for discontiguous group ids, which would mean option 2 wouldn't work for them.  If there is a use-case, can we write it down (maybe mail to the list) so we can evaluate pros and cons? I think Luke has given a use case for making group IDs sequential: they can be used for gap detection, and would allow relays to do simple math to compute relative groups.\r\n",
              "createdAt": "2024-03-25T20:55:50Z",
              "updatedAt": "2024-03-25T20:55:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M50wKh1",
          "commit": {
            "abbreviatedOid": "6e19b12"
          },
          "author": "kixelated",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-25T21:05:24Z",
          "updatedAt": "2024-03-25T21:05:24Z",
          "comments": [
            {
              "originalPosition": 144,
              "body": "Oh yeah I didn't even read the full text. Any subscribe decision based on a relay's current cache is going to be problematic. \r\n\r\n`current-1` makes more sense. The wrinkle is that `group_ids` are apparently not sequential , so `current-1` might not exist.\r\n\r\nBut I would remove this mode altogether. `current-1` is not sufficient in most scenarios.",
              "createdAt": "2024-03-25T21:05:24Z",
              "updatedAt": "2024-03-25T21:07:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M51Dd-y",
          "commit": {
            "abbreviatedOid": "6e19b12"
          },
          "author": "ianswett",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-27T16:19:58Z",
          "updatedAt": "2024-03-27T16:19:59Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "SUBSCRIBE uses track alias to deliver Objects, and Fetch uses the monotonically increasing IDs.",
              "createdAt": "2024-03-27T16:19:59Z",
              "updatedAt": "2024-03-27T16:19:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M51HNgs",
          "commit": {
            "abbreviatedOid": "6e19b12"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-27T21:42:28Z",
          "updatedAt": "2024-03-27T21:42:28Z",
          "comments": [
            {
              "originalPosition": 321,
              "body": "Is there some way to express \"give me all the objects in the group\" if we don't know the max object ID?",
              "createdAt": "2024-03-27T21:42:28Z",
              "updatedAt": "2024-03-27T21:42:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M51Hz40",
          "commit": {
            "abbreviatedOid": "6e19b12"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-28T00:42:48Z",
          "updatedAt": "2024-03-28T00:42:48Z",
          "comments": [
            {
              "originalPosition": 321,
              "body": "With SUBSCRIBE, the requested range was [Start, End), so you can request Start=X/0, End=X+1/0 to get all the objects in group X.",
              "createdAt": "2024-03-28T00:42:48Z",
              "updatedAt": "2024-03-28T00:42:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M51QKt_",
          "commit": {
            "abbreviatedOid": "6e19b12"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-28T20:08:14Z",
          "updatedAt": "2024-03-28T20:08:15Z",
          "comments": [
            {
              "originalPosition": 321,
              "body": "Individual Comment:\r\n\r\nWhat is the normative behavior if `end` is larger than `largest` for a live track?\r\n\r\nHere are some possibilities:\r\n\r\n1) Fail the request\r\n2) return everything up to min(end, live) at the time of the request, indicate end in a fetch OK\r\n3) return everything up to min(end, live) at the time of the response, indicate end in a fetch trailer\r\n4) When the fetch catches up to live, continue offering FETCH semantics for new objects (all objects delivered or gap notification), until end is reached\r\n\r\n1 and 2 are fairly easy to implement.  3 is a little trickier but accounts for live head moving in the time it takes to serve the beginning of the request.  4 feels the hardest, but maybe handles the \"reliable live\" use case the best?\r\n\r\nAre the other options?",
              "createdAt": "2024-03-28T20:08:14Z",
              "updatedAt": "2024-03-28T20:08:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOG2Ho4M51QcEU",
          "commit": {
            "abbreviatedOid": "6e19b12"
          },
          "author": "wilaw",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-28T20:39:52Z",
          "updatedAt": "2024-03-28T20:39:52Z",
          "comments": [
            {
              "originalPosition": 321,
              "body": "I'd vote for 4 - `When the fetch catches up to live, continue offering FETCH semantics for new objects (all objects delivered or gap notification), until end is reached .`. As you state, this satisfies a \"reliable live\" use case with a start behind the live head. \r\n\r\nI'd also suggest that EndGroup and EndObject can be omitted, in which it defaults to the behavior [4]. This prevents the ugliness of people asking for group 99999999999999 when all they really want is delivery until end-of -track. ",
              "createdAt": "2024-03-28T20:39:52Z",
              "updatedAt": "2024-03-28T20:39:52Z"
            }
          ]
        }
      ]
    }
  ]
}